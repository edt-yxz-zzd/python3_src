
__all__ = '''
    '''.split()
from itertools import chain
from .abc import ABC, abstractmethod, override, not_implemented, ABCMeta
    # since abc.ABC has no "__slots__ = ()"
    __slots__ = ()
    (printf "\"%s\"\0" "class \|__slots__ =" && find -name "*.py" -and -not -path *-* -print0) | xargs -0 grep
class IXXX(metaclass=ABCMeta):
    __slots__ = ()
class IXXX(ABC):
    __slots__ = ()

if __name__ == "__main__":
    import doctest
    doctest.testmod()


if __name__ == '__main__':
    XXX = ???

    from seed.helper.print_methods import wrapped_print_methods
    wrapped_print_methods(XXX)

    from seed.helper.detect_method_conflict import \
        wrapped_print_detect_method_conflict
    wrapped_print_detect_method_conflict(XXX)

    from seed.helper.find_bases_without_slots import print_bases_without_slots
    print_bases_without_slots(XXX)

from seed.helper.repr_input import repr_helper
    def __repr__(self):
        return repr_helper(self, *args, **kwargs)




if __name__ == "__main__":
    from timeit import timeit
    from time import perf_counter, process_time
    from random import *


if __name__ == '__main__':
    from seed.helper.print_global_names import print_global_names
    print_global_names(globals())

if __name__ == '__main__':
    print('\n'.join(dir(XXX)))
    print('\n'.join(n for n in dir(XXX) if getattr(getattr(XXX, n), '__isabstractmethod__', False)))
    print('\n'.join('\n\t'.join([XXX.__name__, '\n\t'.join(dir(XXX))]) for XXX in map(globals().__getitem__, __all__) if isinstance(XXX, type)))

if __name__ == '__main__':
    from seed.test_utils.generate_test_data import str2values_by_line2expr
    data = '''
        [input], [output]
        [input], [output]
        '''
    data = str2values_by_line2expr(data)


def main(argv=None):
    import argparse
    from seed.io.may_open import may_open_stdin, may_open_stdout

    parser = argparse.ArgumentParser(
        description=description_str
        , epilog=epilog_str
        , formatter_class=argparse.RawDescriptionHelpFormatter
        )
    parser.add_argument('-i', '--input', type=str, default = None
                        , help='input file path')
    parser.add_argument('-o', '--output', type=str, default = None
                        , help='output file path')
    parser.add_argument('-e', '--encoding', type=str
                        , default='utf8'
                        , help='input/output file encoding')
    parser.add_argument('-f', '--force', action='store_true'
                        , default = False
                        , help='open mode for output file')

    args = parser.parse_args(argv)
    encoding = args.encoding
    omode = 'wt' if args.force else 'xt'

    may_ifname = args.input
    with may_open_stdin(may_ifname, 'rt', encoding=encoding) as fin:

    may_ofname = args.output
    with may_open_stdout(may_ofname, omode, encoding=encoding) as fout:
if __name__ == "__main__":
    main()


