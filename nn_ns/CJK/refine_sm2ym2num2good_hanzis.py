

__all__ = '''
    refined_sm2ym2num2good_hanzi_str

    refine_sm2ym2num2good_hanzis
    '''.split()


from .sm2ym2num2good_hanzi_str import sm2ym2num2good_hanzi_str
from .max_refined_pair2original_max_pairs__shT_ygT_ydT_nsm8_nym8 import \
    max_refined_pair2original_max_pairs__shT_ygT_ydT_nsm8_nym8
from collections import defaultdict


def dict_intersect_keys(d, keys):
    # keys :: Set key | Map key ?
    d = dict(d)
    for key in list(d):
        if key not in keys:
            del d[key]
    return d

def refine_sm2ym2num2good_hanzis(
    sm_ls, ym_digit_ls, sm2ym2num2good_hanzis
    ):
    sm_set = set(sm_ls)
    ym2num_set = defaultdict(set)
    for ym_digit in ym_digit_ls:
        ym = ym_digit[:-1]
        digit = ym_digit[-1:]
        num = int(digit)
        ym2num_set[ym].add(num)

    sm2ym2num2good_hanzis = dict_intersect_keys(sm2ym2num2good_hanzis, sm_set)
    new_sm2ym2num2good_hanzis = {}
    for sm, ym2num2good_hanzis in sm2ym2num2good_hanzis.items():
        ym2num2good_hanzis = dict_intersect_keys(ym2num2good_hanzis, ym2num_set)
        new_ym2num2good_hanzis = {}
        for ym, num2good_hanzis in ym2num2good_hanzis.items():
            num2good_hanzis = dict_intersect_keys(num2good_hanzis, ym2num_set[ym])
            new_ym2num2good_hanzis[ym] = num2good_hanzis
        new_sm2ym2num2good_hanzis[sm] = new_ym2num2good_hanzis
    return new_sm2ym2num2good_hanzis


# happen to be unique!!!
[[__sms_yms_pair]
] = max_refined_pair2original_max_pairs__shT_ygT_ydT_nsm8_nym8.values()
(__sm_ls, __ym_digit_ls) = __sms_yms_pair

(refined_sm2ym2num2good_hanzi_str
) = refine_sm2ym2num2good_hanzis(
        __sm_ls, __ym_digit_ls, sm2ym2num2good_hanzi_str
        )
assert __sms_yms_pair == \
    (['c', 'ch', 'd', 'g', 'h', 'k', 's', 't', 'z', 'zh']
    ,['a1', 'a3', 'ai1', 'ai3', 'ai4', 'an1', 'an3', 'an4', 'ang1', 'ang3', 'ang4', 'ao1', 'ao3', 'ao4', 'eng1', 'ong1', 'ong3', 'ong4', 'ou1', 'ou3', 'ou4', 'u1', 'u2', 'u3', 'u4', 'uei1', 'uei3', 'uei4', 'uo4'])

def main(args=None):
    import argparse
    from seed.io.may_open import may_open_stdout # may_open_stdin
    from pprint import pprint
    from pathlib import PurePath as Path
    this_file = Path(__file__)
    this_folder = this_file.parent
    this_file_name = this_file.name

    parser = argparse.ArgumentParser(
        description=f'refine sm2ym2num2good_hanzi_str'
        , epilog=''
        , formatter_class=argparse.RawDescriptionHelpFormatter
        )
    parser.add_argument('-o', '--output', type=str, default=None
                        , help='output file path')
    parser.add_argument('-oe', '--output_encoding', type=str
                        , default='utf8'
                        , help='output file encoding')
    parser.add_argument('-f', '--force', action='store_true'
                        , default = False
                        , help='open mode for output file')

    args = parser.parse_args(args)
    output_encoding = args.output_encoding
    omode = 'wt' if args.force else 'xt'
    var_name = 'refined_sm2ym2num2good_hanzi_str'
    sm2ym_num_graph = globals()[var_name]

    may_ofname = args.output
    if may_ofname is None:
        may_ofname = this_folder / f'{var_name}.py'
    with may_open_stdout(may_ofname, omode, encoding=output_encoding) as fout:
        print(f'#{var_name} generated by {this_file_name}', file=fout);
        print(f'{var_name} = \\', file=fout);
        pprint(refined_sm2ym2num2good_hanzi_str, stream=fout)



if __name__ == '__main__':
    main()

