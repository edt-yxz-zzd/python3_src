#HHHHH
r'''
本来是想 完全对称，但做不到
    也许可以这样:
        N = len(charset4mask)
        n = floor_log2(N)
        2**n <= N < 2**(n+)
        做两次:
        * [0..2**n-1]
        * [N-2**n, N-1]
        遇到带外元素，则保持不变
        但这样也不对称，两次的次序需颠倒。
see:
    view others/数学/编程/TODO_list/周期长度为二的对称加密.txt

e ../../python3_src/nn_ns/app/register_xor.py
py -m nn_ns.app.register_xor
py -m nn_ns.app.debug_cmd   nn_ns.app.register_xor

view ../../python3_src/seed/text/mk_char_pt_ranges5predicator.py
view ../../python3_src/seed/text/charset_filter.py






#'''



r'''[[[#to generate ./_4register_xor
[[to generate ./_4register_xor.py
py -m nn_ns.app.register_xor > /sdcard/0my_files/tmp/_.txt
view /sdcard/0my_files/tmp/_.txt
!mv /sdcard/0my_files/tmp/_.txt ../../python3_src/nn_ns/app/_4register_xor.py
]]


#from seed.text.mk_char_pt_ranges5predicator import mk_char_pt_ranges5predicator, mk_ascii_char_pt_ranges5predicator
from seed.text.mk_char_pt_ranges5predicator import printable_ascii_char_pt_ranges, printable_ascii_sorted_chars
from seed.text.mk_char_pt_ranges5predicator import is_printable_ascii_char, is_printable_ascii_str
from seed.text.mk_char_pt_ranges5predicator import char_pt_ranges2char_set, char_pt_ranges2sorted_chars, char_pt_ranges2iter_sorted_chars

from seed.text.charset_filter import (
        EncodingCharFilter
        ,CharsetCharFilter
        ,CharNameRegexCharFilter
        ,CharPredicatorCharFilter
)
from seed.text.charset_filter import (
    the_space_char_filter
    ,the_printable_char_filter
        ,the_identifier_char_filter
            ,the_alpha_numeric_char_filter
                ,the_alpha_char_filter
                    ,the_lower_char_filter
                    ,the_upper_char_filter
                ,the_numeric_char_filter
                    ,the_digit_char_filter
                        ,the_decimal_char_filter
)

def _4register_xor():
    'to generate ./_4register_xor.py'
    printable_ascii_gb2312_char_pt_ranges = ((EncodingCharFilter('ascii') | EncodingCharFilter('gb2312')) & the_printable_char_filter).to_NonTouchRanges()


    printable_ascii_gb2312_sorted_chars = char_pt_ranges2sorted_chars(printable_ascii_gb2312_char_pt_ranges)

    print('#generated by ./register_xor.py')
    print('from seed.data_funcs.rngs import NonTouchRanges')
    print(f'printable_ascii_gb2312_char_pt_ranges = {printable_ascii_gb2312_char_pt_ranges!r}')
    print(f'printable_ascii_gb2312_sorted_chars = {printable_ascii_gb2312_sorted_chars!r}')
#]]]'''


#################################
#HHHHH
__all__ = '''
    alnum_ascii_char2idx4sorted_chars
    printable_ascii_char2idx4sorted_chars
    printable_ascii_gb2312_char2idx4sorted_chars

    is_alnum_ascii_str
    is_printable_ascii_gb2312_str

    usrhash_xor
        usrhash_xor_
        usrhash__bytes
        almost_symmetry_cipher
    main
    '''.split()

#################################
#HHHHH
___begin_mark_of_excluded_global_names__0___ = ...
import re
import hashlib
from seed.text.mk_char_pt_ranges5predicator import printable_ascii_char_pt_ranges, printable_ascii_sorted_chars, alnum_ascii_sorted_chars
from seed.text.mk_char_pt_ranges5predicator import is_printable_ascii_char, is_printable_ascii_str
from seed.mapping_tools.dict_op import inv__k2v_to_v2k#, inv__k2v_to_v2ks, inv__k2vs_to_v2k, inv__k2vs_to_v2ks
from seed.tiny import MapView, mk_tuple, check_type_is
from ._4register_xor import printable_ascii_gb2312_char_pt_ranges, printable_ascii_gb2312_sorted_chars
___end_mark_of_excluded_global_names__0___ = ...


assert printable_ascii_sorted_chars in printable_ascii_gb2312_sorted_chars
assert printable_ascii_char_pt_ranges < printable_ascii_gb2312_char_pt_ranges
assert 7539 == (len(printable_ascii_gb2312_sorted_chars))
assert 7539 == (printable_ascii_gb2312_char_pt_ranges.len_ints())


#################################
#HHHHH

alnum_ascii_char2idx4sorted_chars = MapView(inv__k2v_to_v2k(dict(enumerate(alnum_ascii_sorted_chars))))
printable_ascii_char2idx4sorted_chars = MapView(inv__k2v_to_v2k(dict(enumerate(printable_ascii_sorted_chars))))
printable_ascii_gb2312_char2idx4sorted_chars = MapView(inv__k2v_to_v2k(dict(enumerate(printable_ascii_gb2312_sorted_chars))))

def is_alnum_ascii_str(s, /):
    return {*s} <= alnum_ascii_char2idx4sorted_chars.keys()
def is_printable_ascii_gb2312_str(s, /):
    if is_printable_ascii_str(s):
        return True
    return {*s} <= printable_ascii_gb2312_char2idx4sorted_chars.keys()

#################################
#HHHHH
def usrhash_xor(web_site, usr_account, salt, mask, /, *, encrypt_vs_decrypt, charset_name):
    hash_str = _usrhash_xor(web_site, usr_account, salt, mask, encrypt_vs_decrypt=encrypt_vs_decrypt, charset_name=charset_name)
    mask_ = _usrhash_xor(web_site, usr_account, salt, hash_str, encrypt_vs_decrypt=not encrypt_vs_decrypt, charset_name=charset_name)
    if not mask_ == mask: raise logic-err
    return hash_str
_charset_name2params = dict(
    alnum=(is_alnum_ascii_str, alnum_ascii_sorted_chars, alnum_ascii_char2idx4sorted_chars)
    ,printable_ascii=(is_printable_ascii_str, printable_ascii_sorted_chars,printable_ascii_char2idx4sorted_chars)
    ,printable_gb2312=(is_printable_ascii_gb2312_str, printable_ascii_gb2312_sorted_chars, printable_ascii_gb2312_char2idx4sorted_chars)
)
def _usrhash_xor(web_site, usr_account, salt, mask, /, *, encrypt_vs_decrypt, charset_name):
    #mask__bytes = mask.encode('utf8')
        #??变长...
    #if not is_printable_ascii_str(mask):raise TypeError
        # 希望可以用『失效日期：20220420』，故改为:
    if 0:
        if is_alnum_ascii_str(mask):
            idx2char4mask = alnum_ascii_sorted_chars
            char2idx4mask = alnum_ascii_char2idx4sorted_chars
        elif is_printable_ascii_str(mask):
            idx2char4mask = printable_ascii_sorted_chars
            char2idx4mask = printable_ascii_char2idx4sorted_chars
        else:
            if not is_printable_ascii_gb2312_str(mask):raise TypeError
            idx2char4mask = printable_ascii_gb2312_sorted_chars
            char2idx4mask = printable_ascii_gb2312_char2idx4sorted_chars
    else:
        (is_xxx_str, idx2char4mask, char2idx4mask) = _charset_name2params[charset_name]
        if not is_xxx_str(mask):raise TypeError(f'{charset_name}:{mask!r}')

    return usrhash_xor_(web_site, usr_account, salt, mask, idx2char4mask=idx2char4mask, char2idx4mask=char2idx4mask, encrypt_vs_decrypt=encrypt_vs_decrypt)

def usrhash_xor_(web_site, usr_account, salt, mask__str, /, *, idx2char4mask, char2idx4mask, encrypt_vs_decrypt):
    assert len(idx2char4mask) == len(char2idx4mask)
    check_type_is(str, idx2char4mask)

    mask__idc = (*(char2idx4mask[ch] for ch in mask__str),)
    bare_salt = salt
    bss = []

    for i in range(len(mask__str)):
        i += 1
        salt = f'{i} {bare_salt} {i}'
        digest__bytes = usrhash__bytes(web_site, usr_account, salt)
        bss.append(digest__bytes)

    upper_bound4uint = len(idx2char4mask)
    key__bytess = mk_tuple(bss)
    cleartext__uints = mask__idc
    if 1:
        #using usrhash_xor/_usrhash_xor to detect error instead of almost_symmetry_cipher/_almost_symmetry_cipher
        ciphertext__uints = _almost_symmetry_cipher(upper_bound4uint, key__bytess, cleartext__uints, encrypt_vs_decrypt=encrypt_vs_decrypt)
    else:
        ciphertext__uints = almost_symmetry_cipher(upper_bound4uint, key__bytess, cleartext__uints, encrypt_vs_decrypt=encrypt_vs_decrypt)
    ciphertext__str = ''.join(idx2char4mask[u] for u in ciphertext__uints)
    if not len(ciphertext__str) == len(mask__str): raise logic-err
    hash_str = ciphertext__str
    return hash_str

def usrhash__bytes(web_site, usr_account, salt, /):
    #from nn_ns.app.register import usrhash as usrhash__hex
    hidden_salt = '1, 1, 1, 0, -1, 0, 1, 0, -1, 0, 5, 0, -691'
    # A164555 Numerators of the "original" Bernoulli numbers
    m = hashlib.sha512()
    inputs = [web_site, usr_account, salt, hidden_salt]
    string = ';'.join(inputs)
    bs = string.encode('utf8')
    m.update(bs)
    return m.digest()
    return m.hexdigest()

#################################
#HHHHH
def almost_symmetry_cipher(upper_bound4uint, key__bytess, cleartext__uints, /, *, encrypt_vs_decrypt):
    ciphertext__uints = _almost_symmetry_cipher(upper_bound4uint, key__bytess, cleartext__uints, encrypt_vs_decrypt=encrypt_vs_decrypt)
    cleartext__uints_ = _almost_symmetry_cipher(upper_bound4uint, key__bytess, ciphertext__uints, encrypt_vs_decrypt=not encrypt_vs_decrypt)
    cleartext__uints = mk_tuple(cleartext__uints)
    if not cleartext__uints_ == cleartext__uints: raise logic-err
    return ciphertext__uints

def _almost_symmetry_cipher(upper_bound4uint, key__bytess, cleartext__uints, /, *, encrypt_vs_decrypt):
    if not all(0 <= u < upper_bound4uint for u in cleartext__uints): raise TypeError
    if not len(key__bytess) == len(cleartext__uints): raise TypeError
    decrypt = int.__sub__
    encrypt = int.__add__
    if encrypt_vs_decrypt:
        f = decrypt
    else:
        f = encrypt

    def _iter_vs():
        for bs, u in zip(key__bytess, cleartext__uints):
            i = int.from_bytes(bs, byteorder='big')
            v = f(u, i)
            v %= upper_bound4uint
            yield v
    ciphertext__uints = tuple(_iter_vs())
    return ciphertext__uints




#################################
#HHHHH
_regex4main = re.compile(r'ver(\d+)_(\d+)([+-])(.+)')
def main(args=None):
    sign2case = {'+':False, '-':True}
    if args is None:
        import sys
        args = sys.argv[1:]
    else:
        args = [*args]
    print(args)

    [web_site, usr_account, *salts, len_bifx__indicator__sign___str, prefix_mask_suffix] = args
    m = _regex4main.fullmatch(len_bifx__indicator__sign___str)
    if m is None: raise ValueError(f'bad format: {len_bifx__indicator__sign___str!r}')
    len_prefix = m.group(1)
    len_suffix = m.group(2)
    sign = m.group(3)
    indicator = m.group(4)

    len_prefix = int(len_prefix)
    len_suffix = int(len_suffix)

    def _4indicator_sign():
        indicator, sign

        for is_xxx_str, charset_name in [(is_alnum_ascii_str, 'alnum'), (is_printable_ascii_char, 'printable_ascii'), (is_printable_ascii_gb2312_str, 'printable_gb2312')]:
            if is_xxx_str(indicator):break
        else:
            raise ValueError(f'unknown case:indicator: {indicator!r}')
        encrypt_vs_decrypt = sign2case[sign]
        return charset_name, encrypt_vs_decrypt
    def _4len_bifix():
        len_prefix, len_suffix, prefix_mask_suffix

        if not len_prefix+len_suffix <= len(prefix_mask_suffix):raise TypeError

        begin_mask = len_prefix
        end_mask = len(prefix_mask_suffix)-len_suffix
        mask = prefix_mask_suffix[begin_mask:end_mask]
        ignored_prefix = prefix_mask_suffix[:begin_mask]
        ignored_suffix = prefix_mask_suffix[end_mask:]
        ss4m = (ignored_prefix, mask, ignored_suffix)
        if not prefix_mask_suffix == ''.join(ss4m): raise logic-err
        return ss4m
    def _4salt():
        salts

        Noncharacter = '\uffff'
        Noncharacter
            #66个:32(U+FDD0..U+FDEF)+34(U+[00..10]FFF[E..F])
            # Noncharacter code points are reserved for internal use, such as for sentinel values.
        salt = Noncharacter.join(salts)
        assert salt.split(Noncharacter) == salts
        return salt


    charset_name, encrypt_vs_decrypt = _4indicator_sign()
    ignored_prefix, mask, ignored_suffix = _4len_bifix()
    salt = _4salt()

    hash_str = usrhash_xor(web_site, usr_account, salt, mask, encrypt_vs_decrypt=encrypt_vs_decrypt, charset_name=charset_name)
    ss4h = (ignored_prefix, hash_str, ignored_suffix)
    prefix_hash_suffix = ''.join(ss4h)
    print(prefix_hash_suffix)
    print(hash_str)
    print(hash_str[:9])

if '__main__' == __name__:
    main()

#################################
#HHHHH
