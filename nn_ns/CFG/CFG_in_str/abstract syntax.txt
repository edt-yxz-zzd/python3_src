distinguish concrete text syntax and abstract syntax
    concrete ==>> template name complicate struct
    abstract ==>> name is only name; atom, no internal struct

reduce_name = ([filter_name], Maybe filter_ex_name)
Ref filter_name = ([filter_name], ref_symbol_psidx)
    # f$g$A
    # no filter_ex_name: f$$A
Production filter_name filter_ex_name
    = Discard nonterminal_idx [Ref]
        # -A : ...
        # return None
    | Unit [filter_name] nonterminal_idx [Ref] Ref [Ref]
        # f$g$A = ... +B ...
        # return f(g(B.value))
        # NOTE: '='
    | UnitUnpack [filter_name] nonterminal_idx [(op, Ref)] # op = [-+*]
        # f$g$A = -C +B *D -E
        # return f(g([B.value, *D.value]))
        # NOTE: '='
        # concrete syntax require at least one '*' to distinguish with Unit
    | Tuple [filter_name] nonterminal_idx [(is_selected::bool, Ref)]
        # f$g$A : -C +B +D...
        # return f(g((B.value, D.value, ...)))
        # NOTE: g :: tuple -> obj
    | TupleWithAlias [filter_name] filter_ex_name nonterminal_idx [(is_selected::bool, Ref)] (Map alias_name idx)
        # f$g$h$$A : -C +~@B +d1@D +d2@D -@E
        # return f(g(h(args, kwargs))) # B d1 d2 E
        # NOTE: not: return f(g(h(*args, **kwargs)))??
        #   since unpack is dangerous
        #
        # idx <- [0..len(rhs)-1] # not the result!!
        # idx 1-to-[0..] alias_names
        #

ParseArgs =
    ([Production]
    # should remove duplicated production generated by external templates
    ,Map filter_name func
    ,Map filter_ex_name func
    ,...
    )



