

'''
DRACU-RIOT!.rar.td.cfg
http://dl3.t8.sendfile.vip.xunlei.com:8000/DRACU%2DRIOT%21%2Erar?key=5670454ba2bdc6c16b9fae740076f87e&file_url=%2Fgdrive%2Fresource%2FC9%2F94%2FC9CF69B6C7DE3BEF725B3B578C14359902FC0894&file_type=1&authkey=D79B2A44AA6885DCBE2BB606B8B343D09DE1D6DE70230D545FFA26502AF5EA15&exp_time=1359241659&from_uid=155451406&task_id=5829362019117905154&get_uid=1008631505&f=lixian.vip.xunlei.com&reduce_cdn=1&fid=nZugq2d5uIi9YL6IIcVroDaCBMu7yWvWAAAAAMnPabbH3jvvcls7V4wUNZkC/AiU&mid=666&threshold=150&tid=B7D2391A9D230DF2B7755AE4A412ECDA&srcid=7&verno=1
http://dl1.t8.sendfile.vip.xunlei.com:8000/DRACU-RIOT%21.rar?key=c91c9344825cac6673d098edff7ce68e&file_url=%2Fgdrive%2Fresource%2FC9%2F94%2FC9CF69B6C7DE3BEF725B3B578C14359902FC0894&file_type=1&authkey=3E8B635DFF9F8FEAC6BA617EA677215737963C59BC4F361A2B610393AD57833D&exp_time=1359241659&from_uid=155451406&task_id=5829362019117905154&get_uid=1008631505&f=lixian.vip.xunlei.com&reduce_cdn=1&fid=nZugq2d5uIi9YL6IIcVroDaCBMu7yWvWAAAAAMnPabbH3jvvcls7V4wUNZkC/AiU&mid=666&threshold=150&tid=B7D2391A9D230DF2B7755AE4A412ECDA&srcid=7&verno=1


?key=5670454ba2bdc6c16b9fae740076f87e&file_url=
&authkey=D79B2A44AA6885DCBE2BB606B8B343D09DE1D6DE70230D545FFA26502AF5EA15&exp_time=

?key=c91c9344825cac6673d098edff7ce68e&file_url=
&authkey=3E8B635DFF9F8FEAC6BA617EA677215737963C59BC4F361A2B610393AD57833D&exp_time=
'''



'''
[110826]PCゲーム『穢翼のユースティア』ORIGINAL_SOUND_TRACK(flac+cue+log+png+rr3).part4.rar.td.cfg
http://183.60.157.53/gdown_group266/M00/04/E9/tzydNU9YmzoAAAAAGQAAAA-miik7972874/%5B110826%5DPC%E3%82%B2%E3%83%BC%E3%83%A0%E3%80%8E%E7%A9%A2%E7%BF%BC%E3%81%AE%E3%83%A6%E3%83%BC%E3%82%B9%E3%83%86%E3%82%A3%E3%82%A2%E3%80%8FORIGINAL_SOUND_TRACK%28flac%2Bcue%2Blog%2Bpng%2Brr3%29.part4.rar?k=EAcogd7QbHUAHYDDpv6JLQ&t=1357535775&u=244560600-306470346-eil16bwp&s=102400&file=%5B110826%5DPC%E3%82%B2%E3%83%BC%E3%83%A0%E3%80%8E%E7%A9%A2%E7%BF%BC%E3%81%AE%E3%83%A6%E3%83%BC%E3%82%B9%E3%83%86%E3%82%A3%E3%82%A2%E3%80%8FORIGINAL_SOUND_TRACK%28flac%2Bcue%2Blog%2Bpng%2Brr3%29.part4.rar
http://183.60.157.53/gdown_group266/M00/04/E9/tzydNU9YmzoAAAAAGQAAAA-miik7972874/%5B110826%5DPC%E3%82%B2%E3%83%BC%E3%83%A0%E3%80%8E%E7%A9%A2%E7%BF%BC%E3%81%AE%E3%83%A6%E3%83%BC%E3%82%B9%E3%83%86%E3%82%A3%E3%82%A2%E3%80%8FORIGINAL_SOUND_TRACK%28flac%2Bcue%2Blog%2Bpng%2Brr3%29.part4.rar?k=uQkDCQFp9uihJsEF-0qRvg&t=1357526143&u=244560600-306470346-eil16bwp&s=102400&file=%5B110826%5DPC%E3%82%B2%E3%83%BC%E3%83%A0%E3%80%8E%E7%A9%A2%E7%BF%BC%E3%81%AE%E3%83%A6%E3%83%BC%E3%82%B9%E3%83%86%E3%82%A3%E3%82%A2%E3%80%8FORIGINAL_SOUND_TRACK%28flac%2Bcue%2Blog%2Bpng%2Brr3%29.part4.rar

?k=EAcogd7QbHUAHYDDpv6JLQ&t=1357535775&u=
?k=uQkDCQFp9uihJsEF-0qRvg&t=1357526143&u=
'''



'''
[fyd09@古河渚吧][100402]MOON._For_Windows_XP／Vista／7.part1.rar
http://cdntel.115.com/gdown_group187/M00/00/B1/d5NjMk7aLhEAAAAAMgAAACE5B608980250/%5Bfyd09%40%E5%8F%A4%E6%B2%B3%E6%B8%9A%E5%90%A7%5D%5B100402%5DMOON.%E2%80%8B_For_Windows_XP%EF%BC%8FVista%EF%BC%8F7.part1.rar?k=Yi0r9TetlwWYCEw0sUOshg&t=1384505433&u=242712551-307291462-cy4sug1rsutjdbb6&s=307200&file=%5Bfyd09%40%E5%8F%A4%E6%B2%B3%E6%B8%9A%E5%90%A7%5D%5B100402%5DMOON.%E2%80%8B_For_Windows_XP%EF%BC%8FVista%EF%BC%8F7.part1.rar&h=cdntel.115.com
http://cdntel.115.com/gdown_group187/M00/00/B1/d5NjMk7aLhEAAAAAMgAAACE5B608980250/%5Bfyd09%40%E5%8F%A4%E6%B2%B3%E6%B8%9A%E5%90%A7%5D%5B100402%5DMOON.%E2%80%8B_For_Windows_XP%EF%BC%8FVista%EF%BC%8F7.part1.rar?k=WXC6rJfrlpkk-gb9dJw54A&t=1384460918&u=242712454-307291462-cy4sug1rsutjdbb6&s=1024000&file=%5Bfyd09%40%E5%8F%A4%E6%B2%B3%E6%B8%9A%E5%90%A7%5D%5B100402%5DMOON.%E2%80%8B_For_Windows_XP%EF%BC%8FVista%EF%BC%8F7.part1.rar&h=cdntel.115.com

?k=Yi0r9TetlwWYCEw0sUOshg&t=1384505433&u=
?k=WXC6rJfrlpkk-gb9dJw54A&t=1384460918&u=
'''


import os.path, distutils.file_util
from collections import deque
from prime2 import mod_pow

KB = 1024 # byte
max_file_size = 1000*KB # guess
url_num = 2 # number of the same url in one '.td.cfg' file
maxlen_url = 2000 # standard



'''
wiki/Multiplicative_group_of_integers_modulo_n#Powers_of_2

k > 2, n = 2^k, U(Z/nZ) is not cyclic
U(Z/nZ) = Gen(2^(k-1)-1 mod n) * Gen(3 mod n) ~=~ Cyclic(2) * Cyclic(2^(k-2))
the powers of 3 are a subgroup of order 2^(k − 2)

U(Z/p^kZ) ~=~
    p = 2, k = 1: Cyclic(1)
    p = 2, k > 1: Cyclic(2) * Cyclic(2^(k-2))
    p is odd prime: Cyclic((p-1)*p^(k-1))

=================================================
n > 1, k > 0, p is an odd prime,
U(Z/nZ) is cyclic iff n = 2, 4, p^k, 2*p^k

=================================================
n = product(p[i]^k[i] for i in N)
Z/nZ ~=~ product Z/p[i]^k[i]Z
U(Z/nZ) ~=~ product U(Z/p[i]^k[i]Z)
NOTE: |U(Z/p^kZ)| = p^(k-1)*(p-1),
    1. if p is odd, then 2|(p-1)
    2. if there is another odd prime q, then I2*I2 ~=~ a subgroup of U(Z/p^kZ)*U(Z/q^tZ)
    3. if p = 2, and k > 1, then 2|2^(k-1)*(2-1), n = 2^k*q^t has not primitive root
    4. if p = 2, and k > 2, then Z/2^kZ is not cyclic
    => U(Z/nZ) is cyclic iff n = 2, 4, p^k, 2*p^k

=================================================
phi(n) = Euler_totient_function(n) = order(U(Z/nZ))
lambda(n) = Carmichael_function(n)
    = min [i for i in [1..n] if unique[a^i mod n for a in U(n)] == [1]]
    where U(n) = [u for u in [1..n] if gcd(u, n) == 1]
U(Z/nZ) is cyclic iff phi(n) = lambda(n)
The single generator in the cyclic case is called a primitive root modulo n.

=================================================
Finding primitive roots
1. n = 2 or 4, g = 3
2. n = p
    primitive_root(p) = min [g for g in [1..p-1]
        if 1 not in [g^((p-1)/q) mod p for q in factors(p-1)]]
3. n = p^k
    primitive_root(p^k)
        | g^(p-1) mod p^2 == 1 = g + p
        | otherwise            = g
        where g = primitive_root(p)
4. n = 2*p^k
    primitive_root(2*p^k)
        | g mod 2 == 0 = g + p^k
        | otherwise    = g
        where g = primitive_root(p^k)

        
'''
hash_bit_num = 32
hash_modulo_n = 2**hash_bit_num
hash_base = 3
hash_order= 2**(hash_bit_num - 2)


def replace_key(xunlei_td_cfg_file, backup_file, new_url, key_getter, url_number = url_num, key_char_table = ''):
    '''replace the key and the authkey in the old .td.cfg file with those in new url.

    用迅雷下载网盘的东西，有时会完全停下来，可能是本次下载链接的有效期过了。
    文件大网速慢，下载超过半天的话，很容易出现这种情况。
    重新打开资源的下载网页，复制链接地址，应该能发现与当前的下载地址不一样。
    迅雷快传：把新地址中的key=与authkey=写入.td.cfg文件中，覆盖同名部分即可。
    115网盘：把新地址中的k=与t=写入.td.cfg文件中，覆盖同名部分即可。

    手动修改（以迅雷快传为例）：
    条件：迅雷快传上的资源未过期，迅雷下载中止
    假设下载中的文件为：XXX0.td 与 XXX0.td.cfg
    1）暂停下载
    2）移动XXX0.td 与 XXX0.td.cfg到别的文件夹
    3）备份XXX0.td.cfg
    4）彻底删除迅雷的下载任务（注意前面步骤2不能省）
    5）打开快传资源网页，复制下载地址（当然必须是同一资源）
    ...假设新地址为：http...?key=YYY1&file_url=...&authkey=YYY2&exp_time=...&verno=1
    ...可能每次刷新网页都会出新链接，所以链接会过期也不奇怪吧。
    6）用16进制编辑器（如：Hexplorer）打开XXX0.td.cfg
    ...可以立即看到旧地址为：http...?key=XXX1&file_url=...&authkey=XXX2&exp_time=...&verno=1
    ...复制旧地址。
    7）用YYY1替换XXX0.td.cfg中的XXX1，用YYY2替换XXX2。（注意各有两处）
    ...地址的其它部分也可能不同，但不影响结果。
    ...因为地址的长度可能不同，所以我没试过直接替换地址。
    ...但key与authkey的长度应该是分别相同的。
    8）保存XXX0.td.cfg并退出编辑器
    9）双击XXX0.td，现在迅雷应该开始下载了。

    '''


    if not (os.path.getsize(xunlei_td_cfg_file) < max_file_size):
        raise 'file size error'
    elif not is_xunlei_td_cfg_file(xunlei_td_cfg_file):
        raise ' file format error'

    if backup_file != None:
        backup(xunlei_td_cfg_file, backup_file)

    # of type bytes except file name
    # type : str or bytes or int
    # char == of type str of length 1
    # byte == bytes of length 1
    # ibyte == of type int
    old_url = get_resource_url(xunlei_td_cfg_file)
    new_url = str2bytes(new_url)
    old_keys = key_getter(old_url)
    new_keys = key_getter(new_url)
    check_keys(old_keys, new_keys, key_char_table)
    
    keys_locations = search_all(old_keys, xunlei_td_cfg_file)
    check_keys_locations(keys_locations, url_number, len(old_keys))
    write_keys(new_keys, keys_locations, xunlei_td_cfg_file)





def is_xunlei_td_cfg_file(file):
    postfix = '.td.cfg'
    length = len(postfix)
    if not (file[-length:] == postfix):
        return False

    head = []
    # first 4 bytes '03 00 00 00'
    with open(file, 'rb') as f: #io.BufferedReader
        head = f.read(4)
        
    return b'\3\0\0\0' == head

def backup(file, path):
    if os.path.lexists(path) and os.path.isfile(path):
        raise 'file of the backup name exists!'
    
    distutils.file_util.copy_file(file, path)

def get_resource_url(file):
    with open(file, 'rb') as f: 
        begin = search_next(b'http://', f)
        if begin < 0:
            raise 'url not found'
        
        f.seek(begin)
        url = bytearray()
        while(len(url) <= maxlen_url):
            byte = f.read(1)
            if len(byte) != 1:
                break

            ibyte = byte[0]
            if not is_url_char(chr(ibyte)):
                break
            url.append(ibyte)

        if len(url) == maxlen_url:
            raise 'url too long.'
        
        return url

    raise '?'

def xunleikuaichuan_key_getter(url):
    key_fmt = (b'?key=', b'&file_url=') #'\\?key=([0-9a-fA-F]+)\\&file_url='
    autokey_fmt = (b'&authkey=', b'&exp_time=') #'\\&authkey=([0-9a-fA-F]+)\\&exp_time='
    key = get_key(key_fmt[0], key_fmt[1], url)
    autokey = get_key(autokey_fmt[0], autokey_fmt[1], url)
    return (key, autokey)


def baiduyunwangpan_key_getter(url):
    xcode_fmt = (b'?xcode=', b'&fid=') #'\\?key=([0-9a-fA-F]+)\\&file_url='
    xcode = get_key(xcode_fmt[0], xcode_fmt[1], url)
    return (xcode,)

def wangpan115_key_getter(url):#?k=Yi0r9TetlwWYCEw0sUOshg&t=1384505433&u=
    k_fmt = (b'?k=', b'&t=')
    t_fmt = (b'&t=', b'&u=')
    k = get_key(k_fmt[0], k_fmt[1], url)
    t = get_key(t_fmt[0], t_fmt[1], url)
    return (k, t)

def check_keys(old_keys, new_keys, key_char_table):
    assert(len(old_keys) == len(new_keys))
    for (old, new) in zip(old_keys, new_keys):
        assert(len(old) == len(new))
        oldstr = bytes2str(old)
        newstr = bytes2str(new)
        assert isalnum_or(oldstr, key_char_table)
        assert isalnum_or(newstr, key_char_table)

def isalnum_or(s, otherwise_char_table):
    if s.isalnum(): return True
    for c in s:
        if not (c.isalnum() or c in otherwise_char_table):
            return False
    return True
        
def search_all(keys, file):
    locations = []
    with open(file, 'rb') as f:
        for key in keys:
            f.seek(0)
            locs = []
            locations.append(locs)
            while True:
                loc = search_next(key, f)
                if loc < 0:
                    break
                locs.append(loc)

    assert(len(locations) == len(keys))
    return locations

def check_keys_locations(keys_locations, url_number, key_number):
    assert(url_number > 0)
    assert(key_number > 0)
    assert(len(keys_locations) == key_number)
    for locations in keys_locations:
        assert(len(locations) == url_number)

    # each key in the same relative location of a url in the file
    for i in range(1, url_number):
        diff = keys_locations[0][i] - keys_locations[0][i-1]
        for j in range(1, key_number):
            assert(diff == keys_locations[j][i] - keys_locations[j][i-1])
            
def write_keys(new_keys, key_locations, file):
    assert(len(new_keys) == len(key_locations))
    with open(file, 'r+b') as f:
        for (key, locations) in zip(new_keys, key_locations):
            for loc in locations:
                write_key(key, loc, f)


def is_url_char(char):
    assert(len(char) == 1) # is of type str
    return char.isprintable()

def get_key(left, right, url):
    begin = url.find(left)
    if begin < 0:
        raise 'key not found in url: "' + bytes2str(left) + '"'
    assert 0 <= begin <= len(url) - len(left)
    begin += len(left)
    
    end = url.find(right, begin)
    if end < 0:
        raise 'key not found in url: "' + bytes2str(right) + '"'
    assert begin <= end <= len(url) - len(right)
    
    return url[begin : end]

def search_next(key, f):
    length = len(key)
    data = f.read(length)
    if not (len(data) == length):
        return -1
    elif data == key:
        return f.tell() - length

    block = deque(data, length)
    key_deque = deque(key, length)
    key_hash = Hasher(key).get_hash()
    data_hasher = Hasher(data)
    while True:
        byte = f.read(1)
        if len(byte) != 1:
            break
        old_ibyte = block.popleft()
        new_ibyte = byte[0]
        block.append(new_ibyte)
        data_hash = data_hasher.fifo_hash(old_ibyte, new_ibyte)
        if data_hash == key_hash:
            if block == key_deque:
                return f.tell() - length

    return -1

def write_key(key, loc, f):
    f.seek(loc)
    f.write(key)
    


#class Block:
    '''store some bytes that read from file

    len(temp_data) == length <= len(stored_data) <= max_block
    temp_data == stored_data[-length:]#'''
    '''
    len_time = 5
        
    def __init__(self, temp_data, max_block = -1):
        self.data = temp_data
        self.length = len(self.data) # constant
        self.max_block = max_block
        if max_block < self.length:
            self.max_block = self.len_time * self.length

    def get_data(self):
        return self.data[-self.length:]

    def get_block(self):
        return self.data

    def get_length(self):
        return self.length
    
    def push(self, data):
        if len(data) >= self.max_block:
            self.data = data[-length:]
        elif len(data) >= self.length:
            self.data = data
        elif len(self.data) + len(data) > self.max_block:
            self.data = self.data[-(self.length - len(data)) :] + data
        else:
            self.data += data

    #'''


class Hasher:
    def __init__(self, data, modulo_n = hash_modulo_n, base = hash_base, order = hash_order):
        self.modulo_n = modulo_n
        self.base = base
        self.order = order
        self.length = len(data)
        (h, p) = hash_str(data, modulo_n, base, order)
        self.hash = h
        self.patch = p

    def fifo_hash(self, old_ibyte, new_ibyte):
        self.hash = hash_str_plus(self.hash, old_ibyte, new_ibyte, \
                                  self.modulo_n, self.base, self.patch)
        return self.hash

    def get_hash(self):
        return self.hash




def hash_str(data, modulo_n, base, order):
    assert(type(data[0]) == int) # data is of type bytes or bytearray, but not str
    
    # data[0]*base**(length-1+d) +..+ data[-1]*base**(0+d) mod n
    # base**(length+d) = 1 mod n
    # length+d = 0 mod order
    length = len(data)
    # The modulo operator always yields a result
    # with the same sign as its second operand (or zero);
    # the absolute value of the result is strictly
    # smaller than the absolute value of the second operand.
    d = (-length) % order
    patch = mod_pow(base, d, modulo_n)
    h = 0
    for ibyte in data:
        # a = ord(c)
        h *= base
        h += ibyte
        h %= modulo_n

    h = (h * patch) % modulo_n
    return (h, patch)
    

def hash_str_plus(data_hash, old_ibyte, new_ibyte, modulo_n, base, patch):
    assert(type(old_ibyte) == int)
    assert(type(new_ibyte) == int)
    h = data_hash * base + (new_ibyte) * patch - (old_ibyte)
    h %= modulo_n
    return h



def str2bytes(s):
    return bytes(s, 'ascii')
    
def bytes2str(b):
    return str(b, 'ascii')


def test_replace_key_1():
    fn = '1.td.cfg'
    backup_file = '2.td.cfg'
    backup_file = None
    old_url = r'http://dl1.t7.sendfile.vip.xunlei.com:8000/' \
              r'%E7%A7%8B%E4%B9%8B%E5%9B%9E%E5%BF%863.part1.rar' \
              r'?key=749b83a29f34fe32ae6b19c097ed8211' \
              r'&file_url=%2Fgdrive%2Fresource%2F8A' \
              r'%2F84%2F8A07699B15E5A47AFD477AD3E9631510C1C30584' \
              r'&file_type=0' \
              r'&authkey=1B742FA379E99C032DC4F86662E27B6CE803B60350118D67C22E560A3BF96D46' \
              r'&exp_time=1361134562&from_uid=73923990&task_id=5693989133894421762' \
              r'&get_uid=1003794037&f=lixian.vip.xunlei.com&reduce_cdn=1' \
              r'&fid=vZ6WYCZYaayQMJcR2mVFm3zoQjeAvVEqAAAAAIoHaZsV5aR6/Ud60+ljFRDBwwWE' \
              r'&mid=666&threshold=150&tid=08D2711593DF3F2B8E6ABB97C5785D1C&srcid=7&verno=1'
    
    new_url = r'http://dl1.t7.sendfile.vip.xunlei.com:8000/' \
              r'%E7%A7%8B%E4%B9%8B%E5%9B%9E%E5%BF%863.part1.rar' \
              r'?key=ffffffffffffffffffffffffffffffff' \
              r'&file_url=%2Fgdrive%2Fresource%2F8A' \
              r'%2F84%2F8A07699B15E5A47AFD477AD3E9631510C1C30584' \
              r'&file_type=0' \
              r'&authkey=fff42FA379E99C032DC4F86662E27B6CE803B60350118D67C22E560A3BF96D46' \
              r'&exp_time=1361134562&from_uid=73923990&task_id=5693989133894421762' \
              r'&get_uid=1003794037&f=lixian.vip.xunlei.com&reduce_cdn=1' \
              r'&fid=vZ6WYCZYaayQMJcR2mVFm3zoQjeAvVEqAAAAAIoHaZsV5aR6/Ud60+ljFRDBwwWE' \
              r'&mid=666&threshold=150&tid=08D2711593DF3F2B8E6ABB97C5785D1C&srcid=7&verno=1'
    
    key_getter = xunleikuaichuan_key_getter
    
    replace_key(fn, backup_file, new_url, key_getter)



def test_replace_key():
    path = r'd:/download/'
    fn = path + 'Cabelas.Hunting.Expedition.Cracked.Chs.Green.Edition-ali213.part08.rar.td.cfg'
    backup_file = path + 'old_Cabelas.Hunting.Expedition.Cracked.Chs.Green.Edition-ali213.part08.rar.td.cfg'
    backup_file = None
    old_url = r'http://14.17.101.73/ws.cdn.baidupcs.com/file/273f1b2cecbb4da9cc6838996efec001?xcode=efbc2fa45337252bd9ea10f0ae210cf258d56787ead6a0a9837047dfb5e85c39&fid=1661631861-250528-93022428669703&time=1407545206&sign=FDTAXER-DCb740ccc5511e5e8fedcff06b081203-6X3tbNkqSv%2Fj2MLeZnhiZWmQgtQ%3D&to=cb&fm=Nan,B,T,t&sta_dx=477&sta_cs=2&sta_ft=rar&sta_ct=5&newver=1&newfm=1&expires=1407554972&rt=sh&r=792742344&mlogid=4043895927&sh=1&vuk=2067780081&vbdid=1546903363&fn=Cabelas.Hunting.Expedition.Cracked.Chs.Green.Edition-ali213.part08.rar&wshc_tag=0&wsiphost=ipdbm'

    
    new_url = r'http://14.17.101.73/ws.cdn.baidupcs.com/file/273f1b2cecbb4da9cc6838996efec001?xcode=77495089413b756676a4876e10957ffb58d56787ead6a0a9837047dfb5e85c39&fid=1661631861-250528-93022428669703&time=1407552546&sign=FDTAXER-DCb740ccc5511e5e8fedcff06b081203-QnLXH96RRqcEj7cRT4vvIaB3FM8%3D&to=cb&fm=Nan,B,T,t&sta_dx=477&sta_cs=2&sta_ft=rar&sta_ct=5&newver=1&newfm=1&expires=1407562312&rt=sh&r=284405502&mlogid=2160815884&sh=1&vuk=2067780081&vbdid=1546903363&fn=Cabelas.Hunting.Expedition.Cracked.Chs.Green.Edition-ali213.part08.rar&wshc_tag=0&wsiphost=ipdbm'
    
    key_getter = baiduyunwangpan_key_getter
    
    replace_key(fn, backup_file, new_url, key_getter)


t = test_replace_key





    
