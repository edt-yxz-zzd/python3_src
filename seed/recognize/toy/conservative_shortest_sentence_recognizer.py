#__all__:goto
r'''[[[
e ../../python3_src/seed/recognize/toy/conservative_shortest_sentence_recognizer.py
rm:e ../../python3_src/seed/recognize/toy/poor_efficiency_toy_recognizer.py


seed.recognize.toy.conservative_shortest_sentence_recognizer
py -m nn_ns.app.debug_cmd   seed.recognize.toy.conservative_shortest_sentence_recognizer -x
py -m nn_ns.app.doctest_cmd seed.recognize.toy.conservative_shortest_sentence_recognizer:__doc__
py -m nn_ns.app.doctest_cmd seed.recognize.toy.conservative_shortest_sentence_recognizer:__doc__  -ff -v --ndiff
py_adhoc_call   seed.recognize.toy.conservative_shortest_sentence_recognizer   @f
py_adhoc_call  seed.helper.print_methods  @wrapped_print_methods   %seed.recognize.toy.conservative_shortest_sentence_recognizer:XXX@T    =T      ++exclude_prefixes:_       +exclude_attrs5listed_in_cls_doc
from seed.recognize.toy.conservative_shortest_sentence_recognizer import *
#]]]'''
__all__ = r'''
'''.split()#'''
__all__
r'''[[[
#]]]'''#'''
r'''[[[
    ===
结果冃子
    # False/结果乊失败 | .../结果乊裁剪导致中断 | (内禀结果,外赋结果冖惰性值)/结果乊返回
    ===
需要:内建解码器:
    内建伪解码器冫返回
    内建伪解码器冫全局退出
    内建解码器冫主解码器
        [内建解码器冫主解码器 ~==~ [.欤继承已解禁=True]:(解禁+++主解码器冖用户+++裁剪+++内建伪解码器冫全局退出)]
解码器 分类:三纲:四属:五种
    * 凡解码器:一属:一种
        * 非伪非幺解码器
            #包含: 内建解码器冫主解码器
            #接口规范 ==>> 用户自定义类型
    * 幺解码器:一属:一种
        * 魊码元解码器
            #接口规范 ==>> 用户自定义类型
    * 伪解码器:两属:三种
        * 幺伪解码器:一种
            * 内建伪解码器冫全局退出
                #实例唯一
                #用于 实现 内建解码器冫主解码器
        * 零伪解码器:两种
            * 内建计算暨赋值零伪解码器
                #类型唯一
                #参数=>不同实例
                #解禁之后:清空 局部地址变量环境乊父乊子起，不允许 取地址,取码元串:
                #   [欤本分支已解禁乊父乊子起===(局部地址变量环境乊父乊子起 is None)]
            * 内建伪解码器冫返回
                #实例唯一
                #用于 实现 取囗鬽返回俩鬽名纟所在父解码器分支扌()
另外:综合归类:四属:五种
    #说是『归类』不太恰当，因为 分类 依赖于 特定文本特定位置
    泛幺解码器:两属:两种
        幺解码器:一属:一种
        幺伪解码器:一属:一种
    泛零解码器:一个半属:两个半种
        零伪解码器:一属:两种
        零凡解码器:半属:半种
            ===特定文本特定位置上不论成败解码过程未用到泛幺解码器的凡解码器#xxx不含泛幺解码器子部件的凡解码器
    步进凡解码器:半属:半种
        ===特定文本特定位置上不论成败用到泛幺解码器的凡解码器#xxx含泛幺解码器子部件的凡解码器
    ===

#]]]'''#'''
r'''[[[
也许 应该 考虑 更抽象一点的 具现方案
    并行计算
    同步乊返回
    步进时钟
各种类型，全部同步 统一处理:
    返回,裁剪,全局退出,步进
    歧义纟不兼容:裁剪,返回,全局退出
    歧义纟分支状态合流
    #####
    #xxx:[充分展开层<返回同步层]
    [充分展开层-返回同步层:循环 直至 稳定]
        #稳定==>> 正常 或 同步统计所有错误
    返回触发:
        *发现 返回件,分支 是 返回件
        *发现 直接返回 立即讫果
        某分支 返回 => 委托方 挂靠到 场景.待办队列乊下达指令冫自查欤受阻
            #???下达:自查 全线受阻???
            #   ???有毛病:挤牙膏式 发现 某算件 返回唯一，多次自查，多次更新自查结果???...
            #   [全线受阻==True]这一结果 步进前 不变
            #   但[全线受阻==False]这一结果 可能改变，某算件 返回:
            #       (1)父后移 然后 受阻，[父.受阻分支数量+=1]
            #       (2)父后移 然后 失败，[父.存活分支数量-=1]
            #       即:下达自查+缓存(当前地址,受阻分支数量)+自动更新(自查时地址{==当前},受阻分支数量)+自动更新(存活分支数量)
            #   注意:防止 死循环
            #   非DAG是有错误的#零-相互依赖 是 不被允许的: 一出结果便生歧义:非解析树
            #   DAG是能正常执行:注意:缓存自查结果@当前地址
            #???上传:自报 全线受阻???:最简单，但最耗时
    返回同步层:检查 返回唯一性
        不能独立，必须循环！
        后移 要求 前子 出结果，因为 需要更新 变量环境
        发现 返回 唯一，需得 出结果 然后 循环
        这时 完毕件 未全部完毕，可能 受阻于 某个 已有 分支 返回 但 等待 检查返回唯一 而 未出结果
    #####
    [结果层=[def]=充分展开层返回同步层循环]
    完毕件:
        泛零透件:结果层居后 全部出现 完毕
        部件{讫==当前}:结果层居后 全部返回 完毕
        出结果(不论成败)，父已后移，可撤除
    受阻件:
        未返回部件:结果层居后 所有存活分支 受阻于 其他受阻件|伪幺阻件(幺阻件|退出件)
        由于 尚未撤消，可能出现以下情形:
            #公算件:分支集合
            [私算件 是 受阻件]
            [私算件.公 是 完毕件]
            #同理:私算件:分支集合#多种展开/多后续
    #####
    结果层诸前:算件 只增
        『公/公算件』只增
        『私/私算件』只增
        新构造{起==当前}
    #####
    [结果层<过气件撤消层]
    #####
    过气件撤消层:算件 只减
        #####
        * 撤消 所有 完毕件#一遍
            [私算件 是 受阻件][私算件.公 是 完毕件]:
                [撤消 完毕件=>私算件 无委托方]
        #####
        * 撤消 所有 无委托方 受阻件#循环
            #下达-->del 上传.委托方[过气件]
        下达:
            私算件.存活未果后续展开
            公算件.所有存活未果分支
        上传:
            公算件.所有委托方
            私算件.公/唯一委托方
        委托方向:
            公算件->私算件as分支#并态未来结果冃分支
            私算件->公算件as调用#并态未来结果冃展开
            [私算件 是 受阻件][私算件.公 被撤消]:
                !! [私算件.公 是 私算件 唯一委托方]
                [私算件 无委托方]
            [私算件 是 公算件 的 某一委托方][私算件 被撤消]:
                [公算件 委托方 减少一个]
        #####
    #####
    #####
    #####
    #####


太上件#内建关键操作符
    幺阻件#受阻于步进前夕
    解禁件#欤继承已解禁乊父起=(T|F) if 父起<当前 else (T|NA) #充分展开层居后 步进前:于 充分解禁层居后 固化
    裁剪件
    返回件
    退出件#全局退出
    太初件#as主解码器
乸并行计算
    #.构造囗公算件扌(起时刻乊公,构造参数;场景) -> 公/公算件
    场景.构造囗公算件扌(起时刻乊公,构造参数;) -> 公/公算件
        要求结果可重复利用
        ==>>外界定位
        ==>>没有多余的数据
        公算件.所有委托方#借地缓存
        公.场景 是 共通背景/无关项
        取出唯一缓存的『公』，允许将 缓存数据 放置于『公』
            若 真构造，则 要求 [起时刻乊公==当前时刻]@结果层诸前:只增#过气件撤消层:只减#过气件撤消层:难说
                顺带 挂靠到 场景.待办队列乊展开
            hash==id
            保证唯一冖冖构造先查询缓存
    #.构造囗私算件扌(起时刻乊公,构造参数,起时刻乊私,分支状态乊起;场景,私有数据) -> 私/私算件
    公.构造囗私算件扌(起时刻乊私,分支状态乊起;私有数据) -> 私
        私有数据
        ==>>有多余的数据
        ==>>外界无法定位
        私算件.公/唯一委托方#逻辑必要数据
        #
        (起时刻乊私,分支状态乊起):用于 检测 歧义乊合流
            hash==id
            保证唯一冖冖禁止合流
    公.启动扌() -> 并态未来结果冃分支
        只执行一次
        公.所有存活未果分支#借地缓存
    私.运行扌() -> 并态未来结果冃展开
        只执行一次
        私.存活未果后续展开#借地缓存
        #####
        [并态未来结果冃分支==(立即讫错果|叉[私])]
        [并态未来结果冃展开==(立即讫错果|叉[私臫他公果])]
        [立即讫错果==(立即讫错|立即讫果)==(讫时刻乊公,错误丨结果)]
        [私臫他公果==(泛公冃子,私巛他公果扌)]
        [泛公冃子==(他公/公开接口|太上件)]
        #这里的『私』都是『公』的『私』
        #   『他公』是外来的，与『私』无关
        # 要求:[公 is 私.公]
        # 要求: 起起符合@下沉调用/初始展开/就地展开
        # 要求: 讫起符合@后移
        # 要求:启动扌[立即讫错果.讫时刻 is 公.起时刻乊公]
        # 要求:运行扌[立即讫错果.讫时刻 is 私.起时刻乊私]
        # 要求:启动扌 [他公.起时刻乊公==公.起时刻乊公]
        # 要求:运行扌 [他公.起时刻乊公==私.起时刻乊私]
        # 要求:[私巛他公果扌(讫果纟他公.果).起时刻乊私==讫果纟他公.讫时刻]
        # 要求:[私巛他公果扌(讫果纟他公.果).公 is 公]

#]]]'''#'''
r'''[[[
对象清单:
#######
注意:下达指令:展开丷撤消
注意:返回预定,上传结果:触发器
#######
[:定义处冫具名缓存空间]:goto
具名缓存空间:
    名称:返回结果缓冲区
    名称:上传区
    名称:下达暨后移区
    名称:原地合流检测区
    名称:步进合流检测区
    #目前:都是 单层缓存空间
        #上传区 可算 一个半层缓存空间:扩展父调用处as爷 -->撤消连锁反应
        #下达暨后移区 可算 一个半层缓存空间: 解码器名冃子 -->撤消连锁反应
#######
[:定义处冫具名阶段]:goto
具名阶段:
    [初始化层<充分展开层<解禁更新充分传播层<裁剪层<全局退出层<步进层]
#######
[:定义处冫具名触发器]:goto
具名触发器:
    撤消受阻于幺解码器的分支乊返回预定乊全局退出预定
    撤消父解码器乊唯一返回
    固化实时访问乊步进前夕
#######
问题:
    具名阶段.前置条件
    具名阶段.执行动作
    具名阶段.后置条件
    具名缓存空间.初始化
    具名缓存空间.更新
    具名缓存空间.撤消
    具名触发器.初始化
    具名触发器.触发条件
    具名触发器.触发动作
    具名触发器.撤消
#######
[:定义处冫具名缓存空间灬动作]:goto
#######
#######
#######
#]]]'''#'''
r'''[[[
[:定义处冫具名触发器]:here
具名触发器:
    涉及多个 具名缓存空间 以及 各自的相应键值
#######
#######
撤消受阻于幺解码器的分支乊返回预定乊全局退出预定
    @下达暨后移区.后移扌(扩展父调用处,解码器名冃子,扩展结果冃子)
        if 解码器冃子 is 内建伪解码器冫返回
撤消父解码器乊唯一返回
#######
#]]]'''#'''
r'''[[[
[:定义处冫具名阶段]:here
具名阶段:
#######
#######
#######

初始化层@全文始:
    初始化:当前地址
        := 0
    初始化:原地合流检测区
        :={}
    初始化:内建解码器冫主解码器
        :=串联(解禁,主解码器冖用户,裁剪,内建伪解码器冫全局退出)
    初始化:上传区.待办队列冫调用展开
        :=[]
        ...
    下达暨后移区.初始展开扌(
        父入口:=(起地址乊父:=当前地址,解码器名冃父:=内建解码器冫主解码器.解码器名)
        ,实时访问丷解禁纟继承=True
        )
    #####
    assert 上传区.待办队列冫调用展开
初始化层@非全文始:
    assert 上传区.待办队列冫调用展开#<<==步进层
    assert not 上传区.待办队列冫调用展开冖冖幺解码器
    #####
    启用 新的: 当前地址 += 1
    初始化:原地合流检测区
        <<==步进合流检测区
    #####
    撤消 步进合流检测区
充分展开层:
    assert 上传区.待办队列冫调用展开
    #xxx:assert not 上传区.待办队列冫调用展开冖冖幺解码器
    #####
    for (解码器名冃子,扩展父调用处) in 上传区.待办队列冫调用展开:
        下达暨后移区.初始展开扌(子入口,实时访问丷解禁纟继承=False)
    下达暨后移区
    #####
    撤消 原地合流检测区
    assert not 上传区.待办队列冫调用展开

解禁更新充分传播层:
裁剪层:
全局退出层:
    if 上传区.待办队列冫调用展开冖冖幺伪解码器:
        assert 欤继承已解禁乊父起
        assert 欤本分支已解禁乊父乊子起
        assert 欤本分支已裁剪乊父乊子起
步进层:
    assert not 上传区.待办队列冫调用展开
    #####
    上传区.待办队列冫调用展开冖冖幺解码器
    #####
    if not 上传区.待办队列冫调用展开#<<==步进层: raise 全局失败
    assert 上传区.待办队列冫调用展开#<<==步进层



#]]]'''#'''
r'''[[[
[:定义处冫具名缓存空间]:here
具名缓存空间:

#######
#{父入口:扩展结果冃父}
#    扩展结果冃父 = (讫地址乊父,结果冃父)
#    结果冃父 = (内禀结果冃父,外赋结果冃父冖惰性值)
{子入口:扩展结果冃子}
    名称:返回结果缓冲区
    扩展结果冃子 = (讫地址乊子,结果冃子)
    结果冃子 = (内禀结果冃子,外赋结果冃子冖惰性值)
    何时撤消？
        裁剪之前
        <<==:
        * [起地址乊子 < 讫地址乊子]:
            通告:所有 扩展父调用处，当他们移位后(变量环境更新)，即可 删除
                !! 不可能再有 新的 扩展父调用处
        * [起地址乊父 == 讫地址乊父]:
            !! 可能有 新的 扩展父调用处
            只能等 充分展开之后，裁剪之前，步进之前
#######
{父入口:(扩展欤继承已解禁乊父起,累积欤任一分支曾裁剪)}
    #xxx:拆开 父入口，一级变两级，是为方便:步进之后，在 新地址 枚举出 相应 解码器名
#xxx:{起地址乊父:{解码器名冃父:(扩展欤继承已解禁乊父起,累积欤任一分支曾裁剪)}}
    名称:上传区#调用交接区
        #逆转:就地展开扌():需要:
        上传下达:here
        上传:调用交接区::扩展欤继承已解禁乊父起::扩展父调用处
        下达:未果存活后续分支集中区::子入口(扩展分支状态冃父乊子起+子解码器名讠后续)
    父入口:
        ===(起地址乊父,解码器名冃父)
    扩展欤继承已解禁乊父起:
        #xxx|===({欤继承已解禁乊父起:计数},欤继承已解禁乊父起冖最优值)
        |===({欤继承已解禁乊父起:{扩展父调用处as爷}},欤继承已解禁乊父起冖最优值)
        同一 扩展父调用处 允许 至多两次 进入:必须:第一次 非 最优值，第二次 最优值:==>>解禁更新充分传播层
        扩展欤继承已解禁乊父起:更新:
            * [当前地址==起地址乊父]:
                新增 扩展父调用处as爷
                欤继承已解禁乊父起冖最优值 只增
            * 裁剪:
                减少 扩展父调用处as爷
                欤继承已解禁乊父起冖最优值 不变
            #####
            欤继承已解禁乊父起冖最优值:更新:
                只增=>更新的前提:[当前地址==起地址乊父][欤继承已解禁乊父起冖最优值==False]
            若 欤继承已解禁乊父起冖最优值 更新，需将 影响 传播 给 各分支，或者说，各分支 实时访问？
                为保证 合理，充分展开之后，裁剪之前，增加一层:解禁更新充分传播层
                [初始化层<充分展开层<解禁更新充分传播层<裁剪层<全局退出层<步进层]
                一层一待办队列
            #####
    特殊:欤继承已解禁乊父起-->{欤继承已解禁乊父起:计数}
        并行态,影响不大,但需 定期维护/同步/确认一致性
        ???有毛病:裁撤之后:归一:泛零解码器:很复杂
        没毛病:[最优值只增|整个被撤消]
        充分展开过程中，只增/只考虑最优值
        步进之前&&裁撤前夕=>
            * 无裁剪建议:安然无恙:只增
            * 出现裁剪建议-身处主枝/至少有一个上司身处主枝:最优值保留有效:之前依照最优值行事 没错:无论 一致 还是 歧义
            * 出现裁剪建议-身处旁枝/没有一个上司身处主枝:没有发出裁剪建议:错不在我
        步进之前&&裁撤之后=>
            * 无裁剪建议:安然无恙:只增
            * 出现裁剪建议-身处主枝/至少有一个上司身处主枝:最优值保留有效
            * 出现裁剪建议-身处旁枝/没有一个上司身处主枝:整个被撤消:增减也就无所谓
    何时撤消？
        匹配|不匹配:
            同于『{子入口:扩展结果冃子}』
            裁剪之前 撤消
        裁撤:
            +并非自己提出的裁剪建议
            +出结果前被裁撤#返回前被裁撤
            #####
            [解禁更新充分传播层<裁剪层]
            裁剪之时 还存在==>>未出结果
            如何判定 裁剪建议 是否 自己 由提出的?
                +[欤继承已解禁乊父起冖最优值==True]
                +[累积欤任一分支曾裁剪==True]
                !! 上述两者
                [曾经 欤真裁剪]
                [锁定]
                !! 仍存在@裁剪层
                [未出结果]
                !! [未出结果][锁定]
                [歧义]or[裁剪建议 出自自身]

#######
{(父入口,讫地址乊子as当前地址):{分支状态冃父乊子讫乊步进后:{分支状态冃父乊子起乊步进前:幺解码器名冃子}}}
    名称:步进合流检测区
    何时撤消？
        初始化层之后，充分展开层之前
        初始化:原地合流检测区 之后 即可撤消
#######
#{(父入口,起地址乊子as当前地址):累积集合纟分支状态乊所有分支含已裁撤分支乊当前地址}
{(父入口,起地址乊子as当前地址):累积集合纟分支状态乊所有分支乊当前地址冖冖含湮没丶流产状态}
    名称:原地合流检测区
    不受 裁剪 影响，步进之后 删除
        事实上，撤消 于 裁剪之前
        ！所谓 含 已裁撤 分支状态 没有意义！
        不一定无意义:裁撤=>裁剪|撤消
            撤消 来源于:
                所有 后续分支 出结果==>>过气被覆盖 湮没
                某 后续分支 不匹配==>>后续分支状态 流产
    集合只增，用于 检测 当前地址 分支状态 合流:异分支=>歧义，同分支=>死循环
        ??但 步进之后 合流 怎么检测？
            ==>>步进合流检测区
    初始化:
        * 步进合流检测区
    更新:
        #内建解码器冫主解码器
        * 上传区.调用扌()::解码器.初始分支状态集合
        * 解码器.就地展开扌()::分支状态乊子讫
    『合流』与『被多次调用』无关
    『被多次调用』更改的是『调用交接区::扩展父调用处』
    何时撤消？
        !! [初始化层<充分展开层<解禁更新充分传播层<裁剪层<全局退出层<步进层]
        充分展开之后:已无虞 原地 合流#歧义|死循环
        解禁更新充分传播层之前！

#######
{扩展父调用处:下达暨后移所需资讯}
#xxx:{父入口:{扩展分支状态冃父乊子起:下达暨后移所需资讯}}
#xxx:{起地址乊父:{解码器名冃父:{扩展分支状态冃父乊子起:下达暨后移所需资讯}}}
    名称:下达暨后移区#父调用处实况暨未果存活后续分支集中区
        融合:父调用处实况+未果存活后续分支集中区
            !! 两者 撤消条件 一样
    #后移所需资讯:
    下达暨后移所需资讯:
        === (实时访问[上传区].扩展欤继承已解禁乊父起,扩展仨变量环境乊父乊子起,所有分支状态乊本分支乊当前地址,子解码器名讠后续)
    一旦 欤继承已解禁乊父起冖最优值 不再改变:
        则:实时访问[上传区].扩展欤继承已解禁乊父起 改为 保存
        实时访问 依赖于 上传区，不方便
        更新的前提:[当前地址==起地址乊父][欤继承已解禁乊父起冖最优值==False]
#######
#{扩展父调用处:子解码器名讠后续}
#{父入口:{扩展分支状态冃父乊子起:子解码器名讠后续}}
    #名称:未果存活后续分支集中区-->下达暨后移区
        子-未出结果
        上传下达:goto
    #就地展开扌()
    #子解码器名讠后续 = 解码器冃父.就地展开扌(分支状态冃父乊子起, 内禀变量环境乊父乊子起)
    子解码器名讠后续:
        ==={解码器名冃子:_后续乊子}
    _后续乊子:
        === (分支状态乊子讫,内禀输出名,外赋输出名,内禀计算器,外赋计算器)
    初始化后续更改:只减
        子-死亡:
            子-裁撤/非最短锁定
            #经 未果存活后续分支集中区::子入口 下达 撤消指令
        子-出结果:
            子-失败/不匹配
            子-成功/匹配
            #返回结果缓冲区 经 调用交接区::扩展父调用处 上传 返回结果
        #就地展开扌()
    何时撤消？
        * 削减至空:由里向外层层自动撤消
        * 父-出结果
        * 父-裁撤
        ##
        撤消触发动作:
            +撤消囗所有存活未果后续 计数一次？
                #撤消-子#存活&&未果
                #逆转:就地展开扌()
            +撤消 相应 父调用处实况[扩展父调用处]

#######
#{扩展父调用处:(实时访问[上传区].扩展欤继承已解禁乊父起,扩展仨变量环境乊父乊子起,所有分支状态乊本分支乊当前地址)}
    #名称:父调用处实况-->下达暨后移区
        父调用处实况+未果存活后续分支集中区==>>用于 实现 平移/移位
    扩展父调用处:
        ===(父入口,扩展分支状态冃父乊子起)
    扩展仨变量环境乊父乊子起:
        ===(欤本分支已解禁乊父乊子起,欤本分支已裁剪乊父乊子起,鬽返回俩鬽名,仨变量环境乊父乊子起)
            #一旦 扩展欤继承已解禁乊父起 解禁，(欤本分支已解禁乊父乊子起,欤本分支已裁剪乊父乊子起) 就能 后知后觉地 产生作用
            #   累积欤任一分支曾裁剪|=欤本分支已裁剪乊父乊子起
            #鬽返回俩鬽名==>>欤本分支返回/欤子乃返回@子讫
            #取囗鬽返回俩鬽名纟所在父解码器分支扌
    仨变量环境乊父乊子起:
        === (内禀变量环境乊父乊子起,外赋变量环境乊父乊子起,局部地址变量环境乊父乊子起)
        初始分支状态集合
        初始内禀变量环境
    扩展分支状态冃父乊子起:
        ===(起地址乊子,分支状态冃父乊子起)
        相当于 扩展状态，步进之后 允许 分支状态 回收复用
    #xxx:(起地址乊子,数目纟分支状态乊本分支乊当前地址,分支状态冃父乊子起):
        相当于 扩展状态，无需步进, 原地踏步 也允许 分支状态 回收复用
        ???反对原因一:但是,无意义:因为 同一 分支状态 基本会有相同展开，除非 运用 内禀变量环境乊父乊子起
            #并行态有限状态机:步进之前:彻底展开，步进之后:已有 起地址乊子 区分 状态，这里 数目 无用
        反对原因二:不同分支 合流 产生 歧义;同分支 合流 产生 死循环:更快发现错误，好过 零解码器 无用 计数
            除非 使用 所有分支状态乊本分支乊当前地址 作区分
        #就地展开扌()
    所有分支状态乊本分支乊当前地址:
        ===(数目纟分支状态乊本分支乊当前地址,右增链表纟分支状态乊本分支乊当前地址)
        用于 判定 是否为 兄弟关系
        #偏序比较囗分支状态扌()
        兄弟关系=>裁剪建议-相互兼容
        非兄弟关系=>裁剪建议-异地址相互裁撤,同地址导致冲突歧义
        裁剪建议=>子讫#发生于:(步进之后|全文始)，下一次 步进之前
    何时撤消？
        !! 父调用处实况 配合 未果存活后续分支集中区 用于 实现 平移/移位
        未果存活后续分支集中区 相应 扩展父调用处 撤消 则 父调用处实况 亦然
#######
#######
    ===


#]]]'''#'''
r'''[[[
[:定义处冫具名缓存空间灬动作]:here
具名缓存空间灬动作:
抽象化角色定位:
    角色:公开接口:
        上传区.调用扌(解码器名冃子,欤继承已解禁乊子起,扩展父调用处)
    角色:私有接口:
        下达暨后移区.新增扌(扩展父调用处, ..., 子解码器名讠后续)
        ???下达暨后移区.初始展开扌(子入口,实时访问丷解禁纟继承)

[[[
===
def 上传区.调用扌(解码器名冃子,欤继承已解禁乊子起,扩展父调用处)
    #保存+缓存待办
    if 零伪解码器:
        raise 000
    if 内建解码器冫主解码器:
        !! [主解码器 无 太上]
        只能通过 下达暨后移区.初始展开扌()@全文始，唯一一次
        raise 000
    if 泛幺解码器:
        上传区.待办队列冫调用展开冖冖幺解码器
        上传区.待办队列冫调用展开冖冖幺伪解码器#幺伪解码器/全局退出层
        return
    上传区.待办队列冫调用展开::[(解码器名冃子,扩展父调用处)]
        欤继承已解禁乊子起 的 值 不重要，若 False，则 实时访问
===
#def 下达暨后移区.初始展开扌(父入口,欤继承已解禁乊父起)
def 下达暨后移区.初始展开扌(父入口,实时访问丷解禁纟继承)
    #立即执行
    if 实时访问丷解禁纟继承:
        :保存:欤继承已解禁乊父起=True
    else:
        实时访问[上传区].扩展欤继承已解禁乊父起
    if 泛幺解码器:
        raise 000
    if 零伪解码器:
        raise 000
    解码器冃父.初始分支状态集合
    解码器冃父.初始内禀变量环境
    子解码器名讠后续=解码器冃父.就地展开扌(...)
    下达暨后移区.新增扌(扩展父调用处, ..., 子解码器名讠后续)
    return
def 下达暨后移区.新增扌(扩展父调用处, ..., 子解码器名讠后续)
    下达暨后移区[扩展父调用处] = (..., 子解码器名讠后续)
    for 解码器名冃子,_后续乊子:
        下达暨后移区.调用或立即处理扌(扩展父调用处,解码器名冃子)
def 下达暨后移区.调用或立即处理扌(扩展父调用处,解码器名冃子)
    '-> 调用丷立即处理'
    if 零伪解码器:
        #立即处理
        *内建伪解码器冫返回
        *内建计算暨赋值零伪解码器
        #直接跳过:返回结果缓冲区
        下达暨后移区.后移扌(扩展父调用处,解码器名冃子,扩展结果冃子)
        return True
    上传区.调用扌(...)
    return False
def 下达暨后移区.后移扌(扩展父调用处,解码器名冃子,扩展结果冃子)
    (..., 子解码器名讠后续) = 下达暨后移区[扩展父调用处]
        #查询 后移所需资讯
    if 零伪解码器:
        *内建伪解码器冫返回
            ?返回结果缓冲区.保存扌(父入口,扩展结果冃父)
            撤消受阻于幺解码器的分支乊返回预定乊全局退出预定
            撤消父解码器乊唯一返回
            撤消-父
            有毛病！返回 要求 裁撤 其余分支 但 其余 分支 可能 还有 泛零解码器 待处理！
            父.返回预定 && 父.全局退出预定:
                其余分支 遇到 幺解码器 自动撤消
                其余分支 再有 返回预定,全局退出预定 则 出错#集中在 裁剪之前
        *内建计算暨赋值零伪解码器
    ...
    #下一个:
    子起冖后续 := 子讫
    下达暨后移区.新增扌(next扩展父调用处, ..., next子解码器名讠后续)
    #先:新增 再 撤消，免得 清空导致完蛋
    下达暨后移区.撤消乊子出结果扌(扩展父调用处,解码器名冃子)
def 下达暨后移区.撤消乊子出结果扌(扩展父调用处,解码器名冃子)
    (..., 子解码器名讠后续) = 下达暨后移区[扩展父调用处]
    del 子解码器名讠后续[解码器名冃子]
    撤消连锁反应...
===
#def :返回结果缓冲区.保存扌(父入口,扩展结果冃父)
def :返回结果缓冲区.保存扌(子入口,扩展结果冃子)
===
]]]
#]]]'''#'''
__all__
__all__
__all__

def __():
    from seed.tiny import ifNonef, ifNone, echo
    from seed.tiny import check_type_is, fst, snd, at
    from seed.tiny_.check import check_uint_lt, check_int_ge_lt, check_int_ge, check_int_ge_le
    from seed.tiny import print_err, mk_fprint, mk_assert_eq_f, expectError
    from seed.func_tools.fmapT.fmapT__tiny import dot, fmapT__dict, fmapT__list, fmapT__iter
    from seed.helper.repr_input import repr_helper

def __():
    from seed.abc.abc__ver1 import abstractmethod, override, ABC, ABC__no_slots
    from seed.helper.repr_input import repr_helper
    class _(ABC):
        __slots__ = ()
        raise NotImplementedError
        ___no_slots_ok___ = True
        def __repr__(sf, /):
            #return repr_helper(sf, *args, **kwargs)
            #return repr_helper_ex(sf, args, ordered_attrs, kwargs, ordered_attrs_only=False)
            ...
if __name__ == "__main__":
    pass
__all__


from seed.recognize.toy.conservative_shortest_sentence_recognizer import *
