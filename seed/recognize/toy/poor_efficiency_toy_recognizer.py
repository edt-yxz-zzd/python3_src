#__all__:goto
r'''[[[
e ../../python3_src/seed/recognize/toy/poor_efficiency_toy_recognizer.py
    view ../../python3_src/useful__cjk_naming.txt
        魖/囗

需求源自:
    e ./script/hz/部件拆分.py
        用于解析部件名

seed.recognize.toy.poor_efficiency_toy_recognizer
py -m nn_ns.app.debug_cmd   seed.recognize.toy.poor_efficiency_toy_recognizer -x
py -m nn_ns.app.doctest_cmd seed.recognize.toy.poor_efficiency_toy_recognizer:__doc__ --ndiff -ff -v



[[
prune修剪clip, trim
    cutout:剪切块

e ../../python3_src/seed/types/PruneableArray.py
语法:
    识别器:
        ===
        参数:
            *静态:语法+交集/等价变换/简化/?语句生成器
            *动态:配置/运行期宏参数
            *动态:数据流相关:上下文变量:语境
        方向:
            向右
            向左
            双向
            #内嵌逆向: 向左 内嵌 向右；反之亦然
        匹配:
            * 单端固定匹配
            * 单向漂移搜索
                例如:原貌字串 内嵌 表达式:先定位 结束符，再 仔细分析路过部分
                ==>>两端固定匹配
                这里有个问题:
                    两端固定匹配囗识别器 ++ 单向漂移搜索囗识别器
                    能力不同，需求不同==>>接口不同
                    也就是说:识别器 有 多种类型！！
            * 两端固定匹配
        识别<环境>:
            完整子句
            子句前缀锁定#==>>裁剪
            非法子句前缀###注意:方向
                ===not$合理子句前缀###注意:方向
            非法子句后缀###注意:方向
                ===not$合理子句后缀###注意:方向
        状态:
            *链式:尾解包:突出:热点子识别器#==>>识别时，先检查自身缓存，未曾则直接识别:热点子识别器，由底向上 进行识别
            *生成下一合理码元
        环境:
            #隐式地址:只能作减法+定位+加偏移量
            * 数据流#必要:隐式
            * 已裁剪缓存<数据流>#必要:隐式
            * 起地址#必要:隐式
            * ?讫地址#可选:隐式地址
            * ?引入前文变量#可选##注意:方向
            * ?回溯用后文识别器+回溯用引出变量可选###注意:方向
            环境一致，结果一致==>>缓存?内嵌逆向 时，对于 裁剪/缓存 将有更多的要求
        是否受回溯影响？
            * 声明拒绝回溯:自锁定
            * 内生性回溯免疫:
                * 无分支，且 所有子部件 不受回溯影响 或 所在位置 声明拒绝回溯
                * 有分支，但 所有 生成子句/合法子句 互非前缀
                    显著的反例: 重复

        ===
        解码器===(识别器引用,[过滤器名])
        识别器===(识别器构造器,[识别器静态配置参数],[解码器引用],[识别器动态配置参数名])
            静态配置-语法相关
            动态配置-例如:禁止回溯与否#禁止回溯:节省缓存空间
        识别器构造器.类型声明囗囗子识别器囗接口类型
            #见下面『两端固定匹配囗识别器vs单向漂移搜索囗识别器』
        解码器引用===隐式-解码器|解码器名
            #并非:识别器名:不是 一一对应
            #多 解码器 --> 一 识别器
            #   因为 外衣不同
            #??但是！说的是 匿名解码器，任何 有名解码器 必然 一一对应于 识别器？感觉不太行
        识别器引用===隐式-识别器|识别器名
        解码状态===(识别状态/输出无关,中间结果/输出相关)
        识别状态===(识别状态类别,状态细节)
        识别状态类别===已完整|(出错|待续,已锁定|未锁定)
        ===
        识别器巛引用囗 :: 识别器引用->识别器
        解码器巛引用囗 :: 解码器引用->解码器
            语法定义相关
            xxx ==>>识别器巛引用囗
        过滤器巛名囗 :: 过滤器名->过滤器
            输出适配
        识别器动态配置参数巛名囗 :: 识别器动态配置参数名->识别器动态配置参数
        步进囗囗识别器囗 :: 识别器引用->识别器巛引用囗->识别器动态配置参数巛名囗->码类->识别状态->识别状态
        步进囗囗解码器囗 :: 解码器引用->解码器巛引用囗->识别器巛引用囗->识别器动态配置参数巛名囗->过滤器巛名囗->过滤器动态配置环境->码元->解码状态->解码状态
        回溯状态囗 :: ... -> 解码状态->魊 (解码状态,讫地址)
            #下文否决，重选状态
            -> 回溯囗失败 解码状态@出错
            -> 回溯囗完整 解码状态@已完整 讫地址 #讫地址<=当前地址
            -> 回溯囗待续 解码状态@待续 #讫地址==当前地址
        归类识别状态囗 :: 识别器引用->识别器巛引用囗->识别动态配置参数巛名囗->识别状态->识别状态类别
        ===
    发现 缓存 其实非常复杂
        即使没有 回溯驱使状态更新，缓存 状态 本身依然复杂
        溢出探测:
            比如: 『A?』贪婪匹配 作用于文本『B』时 匹配到的文本为空，而实际读取的文本长度为1
            所以 不仅有 匹配结果文本的 起讫点，还要有 溢出探测的 起讫点
            匹配结果 受句外语境影响，即 语境敏感
        ==>>
        缓存 要求 唯一性，但 除非 合法句集 前缀互斥，否则 不可能
        折衷如下: 区分 解码器需要缓存与否
            * 需要缓存结果的解码器 称为『头衔解码器/封号解码器/称号解码器/具名解码器/署名解码器/内敛解码器』
                titled有头衔的
                enfaced具名
                designated指定
                signature署名
                stamp盖印于
                    imprint
                    seal
                    signet
                tag
                marking
                保守/内敛
                conservative保守的
                convergent收敛的
            * 不需要缓存结果的解码器 称为『匿名解码器/外散解码器』
                anonymous匿名/佚名
                divergent发散的
            具名解码器/内敛解码器 需要缓存结果
                ==>> 要求 结果唯一
                ==>> 只匹配最短句子 还必须无歧义分解
            匿名解码器/外散解码器 不需要缓存结果
                ==>> 步进过程 产生一系列成功匹配信号
                ==>> 步进 投喂 码元 或者 讫点(子句讫点vs探测讫点)
                ==>> 类似『A*』『A?』只能作为 零件/细节，若成为 具名解码器，只能匹配 空串
                ==>> 由于 必然是 具名解码器 的 子部件，要求 成功时 子句讫点 与 探测讫点 如一。即 不允许 『(?=B)』，否则 缩短，识别的合法子句 并非 由短至长
        ==>>
        广度并行由短至长匹配
            poor efficiency低效
            inefficiency无效
            toy玩具的/模型的/小型的
            BFS宽度优先搜索(breadth first search)
            DFS深度优先搜索(depth first search)
]]
[[[
class 乸内敛语法最短句子解码器:
===
简化需求:
+ 识别器/语法 内敛/无溢出探测/自动结尾
    但 码元串/[码元] 可扩展为 魊码元串/[魊 码元] 这样就允许了 eof 作为 魊码元 输入
===
==>> 具名识别器 只匹配 最短句子
==>> 不回溯
    禁止『x* y*』
    ==>> 重复囗直到扌(重复囗直到扌(z;y);x)
==>> 限用 不定数量 的 『重复识别器』
    + 形式一:定长:『x{n}』
        重复囗定长扌(n;x)
    + 形式二:后缀:『x* y』
        重复囗直到扌(y;x) = y | x 重复囗直到扌(y;x)
    + 引用前面变量
        例如:纵三组xyz
        例如:原貌字串
        变量来源:
            * 父识别器 的 构造参数
            * 兄识别器 的 内禀输出参数

===
基础识别器:
    #???裁剪建议识别器:不太行, 只能是 声明# 或者 默认 援用裁剪建议识别器, 而 显式 拒绝裁剪建议识别器
    零解码器
        泛解码器:
            #裁剪同时性:[返回/求值/裁剪] 是透明的;『返回』本身就是『裁剪』(父-禁言结束 情形下, 父 裁剪)而且还引入 返回后 下一个 连通的 裁剪
            返回泛解码器
            裁剪泛解码器
            求值泛解码器
            断言泛解码器
                #断言识别器<真值>
                断言假识别器
                    ===不匹配识别器
                断言真识别器
                    忽略: 无返回值
        空串匹配识别器
            返回值为 空串
    幺解码器/魊码元识别器
        全文结束符识别器
            !!!!!不存在 非全文结束符识别器!!!!!!
            并非 简单的 断言识别器
                因为 并非 超前探测/溢出探测
                而是 源自 全文/码元串-->魊码元串
        码元识别器
            ?码集识别器
            欤包含扌
                #步进乊码元扌
                #步进乊全文结束扌
    用户自定义识别器
        #例如:正则表达式
        初始状态
        解释状态扌 :: 状态 -> (欤裁剪,(匹配|不匹配|待续))
            状态讠进度扌 :: 状态 -> (匹配|不匹配|待续)
            状态讠欤裁剪扌 :: 状态 -> 欤裁剪
        取识别器乊待续扌 :: 状态乊待续 -> 识别器/解码器?
        计算共通输出乊匹配扌 :: 状态乊匹配 -> 共通输出
        计算内禀输出乊匹配扌 :: 状态乊匹配 -> 共通输出 -> 内禀输出
        计算外赋输出乊匹配扌 :: 状态乊匹配 -> 共通输出 -> 外赋输出
内建结构识别器
    援用裁剪建议识别器<识别器>
    并联串联识别器
        :: (外赋输出声明, 构造参数名, 构造参数, 并联/[(并联分支/[(识别器丶子句绑定声明丶内禀变量绑定声明丶外赋变量绑定声明|禁言结束声明|裁剪建议/裁剪建议暨锁定声明|内禀计算语句)],外赋计算语句)])
            #删去:内禀输出声明
            #但不删去:内禀变量绑定声明,外赋变量绑定声明
        #xxx: :: (内禀输出声明, 外赋输出声明, 构造参数名, 构造参数, 并联/[并联分支/[(识别器丶子句绑定声明丶内禀变量绑定声明丶外赋变量绑定声明|裁剪建议暨锁定声明|内禀计算语句|外赋计算语句)]])
        构造参数 源自 常量 / 兄识别器内禀输出
        禁言结束声明
            居前 => 禁言状态/缓存状态:子识别器 必须 完整 识别
            居后 => 子识别器 变 援用裁剪建议识别器<子识别器>
        裁剪建议/裁剪建议暨锁定声明 # 『分号』
            === 『禁言结束声明  断言识别器<True>』
            锁定并联分支,裁剪其余分支?若多分支同时锁定==>>^歧义
            计算兄解码器外赋输出
                #因为 可以 多次 提出『裁剪建议』，所以比命名为『锁定声明』更佳
            裁剪文本缓存
        ?无?:内禀输出声明
        外赋输出声明:
            -> --> return
        内禀变量绑定声明,外赋变量绑定声明
            似无必要
            ...似乎是错的！
            输出 只该有 一个
            对于 调用者 而言，需要 或 不需要 输出
            对于 被调用者 而言，并不清楚 外界 需要啥
        子句绑定声明
            用于 绑定 变量名~子句/码元串
            用于 绑定 变量名~计算器/过滤器
            #???识别器构造器 直接 当作 内禀外赋混合变量，覆盖 同名 兄变量
            ===
            内禀: 必须计算,用于 弟识别器 构造
            外赋: 只有 裁剪、匹配 时，才 计算 #更准确地说，只有 裁剪 动作 真实发生时
        计算语句
        内禀计算语句,外赋计算语句
            内禀计算语句 使用 内禀变量
            外赋计算语句 使用 内禀变量,外赋变量
            [x := y]
            [x := (a,b,c)]
            [x := f(a,b,c)]
            [(x,y) := f(a,b,c)]
===
识别器.识别器名 #(构造器, 参数)
匞场景包.识别器巛名扌
@当前位置
待办列表乊就地展开/[(识别器|裁剪建议, 父)]@当前位置
==>>
当前位置:所有 需求 就地完全展开
    ?援用裁剪建议识别器
        改用 更合理的方案: 禁言结束声明
            默认 开启 禁言，直至 (禁言结束声明|裁剪建议)
    #???:反相识别器:不太行
    并联串联识别器
    用户自定义识别器
        待续->子识别器
        匹配/不匹配->?断言识别器?

拆分:待办列表乊非待续/[识别器名]@当前位置
    待办列表乊匹配/[识别器名]@当前位置
    待办列表乊不匹配/[识别器名]@当前位置
##当前位置:所有 断言识别器 执行
当前位置:所有 非待续 识别器:
    回头 更新 父识别器 匹配结果
        --> 又又:更新:待办列表乊就地展开@当前位置
    ?删除 诸前 零引用 识别器
        #:?等待裁剪?:不需要:因为 绑定
    删除 诸前 零分支 识别器
当前位置:任一/所有 裁剪建议/?禁言结束声明 执行
    判断 歧义 存在性
    计算 残缺结果 并保存
    裁剪 缓存

当前位置:读取 魊码元
当前位置:所有 魊码元识别器 执行
    匹配/不匹配-> 生成 下一位置 ?断言识别器?

===
{位置:裁剪建议/?禁言结束声明}
{位置:识别器名:(位置<己>, 起源相关/{(位置<父>, 父识别器名, 分支号):欤所有祖先识别器禁言已结束}, 不匹配|匹配结果|中途状态/{分支号:(串行位置,欤本分支禁言已结束,内禀变量,裁剪后外赋变量)})}
    欤本分支禁言已结束
        用于 裁剪 己之其余分支@无歧义
        与 缓存无关
    ?无?:欤父识别器禁言已结束??
        裁剪时 整树呈直线/全局唯一无分枝
        反之 亦然！！
    欤所有祖先识别器禁言已结束
        但是 某任 祖先 禁言/保护缓存/拒绝作外赋运算 的话，即使 全局唯一无分枝, 也是 不能 裁剪 的 (空间vs时间:这是 外赋折衷策略)

    树 但 某些分枝 合并 而成 有向无环图
        ==>> 既有 {子}@中途状态 又有 {父}@起源相关
===
class 乸内敛语法最短句子解码器:
]]]


py_adhoc_call   seed.recognize.toy.poor_efficiency_toy_recognizer   @f
py_adhoc_call  seed.helper.print_methods  @wrapped_print_methods   %seed.recognize.toy.poor_efficiency_toy_recognizer:XXX@T    =T      ++exclude_prefixes:_
from seed.recognize.toy.poor_efficiency_toy_recognizer import *

#]]]'''
__all__ = r'''
'''.split()#'''
__all__

from seed.types.PruneableArray import PruneableArray
    #def prune_lt_(sf, i, /, *, beyond_end_ok=False):
from seed.abc.abc__ver1 import abstractmethod, override, ABC, ABC__no_slots

from enum import Enum, auto

#class 状态类别囗囗解码器(Enum):
#    出错 = auto()
#    成功 = auto()
#    待续 = auto()
#class 魖解码器(ABC):
#    r'''
#    toy:否决歧义结果: 结果歧义=> ^Error
#    '''#'''
#    __slots__ = ()
#    @abstractmethod
#    def 取囗初始状态囗(sf, /):
#        '-> 初始状态'
#    @abstractmethod
#    def 步进囗囗码元囗(sf, 状态囗囗非错, 码元, /):
#        '-> 状态'
#    @abstractmethod
#    def 步进囗囗结束囗(sf, 状态囗囗非错, /):
#        '-> 状态'
#    @abstractmethod
#    def 解释状态囗(sf, 状态, /):
#        '-> 状态类别'
#    @abstractmethod
#    def 计算结果囗(sf, 状态囗囗成功, /):
#        '-> 匹配结果'
#class 魖漂移解码器(魖解码器):
#    '漂移:起点漂移'
#    __slots__ = ()
#    @abstractmethod
#    def 取囗结果起点偏移量囗(sf, 状态囗囗成功, /):
#        '-> 匹配结果起点偏移量/uint'
#class 魖定点解码器(魖解码器):
#    '定点:单端固定/起点固定'
#    __slots__ = ()
#    pass
#class 魖码集定点解码器(魖定点解码器):
#    __slots__ = ()
#    @abstractmethod
#    def 是合法码元囗(sf, 码元, /):
#        '-> bool'
#    @override
#    def 取囗初始状态囗(sf, /):
#        '-> 初始状态'
#        return True
#    @override
#    def 步进囗囗码元囗(sf, 状态囗囗非错, 码元, /):
#        '-> 状态'
#        if 状态囗囗非错 is True:
#            if sf.是合法码元囗(码元):
#                状态 = (码元,)
#            else:
#                状态 = null_tuple
#        else:
#                状态 = null_tuple
#        return 状态
#    @override
#    def 步进囗囗结束囗(sf, 状态囗囗非错, /):
#        '-> 状态'
#        if 状态囗囗非错 is True:
#            状态 = null_tuple
#        else:
#            状态 = 状态囗囗非错#成功
#        return 状态
#    @override
#    def 解释状态囗(sf, 状态, /):
#        '-> 状态类别'
#        T = 状态类别囗囗解码器
#        if 状态 is True:
#            return T.待续
#        if not 状态:
#            return T.出错
#        return T.成功
#        raise 000
#    @override
#    def 计算结果囗(sf, 状态囗囗成功, /):
#        '-> 匹配结果'
#        [码元] = 状态囗囗成功
#        匹配结果 = 码元
#        return 匹配结果
##end-class 魖码集定点解码器(魖定点解码器):
#
#
#class 魖码集漂移解码器(魖漂移解码器):
#    __slots__ = ()
#    @abstractmethod
#    def 是合法码元囗(sf, 码元, /):
#        '-> bool'
#    @override
#    def 取囗初始状态囗(sf, /):
#        '-> 初始状态'
#        return (0,)
#    @override
#    def 步进囗囗码元囗(sf, 状态囗囗非错, 码元, /):
#        '-> 状态'
#        起点偏移量 = 1+状态囗囗非错[0]
#        if sf.是合法码元囗(码元):
#            状态 = (起点偏移量, 码元)
#        else:
#            状态 = (起点偏移量,)
#        return 状态
#    @override
#    def 步进囗囗结束囗(sf, 状态囗囗非错, /):
#        '-> 状态'
#        L = len(状态囗囗非错)
#        if L == 2:
#            return 状态
#        if L == 1:
#            return null_tuple
#        #if L == 0:
#        raise 000
#    @override
#    def 解释状态囗(sf, 状态, /):
#        '-> 状态类别'
#        T = 状态类别囗囗解码器
#        L = len(状态)
#        if L == 2:
#            return T.成功
#        if L == 1:
#            return T.待续
#        if L == 0:
#            return T.出错
#        raise 000
#    @override
#    def 计算结果囗(sf, 状态囗囗成功, /):
#        '-> 匹配结果'
#        [起点偏移量, 码元] = 状态囗囗成功
#        匹配结果 = 码元
#        return 匹配结果
#    @override
#    def 取囗结果起点偏移量囗(sf, 状态囗囗成功, /):
#        '-> 匹配结果起点偏移量/uint'
#        [起点偏移量, 码元] = 状态囗囗成功
#        return 起点偏移量
##end-class 魖码集漂移解码器(魖漂移解码器):
#
#class 魖具名内敛定点解码器(魖定点解码器):
#    r'''
#    内敛:不缩水&&最短匹配&&结果唯一&&缓存
#        成功匹配 => [子句讫点===探测讫点]
#    toy:否决歧义结果: 结果歧义=> ^Error
#    '''#'''
#    __slots__ = ()
#class 魖匿名递增定点解码器(魖定点解码器):
#    r'''
#    递增:不缩水，由短至长 匹配子句
#        成功匹配 => [子句讫点===探测讫点]
#    toy:否决歧义结果: 结果歧义=> ^Error
#    '''#'''
#    __slots__ = ()
#
#def __():
#    from seed.data_funcs.lnkls import rglnkls_ops, empty_rglnkls, rglnkls_ipush_right, rglnkls_ipop_right, rglnkls2reversed_iterable, rglnkls5iterable
#    #class LeftShiftList:
#    #    def __init__(sf, /):
#    #        sf._lnkls = null_tuple
#    #        sf._sz4payload = 0
#    #        sf._sz4null = 0
#    #    def iappend(sf, x, /):
#
#    empty_lshift_lsp = (0,0,empty_rglnkls)
#        # (sz4nul, sz4dat, rglnkls)
#    def iappend4LeftShiftList_(lshift_lsp, x, /):
#        (sz4nul, sz4dat, rglnkls) = lshift_lsp
#    fail ...
#xxx xxx
#view ../../python3_src/seed/recognize/toy/poor_efficiency_toy_recognizer.py
#from seed.data_funcs.finger_tree.FingerTree import FingerTree
##new-version:TODO:e ../../python3_src/seed/data_funcs/finger_tree2/finger_tree_init.py
#from seed.iters.find import iter_search_subseq_on_seq, iter_search_subseq_on_stream
##view ../../python3_src/seed/iters/find.py
#
#class 特定码串定点解码器(魖定点解码器):
#    r'''
#    码串 :: Eq k => [码元/token]
#    key :: may (码元 -> k)
#    st :: (offset, matched_prefix)
#        [matched_prefix :: [码元]{len<=len(码串)}]
#        [matched_prefix :: WindowFIFO<码元>{len<=len(码串)}]
#            # using FingerTree
#        [offset == len(matched_prefix)]
#            # offset4finder # mk_FindSubseqOverlap
#    '''#'''
#    __slots__ = ()
#    def __init__(sf, 码串, /, *, key=None):
#        if iter(码串) is 码串:raise TypeError
#        码串[:0]
#        sf._key = ifNone(key, echo)
#            # :: 码元 -> k
#        sf._subseq = 码串
#            # :: [token]
#        sf._ks = [*map(sf._key, sf._subseq)]
#            # :: [k]
#        sf._finder = mk_FindSubseqOverlap(sf._ks)
#
#    @abstractmethod
#    def 取囗初始状态囗(sf, /):
#        '-> 初始状态'
#        return (0, FingerTree())
#    @abstractmethod
#    def 步进囗囗码元囗(sf, 状态囗囗非错, 码元, /):
#        '-> 状态'
#    @abstractmethod
#    def 步进囗囗结束囗(sf, 状态囗囗非错, /):
#        '-> 状态'
#    @abstractmethod
#    def 解释状态囗(sf, 状态, /):
#        '-> 状态类别'
#    @abstractmethod
#    def 计算结果囗(sf, 状态囗囗成功, /):
#        '-> 匹配结果'
#





__all__
class 
class 
class 
class 乸解码场景:
    r'''[[[
    解码场景 ~ (共通用户数据,构造囗解码器扌,...各色共通函数)
    解码器 ~ 构造囗解码器扌(解码场景,解码器名)
         ~ 构造囗解码器扌(解码场景,解码器构造器名,*构造参数)
    ???全文:
        #起地址冃全文
        #讫地址冃全文
        #.是全文终扌() #用于 幺解码器
        .当前位置
        .读取囗魊码元扌()

    #]]]'''#'''
    def 取囗函数扌(sf, 函数名, /):
        ''
    def 构造囗解码器扌(sf, 解码器名, /):
        '-> 乸内敛语法最短句子解码器'

class 匪散列:
    __hash__ = None
内建函数名冫恒量 = 匪散列()
内建值冫删除 = 匪散列()

class 乸连锁惰性值:
    r'''[[[
    '{讫地址:[连锁惰性值]}'
    .求解链
    .缓存值
    .起地址
    .讫地址
    #]]]'''#'''
    __hash__ = None
    def __init__(sf, 起地址, 讫地址, 函数名, /, *参数列表):
        if type(函数名) is __class__:
            if not len(参数列表) == 2:raise TypeError
            总长, 位置 = 参数列表
            check_int_ge(0, 总长)
            check_int_ge_lt(0, 总长, 位置)
        elif sf.函数名 is 内建函数名冫恒量:
            if not len(参数列表) == 1:raise TypeError
            [r] = 参数列表
            pass
        else:
            for 参数 in 参数列表:
                check_type_is(__class__, 参数)
        ######################
        sf.函数名 = 函数名
        sf.参数列表 = 参数列表
        sf.魊缓存值 = null_tuple
        sf.起地址 = 起地址
        sf.讫地址 = 讫地址
    def 求解扌(sf, 解码场景, /):
        '-> 缓存值'
        if not sf.魊缓存值:
            #sf.求解扌()
            if type(sf.函数名) is __class__:
                ot = sf.函数名
                总长, 位置 = sf.参数列表
                tpl = ot.求解扌(解码场景)
                check_type_is(tuple, tpl)
                if not len(tpl) == 总长: raise TypeError
                r = tpl[位置]
            elif sf.函数名 is 内建函数名冫恒量:
                [r] = sf.参数列表
            else:
                f = 解码场景.取囗函数扌(sf.函数名)
                args = (参数.求解扌(解码场景) for 参数 in 参数列表)
                r = f(*args)
            sf.魊缓存值 = (r,)
            sf.参数列表 = 内建值冫删除
            sf.函数名 = 内建值冫删除
        [缓存值] = sf.魊缓存值
        return 缓存值
    def 解包扌(sf, 总长, /):
        '-> [连锁惰性值]'
        check_int_ge(0, 总长)
        return tuple(sf.解包乊扌(总长, 位置) for 位置 in range(总长))
    def 解包乊扌(sf, 总长, 位置, /):
        '-> 连锁惰性值'
        return __class__(sf.起地址, sf.讫地址, sf, 总长, 位置)

class 乸地址:
    '地址'
    '__weakref__'
    __hash__ = None
class 乸变量环境:
    r'''[[[
    '等待用数据/{己.分支状态:变量环境}'
    .内禀变量环境
    .外赋指令序列
    .已变现外赋变量环境#?未来值?连锁惰性值
    .局部地址变量环境
    .欤本分支已解禁
    #]]]'''#'''
class 乸关联数据:
    r'''[[[
    '{起地址:{解码器名:关联数据}}'
    .起地址
    .解码器.解码器名
    .解码器.初始环境/构造参数/内禀变量环境
    #返回#上浮
    #调用#下沉
    .裁剪用数据.欤继承已解禁
    .返回用数据#{父调用处:{裁剪用数据}}
        #父调用处 ~ (起地址,解码器名,分支状态)
        #裁剪用数据.欤继承已解禁
    .等待用数据#{己.分支状态:变量环境}
        #变量环境=?(内禀变量环境,外赋指令序列,已变现外赋变量环境,局部地址变量环境,欤本分支已解禁)?
    .鬽结果#结果/(结果囗内禀,结果囗外赋囗惰性值)
    #]]]'''#'''
class 乸裁剪用数据:
    r'''[[[
    裁剪用数据:
        .欤继承已解禁
    #]]]'''#'''
class 乸内敛语法最短句子解码器:
    r'''[[[
    st ~ 分支状态 #裁剪相关
    魊码元 ~ 码元 | 全文终
    解码场景 ~ 全局变量/?(全文码元串,全文地址映射,解码器构造映射/{解码器名:解码器},内禀外赋计算器/过滤器)?
    解码器 ~ 解码场景+解码器构造映射[解码器名]
        解码器 不可散列 #因为 包含 解码场景
        解码器名 可散列
        解码器名 ~ ?(解码器构造器名,解码器构造参数/内禀变量环境)?
        ??但是 构造参数...解码器 也是构造参数 之一，只能 转化为 解码器名 ...有点麻烦
    全文地址映射
        地址差量计算
        读取囗码元串囗囗空串乊反转扌 :: 起地址 -> 讫地址 -> [码元]
        读取囗码元串囗囗反转串乊反转扌 :: 起地址 -> 讫地址 -> [码元]
    内禀变量环境:
        内禀变量名:内禀变量值
        ?包含 地址?
            地址 是特殊变量，不能用作 构造参数
            构造参数 可以是 地址差量/正负长度、子串/码元串，但不能是 地址
            返回值 可以是 地址？
    解码器名:特殊:
        取地址<内禀变量名>
        #返回<外赋计算，输出选择名囗囗内禀>
        返回<输出变量名列表囗囗内禀,输出变量名列表囗囗外赋>
        步进码元集合
        赋值计算<内禀丷外赋,赋值变量名丨列表??,计算表达式>
        解禁裁剪#禁言
        裁剪
    #]]]'''#'''
    # 乸内敛语法最短句子解码器
    def 取囗鬽返回俩鬽名纟所在父解码器分支扌(sf, /):
        '-> 鬽返回俩鬽名/(鬽 (鬽 内禀输出名, 鬽 外赋输出名))'
        return None
    def 裁剪所在父解码器分支吗扌(sf, /):
        '-> bool'
        return False
    def 解禁所在父解码器分支吗扌(sf, /):
        '-> bool'
        return False
    def 是内建计算暨赋值零解码器吗扌(sf, /):
        '-> bool'
        return False
    def 是内建零解码器吗扌(sf, /):
        '-> bool'
        return False
    def 是幺解码器吗扌(sf, /):
        '-> bool'
        return False
    def 取囗解码场景扌(sf, /):
        '-> 解码场景/全局变量/?(全文码元串,全文地址映射,解码器构造映射/{解码器名:解码器},内禀外赋计算器/过滤器)?'
    def 取囗解码器名扌(sf, /):
        '-> 解码器名/?(解码器构造器名,解码器构造参数/内禀变量环境)?'
    def 取囗初始内禀变量环境扌(sf, /):
        '-> 内禀变量环境/{内禀变量名:内禀变量值}'
    def 取囗初始分支状态集合扌(sf, /):
        '-> {分支状态}'
    def 偏序比较囗分支状态扌(sf, 分支状态乊左, 分支状态乊右, /):
        '-> (0/NA|1/LT|2/GT|3/EQ)#see:匞偏序比较结果'
    def 就地展开扌(sf, 分支状态, 内禀变量环境, /):
        '-> 子解码器名讠丮分支状态丶内禀输出名丶外赋输出名丶内禀计算器丶外赋计算器厈{解码器名:(分支状态,输出绑定囗内禀/(鬽[变量名]),输出绑定囗外赋/(鬽[变量名]),内禀计算器/(鬽[过滤器]),外赋计算器/(鬽[过滤器]))}'
        #就地展开
        #需得生成:(欤继承已解禁, 父调用处, 解码器名) = 待办事项
        解码器名冃父 = sf.取囗解码器名扌()
        解码器名冃子 = ...

    #def 步进乊魊码元扌(sf, 分支状态, 内禀变量环境, 魊码元, /):
    #    '-> {分支状态:内禀变量环境}'

class 匞偏序比较结果:
    #(0/NA|1/LT|2/GT|3/EQ)
    NA,LT,GT,EQ = range(4)
    偏序比较结果讠鬽全序比较结果 = (None,-1,+1,0)
匞偏序比较结果.偏序比较结果讠鬽全序比较结果


from collections.abc import Hashable
from functools import cmp_to_key
from seed.types.FrozenDict import FrozenDict, mk_FrozenDict, empty_FrozenDict
def check_hashable_(x, /):
    if not isinstance(x, Hashable): raise TypeError
def _get_may_(d, may_k, /):
    if may_k is None:
        return None
    else:
        k = may_k
        return d[k]
def update(d, news, /):
    if not news:
        dd = d
    else:
        dd = {**d,**news}
        dd = mk_FrozenDict(dd)
    return dd
class 匴内敛语法最短句子解码器:
    r'''[[[
    ===
    源码串#文本
    匞场景包/解码场景
    主解码器
    位置讠相关数据
    待办列表乊就地展开/[(识别器|裁剪建议, 父)]@当前位置
    ===
结果 = (内禀结果,外赋结果冖惰性值)|False/失败|.../其他分支裁剪导致被取消
结果冃子
    # False/结果乊失败 | .../结果乊裁剪导致中断 | (内禀结果,外赋结果冖惰性值)/结果乊返回
    ===
需要:内建解码器:
    内建伪解码器冫返回
    内建伪解码器冫全局退出
    内建解码器冫主解码器
        [内建解码器冫主解码器 ~==~ [.欤继承已解禁=True]:(解禁+++主解码器冖用户+++裁剪+++内建伪解码器冫全局退出)]
解码器 分类:三纲:四属:五种
    * 凡解码器:一属:一种
        * 非伪非幺解码器
            #包含: 内建解码器冫主解码器
            #接口规范 ==>> 用户自定义类型
    * 幺解码器:一属:一种
        * 魊码元解码器
            #接口规范 ==>> 用户自定义类型
    * 伪解码器:两属:三种
        * 幺伪解码器:一种
            * 内建伪解码器冫全局退出
                #实例唯一
                #用于 实现 内建解码器冫主解码器
        * 零伪解码器:两种
            * 内建计算暨赋值零伪解码器
                #类型唯一
                #参数=>不同实例
            * 内建伪解码器冫返回
                #实例唯一
                #用于 实现 取囗鬽返回俩鬽名纟所在父解码器分支扌()
另外:综合归类:四属:五种
    #说是『归类』不太恰当，因为 分类 依赖于 特定文本特定位置
    泛幺解码器:两属:两种
        幺解码器:一属:一种
        幺伪解码器:一属:一种
    泛零解码器:一个半属:两个半种
        零伪解码器:一属:两种
        零凡解码器:半属:半种
            ===特定文本特定位置上不论成败解码过程未用到泛幺解码器的凡解码器#xxx不含泛幺解码器子部件的凡解码器
    步进凡解码器:半属:半种
        ===特定文本特定位置上不论成败用到泛幺解码器的凡解码器#xxx含泛幺解码器子部件的凡解码器
    ===
接口3:初始展开#缓存待办
    -->接口7:幺解码器#缓存待办
    -->
接口4:就地展开#立即执行
    #xxx:-->接口2:返回#缓存待办
        #???返回 之前，插入 裁剪/(解禁++断言真囗零解码器)
        #改用:取囗鬽返回俩鬽名纟所在父解码器分支扌
    #xxx:-->接口9:解禁#立即执行
        #改用:解禁所在父解码器分支吗扌
    -->接口8:计算暨赋值#立即执行
    -->
接口1:调用#缓存待办
    -->接口3:初始展开#缓存待办
    -->
接口2:返回#缓存待办
    -->
接口5:后续发展#立即执行
    <--接口1:调用#缓存待办
    <--接口2:返回#缓存待办#结果唯一
    -->接口6:裁剪统计#缓存待办
    -->:
        |-->接口2:返回#缓存待办
        |-->接口4:就地展开#立即执行
    ===
接口1:调用/下沉/注册悬赏
    (父调用处,后续乊子,扩展子入口)
    (父调用处,后续乊子,欤继承已解禁乊子起,起地址乊子,解码器名冃子)
        欤继承已解禁乊子起 = 欤继承已解禁乊父起 and 欤本分支已解禁乊父乊子起
        父调用处 = (起地址乊父,解码器名冃父,分支状态冃父乊子起)
        #扩展父调用处 = (?,父调用处)
        扩展子入口 = (欤继承已解禁乊子起,子入口)
    待办缓存形式:
        {起地址乊子:{解码器名冃子:{父调用处:(后续乊子,欤继承已解禁乊子起)}}}
        #xxx:{起地址乊子:{解码器名冃子:{父调用处}}}
        #xxx:分离出: {父调用处:(后续乊子,欤继承已解禁乊子起)}
        #   !!内禀变量环境乊父乊子起=>[解码器名冃子 不一定相同]
接口2:返回
    (子入口,扩展结果冃子)
    (起地址,解码器名,讫地址,结果)
        # === (起地址乊子,解码器名冃子,讫地址乊子,结果冃子)
        子入口 = (起地址乊子,解码器名冃子)
        扩展结果冃子 = (讫地址乊子,结果冃子)
    待办缓存形式:
        {起地址乊子:{解码器名冃子:扩展结果冃子/(讫地址乊子,结果冃子)}}
接口3:初始展开
    (欤继承已解禁乊父起,起地址乊父,解码器名冃父)
    (欤继承已解禁,起地址,解码器名)
        # [起地址乊父===起地址===起地址乊子]
        # 初始分支状态集合
        # 初始内禀变量环境
        # 构建:关联数据
    待办缓存形式:
        {起地址乊父:{解码器名冃父:{欤继承已解禁乊父起}/[1,2,3]}}
接口4:就地展开
    (父调用处,欤继承已解禁乊子起,仨变量环境乊父乊子起,起地址乊子)
        # === ((起地址乊父,解码器名冃父,分支状态冃父乊子起),欤继承已解禁乊子起,仨变量环境乊父乊子起,起地址乊子)
        # 仨变量环境乊父乊子起=(内禀变量环境乊父乊子起,外赋变量环境乊父乊子起,局部地址变量环境乊父乊子起)
        # 子解码器名讠后续 = 解码器冃父.就地展开扌(分支状态冃父乊子起, 内禀变量环境乊父乊子起)
        #   后续乊子/(仨变量环境乊父乊子起,_后续乊子/(分支状态乊子讫,内禀输出名,外赋输出名,内禀计算器,外赋计算器))
    待办缓存形式:
        无需
        立即执行
        见:接口1:调用
接口5:后续发展
    # (欤继承已解禁乊父起,父调用处,后续乊子,讫地址乊子,结果冃子,欤本分支已解禁乊父乊子讫)
    (父调用处,后续乊子,讫地址乊子,结果冃子,欤继承已解禁乊子讫,鬽返回俩鬽名)
        欤继承已解禁乊子讫 === 欤继承已解禁乊父起 and 欤本分支已解禁乊父乊子讫
        欤本分支已解禁乊父乊子讫===欤本分支已解禁乊父乊子起 or [子解码器名 is 解禁]
    待办缓存形式:
        无需
        立即执行

接口6:裁剪统计
    (父调用处乊子讫,讫地址乊子,欤真裁剪,欤子乃返回)
        #接口3:初始展开:要求:清空零解码器 之后，步进 之前:执行:接口6:裁剪统计
    # 调用 本函数 之前，前置条件: 步进凡解码器 全部展开, 泛零解码器 处理完毕, 只剩下 泛幺解码器
    #   [:接口六冫裁剪统计冖冖处理待办冖冖大纲]:goto
    #
    裁剪触发:欤本分支已解禁+返回乊子
        #裁剪触发:已解禁&&返回
            #xxx:裁剪触发:裁剪,返回
        裁剪===解禁++无结果囗零解码器
        #同一分支 可能 于 同一 讫地址乊子 裁剪多次(零解码器)!!!
        #???==>> 基础分支状态-->扩展分支状态
        #==>> 偏序比较囗分支状态扌: NA|LT|EQ|GT
    待办缓存形式:
        {讫地址乊子:{起地址乊父:{父调用处乊子讫:欤子乃返回}}}
        #xxx:起地址乊父乊最大唯一区
        .起地址冖非唯一冖最小
            每次 剪裁 更新
接口7:幺解码器
    (欤继承已解禁,起地址,解码器名乊幺)
        # ~~~ 接口3:初始展开
        #『幺』指『魊码元』#码元|全文终
    待办缓存形式:
        {起地址乊子:{解码器名冃子:{欤继承已解禁}/[1,2,3]}}
接口8:计算暨赋值
    仨变量环境乊父乊子起
    (内禀变量环境乊父乊子起, 外赋变量环境乊父乊子起, 局部地址变量环境)
        # 仨变量环境=(内禀变量环境,外赋变量环境,局部地址变量环境)
        #取地址,取局部原文片段
        #综合局部变量计算
        #删除局部变量
        #覆写局部变量
    待办缓存形式:
        无需
        立即执行
接口9:解禁
    更改一:隐式具现:见:接口5:后续发展:检测[子解码器名 is 解禁]
    更改二:
        去除 内建-裁剪,改为 裁剪所在父解码器分支吗扌()
        去除 内建-解禁,改为 解禁所在父解码器分支吗扌()
        去除 内建-返回,改为 取囗鬽返回俩鬽名纟所在父解码器分支扌()
            但是 发现仍然需要 内建伪解码器冫返回
    ===
# [:缓存空间囗集中营]:here
缓存空间甲=地址讠解码器名讠缓存空间甲(地址,解码器名)
缓存空间甲.继承已解禁冖冖三态(起地址乊父, 解码器名冃父)
缓存空间甲.父调用处讠扩展后续(起地址乊子, 解码器名冃子)
缓存空间甲.扩展结果冃子(起地址乊子, 解码器名冃子)
缓存空间甲.分支状态讠扩展变量环境乊子起(起地址乊父, 解码器名冃父)

缓存空间乙=讫地址讠起地址讠缓存空间乙(讫地址,起地址)
缓存空间乙.父调用处乊子讫讠欤子乃返回(讫地址乊子,起地址乊父)
    ===
分支状态:
    * 旁枝#被裁撤
    * 干枝#发出 裁剪建议 的分支
        * 幼枝#最幼嫡枝
        * 老枝#被覆盖撤除
撤除老枝父调用处乊步进前夕扌
裁撤旁枝父调用处乊裁剪乊步进前夕扌
    就地撤消纟裁撤旁枝父调用处乊裁剪乊步进前夕扌
        #?引用数?
    ===
#######
展开丷撤消
#######
#{父入口:扩展结果冃父}
#    扩展结果冃父 = (讫地址乊父,结果冃父)
#    结果冃父 = (内禀结果冃父,外赋结果冃父冖惰性值)
{子入口:扩展结果冃子}
    名称:返回结果缓冲区
    扩展结果冃子 = (讫地址乊子,结果冃子)
    结果冃子 = (内禀结果冃子,外赋结果冃子冖惰性值)
    何时撤消？
        裁剪之前
        <<==:
        * [起地址乊子 < 讫地址乊子]:
            通告:所有 扩展父调用处，当他们移位后(变量环境更新)，即可 删除
                !! 不可能再有 新的 扩展父调用处
        * [起地址乊父 == 讫地址乊父]:
            !! 可能有 新的 扩展父调用处
            只能等 充分展开之后，裁剪之前，步进之前
#######
{父入口:(扩展欤继承已解禁乊父起,累积欤任一分支曾裁剪}
    名称:调用交接区
        #逆转:就地展开扌():需要:
        调用交接区
        未果存活后续分支集中处
    父入口:
        ===(起地址乊父,解码器名乊父)
    扩展欤继承已解禁乊父起:
        ===({欤继承已解禁乊父起:计数?{扩展父调用处@爷}},欤继承已解禁乊父起冖最优值)
        同一 扩展父调用处 允许 至多两次 进入:必须:第一次 非 最优值，第二次 最优值:==>>解禁更新充分传播层
        扩展欤继承已解禁乊父起:更新:
            * [当前地址==起地址乊父]:
                新增 扩展父调用处@爷
                欤继承已解禁乊父起冖最优值 只增
            * 裁剪:
                减少 扩展父调用处@爷
                欤继承已解禁乊父起冖最优值 不变
            #####
            欤继承已解禁乊父起冖最优值:更新:
                只增=>[当前地址==起地址乊父]:
            若 欤继承已解禁乊父起冖最优值 更新，需将 影响 传播 给 各分支，或者说，各分支 实时读取？
                为保证 合理，充分展开之后，裁剪之前，增加一层:解禁更新充分传播层
                [初始化层<充分展开层<解禁更新充分传播层<裁剪层<全局退出层<步进层]
                一层一待办队列
            #####
    特殊:欤继承已解禁乊父起-->{欤继承已解禁乊父起:计数}
        并行态,影响不大,但需 定期维护/同步/确认一致性
        ???有毛病:裁撤之后:归一:泛零解码器:很复杂
        没毛病:[最优值只增|整个被撤消]
        充分展开过程中，只增/只考虑最优值
        步进之前&&裁撤前夕=>
            * 无裁剪建议:安然无恙:只增
            * 出现裁剪建议-身处主枝/至少有一个上司身处主枝:最优值保留有效:之前依照最优值行事 没错:无论 一致 还是 歧义
            * 出现裁剪建议-身处旁枝/没有一个上司身处主枝:没有发出裁剪建议:错不在我
        步进之前&&裁撤之后=>
            * 无裁剪建议:安然无恙:只增
            * 出现裁剪建议-身处主枝/至少有一个上司身处主枝:最优值保留有效
            * 出现裁剪建议-身处旁枝/没有一个上司身处主枝:整个被撤消:增减也就无所谓
    何时撤消？
        匹配|不匹配:
            同于『{子入口:扩展结果冃子}』
            裁剪之前 撤消
        裁撤:
            +并非自己提出的裁剪建议
            +出结果前被裁撤#返回前被裁撤
            #####
            [解禁更新充分传播层<裁剪层]
            裁剪之时 还存在==>>未出结果
            如何判定 裁剪建议 是否 自己 由提出的?
                +[欤继承已解禁乊父起冖最优值==True]
                +[累积欤任一分支曾裁剪==True]
                !! 上述两者
                [曾经 欤真裁剪]
                [锁定]
                !! 仍存在@裁剪层
                [未出结果]
                !! [未出结果][锁定]
                [歧义]or[裁剪建议 出自自身]

#######
{(父入口,讫地址乊子as当前地址):{分支状态冃父乊子讫乊步进后:{分支状态冃父乊子起乊步进前:幺解码器名乊子}}}
    名称:步进合流检测区
    何时撤消？
        初始化层之后，充分展开层之前
        初始化:原地合流检测区 之后 即可撤消
#######
#{(父入口,起地址乊子as当前地址):累积集合纟分支状态乊所有分支含已裁撤分支乊当前地址}
{(父入口,起地址乊子as当前地址):累积集合纟分支状态乊所有分支乊当前地址冖冖含湮没丶流产状态}
    名称:原地合流检测区
    不受 裁剪 影响，步进之后 删除
        事实上，撤消 于 裁剪之前
        ！所谓 含 已裁撤 分支状态 没有意义！
        不一定无意义:裁撤=>裁剪|撤消
            撤消 来源于:
                所有 后续分支 出结果==>>过气被覆盖 湮没
                某 后续分支 不匹配==>>后续分支状态 流产
    集合只增，用于 检测 当前地址 分支状态 合流:异分支=>歧义，同分支=>死循环
        ??但 步进之后 合流 怎么检测？
            ==>>步进合流检测区
    初始化:
        * 初始分支状态集合
        * 步进合流检测区
    之后，不断添加 就地展开扌() 生成的 分支状态乊子讫
    #与 被多次调用 无关
        #就地展开扌()
        #子解码器名讠后续 = 解码器冃父.就地展开扌(分支状态冃父乊子起, 内禀变量环境乊父乊子起)
        子解码器名讠后续/{解码器名冃子:_后续乊子}
        _后续乊子:
            === (分支状态乊子讫,内禀输出名,外赋输出名,内禀计算器,外赋计算器)
    何时撤消？
        !! [初始化层<充分展开层<解禁更新充分传播层<裁剪层<全局退出层<步进层]
        充分展开之后:已无虞 原地 合流#歧义|死循环
        解禁更新充分传播层之前！

#######
{扩展父调用处:子解码器名讠后续}
    名称:未果存活后续分支集中处
        子-未出结果
    初始化后续更改:只减
        子-死亡:
            子-裁撤/非最短锁定
        子-出结果:
            子-失败/不匹配
            子-成功/匹配
        #就地展开扌()
    何时撤消？
        * 削减至空:自动撤消
        * 父-出结果
        * 父-裁撤
        ##
        撤消触发动作:
            撤消囗所有存活未果后续
                #撤消-子#存活&&未果
                #逆转:就地展开扌()

#######
{扩展父调用处:(扩展欤继承已解禁乊父起,扩展仨变量环境乊父乊子起,所有分支状态乊本分支乊当前地址)}
    扩展父调用处:
        ===(父入口,扩展分支状态冃父乊子起)
    扩展仨变量环境乊父乊子起:
        ===(欤本分支已解禁乊父乊子起,欤本分支已裁剪乊父乊子起,鬽返回俩鬽名,仨变量环境乊父乊子起)
            #一旦 扩展欤继承已解禁乊父起 解禁，(欤本分支已解禁乊父乊子起,欤本分支已裁剪乊父乊子起) 就能 后知后觉地 产生作用
            #   累积欤任一分支曾裁剪|=欤本分支已裁剪乊父乊子起
            #鬽返回俩鬽名==>>欤本分支返回/欤子乃返回@子讫
            #取囗鬽返回俩鬽名纟所在父解码器分支扌
    仨变量环境乊父乊子起:
        === (内禀变量环境乊父乊子起,外赋变量环境乊父乊子起,局部地址变量环境乊父乊子起)
        初始分支状态集合
        初始内禀变量环境
    扩展分支状态冃父乊子起:
        ===(起地址乊子,分支状态冃父乊子起)
        相当于 扩展状态，步进之后 允许 分支状态 回收复用
    #xxx:(起地址乊子,数目纟分支状态乊本分支乊当前地址,分支状态冃父乊子起):
        相当于 扩展状态，无需步进, 原地踏步 也允许 分支状态 回收复用
        ???反对原因一:但是,无意义:因为 同一 分支状态 基本会有相同展开，除非 运用 内禀变量环境乊父乊子起
            #并行态有限状态机:步进之前:彻底展开，步进之后:已有 起地址乊子 区分 状态，这里 数目 无用
        反对原因二:不同分支 合流 产生 歧义;同分支 合流 产生 死循环:更快发现错误，好过 零解码器 无用 计数
            除非 使用 所有分支状态乊本分支乊当前地址 作区分
        #就地展开扌()
    所有分支状态乊本分支乊当前地址:
        ===(数目纟分支状态乊本分支乊当前地址,右增链表纟分支状态乊本分支乊当前地址)
        用于 判定 是否为 兄弟关系
        #偏序比较囗分支状态扌()
        兄弟关系=>裁剪建议-相互兼容
        非兄弟关系=>裁剪建议-异地址相互裁撤,同地址导致冲突歧义
        裁剪建议=>子讫#发生于:(步进之后|全文始)，下一次 步进之前
#######
#######
    ===

    #]]]'''#'''

    起地址冖非唯一冖最小
    @property
    def 解码场景(sf, /):
        '-> 乸解码场景'
    def 主旨讠待办列表(sf, 主旨, /):
        '-> 待办列表'
    def 地址讠解码器名讠缓存空间甲(sf, 地址, 解码器名, /):
        '-> 缓存空间甲'
        #'-> {地址:{解码器名:缓存空间甲}}'
        #缓存空间甲 = sf.地址讠解码器名讠缓存空间甲[起地址乊父][解码器名冃父]
    def 讫地址讠起地址讠缓存空间乙(sf, 讫地址, 起地址, /):
        '-> 缓存空间乙'
    def 接口3初始展开(sf, 欤继承已解禁乊父起,起地址乊父,解码器名冃父, /):
        #缓存待办
        #待办缓存形式:
        #   {起地址乊父:{解码器名冃父:{欤继承已解禁乊父起}/[1,2,3]}}
        缓存空间甲 = sf.地址讠解码器名讠缓存空间甲(起地址乊父, 解码器名冃父)
        case = 缓存空间甲.继承已解禁冖冖三态
            # 0|[1,2,3]
        _case = case | (1 if 欤继承已解禁乊父起 else 2)
            # [1,2,3]
        if not case == _case:
            缓存空间甲.继承已解禁冖冖三态 = _case
        #if case & 1:
        #    #已解禁
        #    return
        if not case == 0:
            #已加入:待办列表
            #???零解码器:欤继承已解禁乊父起-忽略不计 无所谓???
            #   <<==接口3:初始展开:要求:清空零解码器 之后，步进 之前:执行:接口6:裁剪统计
            return
        待办列表 = sf.主旨讠待办列表('初始展开')
        待办列表.append((起地址乊父,解码器名冃父))
        return
    def 接口3初始展开冖冖处理待办(sf, /):
        待办列表 = sf.主旨讠待办列表('初始展开')
        while 待办列表:
            (起地址乊父,解码器名冃父) = 待办列表.pop()
            缓存空间甲 = sf.地址讠解码器名讠缓存空间甲(起地址乊父, 解码器名冃父)
            case = 缓存空间甲.继承已解禁冖冖三态
                # 0|[1,2,3]
            assert not case == 0
            欤继承已解禁乊父起 = bool(case & 1)
            解码器冃父 = sf.解码场景.构造囗解码器扌(解码器名冃父)
            if 解码器冃父.是幺解码器吗扌():
                sf.接口7幺解码器(欤继承已解禁乊父起,起地址乊父,解码器名冃父)
                continue
            起地址乊子 = 起地址乊父
            欤本分支已解禁乊父乊子起 = False
            欤继承已解禁乊子起 = 欤继承已解禁乊父起 and 欤本分支已解禁乊父乊子起
            ######################
            初始分支状态集合 = 解码器名冃父.取囗初始分支状态集合扌()
            初始内禀变量环境 = 解码器名冃父.取囗初始内禀变量环境扌()
            ######################
            内禀变量环境乊父乊子起 = 初始内禀变量环境#初始
            外赋变量环境乊父乊子起 = empty_FrozenDict#初始
            局部地址变量环境乊父乊子起 = empty_FrozenDict#初始
            仨变量环境乊父乊子起 = (内禀变量环境乊父乊子起,外赋变量环境乊父乊子起,局部地址变量环境乊父乊子起)
            for 分支状态冃父乊子起 in 初始分支状态集合:
                父调用处 = (起地址乊父,解码器名冃父,分支状态冃父乊子起)
                sf.接口4就地展开(父调用处,欤继承已解禁乊子起,仨变量环境乊父乊子起,起地址乊子)
        return
    def 接口4就地展开(sf, 父调用处,欤继承已解禁乊子起,仨变量环境乊父乊子起,起地址乊子, /):
        #立即执行
        (内禀变量环境乊父乊子起,外赋变量环境乊父乊子起,局部地址变量环境乊父乊子起) = 仨变量环境乊父乊子起
        (起地址乊父,解码器名冃父,分支状态冃父乊子起) = 父调用处
        ######################
        #缓存空间甲 = sf.地址讠解码器名讠缓存空间甲(起地址乊子, 解码器名冃父)
            # ??{起地址乊子:解码器名冃父:父调用处:仨变量环境乊父乊子起}
        缓存空间甲 = sf.地址讠解码器名讠缓存空间甲(起地址乊父, 解码器名冃父)
            # ??{(起地址乊父:解码器名冃父:分支状态冃父乊子起)/父调用处:起地址乊子:仨变量环境乊父乊子起}
        分支状态讠扩展变量环境乊子起 = 缓存空间甲.分支状态讠扩展变量环境乊子起
            # {分支状态冃父乊子起:(起地址乊子,仨变量环境乊父乊子起)}
        扩展变量环境乊子起 = (起地址乊子,仨变量环境乊父乊子起)
        if not 分支状态讠扩展变量环境乊子起.setdefault(分支状态冃父乊子起,扩展变量环境乊子起) is 扩展变量环境乊子起:
            raise 错误囗分支状态乊子起冖冖重复(父调用处,起地址乊子,分支状态冃父乊子起)
        ######################

        解码器冃父 = sf.解码场景.构造囗解码器扌(解码器名冃父)
        子解码器名讠后续 = 解码器冃父.就地展开扌(分支状态冃父乊子起, 内禀变量环境乊父乊子起)

        for 解码器名冃子,_后续乊子 in 子解码器名讠后续.items():
            (分支状态乊子讫,内禀输出名,外赋输出名,内禀计算器,外赋计算器) = _后续乊子
            后续乊子 = (仨变量环境乊父乊子起,_后续乊子)
            解码器冃子 = sf.解码场景.构造囗解码器扌(解码器名冃子)
            子入口 = (起地址乊子,解码器名冃子)
            ######################
            ######################
            ######################
            #改为使用:解禁所在父解码器分支吗扌/裁剪所在父解码器分支吗扌
            #if 解码器冃子 is 解禁:
            #   pass
            #elif 解码器冃子.是内建零解码器吗扌():
            ######################
            ######################
            if 解码器冃子.是内建零解码器吗扌():
                #改为使用:取囗鬽返回俩鬽名纟所在父解码器分支扌
                #if 解码器冃子 is 返回:
                #   TODO
                #   #返回 之前，插入 裁剪/(解禁++断言真囗零解码器)
                #   #???sf.接口6裁剪统计(...)
                #   sf.接口2返回(子入口,扩展结果冃子)
                #elif 解码器冃子 is 解禁:
                #   raise 000
                #   #无:sf.接口9解禁...
                #   #   <<==隐式具现:见:接口5后续发展:检测[子解码器名 is 解禁]
                #elif 解码器冃子.是内建计算暨赋值零解码器吗扌():
                if 解码器冃子.是内建计算暨赋值零解码器吗扌():
                    TODO
                    #sf.接口8计算暨赋值(内禀变量环境乊父乊子起, 外赋变量环境乊父乊子起, 局部地址变量环境)
                    sf.接口8计算暨赋值(仨变量环境乊父乊子起)
                    #continue
                else:
                    raise 000
                pass#continue
            ######################
            #(非幺解码器&&非内建零解码器)||(解禁)
            扩展子入口 = (欤继承已解禁乊子起,子入口)
            sf.接口1调用(父调用处,后续乊子,扩展子入口)
        return
    def 接口1调用(sf, 父调用处,后续乊子,扩展子入口, /):
        #缓存待办
        #待办缓存形式:
        #   {起地址乊子:{解码器名冃子:{父调用处:(后续乊子,欤继承已解禁乊子起)}}}
        ######################
        #(起地址乊父,解码器名冃父,分支状态冃父乊子起) = 父调用处
        (欤继承已解禁乊子起,子入口) = 扩展子入口
        (起地址乊子,解码器名冃子) = 子入口
        缓存空间甲 = sf.地址讠解码器名讠缓存空间甲(起地址乊子, 解码器名冃子)
        ######################
        父调用处讠扩展后续 = 缓存空间甲.父调用处讠扩展后续
            # {}
        扩展后续 = (后续乊子,欤继承已解禁乊子起)
        _扩展后续 = 父调用处讠扩展后续.setdefault(父调用处,扩展后续)
        if _扩展后续 is 扩展后续:
            #新增
            pass
        elif not _扩展后续 == 扩展后续:
            #???
            #可能 需要 更新:欤继承已解禁乊子起
            raise 000
        else:
            # [_扩展后续 == 扩展后续]
            # [not$ _扩展后续 is 扩展后续]
            #已加入:待办列表
            return
        ######################
        扩展结果冃子 = 缓存空间甲.扩展结果冃子
            #None|(讫地址乊子,结果冃子)
        if not 扩展结果冃子 is None:
            #已有结果/已曾调用
            if not _扩展后续 is 扩展后续: raise 000
            sf.接口5后续发展冖冖缓存待办(父调用处,子入口,扩展结果冃子)
            return
        ######################
        #未有结果/未曾调用
        待办列表 = sf.主旨讠待办列表('调用')
        #待办列表.append((父调用处,子入口))
        待办列表.append(子入口)
        return
    def 接口1调用冖冖处理待办(sf, /):
        待办列表 = sf.主旨讠待办列表('调用')
        while 待办列表:
            #(父调用处,子入口) = 待办列表.pop()
            子入口 = 待办列表.pop()
            (起地址乊子,解码器名冃子) = 子入口
            缓存空间甲 = sf.地址讠解码器名讠缓存空间甲(起地址乊子, 解码器名冃子)
            assert 缓存空间甲.扩展结果冃子 is None
                #未有结果/未曾调用
            ######################
            父调用处讠扩展后续 = 缓存空间甲.父调用处讠扩展后续
                # {}
            assert 父调用处讠扩展后续
            acc = None
            for 扩展后续 in 父调用处讠扩展后续.values():
                (后续乊子,欤继承已解禁乊子起) = 扩展后续
                acc = acc or 欤继承已解禁乊子起
            assert not acc is None
            欤继承已解禁乊子起 = acc
            #sf.接口3初始展开(欤继承已解禁乊父起,起地址乊父,解码器名冃父)
            sf.接口3初始展开(欤继承已解禁乊子起,起地址乊子,解码器名冃子)
        return
    def 接口2返回(sf, 子入口,扩展结果冃子, /):
        #缓存待办
        #待办缓存形式:
        #   {起地址乊子:{解码器名冃子:扩展结果冃子/(讫地址乊子,结果冃子)}}
        ######################
        # 刚有结果/已曾调用
        (起地址乊子,解码器名冃子) = 子入口
        缓存空间甲 = sf.地址讠解码器名讠缓存空间甲(起地址乊子, 解码器名冃子)
        扩展结果冃子 = 缓存空间甲.扩展结果冃子
            #None|(讫地址乊子,结果冃子)
        if not 扩展结果冃子 is None:
            # 已有结果/已曾调用
            raise 000
        (讫地址乊子,结果冃子) = 扩展结果冃子
        缓存空间甲.扩展结果冃子 = 扩展结果冃子
        ######################
        if 1:
            #vs:sf.收尾乊失败(父调用处,讫地址乊父分支囗失败)
            sf.收尾乊成功(子入口,讫地址乊子)
        ######################
        父调用处讠扩展后续 = 缓存空间甲.父调用处讠扩展后续
        assert 父调用处讠扩展后续
        for 父调用处 in 父调用处讠扩展后续.keys():
            sf.接口5后续发展冖冖缓存待办(父调用处,子入口,扩展结果冃子)
        return
        #待办列表 = sf.主旨讠待办列表('返回')
        #待办列表.append(子入口)
        return
    #def 接口5后续发展(sf, 欤继承已解禁乊父起,父调用处,后续乊子,讫地址乊子,结果冃子,欤本分支已解禁乊父乊子讫, /):
    def 接口5后续发展(sf, 父调用处,后续乊子,讫地址乊子,结果冃子,欤继承已解禁乊子讫,鬽返回俩鬽名,欤真裁剪, /):
        #立即执行
        结果冃子
            # False/结果乊失败 | .../结果乊裁剪导致中断 | (内禀结果,外赋结果冖惰性值)/结果乊返回
        if 结果冃子 is False:
            #失败/不匹配
            讫地址乊父分支囗失败 = 讫地址乊子
            if 0:
                #?返回?
                结果冃父分支囗失败 = False
                扩展结果冃父分支囗失败 = (讫地址乊父分支囗失败,结果冃父分支囗失败)
                父分支入口 = 000#???
                sf.接口2返回(父分支入口,扩展结果冃父分支囗失败)
                    #<<==sf.接口2返回(子入口,扩展结果冃子)
            sf.收尾乊失败(父调用处,讫地址乊父分支囗失败)
            return
        ######################
        elif 结果冃子 is ...:
            #裁剪导致中断
            讫地址乊父分支囗中断 = 讫地址乊子
            sf.收尾乊中断(父调用处,讫地址乊父分支囗中断)
            return
        ######################
        (内禀结果乊子,外赋结果乊子冖惰性值) = 结果冃子
        check_hashable_(内禀结果乊子)
        check_type_is(乸连锁惰性值, 外赋结果乊子冖惰性值)
        ######################
        (仨变量环境乊父乊子起,_后续乊子) = 后续乊子
        (内禀变量环境乊父乊子起,外赋变量环境乊父乊子起,局部地址变量环境乊父乊子起) = 仨变量环境乊父乊子起
        (分支状态乊子讫,内禀输出名,外赋输出名,内禀计算器,外赋计算器) = _后续乊子
        ######################
        news = {}
        if not 内禀输出名 is None:
            if not 内禀计算器 is None:
                内禀结果乊子 = sf.内禀计算(内禀计算器,内禀结果乊子,外赋结果乊子冖惰性值)
                check_hashable_(内禀结果乊子)
            news[内禀输出名] = 内禀结果乊子
        ######################
        内禀变量环境乊父乊子讫 = update(内禀变量环境乊父乊子起, news)
        欤已更改 = bool(news)
        ######################
        news = {}
        if not 外赋输出名 is None:
            if not 外赋计算器 is None:
                #注意:已更新:内禀结果乊子
                外赋结果乊子冖惰性值 = sf.外赋计算(外赋计算器,内禀结果乊子,外赋结果乊子冖惰性值)
                check_type_is(乸连锁惰性值, 外赋结果乊子冖惰性值)
            news[外赋输出名] = 外赋结果乊子冖惰性值
        ######################
        外赋变量环境乊父乊子讫 = update(外赋变量环境乊父乊子起, news)
        欤已更改 |= bool(news)
        ######################
        局部地址变量环境乊父乊子讫 = 局部地址变量环境乊父乊子起
            #取地址...
        仨变量环境乊父乊子讫 = (内禀变量环境乊父乊子讫,外赋变量环境乊父乊子讫,局部地址变量环境乊父乊子讫) if 欤已更改 else 仨变量环境乊父乊子起
        ######################
        (起地址乊父,解码器名冃父,分支状态冃父乊子起) = 父调用处
        分支状态冃父乊子起冖后续 = 分支状态冃父乊子讫 = 分支状态乊子讫
        父调用处冖后续 = 父调用处乊子讫 = (起地址乊父,解码器名冃父,分支状态冃父乊子讫)
        #欤继承已解禁乊子讫 = 欤继承已解禁乊父起 and 欤本分支已解禁乊父乊子讫
        欤继承已解禁乊子起冖后续 = 欤继承已解禁乊子讫
        起地址乊子冖后续 = 讫地址乊子
        仨变量环境乊父乊子起冖后续 = 仨变量环境乊父乊子讫
        ######################
        ######################
        ######################
        欤子乃返回 = not 鬽返回俩鬽名 is None
        sf.接口6裁剪统计(父调用处乊子讫,讫地址乊子,欤真裁剪,欤子乃返回)
        ######################
        if 欤子乃返回:
            #xxx:assert 欤继承已解禁乊子起冖后续
            #assert 欤本分支已解禁乊父乊子讫
                #==>> 返回 之前 (解禁++裁剪)
            ######################
            讫地址乊父 = 讫地址乊子
            ######################
            (鬽内禀输出名, 鬽外赋输出名) = 返回俩鬽名 = 鬽返回俩鬽名
            内禀结果冃父 = 鬽内禀结果冃父 = _get_may_(内禀变量环境乊父乊子讫,鬽内禀输出名)
                #None 合法
            鬽外赋结果冃父冖惰性值 = _get_may_(外赋变量环境乊父乊子讫,鬽外赋输出名)
                #None 非合法
            外赋结果冃父冖惰性值 = ifNonef(鬽外赋结果冃父冖惰性值,lambda:乸连锁惰性值(起地址乊父, 讫地址乊父, 内建函数名冫恒量, None))
            结果冃父 = (内禀结果冃父,外赋结果冃父冖惰性值)
            ######################
            父入口 = (起地址乊父,解码器名冃父)
            扩展结果冃父 = (讫地址乊父,结果冃父)
                #子入口 = (起地址乊子,解码器名冃子)
                #扩展结果冃子 = (讫地址乊子,结果冃子)
            父分支入口 = 父入口
            扩展结果冃父分支 = 扩展结果冃父
                #<<==裁剪:唯一性
            sf.接口2返回(父分支入口,扩展结果冃父分支)
                #<<==sf.接口2返回(子入口,扩展结果冃子)
        else:
            sf.接口4就地展开(父调用处冖后续,欤继承已解禁乊子起冖后续,仨变量环境乊父乊子起冖后续,起地址乊子冖后续)
                #灬冖后续<<==sf.接口4就地展开(父调用处,欤继承已解禁乊子起,仨变量环境乊父乊子起,起地址乊子)
        ######################
        return
    def 接口5后续发展冖冖缓存待办(sf, 父调用处,子入口,扩展结果冃子, /):
        待办列表 = sf.主旨讠待办列表('后续发展')
        待办列表.append((父调用处,子入口,扩展结果冃子))
        return
    def 接口5后续发展冖冖处理待办(sf, /):
        待办列表 = sf.主旨讠待办列表('后续发展')
        while 待办列表:
            (父调用处,子入口,扩展结果冃子) = 待办列表.pop()
            (起地址乊子,解码器名冃子) = 子入口
            缓存空间甲 = sf.地址讠解码器名讠缓存空间甲(起地址乊子, 解码器名冃子)
            父调用处讠扩展后续 = 缓存空间甲.父调用处讠扩展后续
            #扩展结果冃子 = 缓存空间甲.扩展结果冃子
            assert 扩展结果冃子 is 缓存空间甲.扩展结果冃子
            assert not 扩展结果冃子 is None
            (讫地址乊子,结果冃子) = 扩展结果冃子
            扩展后续 = 父调用处讠扩展后续[父调用处]
            (后续乊子,欤继承已解禁乊子起) = 扩展后续
            ######################
            (欤继承已解禁乊父起,解码器冃子,鬽返回俩鬽名,欤子乃返回,欤子乃裁剪,欤子乃解禁,欤继承已解禁乊子讫,欤真裁剪) = sf._g(子入口)
            #sf.接口5后续发展(欤继承已解禁乊父起,父调用处,后续乊子,讫地址乊子,结果冃子,欤本分支已解禁乊父乊子讫)
            sf.接口5后续发展(父调用处,后续乊子,讫地址乊子,结果冃子,欤继承已解禁乊子讫,鬽返回俩鬽名,欤真裁剪)
            ######################
        return
    def _g(sf, 子入口, /):
        #@返回.后续
        (起地址乊子,解码器名冃子) = 子入口
        case = 缓存空间甲.继承已解禁冖冖三态
            # 0|[1,2,3]
        assert not case == 0
        欤继承已解禁乊父起 = bool(case & 1)
        ######################
        (解码器冃子,鬽返回俩鬽名,欤子乃返回,欤子乃裁剪,欤子乃解禁,欤继承已解禁乊子讫,欤真裁剪) = sf._f(解码器名冃子,欤继承已解禁乊父起)
        return (欤继承已解禁乊父起,解码器冃子,鬽返回俩鬽名,欤子乃返回,欤子乃裁剪,欤子乃解禁,欤继承已解禁乊子讫,欤真裁剪)
    def _f(sf, 解码器名冃子,欤继承已解禁乊父起, /):
        #@返回.后续
        解码器冃子 = sf.解码场景.构造囗解码器扌(解码器名冃子)
        鬽返回俩鬽名 = 解码器冃子.取囗鬽返回俩鬽名纟所在父解码器分支扌()
        欤子乃返回 = not 鬽返回俩鬽名 is None
        欤子乃裁剪 = 欤子乃返回 or 解码器冃子.裁剪所在父解码器分支吗扌()
            #返回 之前 裁剪
        欤子乃解禁 = 欤子乃返回 or 欤子乃裁剪 or 解码器冃子.解禁所在父解码器分支吗扌()
            #返回 之前 解禁
            #允许 解禁 而不 裁剪
            #裁剪 必定 解禁
        #if 解码器冃子 is 解禁:
        if 欤子乃解禁:
            # [子解码器名 is 解禁]
            # !! [欤本分支已解禁乊父乊子讫===欤本分支已解禁乊父乊子起 or [子解码器名 is 解禁]]
            欤本分支已解禁乊父乊子讫 = True
            欤继承已解禁乊子讫 = 欤继承已解禁乊父起 and 欤本分支已解禁乊父乊子讫
        else:
            # [not$ 子解码器名 is 解禁]
            # !! [欤本分支已解禁乊父乊子讫===欤本分支已解禁乊父乊子起 or [子解码器名 is 解禁]]
            # => [欤本分支已解禁乊父乊子讫 == 欤本分支已解禁乊父乊子起]
            # !! [欤继承已解禁乊子起 := 欤继承已解禁乊父起 and 欤本分支已解禁乊父乊子起]
            # !! [欤继承已解禁乊子讫 := 欤继承已解禁乊父起 and 欤本分支已解禁乊父乊子讫]
            # [欤继承已解禁乊子讫 == 欤继承已解禁乊子起]
            欤继承已解禁乊子讫 = 欤继承已解禁乊子起
            if 0:
                # [欤继承已解禁乊子讫 == 欤继承已解禁乊子起 == 欤继承已解禁乊父起 and 欤继承已解禁乊子起]
                # => [欤本分支已解禁乊父乊子讫 ~=~ 欤继承已解禁乊子起]
                欤本分支已解禁乊父乊子讫 = 欤继承已解禁乊子起
        欤继承已解禁乊子讫
        欤真裁剪 = 欤继承已解禁乊父起 and 欤子乃裁剪
        return (解码器冃子,鬽返回俩鬽名,欤子乃返回,欤子乃裁剪,欤子乃解禁,欤继承已解禁乊子讫,欤真裁剪)

    #def 接口6裁剪统计(sf, 父调用处冖后续,讫地址乊子,欤继承已解禁乊子讫, /):
    def 接口6裁剪统计(sf, 父调用处乊子讫,讫地址乊子,欤真裁剪,欤子乃返回, /):
        #缓存待办
        #待办缓存形式:
        #   {讫地址乊子:{起地址乊父:{父调用处乊子讫:欤子乃返回}}}
        #   起地址乊父乊最大唯一区
        if not 欤真裁剪:
            #父起.继承未解禁 or 本分支未解禁
            return
        if 欤子乃返回:
            # 返回@本分支
            #   既然 高层已解禁，那就 返回到高层再裁剪
            #
            pass#return
                #直接返回不行！因为 之前 还有 兄@本分支...
        (起地址乊父,解码器名冃父,分支状态冃父乊子讫) = 父调用处乊子讫
        缓存空间乙 = sf.讫地址讠起地址讠缓存空间乙(讫地址乊子,起地址乊父)
        #父调用处冖后续冖集合 = 缓存空间乙.父调用处冖后续冖集合
            # {/}
        父调用处乊子讫讠欤子乃返回 = 缓存空间乙.父调用处乊子讫讠欤子乃返回
            # {父调用处乊子讫:欤子乃返回}
        L = len(父调用处乊子讫讠欤子乃返回)
        #父调用处冖后续冖集合.add(父调用处冖后续)
        #父调用处乊子讫 = 父调用处冖后续
        父调用处乊子讫讠欤子乃返回.setdefault(父调用处乊子讫, 欤子乃返回)
        if L == len(父调用处乊子讫讠欤子乃返回):
            raise 错误囗分支状态乊子讫冖冖重复(父调用处乊子讫,讫地址乊子,父调用处乊子讫讠欤子乃返回)
            #已加入:待办列表
            return
        if not L == 0:
            # 已加入:待办列表<起讫>
            return
        待办列表 = sf.主旨讠待办列表('裁剪统计')
        待办列表.append((讫地址乊子,起地址乊父))
        return

    def 接口6裁剪统计冖冖处理待办(sf, /):
        待办列表 = sf.主旨讠待办列表('裁剪统计')
        if not 待办列表:
            #未出现有效 裁剪建议
            return
        #出现有效 裁剪建议
        (讫地址乊子0,_) = 待办列表[0]
        ######################
        # [:接口六冫裁剪统计冖冖处理待办冖冖大纲]:here
        ######################
        # 调用 本函数 之前，前置条件: 步进凡解码器 全部展开, 泛零解码器 处理完毕, 只剩下 泛幺解码器
        #
        ######################
        # 裁剪:源自 返回@本分支
        # 裁剪:源自 父起.继承已解禁>>>子讫.裁剪
        # 裁剪:源自 子起.继承已解禁>>>子讫
        #   子起.继承已解禁 == 父起.继承已解禁 && 本分支已解禁@子起
        ######################
        #先处理 完成品,半成品乊移位:
        #   <<== 待办列表:起讫地址+父调用处乊子讫
        #   <<== 一个(全文始|幺解码器)+多个(泛零解码器)
        #   父子关系/完成品<<==返回@本分支
        #   兄弟关系/半成品乊移位<<==子讫+裁剪+移动
        #       #就地展开-未移位/(首个非凡解码器 是 泛幺解码器) 没有 裁剪建议，不在 考虑范围
        #   ==>>爷孙关系,叔侄关系,...
        #   ==>>DAG多重领导
        #   ==>> [同父->同一分支兄弟关系]，否则 歧义
        #       ==>> 『乸内敛语法最短句子解码器:def 偏序比较囗分支状态扌()』
        #   ==>>以幼为嫡，则 嫡系成树, 消除了『DAG多重领导』
        #   去除 完成品，只保留 半成品乊移位
        #       <<== 『接口6裁剪统计():++欤子乃返回』
        ######################
        #再处理 半成品乊未移位:超限:
        #
        ######################
        #
        #xxx:父入口讠裁剪数 = defaultdict(int)
        父入口讠集合纟分支状态冃父乊子讫 = defaultdict(set)
            #{父入口:{分支状态冃父乊子讫}}
        父入口讠分支状态冃父乊子讫讠欤子乃返回 = defaultdict(dict)
            #{父入口:{分支状态冃父乊子讫:欤子乃返回}}
            #<<==同一分支 可能 于 同一 讫地址乊子 裁剪多次(零解码器)!!!
            #<<==讫地址乊子 唯一@本轮 裁剪统计
        total = 0
        while 待办列表:
            (讫地址乊子,起地址乊父) = 待办列表.pop()
            assert 讫地址乊子 == 讫地址乊子0
                #<<==讫地址乊子 唯一@本轮 裁剪统计
            缓存空间乙 = sf.讫地址讠起地址讠缓存空间乙(讫地址乊子,起地址乊父)
            #父调用处冖后续冖集合 = 缓存空间乙.父调用处冖后续冖集合
                # {/}
            父调用处乊子讫讠欤子乃返回 = 缓存空间乙.父调用处乊子讫讠欤子乃返回
                # {父调用处乊子讫:欤子乃返回}
            assert 父调用处乊子讫讠欤子乃返回
            total += len(父调用处乊子讫讠欤子乃返回)
            #for 父调用处冖后续 in 父调用处冖后续冖集合:
            for 父调用处乊子讫,欤子乃返回 in 父调用处乊子讫讠欤子乃返回.items():
                (起地址乊父,解码器名冃父,分支状态冃父乊子讫) = 父调用处乊子讫
                父入口 = (起地址乊父,解码器名冃父)
                #父入口讠集合纟分支状态冃父乊子讫[父入口].add(分支状态冃父乊子讫)
                父入口讠分支状态冃父乊子讫讠欤子乃返回[父入口][分支状态冃父乊子讫] = 欤子乃返回
        ######################
        父入口讠分支状态冃父乊子讫讠欤子乃返回 = dict(父入口讠分支状态冃父乊子讫讠欤子乃返回)
        assert total == sum(map(len, 父入口讠分支状态冃父乊子讫讠欤子乃返回.values()))
        ######################
        def _cmp_(f, x2may_rcmp, 分支状态乊左, 分支状态乊右, /):
            x = f(分支状态乊左, 分支状态乊右)
            check_int_ge_lt(0,4, x)
            may_rcmp = x2may_rcmp[x]
            if may_rcmp is None:
                raise 错误囗同时裁剪冖冖讫地址乊子(起地址乊父,解码器名冃父,讫地址乊子,分支状态乊左,分支状态乊右)
            rcmp = may_rcmp
            return rcmp
        ######################
        x2may_rcmp = 匞偏序比较结果.偏序比较结果讠鬽全序比较结果
        #父入口讠列表灬 = 父入口讠列表纟分支状态冃父乊子讫 = {}
        父入口讠灬 = 父入口讠分支状态冃父乊子讫冖最幼嫡冖非返回 = {}
            # {父入口:非返回之子讫-最幼嫡系-分支状态冃父乊子讫}
        ######################
        #for 父入口,集合纟分支状态冃父乊子讫 in 父入口讠集合纟分支状态冃父乊子讫.items():
        for 父入口,分支状态冃父乊子讫讠欤子乃返回 in 父入口讠分支状态冃父乊子讫讠欤子乃返回.items():
            # [同父->同一分支兄弟关系]，否则 歧义
            if not len(分支状态冃父乊子讫讠欤子乃返回) >= 2:
                列表纟分支状态冃父乊子讫 = [*分支状态冃父乊子讫讠欤子乃返回]
            else:
                (起地址乊父,解码器名冃父) = 父入口
                解码器冃父 = sf.解码场景.构造囗解码器扌(解码器名冃父)
                f = 解码器冃父.偏序比较囗分支状态扌
                def cmp_(分支状态乊左, 分支状态乊右, /, *, _cmp_=_cmp_, f=f, x2may_rcmp=x2may_rcmp):
                    return _cmp_(f, x2may_rcmp, 分支状态乊左, 分支状态乊右)
                列表纟分支状态冃父乊子讫 = sorted(分支状态冃父乊子讫讠欤子乃返回, key=cmp_to_key(cmp_))
                    #^错误囗同时裁剪冖冖讫地址乊子
                    #   <<==裁剪有歧义@讫地址乊子
            列表纟分支状态冃父乊子讫
            #父入口讠列表灬[父入口] = 列表纟分支状态冃父乊子讫
            分支状态冃父乊子讫冖最幼嫡 = 列表纟分支状态冃父乊子讫[-1]
            欤子乃返回冖最幼嫡 = 分支状态冃父乊子讫讠欤子乃返回[分支状态冃父乊子讫冖最幼嫡]
            if not 欤子乃返回冖最幼嫡:
                分支状态冃父乊子讫冖最幼嫡冖非返回 = 分支状态冃父乊子讫冖最幼嫡
                父入口讠灬[父入口] = 分支状态冃父乊子讫冖最幼嫡冖非返回
        ######################
        父入口讠分支状态冃父乊子讫讠欤子乃返回 = None
        父入口讠分支状态冃父乊子讫冖最幼嫡冖非返回
        #父入口讠列表纟分支状态冃父乊子讫
            #裁剪无歧义@讫地址乊子
        #父入口讠分支状态冃父乊子讫 = {k:ls[-1] for k,ls in 父入口讠列表纟分支状态冃父乊子讫.items()}
        父入口讠分支状态冃父乊子讫冖嫡系冖临界超限 = 父入口讠分支状态冃父乊子讫冖最幼嫡冖非返回
        ######################
        # !! 已去除 完成品，只保留 半成品乊移位
        #       <<== 『接口6裁剪统计():if 欤子乃返回:return』
        #
        讫地址乊最底层 = 讫地址乊子
        if not len(父入口讠分支状态冃父乊子讫冖嫡系冖临界超限) == 1:
            raise 错误囗同时裁剪冖冖半成品乊移位冖冖临界超限((讫地址乊最底层, 父入口讠分支状态冃父乊子讫冖嫡系冖临界超限))
        [(父入口冖冖临界超限,分支状态冃父乊子讫冖冖临界超限)] = 父入口讠分支状态冃父乊子讫冖嫡系冖临界超限.items()

        #######################
        #子入口讠分支状态冃子乊孙讫 = 父入口讠分支状态冃父乊子讫
        #######################
        #def 是有效的父调用处冃子调用处吗扌(子入口,父调用处, /):
        #    '-> 欤子调用处有效/bool'
        #    (欤子调用处有效,欤子调用处乃嫡系) = 扩展囗是有效的父调用处冃子调用处吗扌(子入口,父调用处)
        #    return 欤子调用处有效
        #def 扩展囗是有效的父调用处冃子调用处吗扌(子入口,父调用处, /, *, 父入口讠分支状态冃父乊子讫=父入口讠分支状态冃父乊子讫, 父入口讠列表纟分支状态冃父乊子讫=父入口讠列表纟分支状态冃父乊子讫):
        #    '-> (欤子调用处有效/bool, 欤子调用处乃嫡系/bool)'
        #    # [注意:输入其实是:(子入口,父调用处) := (父入口,爷调用处)]
        #    #
        #    #欤子调用处有效===父调用处 是否是 有效 子调用处#真裁剪
        #    #欤子调用处有效===父入口+分支状态 是否是 有效 子入口+分支状态#真裁剪
        #    #欤子调用处乃嫡系===是否是 长房 即 [分支状态 最大]
        #    (起地址乊父,解码器名冃父,分支状态冃父乊子起) = 父调用处
        #    父入口 = (起地址乊父,解码器名冃父)
        #    (起地址乊子,解码器名冃子) = 子入口
        #    缓存空间甲 = sf.地址讠解码器名讠缓存空间甲(起地址乊子, 解码器名冃子)
        #    父调用处讠扩展后续 = 缓存空间甲.父调用处讠扩展后续
        #    扩展后续 = 父调用处讠扩展后续[父调用处]
        #    (后续乊子,欤继承已解禁乊子起) = 扩展后续

        #    (仨变量环境乊父乊子起,_后续乊子) = 后续乊子
        #    (分支状态乊子讫,内禀输出名,外赋输出名,内禀计算器,外赋计算器) = _后续乊子
        #    ######################
        #    分支状态冃父乊子讫 = 分支状态乊子讫
        #    分支状态冃父乊子起
        #    父入口
        #    ######################
        #    ######################
        #    ######################
        #    ######################
        #    #降低一代:
        #    if 0:
        #        子调用处 = 父调用处
        #        子入口 = 父入口
        #        (欤继承已解禁乊父起,解码器冃子,鬽返回俩鬽名,欤子乃返回,欤子乃裁剪,欤子乃解禁,欤继承已解禁乊子讫,欤真裁剪) = sf._g(子入口)
        #        #欤子调用处有效 = 欤继承已解禁乊子讫
        #        #欤子调用处有效 = 欤继承已解禁乊子起
        #            #子起 not 子讫<<==解禁 本身 非 裁剪建议
        #            #now:see:裁剪所在父解码器分支吗扌()
        #        欤子调用处有效 = 欤真裁剪
        #            #即 是否裁剪@含继承
        #    ######################
        #    ######################
        #    ######################
        #    # [注意:输入其实是:(子入口,父调用处) := (父入口,爷调用处)]
        #    #
        #    (_父入口,_爷入口,_爷调用处,_分支状态冃爷乊父讫) = (子入口,父入口,父调用处,分支状态冃父乊子讫)
        #    _欤父调用处有效 = _爷入口 in 父入口讠列表纟分支状态冃父乊子讫
        #    _欤父调用处乃嫡系 = _欤父调用处有效 and (父入口讠分支状态冃父乊子讫[_爷入口] in [_分支状态冃爷乊父讫])
        #    欤子调用处有效 = _欤父调用处有效
        #    欤子调用处乃嫡系 = _欤父调用处乃嫡系
        #    TODO
        #    return (欤子调用处有效,欤子调用处乃嫡系)
        ##end-def 扩展囗是有效的父调用处冃子调用处吗扌
        #######################
        #讫地址乊最底层 = 讫地址乊子
        #子入口讠父调用处囗有效 = {}
        #子入口讠父调用处囗囗子乃嫡系 = {}
        #列表纟丮子入口丶分支状态丶父调用处囗有效囗超限临界厈 = []
        #######################
        ## !! 子入口讠分支状态冃子乊孙讫 = 父入口讠分支状态冃父乊子讫
        ##   降低一代
        #for 子入口,分支状态冃子乊孙讫 in 子入口讠分支状态冃子乊孙讫.items():
        #    (起地址乊子,解码器名冃子) = 子入口
        #    缓存空间甲 = sf.地址讠解码器名讠缓存空间甲(起地址乊子, 解码器名冃子)
        #    父调用处讠扩展后续 = 缓存空间甲.父调用处讠扩展后续
        #    #子入口 不是 主入口
        #    #   不是 主解码器
        #    #   [父调用处讠扩展后续<非 主解码器> 非空]
        #    assert 父调用处讠扩展后续
        #    if len(父调用处讠扩展后续) == 1:
        #        列表纟父调用处囗有效 = [*父调用处讠扩展后续]
        #            #有效
        #        for 父调用处,扩展后续 in 父调用处讠扩展后续.items():
        #            (欤子调用处有效,欤子调用处乃嫡系) = 扩展囗是有效的父调用处冃子调用处吗扌(子入口,父调用处)
        #            if not 欤子调用处有效:
        #                #有效&&[非 有效 子入口++分支状态]==>>超限临界,即[非 子入口]
        #                列表纟丮子入口丶分支状态丶父调用处囗有效囗超限临界厈.append((子入口,分支状态冃子乊孙讫,父调用处))
        #        列表纟父调用处囗囗子乃嫡系 = 列表纟父调用处囗有效
        #    else:
        #        列表纟父调用处囗有效 = []
        #        列表纟父调用处囗囗子乃嫡系 = []
        #        for 父调用处,扩展后续 in 父调用处讠扩展后续.items():
        #            (欤子调用处有效,欤子调用处乃嫡系) = 扩展囗是有效的父调用处冃子调用处吗扌(子入口,父调用处)
        #            if 欤子调用处有效:
        #                列表纟父调用处囗有效.append(父调用处)
        #                if 欤子调用处乃嫡系:
        #                    列表纟父调用处囗囗子乃嫡系.append(父调用处)
        #        if not len(列表纟父调用处囗有效) == 1:
        #            #裁剪有歧义@返回高层@未超限
        #            raise 错误囗同时裁剪冖冖返回高层乊未超限(子入口,分支状态冃子乊孙讫,讫地址乊最底层,列表纟父调用处囗有效)
        #    列表纟父调用处囗有效
        #    列表纟父调用处囗囗子乃嫡系
        #    assert len(列表纟父调用处囗囗子乃嫡系) <= 1
        #    assert len(列表纟父调用处囗有效) == 1
        #        #裁剪无歧义@返回高层@未超限
        #    [父调用处囗有效] = 列表纟父调用处囗有效
        #    子入口讠父调用处囗有效[子入口] = 父调用处囗有效
        #    if 列表纟父调用处囗囗子乃嫡系:
        #        [父调用处囗囗子乃嫡系] = 列表纟父调用处囗囗子乃嫡系
        #        子入口讠父调用处囗囗子乃嫡系[子入口] = 父调用处囗囗子乃嫡系
        #######################
        #子入口讠父调用处囗有效
        #列表纟丮子入口丶分支状态丶父调用处囗有效囗超限临界厈
        #######################
        #if not len(列表纟丮子入口丶分支状态丶父调用处囗有效囗超限临界厈) == 1:
        #    #裁剪有歧义@返回高层@超限临界
        #    raise 错误囗同时裁剪冖冖返回高层乊超限临界(讫地址乊最底层,列表纟丮子入口丶分支状态丶父调用处囗有效囗超限临界厈)
        #[(子入口,分支状态冃子乊孙讫,父调用处)] = 列表纟丮子入口丶分支状态丶父调用处囗有效囗超限临界厈
        #    #裁剪无歧义@返回高层@超限临界
        #父调用处
        if 1:
            父调用处乊子讫冖冖临界超限 = (*父入口冖冖临界超限,分支状态冃父乊子讫冖冖临界超限)
            父调用处冖后续 = 父调用处冖后续冖冖超限 = 父调用处乊子起冖后续冖冖超限 = 父调用处乊子讫冖冖临界超限
            起地址乊子冖后续 = 讫地址乊子#讫地址乊最底层
            ######################
            # 移位 到 下一个 子入口:
            父调用处 = 父调用处冖后续
            起地址乊子 = 起地址乊子冖后续
        ######################
        父调用处, 起地址乊子
        ######################

        起地址冖非唯一冖最小 = sf.起地址冖非唯一冖最小
        列表纟父调用处囗超限 = []
            ####第一个:as子讫:临界超限:半成品乊移位
            # 第一个:as子起冖后续:超限:半成品乊未移位
            # 第二个诸后:超限:半成品乊未移位
            #
        while 1:
            父调用处, 起地址乊子
                # 虽然第一个 是『灬乊子讫』
                # 但 只用于『if 分支状态冃子乊孙起 < 起地址冖非唯一冖最小:』影响不大
                #
                # 甚至 可以当作 下一个 子解码器 的 父调用处
                #
            if 起地址乊子 < 起地址冖非唯一冖最小:
                break
            (起地址乊父,解码器名冃父,_) = 父调用处
            列表纟父调用处囗超限.append(父调用处)
            父入口 = (起地址乊父,解码器名冃父)
            ######################
            #下一轮
            _子调用处 = 父调用处
            子入口 = 父入口
            ######################
            #新一轮
            (起地址乊子,解码器名冃子) = 子入口
            缓存空间甲 = sf.地址讠解码器名讠缓存空间甲(起地址乊子, 解码器名冃子)
            父调用处讠扩展后续 = 缓存空间甲.父调用处讠扩展后续
            列表纟父调用处 = []
            for 父调用处,扩展后续 in 父调用处讠扩展后续.items():
                (后续乊子,欤继承已解禁乊子起) = 扩展后续
                if 欤继承已解禁乊子起:
                    列表纟父调用处.append(父调用处)
            列表纟父调用处
            if not len(列表纟父调用处) == 1:
                ######################
                if not 列表纟父调用处:
                    raise 000-'[内建解码器冫主解码器 ~==~ [.欤继承已解禁=True]:(解禁+++主解码器冖用户+++裁剪+++内建伪解码器冫全局退出)]'
                    if not sf.是主入口吗(起地址乊子,解码器名冃子): raise 000
                    break
                ######################
                #裁剪有歧义@返回高层@已超限
                raise 错误囗同时裁剪冖冖返回高层乊已超限(_子调用处,讫地址乊最底层,列表纟父调用处)
            ######################
            [父调用处] = 列表纟父调用处
            #loop:
            父调用处, 起地址乊子
        ######################
        assert 列表纟父调用处囗超限
        assert 子入口讠父调用处囗有效
        起地址冖非唯一冖最小冖旧 = 起地址冖非唯一冖最小
        起地址冖非唯一冖最小 = None
        assert sf.起地址冖非唯一冖最小 is 起地址冖非唯一冖最小冖旧
        起地址冖非唯一冖最小冖新 = 讫地址乊最底层
        ######################
        #子入口讠分支状态冃子乊孙讫
        #子入口讠父调用处囗有效
        列表纟父调用处囗超限
        起地址冖非唯一冖最小冖旧
        起地址冖非唯一冖最小冖新
        ######################
        if not 起地址冖非唯一冖最小冖旧 is 起地址冖非唯一冖最小冖新:
            sf.清空缓存(起地址冖非唯一冖最小冖旧,起地址冖非唯一冖最小冖新,列表纟父调用处囗超限)
            #sf.清空缓存(起地址冖非唯一冖最小冖旧,起地址冖非唯一冖最小冖新,子入口讠分支状态冃子乊孙讫,子入口讠父调用处囗有效,列表纟父调用处囗超限)
        ######################
        assert sf.起地址冖非唯一冖最小 is 起地址冖非唯一冖最小冖新
        return
    def 清空缓存(sf, 起地址冖非唯一冖最小冖旧,起地址冖非唯一冖最小冖新,列表纟父调用处囗超限, /):
        ######################
        #assert 子入口讠分支状态冃子乊孙讫.keys() == 子入口讠父调用处囗有效.keys()
        if not 起地址冖非唯一冖最小冖旧 < 起地址冖非唯一冖最小冖新: raise 000
        讫地址乊最底层 = 起地址冖非唯一冖最小冖新
        ######################
        #保留 缓存@起地址冖非唯一冖最小冖新
        #   ==>> 列表纟父调用处囗超限[0] 可以 不管
        #   ==>> 降低一代 无所谓:
        列表纟丮子入口丶父调用处厈 = sf.列出丮子入口丶父调用处厈纟清空缓存(讫地址乊最底层,列表纟父调用处囗超限)
        列表纟丮子入口丶父调用处厈
                #一对一@超限
                #多对一@临界超限:子讫/后续
        ######################
        #确认囗所有地址变量囗大于等于扌
        #求解囗所有外赋变量扌
        for 子入口,父调用处 in 列表纟丮子入口丶父调用处厈:
            仨变量环境乊父乊子起 = sf.取囗仨变量环境乊父乊子起扌(父调用处,子入口)
            (内禀变量环境乊父乊子起,外赋变量环境乊父乊子起,局部地址变量环境乊父乊子起) = 仨变量环境乊父乊子起
            确认囗所有地址变量囗大于等于扌(讫地址乊最底层,局部地址变量环境乊父乊子起)
                #1.不完全确认: 因为 子解码器 就地展开-未移位??初始 即 未取地址,局部地址变量环境乊父乊子起 初始应为 空，那 应该 是 完全确认
                #2.乸连锁惰性值.起地址/讫地址,...# 或许应该:求值后删掉 起讫地址？
            求解囗所有外赋变量扌(外赋变量环境乊父乊子起)
        ######################
        ######################
        ######################
        起地址讠解码器名讠分支状态乊子起 = {}
        for 父调用处 in 列表纟父调用处囗超限:
            (起地址乊父,解码器名冃父,分支状态冃父乊子起) = 父调用处
            if not 分支状态冃父乊子起 is 起地址讠解码器名讠分支状态乊子起.setdefault(起地址乊父,{}).setdefault(解码器名冃父,分支状态冃父乊子起):raise 000
        assert sum(map(len, 起地址讠解码器名讠分支状态乊子起)) == len(列表纟父调用处囗超限)
        起地址讠解码器名讠分支状态乊子起
        ######################
        # [:缓存空间囗集中营]:goto
        _地址讠解码器名讠缓存空间甲 = sf._地址讠解码器名讠缓存空间甲
        for 地址 in sf.枚举地址冖左闭右开扌(起地址冖非唯一冖最小冖旧,起地址冖非唯一冖最小冖新):
            缓存空间甲.继承已解禁冖冖三态(起地址乊父, 解码器名冃父)
            TODO
        (起地址乊父,解码器名冃父,分支状态冃父乊子讫) = 父调用处乊子讫
        缓存空间乙 = sf.讫地址讠起地址讠缓存空间乙(讫地址乊子,起地址乊父)
            缓存空间甲 = sf.地址讠解码器名讠缓存空间甲(起地址乊父, 解码器名冃父)
        缓存空间甲.继承已解禁冖冖三态(起地址乊父, 解码器名冃父)
        缓存空间甲.扩展结果冃子(起地址乊子, 解码器名冃子)

        缓存空间乙.父调用处乊子讫讠欤子乃返回(讫地址乊子,起地址乊父)

        ######################
        assert sf.起地址冖非唯一冖最小 is 起地址冖非唯一冖最小冖旧 is not 起地址冖非唯一冖最小冖新
        sf.起地址冖非唯一冖最小 = 起地址冖非唯一冖最小冖新
        assert sf.起地址冖非唯一冖最小 is 起地址冖非唯一冖最小冖新 is not 起地址冖非唯一冖最小冖旧
        ######################
        return

    def 列出丮子入口丶父调用处厈纟清空缓存(sf, 讫地址乊最底层,列表纟父调用处囗超限, /):
        列表纟子调用处囗超限 = 列表纟父调用处囗超限
        列表纟丮子入口丶父调用处厈 = []
        for 子调用处,父调用处 in pairwise(列表纟子调用处囗超限):
            (起地址乊子,解码器名冃子,_) = 子调用处
            子入口 = (起地址乊子,解码器名冃子)
            列表纟丮子入口丶父调用处厈.append((子入口,父调用处))
                #一对一@超限
        列表纟丮子入口丶父调用处厈
                #已完成:一对一@超限
                #待填充:多对一@临界超限:子讫/后续
        #下面:填充:多对一
        父调用处 = 列表纟父调用处囗超限[0]
        (扩展变量环境乊子起,列表纟子入口) = sf.列出子入口扌(父调用处)
        (起地址乊子,仨变量环境乊父乊子起) = 扩展变量环境乊子起
        if not 起地址乊子 is 讫地址乊最底层:
            raise 000
        for 子入口 in 列表纟子入口:
            列表纟丮子入口丶父调用处厈.append((子入口,父调用处))
        return 列表纟丮子入口丶父调用处厈
        ######################
    def 取囗仨变量环境乊父乊子起扌(sf, 父调用处,子入口, /):
        扩展后续 = sf.取囗扩展后续扌(父调用处,子入口)
        (后续乊子,欤继承已解禁乊子起) = 扩展后续
        (仨变量环境乊父乊子起,_后续乊子) = 后续乊子
        return 仨变量环境乊父乊子起
    def 取囗扩展后续扌(sf, 父调用处,子入口, /):
        (起地址乊子,解码器名冃子) = 子入口
        缓存空间甲 = sf.地址讠解码器名讠缓存空间甲(起地址乊子, 解码器名冃子)
        父调用处讠扩展后续 = 缓存空间甲.父调用处讠扩展后续
        扩展后续 = 父调用处讠扩展后续[父调用处]
        return 扩展后续
    def 列出子入口扌(sf, 父调用处, /):
        (起地址乊父,解码器名冃父,分支状态冃父乊子起) = 父调用处
        缓存空间甲 = sf.地址讠解码器名讠缓存空间甲(起地址乊父, 解码器名冃父)
        分支状态讠扩展变量环境乊子起 = 缓存空间甲.分支状态讠扩展变量环境乊子起
        扩展变量环境乊子起 = 分支状态讠扩展变量环境乊子起[分支状态冃父乊子起]
        (起地址乊子,仨变量环境乊父乊子起) = 扩展变量环境乊子起
        #参考: def 接口4就地展开()
        解码器冃父 = sf.解码场景.构造囗解码器扌(解码器名冃父)
        子解码器名讠后续 = 解码器冃父.就地展开扌(分支状态冃父乊子起, 内禀变量环境乊父乊子起)
        列表纟子入口 = []
        for 解码器名冃子,_后续乊子 in 子解码器名讠后续.items():
            子入口 = (起地址乊子,解码器名冃子)
            列表纟子入口.append(子入口)
        return (扩展变量环境乊子起,列表纟子入口)

    def 接口7幺解码器(sf, 欤继承已解禁乊父起,起地址乊父,解码器名冃父, /):
    待办缓存形式:
        {起地址乊子:{解码器名冃子:{欤继承已解禁}/[1,2,3]}}
    #def 接口8计算暨赋值(sf, 内禀变量环境乊父乊子起, 外赋变量环境乊父乊子起, 局部地址变量环境, /):
    def 接口8计算暨赋值(sf, 仨变量环境乊父乊子起, /):
        #立即执行
        (内禀变量环境乊父乊子起,外赋变量环境乊父乊子起,局部地址变量环境乊父乊子起) = 仨变量环境乊父乊子起
接口3:初始展开#缓存待办
    (欤继承已解禁乊父起,起地址乊父,解码器名冃父)
    -->接口7:幺解码器#缓存待办
    -->
接口4:就地展开#立即执行
    (父调用处,欤继承已解禁乊子起,仨变量环境乊父乊子起,起地址乊子)
    #xxx:-->接口2:返回#缓存待办
        #改用:取囗鬽返回俩鬽名纟所在父解码器分支扌
    #xxx:-->接口9:解禁#立即执行
        #改用:解禁所在父解码器分支吗扌
    -->接口8:计算暨赋值#立即执行
    -->
接口1:调用#缓存待办
    (父调用处,后续乊子,扩展子入口)
    -->接口3:初始展开#缓存待办
    -->
接口2:返回#缓存待办
    (子入口,扩展结果冃子)
    -->
接口5:后续发展#立即执行
    (父调用处,后续乊子,讫地址乊子,结果冃子,欤继承已解禁乊子讫,鬽返回俩鬽名)
    <--接口1:调用#缓存待办
    <--接口2:返回#缓存待办#结果唯一
    -->接口6:裁剪统计#缓存待办
    -->:
        |-->接口2:返回#缓存待办
        |-->接口4:就地展开#立即执行
    ===
接口6:裁剪统计
    (父调用处乊子讫,讫地址乊子,欤真裁剪,欤子乃返回)
        #接口3:初始展开:要求:清空零解码器 之后，步进 之前:执行:接口6:裁剪统计
接口7:幺解码器
    (欤继承已解禁,起地址,解码器名乊幺)
接口8:计算暨赋值
    仨变量环境乊父乊子起
接口9:解禁
    隐式具现:见:接口5:后续发展:检测[子解码器名 is 解禁]






    def 主要循环体囗处理幺解码器扌(sf, 解码场景, 当前位置, /):
        '-> bool'
    #def 主要循环体囗处理零解码器扌(sf, 解码场景, 当前位置, /):
    def 主要循环体囗处理非幺解码器扌(sf, 解码场景, 当前位置, /):
        '-> bool'
        魊非幺解码器 = sf.弹出下一个魊非幺解码器扌(当前位置)
        if not 魊非幺解码器:
            return False
        [非幺解码器] = 魊非幺解码器
        if not 是零解码器扌(非幺解码器):
            凡解码器冃父 = 非幺解码器
            魊关联数据 = sf.取囗魊关联数据扌(当前位置, 凡解码器冃父)
            if not 魊关联数据:
                raise 000
            [关联数据] = 魊关联数据
            欤继承已解禁乊父起 = 关联数据.裁剪用数据.欤继承已解禁
            起地址乊父 = 当前位置#@初始分支状态集合
            起地址乊子 = 当前位置
            for 分支状态冃父乊子起, 变量环境 in 关联数据.等待用数据.items():
                #需得生成:(欤继承已解禁, 父调用处, 解码器名) = 待办事项
                欤本分支已解禁乊父乊子起 = 变量环境.欤本分支已解禁
                欤继承已解禁乊子起 = 欤继承已解禁乊父起 and 欤本分支已解禁乊父乊子起
                解码器名冃父 = 凡解码器冃父.取囗解码器名扌()
                父调用处 = (起地址乊父,解码器名冃父,分支状态冃父乊子起)
                内禀变量环境 = 变量环境.内禀变量环境
                子解码器名讠后续 = 子解码器名讠丮分支状态丶内禀输出名丶外赋输出名丶内禀计算器丶外赋计算器厈 = 凡解码器冃父.就地展开扌(分支状态冃父乊子起, 内禀变量环境)
                for 解码器名冃子 in 子解码器名讠后续:
                    待办事项 = (欤继承已解禁乊子起, 父调用处, 解码器名冃子)
            return . .
        零解码器 = 非幺解码器
        if type(零解码器) is 返回:
            . .
        ######################
        return True
    def 主要循环体囗处理待办事项扌(sf, 解码场景, 当前位置, /):
        '-> bool'
        魊待办事项 = sf.弹出下一个魊待办事项扌(当前位置)
        if not 魊待办事项:
            return False
        [待办事项] = 魊待办事项
        (欤继承已解禁, 父调用处, 解码器名) = 待办事项
        裁剪用数据 = 乸裁剪用数据(欤继承已解禁)
        解码器 = 解码场景.构造囗解码器扌(解码器名)
            #乸内敛语法最短句子解码器
        魊关联数据 = sf.取囗魊关联数据扌(当前位置, 解码器)
        if 魊关联数据:
            [关联数据] = 魊关联数据
            #关联数据.返回用数据[父调用处].add(裁剪用数据)
            sf.更新囗父调用处扌(当前位置, 解码器, 关联数据, 父调用处, 裁剪用数据)
            return True
        #返回用数据 = {父调用处:{裁剪用数据}}
        返回用数据 = {}
        if type(解码器) is 返回:
            . .
        初始分支状态集合 = 解码器.取囗初始分支状态集合扌()
        初始内禀变量环境 = 解码器.取囗初始内禀变量环境扌()
        ######################
        内禀变量环境 = 初始内禀变量环境
        外赋指令序列 = []
        已变现外赋变量环境 = {}#?未来值?连锁惰性值
        局部地址变量环境 = {}
        欤本分支已解禁 = False
        ######################
        变量环境 = 乸变量环境(内禀变量环境, 外赋指令序列, 已变现外赋变量环境, 局部地址变量环境, 欤本分支已解禁)
        #for 分支状态 in 初始分支状态集合:
        #    解码器.就地展开扌(分支状态, 初始内禀变量环境)
        等待用数据 = dict.fromkeys(初始分支状态集合, 变量环境)
        鬽结果 = None
        关联数据 = 乸关联数据(当前位置, 解码器, 返回用数据, 裁剪用数据, 等待用数据, 鬽结果)
        sf.放置扌(当前位置, 解码器, 关联数据)
        sf.更新囗父调用处扌(当前位置, 解码器, 关联数据, 父调用处, 裁剪用数据)
        ######################
        return True
    def 主要循环体扌(sf, 解码场景, 当前位置, /):
        '-> bool'
        #'-> (内禀结果,外赋结果)'
        #for 当前位置 in range(起地址, 讫地址+1):
        while 1:
            if sf.主要循环体囗处理待办事项扌(解码场景, 当前位置):
                continue
            if sf.主要循环体囗处理非幺解码器扌(解码场景, 当前位置):
                continue
            break
        if sf.主要循环体囗欤结束扌(解码场景, 当前位置):
            return False
        while sf.主要循环体囗处理幺解码器扌(解码场景, 当前位置):
            pass
        return False


    def 读取囗魊码元扌(sf, /):
        '-> 魊码元'
    def 识别扌(sf, /):
        '-> 外赋结果'
        当前位置 = 0
        sf.放置解码器于扌(当前位置, sf.主解码器, None)
        #for 当前位置 in range(1+len(sf.源码串)):
        while 1:
            sf.处理囗待办队列扌(当前位置)
                #就地展开:不断下沉 直至 零解码器,幺解码器
            ######################
            #零解码器
            # 注意:裁剪同时性
            #   特别注意:返回泛解码器
            if sf.处理囗零解码器扌(当前位置):continue
                # 消除 求值,断言,空串
                # 直至 全部 待办 都是 裁剪,返回
            if sf.处理囗零解码器囗返回扌(当前位置):continue
                # 消除 返回 #???返回 之后 还有 上层 返回...??逻辑有毛病！！！歧义判断 不简单！！！==>>裁剪残影
                # 直至 全部 待办 都是 裁剪
            if sf.处理囗裁剪扌(当前位置):continue
            ######################
            #裁剪残影:上面 处理 返回/裁剪 时，留下 残影 继续 前进 并不真的 发生 裁剪/求值?(部分求值 是 前进 必须的)
            sf.处理囗裁剪残影扌(当前位置)

            ######################
            ## 读取之前，检测 全局匹配欤否
            if sf.欤结束扌(当前位置): break
            魊码元 = sf.读取囗魊码元扌()
            ######################
            #幺解码器
            sf.处理囗幺解码器扌(当前位置, 魊码元)
    def 放置解码器于扌(sf, 位置, 解码器, 父解码器囗返回位置, /):
        sf.待办列表乊就地展开
        sf.位置讠相关数据
    def 处理囗幺解码器扌(sf, 位置, 魊码元, /):
        '匹配,不匹配  --> 投放 下一位置 返回泛解码器'
    def 处理囗零解码器扌(sf, 位置, /):
        '裁剪?匹配,不匹配 --> 回头 更新 父解码器 再 折返 添加 弟解码器'
    def 处理囗待办队列扌(sf, 位置, /):
        '待办队列 就地展开 直至 零解码器,幺解码器'









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































__all__


def __():
    from seed.tiny import ifNonef, ifNone, echo
    from seed.tiny import check_type_is, fst, snd, at
    from seed.tiny_.check import check_uint_lt, check_int_ge_lt, check_int_ge, check_int_ge_le
    from seed.tiny import print_err, mk_fprint, mk_assert_eq_f, expectError
    from seed.func_tools.fmapT.fmapT__tiny import dot, fmapT__dict, fmapT__list, fmapT__iter
    from seed.helper.repr_input import repr_helper

def __():
    from seed.abc.abc__ver1 import abstractmethod, override, ABC, ABC__no_slots
    from seed.helper.repr_input import repr_helper
    class _(ABC):
        __slots__ = ()
        raise NotImplementedError
        ___no_slots_ok___ = True
        def __repr__(sf, /):
            #return repr_helper(sf, *args, **kwargs)
            #return repr_helper_ex(sf, args, ordered_attrs, kwargs, ordered_attrs_only=False)
            ...
if __name__ == "__main__":
    pass
__all__


from seed.recognize.toy.poor_efficiency_toy_recognizer import *
