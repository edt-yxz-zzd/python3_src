#__all__:goto
r'''[[[
e ../../python3_src/seed/recognize/toy/simple_recognizer_/expr_generator__2nd.py

seed.recognize.toy.simple_recognizer_.expr_generator__2nd
py -m seed.recognize.toy.simple_recognizer_.expr_generator__2nd
py -m nn_ns.app.debug_cmd   seed.recognize.toy.simple_recognizer_.expr_generator__2nd -x
py -m nn_ns.app.doctest_cmd seed.recognize.toy.simple_recognizer_.expr_generator__2nd:__doc__
py_adhoc_call   seed.recognize.toy.simple_recognizer_.expr_generator__2nd   @生成冫展符讠表达式纟解码器纟子语言纟圁訄乙版扌  '="; A = b[:3] ;."'  +欤调试中



#]]]'''
__all__ = r'''
魖匴后处理纟圁訄乙版
    乸匴后处理纟圁訄乙版冫解码为表达式
        匴后处理纟圁訄乙版冫解码为表达式
匴圁訄乙版右递归句法语言匕圁訄甲版右递归句法语言
解码器纟圁訄乙版右递归句法语言巛欤调试中扌
    解码器纟圁訄乙版右递归句法语言冖冖调试模式
    解码器纟圁訄乙版右递归句法语言冖冖正常模式
生成冫展符讠表达式纟解码器纟子语言纟圁訄乙版扌



死式
拆包扌
构造冫变果式扌
构造冫尾限式扌
'''.split()#'''
__all__

from seed.recognize.toy.simple_recognizer_._common import abstractmethod, override, ABC
from seed.recognize.toy.simple_recognizer_.syntax_tree_base import 魖泛变换纟句法树

class 魖匴后处理纟圁訄乙版(ABC):
    #后处理纟解码扌
    #后处理纟树变换扌
    #后处理纟泛变换扌
    '用作:匞参数配置'
    __slots__ = ()
    def 冃基符(sf, 句法树, x, /):
        '-> 泛变换结果纟句法树'
        return x
    '空白,函数名,基符名,展符名,字符串常量,整数'
    _nms = ['串联表达式', '互斥表达式', '优选表达式', '允空数', '兼顾表达式', '前瞻符', '前缀符', '前缀符序列', '前缀表达式', '原子表达式', '反转符', '变换乊左侧', '变换冫变果式', '变换序列乊左侧', '句法书', '后缀表达式', '基符', '定义符', '定义行', '定义行冖无首', '尾限', '尾限暨变换乊右侧', '尾限符', '展符', '常量表达式', '忽略符', '拆包符', '括号表达式', '数目纟拆包符', '数量范围', '行首', '表达式', '重复表达式', '锁定表达式']
        # '允空表达式', '空表达式',
    if 0:
        魖泛变换纟句法树#goto
        def 后处理纟泛变换扌(sf, 句法树, 泛变换结果纟句法树容器, /):
            '-> 泛变换结果纟句法树'

    # :s/\([^,]\+\),/\r    @abstractmethod\r    def \1(sf, 句法树, 泛变换结果纟句法树容器, \/):\r        '-> 泛变换结果纟句法树'\r/g

    @abstractmethod
    def 空白 (sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    @abstractmethod
    def 函数名 (sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    @abstractmethod
    def 基符名 (sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    @abstractmethod
    def 展符名 (sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    @abstractmethod
    def 字符串常量 (sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    @abstractmethod
    def 基符 (sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    @abstractmethod
    def 展符 (sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    @abstractmethod
    def 整数 (sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    空白,函数名,基符名,展符名,字符串常量,基符,展符,整数,

    @abstractmethod
    def 串联表达式(sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    @abstractmethod
    def 互斥表达式(sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    @abstractmethod
    def 优选表达式(sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    @abstractmethod
    def 允空数(sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    @abstractmethod
    def 兼顾表达式(sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    #@abstractmethod
    #def 允空表达式(sf, 句法树, 泛变换结果纟句法树容器, /):
    #    '-> 泛变换结果纟句法树'

    @abstractmethod
    def 前瞻符(sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    @abstractmethod
    def 前缀符(sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    @abstractmethod
    def 前缀符序列(sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    @abstractmethod
    def 前缀表达式(sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    @abstractmethod
    def 原子表达式(sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    @abstractmethod
    def 反转符(sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    @abstractmethod
    def 变换乊左侧(sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    @abstractmethod
    def 变换冫变果式(sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    @abstractmethod
    def 变换序列乊左侧(sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    @abstractmethod
    def 句法书(sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    @abstractmethod
    def 后缀表达式(sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    @abstractmethod
    def 定义符(sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    @abstractmethod
    def 定义行(sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    @abstractmethod
    def 定义行冖无首(sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    @abstractmethod
    def 尾限(sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    @abstractmethod
    def 尾限暨变换乊右侧(sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    @abstractmethod
    def 尾限符(sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    @abstractmethod
    def 常量表达式(sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    @abstractmethod
    def 忽略符(sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    @abstractmethod
    def 拆包符(sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    @abstractmethod
    def 括号表达式(sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    @abstractmethod
    def 数目纟拆包符(sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    @abstractmethod
    def 数量范围(sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    #@abstractmethod
    #def 空表达式(sf, 句法树, 泛变换结果纟句法树容器, /):
    #    '-> 泛变换结果纟句法树'

    @abstractmethod
    def 行首(sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    @abstractmethod
    def 表达式(sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    @abstractmethod
    def 重复表达式(sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    @abstractmethod
    def 锁定表达式(sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'

    串联表达式,互斥表达式,优选表达式,允空数,兼顾表达式,前瞻符,前缀符,前缀符序列,前缀表达式,原子表达式,反转符,变换乊左侧,变换冫变果式,变换序列乊左侧,句法书,后缀表达式,定义符,定义行,定义行冖无首,尾限,尾限暨变换乊右侧,尾限符,常量表达式,忽略符,拆包符,括号表达式,数目纟拆包符,数量范围,行首,表达式,重复表达式,锁定表达式,
        #,允空表达式,空表达式
    assert {*_nms} < locals().keys(), {*_nms} - locals().keys()

#end-class 魖匴后处理纟圁訄乙版(ABC):
######################
from seed.recognize.toy.simple_recognizer_.expr import 具名式,串联式,首选式,锁隙式,独尊式,前瞻式,反转式,忽略式,兼顾式,变果式,重复式,尾限式
from seed.recognize.toy.simple_recognizer_.expr import 定长式,码集式,常量式,失败式,成功式,空式,引用式
from seed.recognize.toy.simple_recognizer_.basic import 乸具名引用变量
from seed.recognize.toy.simple_recognizer_.basic import 变换器冫取原文片段
from seed.recognize.toy.simple_recognizer_.context import 构造冫全文暨起讫讫扌
from seed.tiny_.dict__add_fmap_filter import dict_add__new
from seed.recognize.toy.simple_recognizer_._common import _4repr
from seed.recognize.toy.simple_recognizer_.basic import the_one_


def may5tmay_(tmay, /):
    if tmay:
        [i] = tmay
        return i
    return None



死式 = 具名式('死', None, 失败式(None))
class 乸匴后处理纟圁訄乙版冫解码为表达式(_4repr, 魖匴后处理纟圁訄乙版):
    '泛变换结果纟句法树===魖辅助表达式 #少量例外:允空数...'
    __slots__ = ()
    if 0:
        ___no_slots_ok___ = True
        def __init__(sf, 场景, /):
            sf.__1 = 场景
        @property
        def 场景(sf, /):
            '-> 场景'
            return sf.__1
    @override
    def 空白 (sf, 句法树, 泛变换结果纟句法树容器, /):
        '-> 泛变换结果纟句法树'
        return

    @override
    def 函数名 (sf, 句法树, nm4f, /):
        '-> 泛变换结果纟句法树'
        #print(nm4f)
        return 乸具名引用变量(nm4f, None, 1, nm4f)
        return 乸具名引用变量(None, None, 1, nm4f)

    @override
    def 基符名 (sf, 句法树, nm, /):
        '-> 泛变换结果纟句法树'
        return nm

    @override
    def 展符名 (sf, 句法树, nm, /):
        '-> 泛变换结果纟句法树'
        return nm

    @override
    def 字符串常量 (sf, 句法树, s, /):
        '-> 泛变换结果纟句法树'
        return s

    @override
    def 基符 (sf, 句法树, nm, /):
        '-> 泛变换结果纟句法树'
        return 引用式(True, nm)

    @override
    def 展符 (sf, 句法树, nm, /):
        '-> 泛变换结果纟句法树'
        return 引用式(True, nm)

    @override
    def 整数 (sf, 句法树, n, /):
        '-> 泛变换结果纟句法树'
        return n

    @override
    def 串联表达式(sf, 句法树, es, /):
        '-> 泛变换结果纟句法树'
        if len(es) >= 2:
            return 串联式(*es)
        if es:
            return es[0]
        return 空式

    @override
    def 互斥表达式(sf, 句法树, es, /):
        '-> 泛变换结果纟句法树'
        if len(es) >= 2:
            return 独尊式(*es)
        if es:
            return es[0]
        return 死式

    @override
    def 优选表达式(sf, 句法树, es, /):
        '-> 泛变换结果纟句法树'
        if len(es) >= 2:
            return 首选式(*es)
        if es:
            return es[0]
        return 死式

    @override
    def 允空数(sf, 句法树, tmay_n, /):
        '-> 泛变换结果纟句法树'
        return may5tmay_(tmay_n)

    @override
    def 兼顾表达式(sf, 句法树, es, /):
        '-> 泛变换结果纟句法树'
        if len(es) >= 2:
            return 兼顾式(*es)
        if es:
            return es[0]
        return 死式

    #@abstractmethod
    #def 允空表达式(sf, 句法树, 泛变换结果纟句法树容器, /):
    #    '-> 泛变换结果纟句法树'

    @override
    def 前瞻符(sf, 句法树, _, /):
        '-> 泛变换结果纟句法树'
        return 前瞻式

    @override
    def 前缀符(sf, 句法树, 式扌, /):
        '-> 泛变换结果纟句法树'
        return 式扌

    @override
    def 前缀符序列(sf, 句法树, Ts, /):
        '-> 泛变换结果纟句法树'
        return Ts

    @override
    def 前缀表达式(sf, 句法树, Ts_e, /):
        '-> 泛变换结果纟句法树'
        Ts, e = 前缀符序列, 后缀表达式 = Ts_e
        for T in reversed(Ts):
            e = T(e)
        return e

    @override
    def 原子表达式(sf, 句法树, e, /):
        '-> 泛变换结果纟句法树'
        return e

    @override
    def 反转符(sf, 句法树, _, /):
        '-> 泛变换结果纟句法树'
        return 反转式

    @override
    def 变换乊左侧(sf, 句法树, x, /):
        '-> 泛变换结果纟句法树'
        return x

    @override
    def 变换冫变果式(sf, 句法树, nm4f, /):
        '-> 泛变换结果纟句法树'
        return nm4f

    @override
    def 变换序列乊左侧(sf, 句法树, nm4f_n_pairs, /):
        '-> 泛变换结果纟句法树'
        return nm4f_n_pairs

    @override
    def 句法书(sf, 句法树, es, /):
        '-> 泛变换结果纟句法树'
        d = {}
        for 行冃具名式 in es:
            展符名 = 行冃具名式.鬽名纟解码器
            dict_add__new(d, 展符名, 行冃具名式)
        return d

    @override
    def 后缀表达式(sf, 句法树, e_ts, /):
        '-> 泛变换结果纟句法树'
        e, ts = 重复表达式, 列表纟变换暨尾限 = e_ts
        for t in ts:
            T = type(t)
            assert T is list
            x,y = t
            if type(x) is int:
                n, te = 尾限 = t
                e  = 构造冫尾限式扌(e, n, te)
            elif type(x) is 乸具名引用变量 and type(y) is int:
                nm4f, 数目纟拆包符 = 变换乊左侧 = t
                e = 构造冫变果式扌(e, nm4f, 数目纟拆包符)
            else:
                raise 000
        return e

    @override
    def 定义符(sf, 句法树, _, /):
        '-> 泛变换结果纟句法树'
        return

    @override
    def 定义行(sf, 句法树, e, /):
        '-> 泛变换结果纟句法树'
        return e

    @override
    def 定义行冖无首(sf, 句法树, xs, /):
        '-> 泛变换结果纟句法树'
        前缀符序列, 展符名, 数目纟拆包符, 变换序列乊左侧, e = xs
        e = 拆包扌(e, 数目纟拆包符)
        for 变换乊左侧 in 变换序列乊左侧:
            nm4f, 数目纟拆包符 = 变换乊左侧
            e = 构造冫变果式扌(e, nm4f, 数目纟拆包符)
        for 式扌 in 前缀符序列:
            e = 式扌(e)
        return 具名式(None, 展符名, e)

    @override
    def 尾限(sf, 句法树, n_e, /):
        '-> 泛变换结果纟句法树'
        return n_e

    @override
    def 尾限暨变换乊右侧(sf, 句法树, x, /):
        '-> 泛变换结果纟句法树'
        return x

    @override
    def 尾限符(sf, 句法树, n, /):
        '-> 泛变换结果纟句法树'
        return n

    @override
    def 常量表达式(sf, 句法树, s, /):
        '-> 泛变换结果纟句法树'
        return 常量式(s)

    @override
    def 忽略符(sf, 句法树, _, /):
        '-> 泛变换结果纟句法树'
        return 忽略式

    @override
    def 拆包符(sf, 句法树, _, /):
        '-> 泛变换结果纟句法树'
        return

    @override
    def 括号表达式(sf, 句法树, tmay_e, /):
        '-> 泛变换结果纟句法树'
        return tmay_e[0] if tmay_e else 空式

    @override
    def 数目纟拆包符(sf, 句法树, n, /):
        '-> 泛变换结果纟句法树'
        return n

    @override
    def 数量范围(sf, 句法树, mns, /):
        '-> 泛变换结果纟句法树'
        if len(mns) == 1:
            [i] = mns
            return i
        mi, mj = mns
        return slice(mi,mj,None)

    #@abstractmethod
    #def 空表达式(sf, 句法树, 泛变换结果纟句法树容器, /):
    #    '-> 泛变换结果纟句法树'

    @override
    def 行首(sf, 句法树, _, /):
        '-> 泛变换结果纟句法树'
        return

    @override
    def 表达式(sf, 句法树, e, /):
        '-> 泛变换结果纟句法树'
        return e

    @override
    def 重复表达式(sf, 句法树, e_n_ks, /):
        '-> 泛变换结果纟句法树'
        e,n,ks = 原子表达式,数目纟拆包符,列表纟数量范围 = e_n_ks
        e = 拆包扌(e, 数目纟拆包符)
        for k in ks:
            # [k :: int|slice]
            e = e[k]
        return e

    @override
    def 锁定表达式(sf, 句法树, es, /):
        '-> 泛变换结果纟句法树'
        if len(es) >= 2:
            return 锁隙式(*es)
        if es:
            return es[0]
            if 0:
                #bug:
                #实心锁定
                return 锁隙式(*es,空式)%the_one_
        return 空式
def 拆包扌(表达式, 数目纟拆包符, /):
    for _ in range(数目纟拆包符):
        表达式 %= the_one_
    return 表达式
def 构造冫变果式扌(表达式, f, 数目纟拆包符, /):
    return 拆包扌(表达式%f, 数目纟拆包符)
def 构造冫尾限式扌(e, n, te, /):
    if n == 1:
        e /= te
    elif n == 2:
        e //= te
    else:
        raise 000
    return e
#end-class 乸匴后处理纟圁訄乙版冫解码为表达式(_4repr, 魖匴后处理纟圁訄乙版):
匴后处理纟圁訄乙版冫解码为表达式 = 乸匴后处理纟圁訄乙版冫解码为表达式()





######################
######################
######################
######################
'copy from: ./grammar.py'
######################
######################
from seed.recognize.toy.simple_recognizer_.basic import at, 构造冫具名函数扌# 乸具名函数
from seed.recognize.toy.simple_recognizer_.basic import 数字表,标识体字集,标识首字集,空白字集
from ast import literal_eval
def _add_(x_y, /):
    x, y = x_y
    return x+y
con4str_ = _add_
def con_(x_xs, /):
    try:
        x, xs = x_xs
        return (x, *xs)
    except ValueError as e:
        raise ValueError(len(x_xs), x_xs) from e

#fst = at[0]
snd = at[1]
mk_int = 构造冫具名函数扌('int', int)




class 匴圁訄乙版右递归句法语言匕圁訄甲版右递归句法语言:
    'copy from: ./grammar.py'
    ######################
    ######################
    ######################
    # [:命名规范冫句法分析]:goto
    # 圁訄甲版右递归句法语言=>:
    # 圁訄乙版右递归句法语言
    #句法文本
    (冊句法纟乙匕甲 :=
    (冊句法文本纟乙版匕甲版 :=
    (冊句法文本纟圁訄乙版匕圁訄甲版 :=
    (冊句法文本纟圁訄乙版右递归句法语言匕圁訄甲版右递归句法语言 :=
    r'''
#『>>the_one_』-->『!』
#『>>f』-->左侧『%f』
#『常量式』-->已无需
# 行首 插入『;』
# 多个:兼顾表达式
#
# len,con_
#
#; 空白 = `丶空白
#; 函数名 = `丶函数名
#; 展符名 = `丶展符名
#; 基符名 = `丶基符名
#; 字符串常量 = `丶字符串常量
#; 整数 = `丶整数
######################
; 基符 = 基符名
; 展符 = 展符名
; -定义符 = -('=') + -空白
; -行首 = -(';') + -空白
; 变换冫变果式! = -('%') + -空白 + 函数名
; 拆包符! = '!' + -空白
; 数目纟拆包符%len%冃基符扌 = 拆包符[:]
; 变换乊左侧 = 变换冫变果式 + 数目纟拆包符
; 变换序列乊左侧 = 变换乊左侧[:]
; 常量表达式 = 字符串常量
#; 空表达式 = ()
#; 允空表达式 = 表达式 | 空表达式
#; 括号表达式! = -('(') + -空白 + 允空表达式 + -(')') + -空白
; 括号表达式! = -('(') + -空白 + 表达式[:1] + -(')') + -空白
; 原子表达式 = 基符 | 展符 | 常量表达式 | 括号表达式
#; 允空数 %may5tmay_ = 整数[:1]
; 允空数 = 整数[:1]
; 数量范围 %con_ = -('[') + -空白 + -+~(']') + 允空数 + (-(':') + -空白 + 允空数)![:1] + -(']') + -空白
; 重复表达式 = 原子表达式 + 数目纟拆包符 + 数量范围[:]
; 尾限符!%len%冃基符扌 = ('/')[1:2] + -空白
; 尾限 = 尾限符 + 重复表达式
; 尾限暨变换乊右侧 = 变换乊左侧 | 尾限
; 后缀表达式 = 重复表达式 + 尾限暨变换乊右侧[:]
; 前瞻符 = -('+') + -空白
; 反转符 = -('~') + -空白
; 忽略符 = -('-') + -空白
; 前缀符 = 前瞻符 | 反转符 | 忽略符
; 前缀符序列 = 前缀符[:]
; 前缀表达式 = 前缀符序列 + 后缀表达式
; 串联表达式 %con_ = 前缀表达式 + (-('+') + -空白 + 前缀表达式)![:]
; 锁定表达式 %con_ = 串联表达式 + (-('>>') + -空白 + 串联表达式)![:1]
; 兼顾表达式 %con_ = 锁定表达式 + (-('&') + -空白 + 锁定表达式)![:]
; 优选表达式 %con_ = 兼顾表达式 + (-('|') + -空白 + 兼顾表达式)![:]
; 互斥表达式 %con_ = 优选表达式 + (-('^') + -空白 + 优选表达式)![:]
; 表达式 = 互斥表达式
; 定义行冖无首 = 前缀符序列 + 展符名 + 数目纟拆包符 + 变换序列乊左侧 + -定义符 + 表达式
; 定义行! = 定义行冖无首 + -行首[1:]
; 句法书! = -空白 + -行首[1:] + 定义行//'.'
;.

'''#'''
    ))))
    def 构造冫展符讠表达式纟解码器纟圁訄乙版扌():
        'copy from: ./grammar.py'
        冃基符扌 = 乸具名引用变量('冃基符扌', None, 1, '冃基符扌')
        len = 乸具名引用变量('len', None, 1, 'len')
        con_ = 乸具名引用变量('con_', None, 1, 'con_')
        return \
{'基符': 具名式(None, '基符', 引用式(True, '基符名'))
,'展符': 具名式(None, '展符', 引用式(True, '展符名'))
,'定义符': 具名式(None, '定义符', 忽略式(串联式(忽略式(常量式('=')), 忽略式(引用式(True, '空白')))))
,'行首': 具名式(None, '行首', 忽略式(串联式(忽略式(常量式(';')), 忽略式(引用式(True, '空白')))))
,'变换冫变果式': 具名式(None, '变换冫变果式', 变果式(the_one_, 串联式(忽略式(常量式('%')), 忽略式(引用式(True, '空白')), 引用式(True, '函数名'))))
,'拆包符': 具名式(None, '拆包符', 变果式(the_one_, 串联式(常量式('!'), 忽略式(引用式(True, '空白')))))
,'数目纟拆包符': 具名式(None, '数目纟拆包符', 变果式(冃基符扌, 变果式(len, 重复式(0, None, 引用式(True, '拆包符')))))
,'变换乊左侧': 具名式(None, '变换乊左侧', 串联式(引用式(True, '变换冫变果式'), 引用式(True, '数目纟拆包符')))
,'变换序列乊左侧': 具名式(None, '变换序列乊左侧', 重复式(0, None, 引用式(True, '变换乊左侧')))
,'常量表达式': 具名式(None, '常量表达式', 引用式(True, '字符串常量'))
,'括号表达式': 具名式(None, '括号表达式', 变果式(the_one_, 串联式(忽略式(常量式('(')), 忽略式(引用式(True, '空白')), 重复式(0, 1, 引用式(True, '表达式')), 忽略式(常量式(')')), 忽略式(引用式(True, '空白')))))
,'原子表达式': 具名式(None, '原子表达式', 首选式(引用式(True, '基符'), 引用式(True, '展符'), 引用式(True, '常量表达式'), 引用式(True, '括号表达式')))
,'允空数': 具名式(None, '允空数', 重复式(0, 1, 引用式(True, '整数')))
,'数量范围': 具名式(None, '数量范围', 变果式(con_, 串联式(忽略式(常量式('[')), 忽略式(引用式(True, '空白')), 忽略式(前瞻式(反转式(常量式(']')))), 引用式(True, '允空数'), 重复式(0, 1, 变果式(the_one_, 串联式(忽略式(常量式(':')), 忽略式(引用式(True, '空白')), 引用式(True, '允空数')))), 忽略式(常量式(']')), 忽略式(引用式(True, '空白')))))
,'重复表达式': 具名式(None, '重复表达式', 串联式(引用式(True, '原子表达式'), 引用式(True, '数目纟拆包符'), 重复式(0, None, 引用式(True, '数量范围'))))
,'尾限符': 具名式(None, '尾限符', 变果式(冃基符扌, 变果式(len, 变果式(the_one_, 串联式(重复式(1, 2, 常量式('/')), 忽略式(引用式(True, '空白')))))))
,'尾限': 具名式(None, '尾限', 串联式(引用式(True, '尾限符'), 引用式(True, '重复表达式')))
,'尾限暨变换乊右侧': 具名式(None, '尾限暨变换乊右侧', 首选式(引用式(True, '变换乊左侧'), 引用式(True, '尾限')))
,'后缀表达式': 具名式(None, '后缀表达式', 串联式(引用式(True, '重复表达式'), 重复式(0, None, 引用式(True, '尾限暨变换乊右侧'))))
,'前瞻符': 具名式(None, '前瞻符', 串联式(忽略式(常量式('+')), 忽略式(引用式(True, '空白'))))
,'反转符': 具名式(None, '反转符', 串联式(忽略式(常量式('~')), 忽略式(引用式(True, '空白'))))
,'忽略符': 具名式(None, '忽略符', 串联式(忽略式(常量式('-')), 忽略式(引用式(True, '空白'))))
,'前缀符': 具名式(None, '前缀符', 首选式(引用式(True, '前瞻符'), 引用式(True, '反转符'), 引用式(True, '忽略符')))
,'前缀符序列': 具名式(None, '前缀符序列', 重复式(0, None, 引用式(True, '前缀符')))
,'前缀表达式': 具名式(None, '前缀表达式', 串联式(引用式(True, '前缀符序列'), 引用式(True, '后缀表达式')))
,'串联表达式': 具名式(None, '串联表达式', 变果式(con_, 串联式(引用式(True, '前缀表达式'), 重复式(0, None, 变果式(the_one_, 串联式(忽略式(常量式('+')), 忽略式(引用式(True, '空白')), 引用式(True, '前缀表达式')))))))
,'锁定表达式': 具名式(None, '锁定表达式', 变果式(con_, 串联式(引用式(True, '串联表达式'), 重复式(0, 1, 变果式(the_one_, 串联式(忽略式(常量式('>>')), 忽略式(引用式(True, '空白')), 引用式(True, '串联表达式')))))))
,'兼顾表达式': 具名式(None, '兼顾表达式', 变果式(con_, 串联式(引用式(True, '锁定表达式'), 重复式(0, None, 变果式(the_one_, 串联式(忽略式(常量式('&')), 忽略式(引用式(True, '空白')), 引用式(True, '锁定表达式')))))))
,'优选表达式': 具名式(None, '优选表达式', 变果式(con_, 串联式(引用式(True, '兼顾表达式'), 重复式(0, None, 变果式(the_one_, 串联式(忽略式(常量式('|')), 忽略式(引用式(True, '空白')), 引用式(True, '兼顾表达式')))))))
,'互斥表达式': 具名式(None, '互斥表达式', 变果式(con_, 串联式(引用式(True, '优选表达式'), 重复式(0, None, 变果式(the_one_, 串联式(忽略式(常量式('^')), 忽略式(引用式(True, '空白')), 引用式(True, '优选表达式')))))))
,'表达式': 具名式(None, '表达式', 引用式(True, '互斥表达式'))
,'定义行冖无首': 具名式(None, '定义行冖无首', 串联式(引用式(True, '前缀符序列'), 引用式(True, '展符名'), 引用式(True, '数目纟拆包符'), 引用式(True, '变换序列乊左侧'), 忽略式(引用式(True, '定义符')), 引用式(True, '表达式')))
,'定义行': 具名式(None, '定义行', 变果式(the_one_, 串联式(引用式(True, '定义行冖无首'), 忽略式(重复式(1, None, 引用式(True, '行首'))))))
,'句法书': 具名式(None, '句法书', 变果式(the_one_, 串联式(忽略式(引用式(True, '空白')), 忽略式(重复式(1, None, 引用式(True, '行首'))), 尾限式(True, 常量式('.'), 引用式(True, '定义行')))))
}

    展符讠表达式纟解码器纟圁訄乙版 = 构造冫展符讠表达式纟解码器纟圁訄乙版扌()
    del 构造冫展符讠表达式纟解码器纟圁訄乙版扌


    空白字集式 = 码集式(空白字集)
    空白 = -(-空白字集式[1:] | -常量式('#') + 定长式(1)//常量式('\n'))[:]
    标识首字集式 = 码集式(标识首字集)
    标识体字集式 = 码集式(标识体字集)
    标识冖无尾随空白 = 标识首字集式 + 标识体字集式[:]%''.join >>con4str_
    标识 = 标识冖无尾随空白 + -空白 >>the_one_

    数字集式 = 码集式(数字表)
    整数冖无尾随空白 = 数字集式[1:]%''.join
    整数 = 整数冖无尾随空白 + -空白 >>the_one_ >> mk_int

    元素纟字符串常量冖无尾随空白 = -(常量式("\\")[:1] + 定长式(1))
    跳过纟双引号纟字符串常量冖无尾随空白 = -常量式('"') + -(元素纟字符串常量冖无尾随空白) // 常量式('"')
    跳过纟单引号纟字符串常量冖无尾随空白 = -常量式("'") + -(元素纟字符串常量冖无尾随空白) // 常量式("'")
    跳过纟字符串常量冖含原貌冖无尾随空白 = -常量式('r')[:1] + (跳过纟单引号纟字符串常量冖无尾随空白 | 跳过纟双引号纟字符串常量冖无尾随空白)
    文本纟字符串常量冖含原貌冖无尾随空白 = 跳过纟字符串常量冖含原貌冖无尾随空白 >> 变换器冫取原文片段
    字符串常量冖部分 = 文本纟字符串常量冖含原貌冖无尾随空白 + -空白 >>the_one_ >>literal_eval
    字符串常量 = 字符串常量冖部分[1:] >>''.join

    码集式('`丶灬罒艹冖凵囿槑魅')
    基符首字集式 = 码集式('`')
    基符名 = -基符首字集式 >> 标识 >>the_one_
    展符名 = +标识首字集式 + +~基符首字集式 >> 标识 >>snd
    函数名 = 标识


#end-class 匴圁訄乙版右递归句法语言匕圁訄甲版右递归句法语言:
匴圁訄乙版右递归句法语言匕圁訄甲版右递归句法语言 = 匴圁訄乙版右递归句法语言匕圁訄甲版右递归句法语言()

def _宽解码冃辅助表达式巛冊句法文本扌(解码器, 冊句法文本, /):
    from seed.recognize.toy.simple_recognizer_.context import 乸具名全文冖冖记录讫地址
    全文 = 乸具名全文冖冖记录讫地址('冊句法文本', None, 冊句法文本, 0)
    全文暨起讫讫 = 构造冫全文暨起讫讫扌(全文, 0, None, None)
    #bug:return 全文.讫地址纟已访问, 解码器.宽解码扌(全文暨起讫讫)
    #   !! 取 讫地址 时，尚未解码
    r = 解码器.宽解码扌(全文暨起讫讫)
    讫地址纟已访问纟全文 = 全文.讫地址纟已访问
    return 讫地址纟已访问纟全文, r

def __(*, 欤调试中):
    ######################
    匴 = 匴圁訄乙版右递归句法语言匕圁訄甲版右递归句法语言
    d = 匴.展符讠表达式纟解码器纟圁訄乙版
    #表达式冫句法书 = d['句法书']
    nms = sorted(d)
        #1/2=>魖匴后处理纟圁訄乙版:goto
    assert nms == ['串联表达式', '互斥表达式', '优选表达式', '允空数', '兼顾表达式', '前瞻符', '前缀符', '前缀符序列', '前缀表达式', '原子表达式', '反转符', '变换乊左侧', '变换冫变果式', '变换序列乊左侧', '句法书', '后缀表达式', '基符', '定义符', '定义行', '定义行冖无首', '尾限', '尾限暨变换乊右侧', '尾限符', '展符', '常量表达式', '忽略符', '拆包符', '括号表达式', '数目纟拆包符', '数量范围', '行首', '表达式', '重复表达式', '锁定表达式'], nms
        # '允空表达式', '空表达式',
    ######################

    ######################
    from seed.recognize.toy.simple_recognizer_.syntax_tree_base import 乸句法树纟基符,乸句法树纟展符
    from seed.recognize.toy.simple_recognizer_.basic import 构造冫具名函数扌
    from seed.recognize.toy.simple_recognizer_.scene import 构造冫解码场景扌
    from seed.tiny import curry1
    def 冃基符扌(果, /):
        return 基符名凵变换结果扌('冃基符', 果)
    冃基符扌 = 构造冫具名函数扌(..., 冃基符扌)
    def 基符名凵变换结果扌(基符名, 果, /):
        return 乸句法树纟基符(基符名, 果)
    def 展符名凵变换结果扌(展符名, 果, /):
        return 乸句法树纟展符(展符名, 果)
    def 名凵变换结果扌(名, 果, /):
        return (名, 果)
    def 预处理器纟构造冫具名解码器(场景, 名, 解码器名, /):
        #解码器 = 场景.变换结果解码器扌(None, curry1(名凵变换结果扌,名), 解码器名)
        #return 场景.包装灬扌(乊起始扌:=curry1(名凵乊起始扌,名), 乊锁定扌:=None, 乊失败扌:=None, 乊匹配扌:=None, 乊结束扌:=curry1(名凵乊结束扌,名), 解码器, 鬽名=None)
        return 场景.变换结果解码器扌(None, curry1(名凵变换结果扌,名), 解码器名)
    ######################
    ######################
    场景 = 构造冫解码场景扌(鬽名='场景')
    场景.欤调试纟构造冫具名解码器 = 欤调试中

    ######################
    ######################
    场景.欤自动注册冫具名解码器 = True
    场景.欤自动变换结果冫具名解码器 = True
    ######################
    #自动注册:
    #   !! 现在 基符名不是『丶空白』而是相同的『空白』，或者说 没有 基符，全都是 展符！
    #但避免自动预处理:因为 基符 之下 还有 一些更基本的变果操作，不适合 自动返回树节点
    名凵变换结果扌 = 基符名凵变换结果扌
    for nm in '空白,函数名,基符名,展符名,字符串常量,整数'.split(','):
        #1/2=>魖匴后处理纟圁訄乙版:goto
        基符名 = nm
        表达式纟基符 = getattr(匴, 基符名) >> curry1(名凵变换结果扌,基符名)
        场景.注册冫解码器名纟公用扌(解码器名纟基符:=基符名, 表达式纟基符(场景))
    ######################
    名凵变换结果扌 = 展符名凵变换结果扌
    场景.预处理器纟构造冫具名解码器 = 预处理器纟构造冫具名解码器
    ######################
    #注册:函数:
    for nm4f in 'len,con_,冃基符扌'.split(','):
        场景.注册冫变量名纟公用扌(nm4f, eval(nm4f))
    ######################
    #自动注册:展符:解码器:
    for 表达式 in d.values():
        表达式(场景)
    解码器纟句法书 = 场景.构造冫解码器巛名扌('句法书')
    if 欤调试中:
        return (解码器纟圁訄乙版右递归句法语言:=解码器纟句法书)
    #assert 0, (场景.罓注册处纟解码器, 场景.罓注册处纟变量)
    #assert 0, 场景.罓注册处纟解码器
    #assert 0, 场景.罓注册处纟变量
    a,r = _宽解码冃辅助表达式巛冊句法文本扌(解码器纟句法书, 冊句法文本:=';A=b;.')
    #assert 0, (a,r)
    assert ((a,r) ==
        (6, (6, True, ('句法书', [('定义行', ('定义行冖无首', [('前缀符序列', []), ('展符名', 'A'), ('数目纟拆包符', ('冃基符', 0)), ('变换序列乊左侧', []), ('表达式', ('互斥表达式', (('优选表达式', (('兼顾表达式', (('锁定表达式', (('串联表达式', (('前缀表达式', [('前缀符序列', []), ('后缀表达式', [('重复表达式', [('原子表达式', ('展符', ('展符名', 'b'))), ('数目纟拆包符', ('冃基符', 0)), []]), []])]),)),)),)),)),)))]))])))
    ), (a,r)
    ######################
    assert type(r[2]) is 乸句法树纟展符
    句法树 = r[2]
    展符讠表达式纟解码器纟子语言 = 句法树.解码扌(匞参数配置纟解码:=匴后处理纟圁訄乙版冫解码为表达式)
    assert (展符讠表达式纟解码器纟子语言==
        #old:{'A': 具名式(None, 'A', 变果式(the_one_, 锁隙式(引用式(True, 'b'), 空式)))}
        {'A': 具名式(None, 'A', 引用式(True, 'b'))}
        ), 展符讠表达式纟解码器纟子语言
    ######################
    ######################
    a,r = _宽解码冃辅助表达式巛冊句法文本扌(解码器纟句法书, 匴.冊句法纟乙匕甲)
    assert r[1], (a, r)
    #assert 0, r[2]
    句法树 = r[2]
    nm2e = 展符讠表达式纟解码器纟圁訄乙版 = 句法树.解码扌(匞参数配置纟解码:=匴后处理纟圁訄乙版冫解码为表达式)
    from seed.mapping_tools.dict_op import mapping_symmetric_diff4patch__immutable__default
    assert nm2e == d, mapping_symmetric_diff4patch__immutable__default(nm2e, d)
    ######################
    ######################
    return (解码器纟圁訄乙版右递归句法语言:=解码器纟句法书)
    ######################
    ######################

解码器纟圁訄乙版右递归句法语言冖冖调试模式 = __(欤调试中=True)
解码器纟圁訄乙版右递归句法语言冖冖正常模式 = __(欤调试中=False)
def 解码器纟圁訄乙版右递归句法语言巛欤调试中扌(欤调试中, /):
    if 欤调试中:
        return 解码器纟圁訄乙版右递归句法语言冖冖调试模式
    else:
        return 解码器纟圁訄乙版右递归句法语言冖冖正常模式
def 生成冫展符讠表达式纟解码器纟子语言纟圁訄乙版扌(冊句法纟子语言匕圁訄乙版, /, *, 欤调试中=False):
    '-> (讫地址纟已访问纟全文, 讫错果, 鬽 展符讠表达式纟解码器纟子语言纟圁訄乙版)'
    if 0b000:
        #无效！因为 构造解码器时已绑定
        场景 = 解码器纟圁訄乙版右递归句法语言.场景
        场景.欤调试纟构造冫具名解码器 = 欤调试中
    解码器纟圁訄乙版右递归句法语言 = 解码器纟圁訄乙版右递归句法语言巛欤调试中扌(欤调试中)
    ######################
    try:
        a,r = _宽解码冃辅助表达式巛冊句法文本扌(解码器纟圁訄乙版右递归句法语言, 冊句法纟子语言匕圁訄乙版)
    finally:
        if 0b000:
            #无效！因为 构造解码器时已绑定
            场景.欤调试纟构造冫具名解码器 = False
    ######################
    #
    讫地址纟已访问纟全文 = a
    (讫地址乊严, 错误丷结果, 错误丨结果) = 讫错果 = r
    if 错误丷结果:
        句法树纟子语言 = 结果 = 错误丨结果
        m = 展符讠表达式纟解码器纟子语言纟圁訄乙版 = 句法树纟子语言.解码扌(匞参数配置纟解码:=匴后处理纟圁訄乙版冫解码为表达式)
    else:
        m = None
    return (讫地址纟已访问纟全文, 讫错果, 鬽冖展符讠表达式纟解码器纟子语言纟圁訄乙版:=m)
    return a,r,m

assert (_arm:=生成冫展符讠表达式纟解码器纟子语言纟圁訄乙版扌(';A=()&`b!>>h ^g[2:3];.'))[::2] == (
    (22, {'A': 具名式(None, 'A', 独尊式(兼顾式(空式, 锁隙式(变果式(the_one_, 引用式(True, 'b')), 引用式(True, 'h'))), 重复式(2, 3, 引用式(True, 'g'))))})
    ), _arm
__all__
from seed.recognize.toy.simple_recognizer_.expr_generator__2nd import 生成冫展符讠表达式纟解码器纟子语言纟圁訄乙版扌
from seed.recognize.toy.simple_recognizer_.expr_generator__2nd import 解码器纟圁訄乙版右递归句法语言巛欤调试中扌
from seed.recognize.toy.simple_recognizer_.expr_generator__2nd import 匴后处理纟圁訄乙版冫解码为表达式
from seed.recognize.toy.simple_recognizer_.expr_generator__2nd import *


