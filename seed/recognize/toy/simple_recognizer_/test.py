#__all__:goto
r'''[[[

seed.recognize.toy.simple_recognizer_.test
py -m nn_ns.app.doctest_cmd seed.recognize.toy.simple_recognizer_.test:__doc__
py -m nn_ns.app.doctest_cmd seed.recognize.toy.simple_recognizer_.test!


py -m nn_ns.app.doctest_cmd seed.recognize.toy.simple_recognizer_.test:test4context__no_op
py -m nn_ns.app.doctest_cmd seed.recognize.toy.simple_recognizer_.test:test4context__has_op

#]]]'''
__all__ = r'''
'''.split()#'''
__all__
#TODO:新类型测试+更新流程
#    乸具名引用变量
######################
######################
######################
#别的并不特别需要:共计6步骤:
#   ######################
#   ######################
#   1. 构建 表达式(eg:常量式,引用式)/.整理扌 #at,构造冫具名函数扌,乸具名函数,乸具名码集
#   2. 构建 场景:构造冫解码场景扌(鬽名=...)
#   3. 注册 变量 以使用 乸具名引用变量:注册冫变量名纟公用扌,注册冫变量名纟私用扌#取冫变量值扌#乸私用空间,乸具名私用空间,乸私钥,乸具名私钥
#       注册冫变换结果函数纟具名解码器扌,取冫变换结果函数纟具名解码器扌#具名扌
#   4. 构建 解码器:表达式(场景),场景.引用扌/.具名扌/.包装扌
#       具名式/.具名扌:设定:场景.欤自动注册冫具名解码器/.欤自动变换结果冫具名解码器#公钥纟欤自动注册冫具名解码器,公钥纟欤自动变换结果冫具名解码器,注册冫变量名纟公用扌
#   5. 注册 解码器 以使用 引用式:注册冫解码器名纟公用扌,注册冫解码器名纟私用扌#构造冫解码器巛名扌(场景,解码器名)
#   6. 构建 全文暨起讫讫:构造冫全文暨起讫讫扌, 乸具名全文, 构造冫具名全文暨起讫讫扌,乸具名全文冖冖记录讫地址
#   7. 解码:解码器.宽解码扌(全文暨起讫讫)/.严解码乊容错扌/.严解码乊不容错扌
#   ######################
#   ######################
# 构造 表达式:
from seed.recognize.toy.simple_recognizer_.expr import 定长式,码集式,常量式,失败式,成功式,空式,引用式
from seed.recognize.toy.simple_recognizer_.basic import at,构造冫具名函数扌,乸具名函数,乸具名码集
from seed.recognize.toy.simple_recognizer_.basic import 乸具名引用变量,乸两段式篡改器,惑构造冫讫错果变换器扌,变换器冫取原文片段#乸讫错果变换器
from seed.recognize.toy.simple_recognizer_.basic import 惑构造冫结果变换器扌#乸错果变换器,乸结果变换器,

# 构造 场景:
from seed.recognize.toy.simple_recognizer_.scene import 魖解码场景, 乸解码场景, 构造冫解码场景扌

# 注册 变量:
#   特别是:乸具名引用变量.变量名
#   命名规范:变量名『变量冫某某』;;连锁引用:变量名<乸具名引用变量>『引用冫某某』
from seed.recognize.toy.simple_recognizer_.scene import 具名扌,注册冫变换结果函数纟具名解码器扌,取冫变换结果函数纟具名解码器扌
from seed.recognize.toy.simple_recognizer_.scene import 取冫变量值扌,注册冫变量名纟公用扌,注册冫变量名纟私用扌
from seed.recognize.toy.simple_recognizer_.scene import 乸私用空间,乸具名私用空间,乸私钥,乸具名私钥

# 构造 解码器 并 注册:
from seed.recognize.toy.simple_recognizer_.scene import 构造冫解码器巛名扌,注册冫解码器名纟公用扌,注册冫解码器名纟私用扌

# 构造 输入纟解码:
from seed.recognize.toy.simple_recognizer_.context import 构造冫全文暨起讫讫扌, 乸具名全文, 构造冫具名全文暨起讫讫扌,乸具名全文冖冖记录讫地址
# 最后:解码 并 检查: 解码器.宽解码扌
from seed.recognize.toy.simple_recognizer_.basic import 检查冫讫错果扌,检查冫讫错果冖扩展扌
######################
######################
######################

from seed.recognize.toy.simple_recognizer_._common import echo
echo = 乸具名函数('echo', echo)
    #不能用 构造冫具名函数扌
    #   !! lambda


__all__
class test4expr__no_op:
    r'''[[[
,定长式
,码集式
,常量式
,失败式
,成功式
,空式
,引用式

>>> 空式
空式
>>> 引用式(False, 'x')
引用式(False, 'x')
>>> 码集式('abc')
码集式('abc')
>>> 常量式('ggg')
常量式('ggg')
>>> 成功式(999)
成功式(999)
>>> 失败式(999)
失败式(999)
>>> 定长式(999)
定长式(999)

def 构造冫解码场景扌(cls=None, /, *, 鬽名=None, 用户数据纟场景固化=None, 鬽构造冫解码器纟并联扌=None, 鬽名丨注册处纟解码器=None, 鬽名丨注册处纟变量=None, 鬽乸具名注册处=None):
#>>> 场景 = 乸解码场景(鬽名, 用户数据纟场景固化, 鬽构造冫解码器纟并联扌, 公用区, 私用区)
#>>> 场景 = 构造冫解码场景扌(鬽名=...)

>>> 构造冫解码场景扌() #doctest: +ELLIPSIS
乸解码场景(None, None, None, 乸具名注册处(None, {}, <WeakValueDictionary at 0x...>), 乸具名注册处(None, {}, <WeakValueDictionary at 0x...>))
>>> 构造冫解码场景扌(鬽名丨注册处纟解码器='注册处纟解码器', 鬽名丨注册处纟变量='注册处纟变量')
乸解码场景(None, None, None, 注册处纟解码器, 注册处纟变量)
>>> 场景 = 构造冫解码场景扌(鬽名='场景')
>>> 场景
场景
>>> 空式(场景)
空
>>> 码集式('abc')(场景)
乸码元集合匹配解码器(场景, 'abc')
>>> 常量式('ggg')(场景)
乸码元串常量匹配解码器(场景, 'ggg')
>>> 成功式(999)(场景)
乸恒果零解码器(场景, 999)
>>> 失败式(999)(场景)
乸失败零解码器(场景, 999)
>>> 定长式(999)(场景)
乸码元串定长读取解码器(场景, 999)


    欤已注册冫解码器名扌
    注册冫解码器名纟公用扌
>>> 引用式(True, 'x')(场景)
乸引用解码器(场景, 'x')
>>> 引用式(False, 'x')(场景)
Traceback (most recent call last):
    ...
LookupError: x
>>> 场景.欤已注册冫解码器名扌('x')
False
>>> 场景.注册冫解码器名纟公用扌('x', 空式)
Traceback (most recent call last):
    ...
TypeError: <class 'seed.recognize.toy.simple_recognizer_.expr._空式'>
>>> 场景.注册冫解码器名纟公用扌('x', 空式(场景))
>>> 场景.注册冫解码器名纟公用扌('x', 空式(场景))
Traceback (most recent call last):
    ...
seed.recognize.toy.simple_recognizer_.error.注册异常冖冖已注册: x
>>> 场景.欤已注册冫解码器名扌('x')
True
>>> 引用式(False, 'x')(场景)
空

    #]]]'''#'''
class test4expr__has_op:
    r'''[[[
,忽略式#-
,反转式#~
,前瞻式#+
,串联式#+
,锁元式#(+)>>(may int)
,保底兼顾式#(&)>>(may int)
,后充式#>>...
,具名式#>>name:name/str
,锁隙式#>>expr
,首选式#|
,独尊式#^
,兼顾式#&
,变果式#% #>>f #>>at[?]
,尾限式#/,//
,重复式#[]


>>> at
at
>>> at[999]
at[999]
>>> at[999:]
at[999:]
>>> at[:999]
at[:999]
>>> at[666:999]
at[666:999]
>>> at[:]
at[:]
>>> at[999::]
at[999:]
>>> at[:999:]
at[:999]
>>> at[666:999:]
at[666:999]
>>> at[::]
at[:]
>>> at[999::111]
at[999::111]
>>> at[:999:111]
at[:999:111]
>>> at[666:999:111]
at[666:999:111]
>>> at[::111]
at[::111]
>>> at[999:, 111]
at[999:, 111]
>>> at[999:, :111]
at[999:, :111]
>>> at[:, :]
at[:, :]

>>> at[1, :]('abc')
('b', 'a', 'b', 'c')
>>> at[:,]('abc')
('a', 'b', 'c')
>>> at[:]('abc')
'abc'
>>> at[1]('abc')
'b'




>>> 空式>>'x'
x
>>> x = 空式>>'x'
>>> y = 空式>>'y'
>>> -x
忽略式(x)
>>> ~x
反转式(x)
>>> +x
前瞻式(x)
>>> x+y
串联式(x, y)
>>> x+y >> 0
锁元式(0, 串联式(x, y))
>>> x+y >> None
锁元式(None, 串联式(x, y))
>>> 空式>>0
Traceback (most recent call last):
    ...
TypeError: <class 'seed.recognize.toy.simple_recognizer_.expr._空式'>
>>> 空式>>None
Traceback (most recent call last):
    ...
TypeError: <class 'seed.recognize.toy.simple_recognizer_.expr._空式'>

>>> (x&y) >> None
保底兼顾式(None, 兼顾式(x, y))
>>> (x&y) >> 1
保底兼顾式(1, 兼顾式(x, y))
>>> x>>...
后充式(x)
>>> 空式>>'x'
x
>>> 空式>>'a:x'
a
>>> 空式>>':x'
具名式(None, 'x', 空式)
>>> 空式>>'a:'
a
>>> 空式>>':'
具名式(None, None, 空式)
>>> x+y >>'w'
w
>>> str(x+y >>'w')
'w'
>>> x+y >>':w'
具名式(None, 'w', 串联式(x, y))
>>> str(x+y >>':w')
"具名式(None, 'w', (x + y))"
>>> x>>y
锁隙式(x, y)
>>> x|y
首选式(x, y)
>>> x^y
独尊式(x, y)
>>> x&y
兼顾式(x, y)
>>> x>>echo
变果式(echo, x)
>>> x>>at[0]
变果式(at[0], x)
>>> x>>at[:]
变果式(at[:], x)
>>> x%echo
变果式(echo, x)
>>> x%(echo,echo)
变果式((echo, echo), x)
>>> x/y #参数序列:先尾再元素
尾限式(False, y, x)
>>> x//y
尾限式(True, y, x)
>>> x[3]
重复式(3, 3, x)
>>> x[:3]
重复式(0, 3, x)
>>> x[3:]
重复式(3, None, x)
>>> x[3:5]
重复式(3, 5, x)
>>> x[3:3]
重复式(3, 3, x)

>>> 场景 = 构造冫解码场景扌(鬽名='场景')
>>> (-x)(场景)
乸收集时忽略结果解码器(场景, x)
>>> (~x)(场景)
乸逆转成败解码器(场景, x)
>>> (+x)(场景)
乸前瞻零解码器(场景, x)
>>> (x+y)(场景)
乸串联解码器(场景, [x, y])
>>> (x+y >> 0)(场景)
乸元素锁定串联解码器(场景, 0, [x, y])
>>> (x+y >> None)(场景)
乸元素锁定串联解码器(场景, None, [x, y])
>>> (x&y >> 1)(场景)
Traceback (most recent call last):
    ...
TypeError: <class 'seed.recognize.toy.simple_recognizer_.expr.具名式'>
>>> ((x&y) >> 1)(场景)
乸定域解码器(场景, False, 1, [x, y])
>>> ((x&y) >> None)(场景)
乸定域解码器(场景, False, 2, [x, y])
>>> (x>>...)(场景)
乸直达终点解码器(场景, x)
>>> (空式>>'x')(场景)
x
>>> (空式>>'a:x')(场景)
x
>>> (空式>>':x')(场景)
x
>>> (空式>>'a:')(场景)
空
>>> (空式>>':')(场景)
空
>>> (x>>y)(场景) #???
乸间隙锁定串联解码器(场景, 1, (x, y))
>>> (y+x>>y)(场景) #???
乸间隙锁定串联解码器(场景, 1, (乸串联解码器(场景, [y, x]), y))
>>> (x>>y+x)(场景) #???
乸间隙锁定串联解码器(场景, 1, (x, 乸串联解码器(场景, [y, x])))
>>> (x+y>>y+x)(场景) #???
乸间隙锁定串联解码器(场景, 1, (乸串联解码器(场景, [x, y]), 乸串联解码器(场景, [y, x])))
>>> (x|y)(场景)
乸优先并联解码器(场景, None, None, (x, y))
>>> (x^y)(场景)
乸互斥并联解码器(场景, None, None, (x, y))
>>> (x&y)(场景)
乸定域解码器(场景, False, 0, (x, y))
>>> (x%echo)(场景) #old:乸变换讫错果解码器(场景, 乸结果变换器(None, echo), x)
乸变换结果解码器(场景, None, echo, x)


>>> (x%(echo,echo))(场景)
乸变换结果解码器(场景, echo, echo, x)
>>> (x/y)(场景) #参数序列:先尾再元素
乸结尾限长序列解码器(场景, None, False, y, x)
>>> (x//y)(场景)
乸结尾限长序列解码器(场景, None, True, y, x)
>>> (x[3])(场景)
乸序列解码器(场景, 3, 3, x)
>>> (x[:3])(场景)
乸序列解码器(场景, 0, 3, x)
>>> (x[3:])(场景)
乸序列解码器(场景, 3, None, x)
>>> (x[3:5])(场景)
乸序列解码器(场景, 3, 5, x)
>>> (x[3:3])(场景)
乸序列解码器(场景, 3, 3, x)



>>> (x+y+x+y+y)(场景)
乸串联解码器(场景, [x, y, x, y, y])
>>> (x>>y>>y>>y)(场景)
乸间隙锁定串联解码器(场景, 1, (x, 乸串联解码器(场景, [y, y, y])))
>>> (x|y|x|y|y)(场景)
乸优先并联解码器(场景, None, None, (x, y, x, y, y))
>>> (x^y^x^y^y)(场景)
乸互斥并联解码器(场景, None, None, (x, y, x, y, y))
>>> (x&y&x&y&y)(场景)
乸定域解码器(场景, False, 0, (x, y, x, y, y))

>>> (x+-y+x+y+y)(场景)
乸串联解码器(场景, [x, 乸收集时忽略结果解码器(场景, y), x, y, y])
>>> (x&-y&x&y&y)(场景)
乸定域解码器(场景, False, 0, (x, 乸收集时忽略结果解码器(场景, y), x, y, y))



>>> (x+y+y)
串联式(串联式(x, y), y)
>>> str(x+y+y)
'((x + y) + y)'
>>> str((x+y+y).整理扌())
'(x + y + y)'
>>> (x|y|y)
首选式(首选式(x, y), y)
>>> str(x|y|y)
'((x | y) | y)'
>>> str((x|y|y).整理扌())
'(x | y | y)'
>>> (x^y^y)
独尊式(独尊式(x, y), y)
>>> str(x^y^y)
'((x ^ y) ^ y)'
>>> str((x^y^y).整理扌())
'(x ^ y ^ y)'
>>> (x&y&y)
兼顾式(兼顾式(x, y), y)
>>> str(x&y&y)
'((x & y) & y)'
>>> str((x&y&y).整理扌())
'(x & y & y)'

    #]]]'''#'''
class test4context__special:
    r'''[[[

>>> 场景 = 构造冫解码场景扌(鬽名='场景')
>>> 全文暨起讫讫 = 构造冫全文暨起讫讫扌('0123456789', 1, None, None)
>>> 全文暨起讫讫
乸全文暨起讫讫(乸全文暨讫讫('0123456789', 10, 10), 1)
>>> str(全文暨起讫讫)
"构造冫全文暨起讫讫扌('0123456789', 1, 10, 10)"
>>> x = 定长式(1)
>>> y = 定长式(2)
>>> z = 定长式(3)
>>> w = 常量式('4')
>>> s = 码集式('1234')
>>> (x+-y+z)(场景).宽解码扌(全文暨起讫讫)
(7, True, ['1', '456'])
>>> (x&-x&x)(场景).宽解码扌(全文暨起讫讫)
(2, True, ['1', '1'])
>>> (x&-y&x)(场景).宽解码扌(全文暨起讫讫)
(2, False, None)
>>> (x&w)(场景).宽解码扌(全文暨起讫讫)
(2, False, None)
>>> (w&x)(场景).宽解码扌(全文暨起讫讫)
(2, False, None)
>>> (w&x)(场景).宽解码扌(全文暨起讫讫<<4)
(5, True, [None, '4'])

>>> (x|y)(场景).宽解码扌(全文暨起讫讫)
(2, True, '1')
>>> (x^y)(场景).宽解码扌(全文暨起讫讫)
Traceback (most recent call last):
    ...
seed.recognize.toy.simple_recognizer_.error.解码异常冖冖互斥并联冖冖多锁定: [0, 1]
>>> (w^y)(场景).宽解码扌(全文暨起讫讫)
(3, True, '12')

锁定:锁元式，锁隙式
锁隙式:
>>> (w >> x ^ y >> z)(场景).宽解码扌(全文暨起讫讫)
(6, True, ['12', '345'])
>>> (x >> w ^ y >> w)(场景).宽解码扌(全文暨起讫讫)
Traceback (most recent call last):
    ...
seed.recognize.toy.simple_recognizer_.error.解码异常冖冖互斥并联冖冖多锁定: [0, 1]
>>> (x >> w)(场景).宽解码扌(全文暨起讫讫)
(3, False, None)
>>> (y >> w)(场景).宽解码扌(全文暨起讫讫)
(4, False, None)
>>> (x + w ^ y + w)(场景).宽解码扌(全文暨起讫讫)
Traceback (most recent call last):
    ...
seed.recognize.toy.simple_recognizer_.error.解码异常冖冖互斥并联冖冖多锁定: [0, 1]

锁元式:
>>> (x + w >> None ^ y + w >> None)(场景).宽解码扌(全文暨起讫讫)
(4, False, None)
>>> (x + w >> 0 ^ y + w >> 0)(场景).宽解码扌(全文暨起讫讫)
Traceback (most recent call last):
    ...
seed.recognize.toy.simple_recognizer_.error.解码异常冖冖互斥并联冖冖多锁定: [0, 1]
>>> (x + w >> 0 ^ y + w >> 1)(场景).宽解码扌(全文暨起讫讫)
(3, False, None)
>>> (x + w >> 0 ^ y >> w)(场景).宽解码扌(全文暨起讫讫)
Traceback (most recent call last):
    ...
seed.recognize.toy.simple_recognizer_.error.解码异常冖冖互斥并联冖冖多锁定: [0, 1]


>>> (w >> x | x >> y)(场景).宽解码扌(全文暨起讫讫)
(4, True, ['1', '23'])
>>> (x >> w | x >> y)(场景).宽解码扌(全文暨起讫讫)
(3, False, None)
>>> (w >> x ^ x >> y)(场景).宽解码扌(全文暨起讫讫)
(4, True, ['1', '23'])
>>> (x >> y ^ w >> y)(场景).宽解码扌(全文暨起讫讫)
(4, True, ['1', '23'])
>>> (w >> y ^ w >> y)(场景).宽解码扌(全文暨起讫讫)
(2, False, None)


保底兼顾式
>>> ((x&w) >> None)(场景).宽解码扌(全文暨起讫讫)
(2, False, None)
>>> ((x&x) >> None)(场景).宽解码扌(全文暨起讫讫)
(2, True, ['1', '1'])
>>> ((x&x) >> 1)(场景).宽解码扌(全文暨起讫讫)
(2, True, ['1', '1'])
>>> ((x&w) >> None | y)(场景).宽解码扌(全文暨起讫讫)
(3, True, '12')
>>> ((x&w) >> 1 | y)(场景).宽解码扌(全文暨起讫讫)
(3, True, '12')
>>> ((x&w) >> 0 | y)(场景).宽解码扌(全文暨起讫讫)
(2, False, None)




>>> (x / w)(场景).宽解码扌(全文暨起讫讫)
(5, True, ['1', '2', '3', None])
>>> (x // w)(场景).宽解码扌(全文暨起讫讫)
(5, True, ['1', '2', '3'])
>>> (x // w % ''.join)(场景).宽解码扌(全文暨起讫讫)
(5, True, '123')
>>> (x // w % ''.join)(场景).严解码乊容错扌(全文暨起讫讫)
Traceback (most recent call last):
    ...
seed.recognize.toy.simple_recognizer_.error.解码失败冖冖宽严讫地址不同: (10, 5)
>>> (x // w % ''.join)(场景).严解码乊不容错扌(全文暨起讫讫)
Traceback (most recent call last):
    ...
seed.recognize.toy.simple_recognizer_.error.解码失败冖冖宽严讫地址不同: (10, 5)
>>> (x // w % ''.join >>...)(场景).严解码乊容错扌(全文暨起讫讫)
(True, '123')
>>> (x // w % ''.join >>...)(场景).严解码乊不容错扌(全文暨起讫讫)
'123'
>>> w(场景).严解码乊容错扌(全文暨起讫讫)
(False, (2, None))
>>> w(场景).严解码乊不容错扌(全文暨起讫讫)
Traceback (most recent call last):
    ...
seed.recognize.toy.simple_recognizer_.error.解码失败冖冖不匹配: (乸码元串常量匹配解码器(场景, '4'), 1, 2, None)


>>> s[2:6](场景).宽解码扌(全文暨起讫讫)
(5, True, ['1', '2', '3', '4'])


    #]]]'''#'''
class test4context__ref_AND_register:
    r'''[[[

>>> 场景 = 构造冫解码场景扌(鬽名='场景')
>>> 全文暨起讫讫 = 构造冫全文暨起讫讫扌('0123456789', 1, None, None)
>>> x = 定长式(1)
>>> y = 定长式(2)

引用式
>>> 场景.注册冫解码器名纟公用扌('aaa', x(场景))
>>> 引用式(False, 'aaa')(场景)
乸码元串定长读取解码器(场景, 1)
>>> 引用式(True, 'aaa')(场景)
乸引用解码器(场景, 'aaa')
>>> 引用式(True, 'aaa')(场景).宽解码扌(全文暨起讫讫)
(2, True, '1')
>>> 引用式(False, 'aaa')(场景).宽解码扌(全文暨起讫讫)
(2, True, '1')
>>> 私钥 = object()
>>> 场景.注册冫解码器名纟私用扌(私钥, {}) #doctest: +ELLIPSIS
Traceback (most recent call last):
    ...
KeyError: <object object at 0x...>
>>> 场景.注册冫解码器名纟私用扌(私钥, {私钥:y})
Traceback (most recent call last):
    ...
TypeError: <class 'seed.recognize.toy.simple_recognizer_.expr.定长式'>
>>> 场景.注册冫解码器名纟私用扌(私钥, {私钥:y(场景)})
Traceback (most recent call last):
    ...
TypeError: cannot create weak reference to 'dict' object
>>> 私用空间 = 乸私用空间({私钥:y(场景)})
>>> 场景.注册冫解码器名纟私用扌(私钥, 私用空间)
>>> 引用式(False, 私钥)(场景)
乸码元串定长读取解码器(场景, 2)
>>> 引用式(False, 私钥)(场景).宽解码扌(全文暨起讫讫)
(3, True, '12')
>>> 引用式(True, 私钥)(场景) #doctest: +ELLIPSIS
乸引用解码器(场景, <object object at 0x...>)
>>> 引用式(True, 私钥)(场景).宽解码扌(全文暨起讫讫)
(3, True, '12')
>>> 场景.注册冫解码器名纟私用扌(私钥, {}) #doctest: +ELLIPSIS
Traceback (most recent call last):
    ...
KeyError: <object object at 0x...>
>>> 场景.注册冫解码器名纟私用扌(私钥, {私钥:444}) #doctest: +ELLIPSIS
Traceback (most recent call last):
    ...
TypeError: <class 'int'>
>>> 场景.注册冫解码器名纟私用扌(私钥, {私钥:x(场景)}) #doctest: +ELLIPSIS
Traceback (most recent call last):
    ...
seed.recognize.toy.simple_recognizer_.error.注册异常冖冖已注册: <object object at 0x...>
>>> 场景.注册冫解码器名纟私用扌('私钥', 私用空间)
Traceback (most recent call last):
    ...
KeyError: '私钥'
>>> 私用空间['私钥'] = 444
>>> 场景.注册冫解码器名纟私用扌('私钥', 私用空间)
Traceback (most recent call last):
    ...
TypeError: <class 'int'>
>>> 私用空间['私钥'] = 私用空间[私钥]
>>> 场景.注册冫解码器名纟私用扌('私钥', 私用空间)
Traceback (most recent call last):
    ...
TypeError: not le_AddrAsHash(<class 'str'>)

>>> 具名私钥 = 乸具名私钥('kkk')
>>> 具名私用空间 = 乸具名私用空间('ddd')
>>> 具名私钥
kkk
>>> 具名私用空间
ddd
>>> repr(具名私钥)
'kkk'
>>> str(具名私钥)
'kkk'
>>> ascii(具名私钥)
'kkk'
>>> 场景.注册冫解码器名纟私用扌(具名私钥, 具名私用空间)
Traceback (most recent call last):
    ...
KeyError: kkk
>>> 具名私用空间[具名私钥] = y(场景)
>>> 场景.注册冫解码器名纟私用扌(具名私钥, 具名私用空间)
>>> 场景.注册冫解码器名纟私用扌(具名私钥, 具名私用空间)
Traceback (most recent call last):
    ...
seed.recognize.toy.simple_recognizer_.error.注册异常冖冖已注册: kkk


    #]]]'''#'''
class test4context__decode__no_op:
    r'''[[[

>>> 场景 = 构造冫解码场景扌(鬽名='场景')
>>> 全文暨起讫讫 = 构造冫全文暨起讫讫扌('0123456789', 1, None, None)

>>> 引用式(False, 'x') #see:test4context__ref_AND_register
引用式(False, 'x')
>>> 码集式('abc')
码集式('abc')
>>> 常量式('ggg') #see:test4context__special
常量式('ggg')
>>> 定长式(999) #see:test4context__special
定长式(999)
>>> 成功式(999)
成功式(999)
>>> 失败式(999)
失败式(999)
>>> 空式
空式

>>> 空式(场景).宽解码扌(全文暨起讫讫)
(1, True, None)
>>> 成功式(999)(场景).宽解码扌(全文暨起讫讫)
(1, True, 999)
>>> 失败式(999)(场景).宽解码扌(全文暨起讫讫)
(1, False, 999)

>>> 定长式(999)(场景).宽解码扌(全文暨起讫讫)
(10, False, None)
>>> 定长式(10)(场景).宽解码扌(全文暨起讫讫)
(10, False, None)
>>> 定长式(9)(场景).宽解码扌(全文暨起讫讫)
(10, True, '123456789')

>>> 常量式('123456789')(场景).宽解码扌(全文暨起讫讫)
(10, True, None)
>>> 常量式('1234567890')(场景).宽解码扌(全文暨起讫讫)
(10, False, None)


>>> 码集式('abc')(场景).宽解码扌(全文暨起讫讫)
(2, False, ('1',))
>>> 码集式('012abc')(场景).宽解码扌(全文暨起讫讫)
(2, True, '1')
>>> 码集式('012abc')(场景).宽解码扌(全文暨起讫讫.限制步进扌(2))
(2, True, '1')
>>> 码集式('012abc')(场景).宽解码扌(全文暨起讫讫.限制步进扌(1))
(1, False, ())


>>> 乸具名码集(None, '012')
乸具名码集(None, '012')
>>> 乸具名码集('s', '012')
s
>>> s = 乸具名码集('s', '012')
>>> 码集式(s)(场景).宽解码扌(全文暨起讫讫)
(2, True, '1')
>>> s = 乸具名码集('s', lambda k:k in '012')
>>> 码集式(s)(场景).宽解码扌(全文暨起讫讫)
(2, True, '1')



    #]]]'''#'''
class test4context__decode__has_op:
    r'''[[[

>>> 场景 = 构造冫解码场景扌(鬽名='场景')
>>> 全文暨起讫讫 = 构造冫全文暨起讫讫扌('0123456789', 1, None, None)
>>> x = 定长式(1)
>>> y = 定长式(2)


>>> (-x)(场景).宽解码扌(全文暨起讫讫) #see:test4context__special
(2, True, None)
>>> (~x)(场景).宽解码扌(全文暨起讫讫)
(2, False, '1')
>>> (+x)(场景).宽解码扌(全文暨起讫讫)
(1, True, (2, True, '1'))
>>> (x+y)(场景).宽解码扌(全文暨起讫讫)
(4, True, ['1', '23'])
>>> (x+y >> 0)(场景).宽解码扌(全文暨起讫讫) #see:test4context__special
(4, True, ['1', '23'])
>>> (x+y >> None)(场景).宽解码扌(全文暨起讫讫) #see:test4context__special
(4, True, ['1', '23'])
>>> ((x&x) >> None)(场景).宽解码扌(全文暨起讫讫) #see:test4context__special
(2, True, ['1', '1'])
>>> ((x&x) >> 1)(场景).宽解码扌(全文暨起讫讫)
(2, True, ['1', '1'])
>>> ((x&y) >> None)(场景).宽解码扌(全文暨起讫讫)
(2, False, None)
>>> ((x&y) >> 1)(场景).宽解码扌(全文暨起讫讫)
(2, False, None)
>>> (x>>...)(场景).宽解码扌(全文暨起讫讫)
(10, True, '1')
>>> (空式>>'x')(场景).宽解码扌(全文暨起讫讫)
(1, True, None)
>>> (空式>>'a:x')(场景).宽解码扌(全文暨起讫讫)
(1, True, None)
>>> (空式>>':x')(场景).宽解码扌(全文暨起讫讫)
(1, True, None)
>>> (空式>>'a:')(场景).宽解码扌(全文暨起讫讫)
(1, True, None)
>>> (空式>>':')(场景).宽解码扌(全文暨起讫讫)
(1, True, None)
>>> (x>>y)(场景).宽解码扌(全文暨起讫讫) #see:test4context__special
(4, True, ['1', '23'])
>>> (y+x>>y)(场景).宽解码扌(全文暨起讫讫)
(6, True, [['12', '3'], '45'])
>>> (x>>y+x)(场景).宽解码扌(全文暨起讫讫)
(5, True, ['1', ['23', '4']])
>>> (x+y>>y+x)(场景).宽解码扌(全文暨起讫讫)
(7, True, [['1', '23'], ['45', '6']])
>>> (x|y)(场景).宽解码扌(全文暨起讫讫)
(2, True, '1')
>>> (x^y)(场景).宽解码扌(全文暨起讫讫) #see:test4context__special
Traceback (most recent call last):
    ...
seed.recognize.toy.simple_recognizer_.error.解码异常冖冖互斥并联冖冖多锁定: [0, 1]
>>> (x&y)(场景).宽解码扌(全文暨起讫讫)
(2, False, None)
>>> (x%echo)(场景).宽解码扌(全文暨起讫讫)
(2, True, '1')
>>> (x%(echo,echo))(场景).宽解码扌(全文暨起讫讫)
(2, True, '1')
>>> (x%repr)(场景).宽解码扌(全文暨起讫讫)
(2, True, "'1'")
>>> (x/y)(场景).宽解码扌(全文暨起讫讫) #see:test4context__special
(3, True, ['12'])
>>> (x//y)(场景).宽解码扌(全文暨起讫讫)
(3, True, [])
>>> (x[3])(场景).宽解码扌(全文暨起讫讫)
(4, True, ['1', '2', '3'])
>>> (x[:3])(场景).宽解码扌(全文暨起讫讫)
(4, True, ['1', '2', '3'])

>>> (x[3:])(场景).宽解码扌(全文暨起讫讫)
(10, True, ['1', '2', '3', '4', '5', '6', '7', '8', '9'])
>>> (x[3:5])(场景).宽解码扌(全文暨起讫讫)
(6, True, ['1', '2', '3', '4', '5'])
>>> (x[3:3])(场景).宽解码扌(全文暨起讫讫)
(4, True, ['1', '2', '3'])


    #]]]'''#'''
class test4old_test:
    r'''[[[

>>> from seed.recognize.toy.simple_recognizer_._common import *
>>> from seed.recognize.toy.simple_recognizer_.error import *
>>> from seed.recognize.toy.simple_recognizer_.context import *
>>> from seed.recognize.toy.simple_recognizer_.scene import *
>>> from seed.recognize.toy.simple_recognizer_.decoder import *
>>> from seed.recognize.toy.simple_recognizer_.expr import *




>>> echo = 乸具名函数('echo', echo)
>>> 全文暨起讫讫 = 构造冫全文暨起讫讫扌('aaaaaabbc', 0, None, None)
>>> 场景 = 构造冫解码场景扌(鬽名='场景')

>>> aaa = 场景.码元串常量匹配解码器扌('aaa')
>>> b = 场景.码元串常量匹配解码器扌('b')

    def 结尾限长序列解码器扌(sf, 鬽错误乊无锁定, 欤去除结果冃结尾, 解码器名冃结尾, 解码器名冃元素, /):
>>> b_aaa = 场景.结尾限长序列解码器扌(None, True, b, aaa)
>>> b_aaa.宽解码扌(全文暨起讫讫[0:])
(7, True, [None, None])
>>> b_aaa = 场景.结尾限长序列解码器扌(None, False, b, aaa)
>>> b_aaa.宽解码扌(全文暨起讫讫[0:])
(7, True, [None, None, None])
>>> b_aaa.宽解码扌(全文暨起讫讫[1:])
(7, False, None)
>>> b_aaa.宽解码扌(全文暨起讫讫[0:7])
(7, True, [None, None, None])
>>> b_aaa.宽解码扌(全文暨起讫讫[0:6])
(6, False, None)

>>> cc = 常量式('cc')
>>> err = 失败式('err')
>>> ggg = 成功式(999)
>>> -cc
忽略式(常量式('cc'))
>>> -cc + err + -ggg
串联式(串联式(忽略式(常量式('cc')), 失败式('err')), 忽略式(成功式(999)))
>>> (-cc + err + -ggg).整理扌()
串联式(忽略式(常量式('cc')), 失败式('err'), 忽略式(成功式(999)))
>>> (cc + err >> ggg + cc | cc + cc >> cc + cc)
首选式(锁隙式(串联式(常量式('cc'), 失败式('err')), 串联式(成功式(999), 常量式('cc'))), 锁隙式(串联式(常量式('cc'), 常量式('cc')), 串联式(常量式('cc'), 常量式('cc'))))
>>> str(cc + err >> ggg + cc | cc + cc >> cc + cc)
"(((常量式('cc') + 失败式('err')) >> (成功式(999) + 常量式('cc'))) | ((常量式('cc') + 常量式('cc')) >> (常量式('cc') + 常量式('cc'))))"
>>> str(cc ^ cc)
"(常量式('cc') ^ 常量式('cc'))"
>>> repr(cc ^ cc)
"独尊式(常量式('cc'), 常量式('cc'))"
>>> type(cc ^ cc) is 独尊式
True


>>> cc = 常量式('cc')
>>> err = 失败式('err')
>>> ggg = 成功式(999)
>>> cc
常量式('cc')
>>> err
失败式('err')
>>> ggg
成功式(999)
>>> str(-cc)
"(-常量式('cc'))"
>>> repr(-cc)
"忽略式(常量式('cc'))"
>>> str(cc+ggg)
"(常量式('cc') + 成功式(999))"
>>> repr(cc+ggg)
"串联式(常量式('cc'), 成功式(999))"
>>> str(cc>>ggg)
"(常量式('cc') >> 成功式(999))"
>>> repr(cc>>ggg)
"锁隙式(常量式('cc'), 成功式(999))"
>>> str(cc|ggg)
"(常量式('cc') | 成功式(999))"
>>> repr(cc|ggg)
"首选式(常量式('cc'), 成功式(999))"
>>> str(cc^ggg)
"(常量式('cc') ^ 成功式(999))"
>>> repr(cc^ggg)
"独尊式(常量式('cc'), 成功式(999))"
>>> str(cc&ggg)
"(常量式('cc') & 成功式(999))"
>>> repr(cc&ggg)
"兼顾式(常量式('cc'), 成功式(999))"
>>> str(+cc)
"(+常量式('cc'))"
>>> repr(+cc)
"前瞻式(常量式('cc'))"
>>> str(~cc)
"(~常量式('cc'))"
>>> repr(~cc)
"反转式(常量式('cc'))"
>>> str(cc%echo)
"(常量式('cc') % echo)"
>>> repr(cc%echo)
"变果式(echo, 常量式('cc'))"
>>> str(cc%None)
"(常量式('cc') % None)"
>>> repr(cc%(echo,None))
"变果式((echo, None), 常量式('cc'))"
>>> str(cc/ggg)
"(常量式('cc') / 成功式(999))"
>>> repr(cc/ggg)
"尾限式(False, 成功式(999), 常量式('cc'))"
>>> str(cc//ggg)
"(常量式('cc') // 成功式(999))"
>>> repr(cc//ggg)
"尾限式(True, 成功式(999), 常量式('cc'))"
>>> str(cc[0])
"常量式('cc')[0]"
>>> repr(cc[0])
"重复式(0, 0, 常量式('cc'))"
>>> str(cc[0:])
"常量式('cc')[:]"
>>> repr(cc[0:])
"重复式(0, None, 常量式('cc'))"
>>> str(cc[:0])
"常量式('cc')[0]"
>>> repr(cc[:0])
"重复式(0, 0, 常量式('cc'))"
>>> str(cc[1])
"常量式('cc')[1]"
>>> repr(cc[1])
"重复式(1, 1, 常量式('cc'))"
>>> str(cc[:1])
"常量式('cc')[:1]"
>>> repr(cc[:1])
"重复式(0, 1, 常量式('cc'))"
>>> str(cc[1:])
"常量式('cc')[1:]"
>>> repr(cc[1:])
"重复式(1, None, 常量式('cc'))"
>>> str(cc[1:1])
"常量式('cc')[1]"
>>> repr(cc[1:1])
"重复式(1, 1, 常量式('cc'))"
>>> str(cc[1:2])
"常量式('cc')[1:2]"
>>> repr(cc[1:2])
"重复式(1, 2, 常量式('cc'))"



>>> str(cc | cc + cc + cc >> cc >> cc | cc)
"((常量式('cc') | ((((常量式('cc') + 常量式('cc')) + 常量式('cc')) >> 常量式('cc')) >> 常量式('cc'))) | 常量式('cc'))"
>>> repr(cc | cc + cc + cc >> cc >> cc | cc)
"首选式(首选式(常量式('cc'), 锁隙式(锁隙式(串联式(串联式(常量式('cc'), 常量式('cc')), 常量式('cc')), 常量式('cc')), 常量式('cc'))), 常量式('cc'))"
>>> str((cc | cc + cc + cc >> cc >> cc | cc).整理扌())
"(常量式('cc') | ((常量式('cc') + 常量式('cc') + 常量式('cc')) >> 常量式('cc') >> 常量式('cc')) | 常量式('cc'))"
>>> repr((cc | cc + cc + cc >> cc >> cc | cc).整理扌())
"首选式(常量式('cc'), 锁隙式(串联式(常量式('cc'), 常量式('cc'), 常量式('cc')), 常量式('cc'), 常量式('cc')), 常量式('cc'))"
>>> 解码器 = (cc | cc + cc + cc >> cc >> cc | cc)(场景)

>>> 解码器 == 场景.构造冫解码器巛名扌(cc | cc + cc + cc >> cc >> cc | cc)
True
>>> CC = 乸码元串常量匹配解码器(场景, 'cc')

#>>> 解码器 == 乸优先并联解码器(场景, None, None, (CC, (乸串联解码器(场景, [CC, CC, CC]), 乸串联解码器(场景, [CC, CC])), CC))
>>> 解码器 == 乸优先并联解码器(场景, None, None, (CC, 乸间隙锁定串联解码器(场景, 1, ( 乸串联解码器(场景, [CC, CC, CC]), 乸串联解码器(场景, [CC, CC]))), CC))
True

>>> 全文暨起讫讫 = 构造冫全文暨起讫讫扌('aaabbc', 0, None, None)
>>> cc
常量式('cc')
>>> aaa = 常量式('aaa')
>>> aa = 常量式('aa')
>>> aa = 常量式('aa')
>>> bc = 常量式('bc')
>>> O = 常量式('')

    乸码元串常量匹配解码器
>>> aaa(场景)
乸码元串常量匹配解码器(场景, 'aaa')
>>> aaa(场景).宽解码扌(全文暨起讫讫 << 0)
(3, True, None)
>>> aaa(场景).宽解码扌(全文暨起讫讫 << 1)
(4, False, None)
>>> bc(场景).宽解码扌(全文暨起讫讫 << 4)
(6, True, None)
>>> bc(场景).宽解码扌(全文暨起讫讫 << 3)
(5, False, None)
>>> bc(场景).宽解码扌(全文暨起讫讫 << 5)
(6, False, None)
>>> bc(场景).宽解码扌(全文暨起讫讫 << 6)
(6, False, None)
>>> cc(场景).宽解码扌(全文暨起讫讫 << 5)
(6, False, None)
>>> cc(场景).宽解码扌(全文暨起讫讫 << 4)
(5, False, None)
>>> cc(场景).宽解码扌(全文暨起讫讫 << 6)
(6, False, None)
>>> O(场景).宽解码扌(全文暨起讫讫 << 6)
(6, True, None)
>>> O(场景).宽解码扌(全文暨起讫讫 << 0)
(0, True, None)


    乸失败零解码器
    乸恒果零解码器

    乸前瞻零解码器
    乸逆转成败解码器
    乸变换结果解码器

    乸优先并联解码器
    乸互斥并联解码器
>>> (aa | aaa)(场景).宽解码扌(全文暨起讫讫 << 0)
(2, True, None)
>>> (aaa | aa)(场景).宽解码扌(全文暨起讫讫 << 0)
(3, True, None)
>>> (aa ^ aaa)(场景).宽解码扌(全文暨起讫讫 << 0)
Traceback (most recent call last):
    ...
seed.recognize.toy.simple_recognizer_.error.解码异常冖冖互斥并联冖冖多锁定: [0, 1]
>>> (aaa ^ aa)(场景).宽解码扌(全文暨起讫讫 << 0)
Traceback (most recent call last):
    ...
seed.recognize.toy.simple_recognizer_.error.解码异常冖冖互斥并联冖冖多锁定: [0, 1]

#上面:中止解码
#下面:继续解码
>>> 乸互斥并联解码器(场景, None, 彧鬽错误乊多锁定:=..., [aa, aaa]).宽解码扌(全文暨起讫讫 << 0)
(3, False, [0, 1])
>>> 乸互斥并联解码器(场景, None, 彧鬽错误乊多锁定:=..., [aaa, aa]).宽解码扌(全文暨起讫讫 << 0)
(3, False, [0, 1])

    乸串联解码器
        乸收集时忽略结果解码器
    乸序列解码器
    乸结尾限长序列解码器


        乸间隙锁定串联解码器
        乸元素锁定串联解码器
        乸首非零锁定串联解码器
        乸首锁定串联解码器
        乸尾锁定串联解码器
        乸实心锁定串联解码器

    乸全文暨讫讫
    乸全文暨起讫讫
    乸直达终点解码器
    乸码元串定长读取解码器
    乸定域解码器


    #]]]'''#'''
class test4new__20240228:
    r'''[[[
乸具名引用变量,惑构造冫讫错果变换器扌,变换器冫取原文片段,乸两段式篡改器,乸讫错果变换器

>>> 场景 = 构造冫解码场景扌(鬽名='场景')
>>> 全文暨起讫讫 = 构造冫全文暨起讫讫扌('0123456789', 1, None, None)
>>> x = 定长式(1)
>>> y = 定长式(2)

变换器冫取原文片段
>>> (-x)(场景).宽解码扌(全文暨起讫讫)
(2, True, None)
>>> (-x >> 变换器冫取原文片段)(场景).宽解码扌(全文暨起讫讫)
(2, True, '1')


>>> def 逆转成败扌(场景, 解码器名, 全文暨起讫讫, 讫错果, /):
...     (讫地址, 错误丷结果, 错误丨结果) = 讫错果
...     return (讫地址, not 错误丷结果, 错误丨结果)
>>> 逆转成败 = 惑构造冫讫错果变换器扌('逆转成败', 逆转成败扌)
>>> 逆转成败
逆转成败
>>> (x%逆转成败)
变果式(逆转成败, 定长式(1))
>>> (x>>逆转成败)
变果式(逆转成败, 定长式(1))
>>> str(x>>逆转成败)
'(定长式(1) % 逆转成败)'
>>> (x>>逆转成败)(场景)
乸变换结果解码器(场景, None, 逆转成败, 乸码元串定长读取解码器(场景, 1))

^old:乸包装解码(场景, 逆转成败, 乸码元串定长读取解码器(场景, 1))
^old:乸变换讫错果解码器(场景, 逆转成败, 乸码元串定长读取解码器(场景, 1))

>>> x(场景).宽解码扌(全文暨起讫讫)
(2, True, '1')
>>> (x>>逆转成败)(场景).宽解码扌(全文暨起讫讫)
(2, False, '1')
>>> (+x>>逆转成败)(场景).宽解码扌(全文暨起讫讫)
(1, False, (2, True, '1'))
>>> (+(x>>逆转成败))(场景).宽解码扌(全文暨起讫讫)
(1, False, (2, False, '1'))
>>> (+x)(场景).宽解码扌(全文暨起讫讫)
(1, True, (2, True, '1'))
>>> (+(x>>逆转成败扌))(场景).宽解码扌(全文暨起讫讫)
(1, False, (2, False, '1'))


>>> def 逆转成败暨全取扌(场景, 解码器名, 全文暨起讫讫, 讫错果, /):
...     (讫地址, 错误丷结果, 错误丨结果) = 讫错果
...     return (讫地址, not 错误丷结果, (场景, 解码器名, 全文暨起讫讫, 讫错果))
>>> 逆转成败暨全取 = 惑构造冫讫错果变换器扌('逆转成败暨全取', 逆转成败暨全取扌)
>>> (x>>逆转成败暨全取)(场景).宽解码扌(全文暨起讫讫)
(2, False, (场景, 乸码元串定长读取解码器(场景, 1), 乸全文暨起讫讫(乸全文暨讫讫('0123456789', 10, 10), 1), (2, True, '1')))



'[乊锁定扌, 乊失败扌, 乊匹配扌, 乊结束扌:: 包装解码器 -> 全文暨起讫讫 -> 讫错果 -> 讫错果]'
'乸两段式篡改器(鬽名, 乊起始扌, 乊锁定扌, 乊失败扌, 乊匹配扌, 乊结束扌)'

>>> 乸两段式篡改器(鬽名:=None, 乊起始扌:=None, 乊锁定扌:=None, 乊失败扌:=None, 乊匹配扌:=None, 乊结束扌:=None)
乸两段式篡改器(None, None, None, None, None, None)
>>> 无更改 = 乸两段式篡改器(鬽名:='无更改', 乊起始扌:=None, 乊锁定扌:=None, 乊失败扌:=None, 乊匹配扌:=None, 乊结束扌:=None)
>>> 无更改
无更改
>>> (x%无更改)
变果式(无更改, 定长式(1))
>>> (x>>无更改)
变果式(无更改, 定长式(1))
>>> str(x>>无更改)
'(定长式(1) % 无更改)'
>>> (x>>无更改)(场景)
乸变换结果解码器(场景, None, 无更改, 乸码元串定长读取解码器(场景, 1))

^old:乸包装解码器(场景, 无更改, 乸码元串定长读取解码器(场景, 1))

>>> (x>>无更改)(场景).宽解码扌(全文暨起讫讫)
(2, True, '1')

>>> def 错暨全取扌(包装解码器, 全文暨起讫讫, 讫错果, /):
...     (讫地址, 错误丷结果, 错误丨结果) = 讫错果
...     return (讫地址, False, (包装解码器, 全文暨起讫讫, 讫错果))
>>> 错暨全取扌 = 构造冫具名函数扌(..., 错暨全取扌)
>>> 错暨全取 = 乸两段式篡改器(鬽名:=None, 乊起始扌:=None, 乊锁定扌:=None, 乊失败扌:=None, 乊匹配扌:=None, 乊结束扌:=错暨全取扌)
>>> (x>>错暨全取)(场景).宽解码扌(全文暨起讫讫)
(2, False, (乸变换结果解码器(场景, None, 乸两段式篡改器(None, None, None, None, None, 错暨全取扌), 乸码元串定长读取解码器(场景, 1)), 乸全文暨起讫讫(乸全文暨讫讫('0123456789', 10, 10), 1), (2, True, '1')))

^old:(2, False, (乸包装解码器(场景, 乸两段式篡改器(None, None, None, None, 错暨全取扌), 乸码元串定长读取解码器(场景, 1)), 乸全文暨起讫讫(乸全文暨讫讫('0123456789', 10, 10), 1), (2, True, '1')))


>>> (x)(场景).宽解码扌(全文暨起讫讫)
(2, True, '1')
>>> (~x)(场景).宽解码扌(全文暨起讫讫)
(2, False, '1')

>>> def 恒错果扌(包装解码器, 全文暨起讫讫, 讫错果, /):
...     (讫地址, 错误丷结果, 错误丨结果) = 讫错果
...     return (讫地址, 错误丷结果, 999)
>>> 恒错果扌 = 构造冫具名函数扌(..., 恒错果扌)
>>> 恒错果 = 乸两段式篡改器(鬽名:=None, 乊起始扌:=None, 乊锁定扌:=None, 乊失败扌:=None, 乊匹配扌:=None, 乊结束扌:=恒错果扌)
>>> (x>>恒错果)(场景).宽解码扌(全文暨起讫讫)
(2, True, 999)
>>> (~x>>恒错果)(场景).宽解码扌(全文暨起讫讫)
(2, False, 999)
>>> 恒乊果 = 乸两段式篡改器(鬽名:=None, 乊起始扌:=None, 乊锁定扌:=None, 乊失败扌:=None, 乊匹配扌:=恒错果扌, 乊结束扌:=None)
>>> (x>>恒乊果)(场景).宽解码扌(全文暨起讫讫)
(2, True, 999)
>>> (~x>>恒乊果)(场景).宽解码扌(全文暨起讫讫)
(2, False, '1')
>>> 恒乊错 = 乸两段式篡改器(鬽名:=None, 乊起始扌:=None, 乊锁定扌:=None, 乊失败扌:=恒错果扌, 乊匹配扌:=None, 乊结束扌:=None)
>>> (x>>恒乊错)(场景).宽解码扌(全文暨起讫讫)
(2, True, '1')
>>> (~x>>恒乊错)(场景).宽解码扌(全文暨起讫讫)
(2, False, 999)



逆转成败扌
逆转成败暨全取扌
恒错果扌
错暨全取扌

'乸具名引用变量(彧鬽名, 鬽变量类型, 参数数目, 变量名)'
取冫变量值扌,注册冫变量名纟公用扌,注册冫变量名纟私用扌

参数数目:=4
>>> 引用冫逆转成败扌=乸具名引用变量(彧鬽名:='引用冫逆转成败扌', 鬽变量类型:=None, 参数数目:=4, 变量名:='变量冫逆转成败扌')
>>> 场景.注册冫变量名纟公用扌('变量冫逆转成败扌', 逆转成败扌)
>>> x >> 引用冫逆转成败扌
变果式(引用冫逆转成败扌, 定长式(1))
>>> (x>>引用冫逆转成败扌)(场景).宽解码扌(全文暨起讫讫)
(2, False, '1')
>>> (~x>>引用冫逆转成败扌)(场景).宽解码扌(全文暨起讫讫)
(2, True, '1')

连锁引用
引用链
>>> 引用冫引用冫逆转成败扌=乸具名引用变量(彧鬽名:='引用冫引用冫逆转成败扌', 鬽变量类型:=None, 参数数目:=4, 变量名:='引用冫逆转成败扌')
>>> 场景.注册冫变量名纟公用扌('引用冫逆转成败扌', 引用冫逆转成败扌)
>>> (x>>引用冫引用冫逆转成败扌)(场景).宽解码扌(全文暨起讫讫)
(2, False, '1')
>>> (~x>>引用冫引用冫逆转成败扌)(场景).宽解码扌(全文暨起讫讫)
(2, True, '1')


参数数目:=1
>>> def 恒果扌(果, /):
...     return 999
>>> 引用冫恒果扌=乸具名引用变量(彧鬽名:='引用冫恒果扌', 鬽变量类型:=None, 参数数目:=1, 变量名:='变量冫恒果扌')
>>> 场景.注册冫变量名纟公用扌('变量冫恒果扌', 恒果扌)
>>> (x>>引用冫恒果扌)(场景).宽解码扌(全文暨起讫讫)
(2, True, 999)
>>> (~x>>引用冫恒果扌)(场景).宽解码扌(全文暨起讫讫)
(2, False, '1')



>>> type(逆转成败)
<class 'seed.recognize.toy.simple_recognizer_.basic.乸讫错果变换器'>
>>> type(恒错果)
<class 'seed.recognize.toy.simple_recognizer_.basic.乸两段式篡改器'>

鬽变量类型:=乸讫错果变换器
>>> 引用冫逆转成败=乸具名引用变量(彧鬽名:='引用冫逆转成败', 鬽变量类型:=type(逆转成败), 参数数目:=-1, 变量名:='变量冫逆转成败')
>>> 场景.注册冫变量名纟公用扌('变量冫逆转成败', 逆转成败)
>>> (x>>引用冫逆转成败)(场景).宽解码扌(全文暨起讫讫)
(2, False, '1')
>>> (~x>>引用冫逆转成败)(场景).宽解码扌(全文暨起讫讫)
(2, True, '1')

鬽变量类型:=乸两段式篡改器
>>> 引用冫恒错果=乸具名引用变量(彧鬽名:='引用冫恒错果', 鬽变量类型:=type(恒错果), 参数数目:=-1, 变量名:='变量冫恒错果')
>>> 场景.注册冫变量名纟公用扌('变量冫恒错果', 恒错果)
>>> (x>>引用冫恒错果)(场景).宽解码扌(全文暨起讫讫)
(2, True, 999)
>>> (~x>>引用冫恒错果)(场景).宽解码扌(全文暨起讫讫)
(2, False, 999)





欤自动注册冫具名解码器
欤自动变换结果冫具名解码器
    公钥纟欤自动注册冫具名解码器
    公钥纟欤自动变换结果冫具名解码器
    注册冫变量名纟公用扌
注册冫变换结果函数纟具名解码器扌
取冫变换结果函数纟具名解码器扌
>>> nmd = x >> 'nmd'
>>> 场景.构造冫解码器巛名扌('nmd')
Traceback (most recent call last):
    ...
LookupError: nmd
>>> nmd(场景) is nmd(场景)
True

^old:False #现在，缓存 解码器<场景>
>>> 场景 = 构造冫解码场景扌(鬽名='场景')

>>> 场景.欤自动注册冫具名解码器
False
>>> 场景.欤自动注册冫具名解码器 = True
>>> 场景.欤自动注册冫具名解码器
True
>>> nmd(场景) is nmd(场景)
True
>>> nmd(场景) is 场景.构造冫解码器巛名扌('nmd')
True

>>> nmd(场景).宽解码扌(全文暨起讫讫)
(2, True, '1')
>>> 场景.注册冫变换结果函数纟具名解码器扌('nmd', 恒果扌)
>>> nmd(场景).宽解码扌(全文暨起讫讫)
(2, True, '1')
>>> 场景.欤自动变换结果冫具名解码器
False
>>> 场景.欤自动变换结果冫具名解码器 = True
>>> 场景.欤自动变换结果冫具名解码器
True
>>> nmd(场景).宽解码扌(全文暨起讫讫) #因为 已经 注册了 不变结果的版本！！
(2, True, '1')
>>> 场景 = 构造冫解码场景扌(鬽名='场景')
>>> 场景.欤自动变换结果冫具名解码器
False
>>> 场景.欤自动变换结果冫具名解码器 = True
>>> 场景.欤自动变换结果冫具名解码器
True
>>> 场景.欤自动注册冫具名解码器
False
>>> 场景.欤自动注册冫具名解码器 = True
>>> 场景.欤自动注册冫具名解码器
True
>>> 场景.注册冫变换结果函数纟具名解码器扌('nmd', 恒果扌)
>>> nmd(场景).宽解码扌(全文暨起讫讫)
(2, True, 999)



>>> 场景.欤调试纟构造冫具名解码器
False
>>> 场景.欤调试纟构造冫具名解码器 = False
>>> 场景.欤调试纟构造冫具名解码器
False
>>> 场景.欤调试纟构造冫具名解码器 = True
>>> 场景.欤调试纟构造冫具名解码器
True
>>> 场景.欤调试纟构造冫具名解码器 = False
>>> 场景.欤调试纟构造冫具名解码器
False

    #]]]'''#'''



__all__
___begin_mark_of_excluded_global_names__0___ = ...
from seed.recognize.toy.simple_recognizer_.expr import \
(忽略式#-
,串联式#+
,锁元式#(+)>>(may int)
,保底兼顾式#(&)>>(may int)
,后充式#>>...
,具名式#>>name:name/str
,锁隙式#>>expr
,首选式#|
,独尊式#^
,兼顾式#&
,前瞻式#+
,反转式#~
,变果式#% #>>f #>>at[?]
,尾限式#/,//
,重复式#[]
,定长式
,码集式
,常量式
,失败式
,成功式
,空式
,引用式
)
___end_mark_of_excluded_global_names__0___ = ...
def __():
    r'''
21-(16-1/锁隙式)=6#还差6个
乸间隙锁定串联解码器~~~锁隙式
乸元素锁定串联解码器
乸首非零锁定串联解码器=[def]=串联式
乸首锁定串联解码器===乸元素锁定串联解码器@0
乸尾锁定串联解码器===乸元素锁定串联解码器@-1
乸实心锁定串联解码器===乸元素锁定串联解码器@None===乸间隙锁定串联解码器@None
==>>
还需实现:乸元素锁定串联解码器
    (expr+expr)>>(int|None)
    锁元式
    场景.元素锁定串联扌
    DONE
    '''#'''

from seed.recognize.toy.simple_recognizer_.test import *
