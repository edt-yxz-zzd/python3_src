#goto
#   :src_start

r'''[[[[[

e ../../python3_src/seed/recognize/cmdline/简化版命令行前缀型解析器.py

[[[设计的基础逻辑
输入参数：数组[命令行的字符串块]
原则一：靠 前缀 来区分 命令行的字符串块 的 类型/解析器
    ==>> 冠区
原则二：允许用户输入大量 原貌字符串 即 无需 大量烦人的 前缀(比如 大量整数，注释)
    ==>> 荒区
    顶层 是？必须是 冠区！这样 荒区 可以 通过 冠区块 标识出来。反之，若 一开始就是 荒区，全是 原貌字符串，则 无法 标识出 冠区。
    ==>> 顶层冠区
    最自然的 荒区 标识 即是 终结 顶层冠区，后面 便是 荒区，不可逆。
    ==>> 顶层尾部荒区
原则三：内建嵌套。序列、记录的序列、关联容器、矩阵，都是常见的输入参数。
    嵌套的 子区，不可能是 荒区，同理 也不能 像 顶层冠区 切换成 荒区，故而 也不同于 顶层冠区。
    依照 原则一，子区 可以是 顶层冠区 的 弱化版。
        ==>> 非顶层冠区
    依照 原则二，子区 可以是 顶层尾部荒区 的 弱化版，即 类似 C++中的 原貌字符串，使用 动态个性化蛮冠 作为 前缀 标示出 冠块，余者 皆是 蛮块(原貌字符串)。
        ==>> 非顶层蛮区
    子区 需要 起止标示。
        ==>> 域始符、域终符
    子区 也可 只有 起始标示，而无 终止标示，这样一来 起始标示 就相当于 切换标示。
        ==>> 域换符

原则四，块 解析 的 相对独立性，可在隔离环境中，复现 解析结果，亦即 与 动态的上下文无关。
    TODO
    所有信息 归结为 全局名，既方便配置又阻止隐含传递的动态参数
拓展四：冠块 的 前缀 是否可以拓展为 由多个前缀组成的短语 或者 由多个短语组成？原则上，没问题。
    若 前缀 = x?y?(a|b)，则 与 LL1 的 要求 类似 x,y,a,b的 识别前缀 不能碰撞。
    若 x,y,z的 识别前缀 不碰撞，则 可 进一步 加强 前缀=(x|y)*(a|b)
        ==>> 循环前冠短语 #x,y 出现多次
        ==>> 伪功能伪前缀 #a,b 终结x,y的循环
    这显然 比 原来的 前缀=(a|b) 强点，但要是 希望 某些 a,b 保持原先的样子 即 没有前置别的短语？由于 受到同样的类LL1约束，语法上 并不能留下更多编码空间，所以 不必在语法层面解决，只需在解析后，由语义判断是否被盖帽。
        ==>> 如冠块类型符
约束五：循环前冠短语、伪功能伪前缀、如冠块类型符，它们前缀前缀之间的合理的互斥条件是什么？
    首先，考虑 同一区内 区块前缀 之间的关系
    其次，考虑 域始符 归 外区 还是 内区 约束
    再次，考虑 域终符 归 外区 还是 内区 约束
        这个问题就有点意思，域始符 归 外区 管，但 域终符 比较暧昧。
        若 内区 是 蛮区，则 域终符 必前冠 内区 蛮冠，与 外区 蛮冠与否 无关。
        若是 域终符 有 前置的 循环前冠短语，则 这些 循环前冠短语 归 内区 管。
        但是！域终符 是由 域始符 决定的，与 内区 无关，因为 域换符 会隔离 域始符 与 尾部的 内区。
        也就是说，域终符 可能 穿透了 多层内区，被它们看到，引入 互斥约束。哪些 区 可能 看到 特定 域始符 决定的 域终符？这就需要 对 用户设定 进行扫描。
        域始符 决定 内区，内区 决定 域换符，域换符 决定 内区，...。所有 这些 内区 都有可能 看到 相应的 域终符。

细节六：如何 动态设定 动态个性化蛮冠、局域标签？如何表达 中继关系？
    中继 的 由来：
        一般 函数 调用 使用 单标识 f(...)
        但 也有 多标识的情形：
            if(...)then(...)else(...)
            `(...)if(...)else(...)
            let(...)in(...)where(...)
            list(...)for(...)in(...)if(...)
            try(...)except(...)else(...)finally(...)
            for(...)in(...)do(...)else(...)
            if(...)then(...)elif(...)then(...)endif
            #SQL
            {#(#}
            其中『xxx(』就叫 待续。
            其中『)xxx(』就叫 中继。
            其中『)xxx』就叫 后续。
            {#)#}

        按这里的语法，实例类似：
            {xxx ... }--{yyy ... }
            {xxx ... }-  -{yyy ... }
            {xxx ... }-  -{yyy ... }-  -{zzz ... }
            {xxx ... }--{yyy ... }-  -{zzz ... }
            {xxx ... }-  -{yyy ... }--{zzz ... }
            {xxx ... }--{yyy ... }--{zzz ... }
            ----
            {xxx ... }--zzz
            {xxx ... }-  -zzz
            .-zzz  -{yyy ... }
            {xxx ... }-  -.-zzz  -{yyy ... }
            {xxx ... }--.-zzz  -{yyy ... }

            #注意：块单步前置接续中继符 默认值(接续符++块单步前置待续符) 与 接续符 碰撞，接续符 是其 真前缀，但幸好 功能也被兼容。
            #   ==>> 『真前缀功能兼容的声明可容许某些配置中的真前缀碰撞作为例外但由于偏好长前缀故剩余后缀无关紧要』
                    #TODO:impl...


]]]

区-分类:
    顶层冠区
    顶层尾部荒区
    非顶层冠区
    非顶层蛮区  #蛮区 是 弱化版荒区

块:
    命令行 由 系统壳/shell 分割成 字符串序列，这里将此序列中的元素成为『块/piece』

各『块』隔离独立解析:
    禁止 不透明的 参数传递:
        被禁止的 参数传递方向:
            * 由兄至弟/由前至后
            * 由父至子/由上至下/由顶至底
    原由:
        透明作用域，where打包域 使用了 相对位置的其他域的内容，故此 解析时 不可能有动态的环境变量
    相对位置的描述:
        不得精确到 前几个域
        不得依赖于 具体的 命令行（动态合理），必须 能够 静态 检查 配置 合理性
        只能笼统地 将 相对位置描述 为：『父+子*』(无『兄』)


冠区:
    冠区块 皆依照 其 非空前缀 而被归类、被解析
    该合法伪前缀集 + 相应的解析器 是 局部的/区域性的/局域性的
    该合法伪前缀集 是 静态的(由静态配置可得，不依赖于动态参数)、透明的(相对于 功能型不透明的，透明 意味着 有限长的、公开的 数据，允许外部独立加工处理)
蛮区:
    #用于 注释、大量『直接数据』的使用/粘贴
    蛮区 之于 冠区 可类比 原貌字符串/raw_string 之于 转义字符串/string，或 注释 之于 代码
        HTML 的 不解析块(注释+CDATA) 说是 不解析，其实跟 C++的 原貌字符串 一样，还是要解析，以定位 终结符。{#『<![CDATA[』『<!--』#} 『-->』『]]>』
        C++ 单行注释 以『newline/eof』为 终结符
        C++ 多行注释 以『*/』为 终结符
    其实是 带动态状态的 冠区，故而 非顶层
        该状态，依前所述，必须 透明
        在此 定义 该状态为 蛮冠/蛮区前冠
    蛮区块 按照 其前缀是否匹配 蛮冠 而分为 冠块、蛮块
        除去 蛮块，再将 剩下的 冠块 的 蛮冠 前缀 去掉，最后 剩下的 其实就是 冠区
        蛮区块 = 冠块 | 蛮块
        冠块 = 动态个性化蛮冠++如冠块
        冠区块 = 如冠块
        #冠- marked-/escaped-，蛮- unmarked-raw-
        #如- pseudo-/quasi-
        #如冠块，拟冠块，准冠块
        如冠块ver1 = 本域循环前冠短语* ++ 本域功能伪前缀 ++ 功能负载块尾??
        如冠块ver2 =:
            * | 如冠块囗无如冠块类型符
                * | 块单步如冠块囗无如冠块类型符
                * | 域单步相关如冠块囗无如冠块类型符
            * | 如冠块囗带如冠块类型符
                * | 块单步如冠块囗带如冠块类型符囗不透明
                * | 块单步如冠块囗带如冠块类型符囗半透明
                * | 域单步相关如冠块囗带如冠块类型符囗半透明
                    * | [己暨祖]域终符
        如冠块ver2 =:
            * | 如冠块囗无如冠块类型符 = [本区域]循环前冠短语* ++ [本区域]伪功能伪前缀 ++ 伪功能负载块尾??
                * | 块单步如冠块囗无如冠块类型符 = [本区域]循环前冠短语* ++ [本区域]功能伪前缀 ++ 功能负载块尾??
                * | 域单步相关如冠块囗无如冠块类型符 = [本区域]循环前冠短语* ++ [本区域]([子]域始符|[子]域换符|[己暨祖]域终符) ++ 伪功能负载块尾??
            * | 如冠块囗带如冠块类型符 = [本区域]如冠块类型符++负载块尾??
                * | 块单步如冠块囗带如冠块类型符囗不透明 = [本区域]如冠块类型符囗不透明++负载块尾(非空)
                * | (块单步如冠块囗带如冠块类型符囗半透明|域单步相关如冠块囗带如冠块类型符囗半透明) ~~~[本区域]如冠块类型符囗半透明++它区如冠块?-??(由 如冠块类型符囗半透明 定名的，负载(必空|允空|非空))
                    * | 混域终块=域单步相关如冠块囗带如冠块类型符囗半透明囗己暨祖域终符 = [己暨祖]域终符 ++ ...
        where
            如冠块类型符 = 如冠块类型符囗不透明 | 如冠块类型符囗半透明
            # 若 如冠块类型符 本身空 负载必空，则 无如使用 ver1-case + 空的 功能指示符
            # 如冠块类型符 本身非空
            #   非空 是由于 空 退化为 ver1直接读取 循环前冠
            #       xxx 之所以 ver1-case 不能配置为 不存在，是因为 伪功能伪前缀 包含 [己暨祖]域终符
            #       #现在 域终符 由 伪功能伪前缀 变更为 如冠块类型符！
            #       现在虽然可以将ver1-case设置为不存在，但有 域终符-如冠块类型符，空的 如冠块类型符 必是 域终符 的 真前缀，故而 不行！
            #想要完全 移出 如冠块类型符 ==>> 蛮区，使用 动态个性化蛮冠 转义 识别 [己暨祖]域终符
            #
            # 后续符 属于 如冠块类型符。为什么 不当作 伪功能伪前缀？因为：
            #   这样一来，后续符 与 域始符 都是 伪功能伪前缀。它们的 组合 还需 另行设置，不太自然。
            # 但 域始符 不是 如冠块类型符。因为：
            #   1. 前置的 循环前冠短语 是 外区 添加的 动态 外部属性(给 所有 区单步，这里即子类型 域单步)，域始符 自己内部 还有 头部如冠块 即 后置的 动态 内部属性
            #   2. 后续符 与 域始符 的 组合更自然。否则 两者 都是 如冠块类型符，还需 另行设置。
            #
            # 域终符 是不是 如冠块类型符？
            # 『为何域终符是如冠块类型符』
            #   按理说，域终符 不该 拥有 语义信息，故而 不该 拥有 前置 循环前冠短语，所以 理应 是 如冠块类型符。但是 局域标签 可能 需要 转义，因为 前面的 局域标签 经过了 转义，所以 原先 将 域终符 归类到 伪功能伪前缀。
            #   现在正式 将其划归 如冠块类型符！！！
            #       至于 转义格式化 问题，头部 解析时 应分成 两个 结果: 转义格式化后字符串->本域语义相关值 以及 原貌字符串->局域标签，亦即 局域标签 即不转义(py-'\0xhh')也不格式化(py-fr'{}')，仍保持 原貌(py-r'')，所见即所得，字面匹配，肉眼匹配。
            #   还是有点不太对，再定义个『真如冠块类型符』
            #       因为 顶层冠区 不需要 域终符，域换符 也不需要 或者说 使用 祖辈的 即 [己暨祖]域终符（多个），属于 动态 确定，并非 区 本身的内禀属性
            #       不同父域可能使用相同的 域终符，互斥关系 需分开表达
            真如冠块类型符
                = 如冠块类型符 - [己暨祖]域终符
                = 后续符 | 原貌块标示符 | 单块注释标示符 | 块单步前置待续符 | 块单步前置中继符 | 块单步前置接续中继符 | ...
                #原貌块标示符 允空类
                #   解析结果 即是 块尾负载 自身
                #   下面假设 原貌块标示符=『,』
                #   比如：冠区 输入原貌参数 『"-xxx"』->『,"-xxx"』
                #   比如：蛮区 使用超简单 蛮冠，如：常见命令行选项前缀『-』，则 输入的原貌参数 容易碰撞之，有必要 逆转 『"-xxx"』->『-,"-xxx"』
                #
                # 块单步前置待续符 | 块单步前置中继符 | 块单步前置接续中继符
                #   域始符 其前可冠 后续符，域终符 其后可接 待续符
                #   域换符 其前可冠 后续符，因为 其 域单步 之后 再无 区单步，故而 无需 待续符
                #   这样一来，域单步 便能 完全实现 中继
                #   但 块单步 只能 前冠 后续符，其后无法接 待续符。
                #   要实现 块单步 的 中继，还需 上面这3个。
                #   假设 待续符 = 后续符 = 『-』
                #   假设 接续符 = 『--』
                #   假设 块单步前置待续符 = 『.-』
                #   假设 块单步前置中继符 = 『-.-』
                #   假设 块单步前置接续中继符 = 『--.-』
                #   { ... }--{ ... }
                #   { ... }-  -{ ... }
                #   { ... }-  -{ ... }-  -{ ... }
                #   { ... }--{ ... }-  -{ ... }
                #   { ... }-  -{ ... }--{ ... }
                #   { ... }--xxx
                #   { ... }-  -xxx
                #   .-xxx  -{ ... }
                #   { ... }-  -.-xxx  -{ ... }
                #   { ... }--.-xxx  -{ ... }



命名解释:
    # 语法中: 『??』表示 静态确定的可选信息(必空，非空)，『?』则相应于 动态(允空)。并非 表示 贪婪与否。
    # 语法中: 『(...)?-??』<==>『((...)?)??』表示 静态确定的信息的可选情形:(必空，非空，允空)
    区 vs 域:
        顶层 是 区，更准确的说是 冠区
        域 内部 是 区
        域 有 域始符（但 不一定有 域终符）
    循环前冠短语 vs 功能伪前缀
        使用场景：『循环前冠短语* ++ 功能伪前缀』
        功能伪前缀 用于 表示 终止 透明性
    功能伪前缀 = 功能非空类前缀 | 功能指示符 | 功能允空类前缀
        #区别 在于 负载/块尾 是否 为空（静态信息）
        ######################
        [某域的]伪功能伪前缀 = 功能伪前缀 | [子/子域]域始符/域换符
            #xxx | [己暨祖/最紧邻的本域或祖域的]域终符
            #   见『为何域终符是如冠块类型符』
            #不含 循环前冠，因为『伪功能』终止『循环』
            为何这么区分？
                域始符/域终符 关系到 嵌套，是 本『简化版命令行前缀型解析器』内建的功能，其负载 不能 完全不透明
                功能非空类前缀/功能指示符 则与 合法伪前缀集 是否 合理（伪前缀两两互斥）有关
        [某区的]合法伪前缀 = 真如冠块类型符 | 循环前冠 | 功能伪前缀 | [子]域始符/域换符
            # 不含 [己暨祖]域终符，因为 不同父域可能使用相同的 域终符，互斥关系 需分开表达
        [某区域的]参与互斥伪前缀
            = (合法伪前缀+[己暨祖]域终符)
            = (伪功能伪前缀+循环前冠+真如冠块类型符+[己暨祖]域终符)
            = (伪功能伪前缀+循环前冠+如冠块类型符)
            = (功能伪前缀 + [子]域始符/域换符+循环前冠+真如冠块类型符+[己暨祖]域终符)

    符 vs 前缀 vs 前冠 vs 短语 vs 块尾
        符,前缀,前冠 :: (静态的固定长度的)字符串常量
            负载 不同
            符 的 负载 相对透明
                * 声明无负载，即 要求 负载/块尾 为空
                    而 前缀 的 负载/块尾 不得为空
                * 负载 前半部分透明，是 块尾，不得为空
                    即 部分解析结果 影响 语法/解析过程
            前缀 的 负载 完全不透明，是 块尾，不得为空
                即 与 语法/解析过程 无关
            前冠 的 负载 并非 块尾，其 负载 之后 不得为空
                * 声明无负载
                    但 与 符 的 声明无负载 不同，这里 负载为空，但 块尾 不得为空
                * 负载 是 短语，不得为空
                    而 符，前缀 的 负载 皆是 块尾
        块尾 :: (动态的不特定的)直至本块终结的字符串变量
        短语 :: (动态的不特定的)自定义终结的字符串变量
        前冠短语 = 前冠++短语(由前冠定义终结的短语) <: 短语
        蛮冠 = 蛮区前冠短语 <: 前冠短语

域-嵌套:
    区单步 = 域单步 | 块单步
    块单步
        = 块单步如冠块囗无如冠块类型符
        | 块单步如冠块囗带如冠块类型符囗不透明
        | 块单步如冠块囗带如冠块类型符囗半透明
        #xxx | 域单步相关如冠块囗无如冠块类型符
        #xxx    * | 混域始块囗无如冠块类
        #xxx | 域单步相关如冠块囗带如冠块类型符囗半透明
        #xxx    * | 混域始块囗带如冠块类(如：后续符++域始块)
        #xxx    * | 所有 混域终块

    域单步
        #xxx 域单步原子 = 域开块 域区间 域闭块
        = 域始块 混域区间 混域拟终块
        | 域换块 混域区间
            #无 终块，直至 父域 结束
            #若 本域 及 父域 皆是 蛮域，则
            #xxx 过时#   *1 父域拟终块 前冠 本域蛮冠++父域蛮冠
            #   *1 父域拟终块 前冠 本域蛮冠 # 没有 『++父域蛮冠』，因为 蛮冠 之后 已是 如冠块，不该再有 蛮冠，否则 伪前缀冲突
            #   *2 本域 不另行声明新的 蛮冠，直接继承 父域 蛮冠，父域拟终块 仍只 前冠 父域蛮冠
            #

    混域区间 = 蛮区 | 冠区

    混域拟终块
        混域终块 = 蛮域终块 | 冠域终块
            # 蛮/冠 属性 相对于 本域，而非 父域 # 未退出
        拟终块 = 终块 | 终块待中继 | 终块再中继始块

    ###################################
    #########外内切换+内外切换#########
    ###################################
    混域始块
            = 父域蛮冠?? ++ 父域循环前冠短语*
            ++ 域始符(属于 父域定名的功能伪前缀，返回 域尾全局名+域尾局域标签的前缀，决定 域终符 集合，不被 局域语法描述短语 影响，更匹配 域始符，个性匹配 可使用 局域标签，提前 也是 为了 下面的 变域换符的指示符，依设计原意，它 很可能 就是 域终符)
            ++ 变域换符的指示符?-??(本域域始符 决定[不变|允变|必变]，语义是 由 域始符 变成 域换符，一般 含有 域终符。(不变，则 必空；允变，可变可不变，则 动态允空；必变，静态决定 只能 域换符，静态允空[非空 时 使用 域终符，必空时，域始符 本身 就是 域终符]))
            ++ 本域蛮冠的设定短语??(本域域始符 决定 如何读取，并返回 本域蛮冠)
            ++ 局域语法描述短语??(本域域始符定名的，返回 域体全局名+域头全局名，用于决定 域块解析器)
            ++ 局域语义描述短语??(本域域始符定名的，含 局域标签??)
            ++ 头部如冠块??(本域局域语法定名的如冠块/域头全局名定名的，且是 例外情况，即 特定位于[头部]的[如冠块]，至此完成 外内 合法伪前缀集 的 切换)

    混域终块
        = 本域蛮冠??
        #删除：++ 本域循环前冠短语*
        #   见『为何域终符是如冠块类型符』
        #
        ++ 域终符(!!!本域域始符定名的!!!/域尾全局名定名的，不属于 父域定名的功能伪前缀，也不属于 本域定名的功能伪前缀/本域局域语法定名的功能伪前缀，但 参与 本域功能伪前缀 的互斥)
        ++ 局域标签?-??(本域域始符定名的，域尾局域标签的前缀)
        ++ 中继信息短语*/?-??(!!!本域域终符定名的!!!，非 本域域始符定名的，不为空时，才有后续部分。)
        ( * ++父域待续符(待续符 不得为空，没有 待续符 则 不接受 后续的 分离式的中继块。待续符 必须与 接续符 不同，因为 空字符串 也可能是 合法的 功能指示符。但 待续符 可以是 接续符 的 非空真前缀，因为 待续符 是 必空类)
        | * ++父域接续符(接续符 不得为空，因为『}{』与『} {』太像，但语义截然不同。)
            #删除: ++ 父域蛮冠??(删除原因：无必要，必定是 如冠块 而非 蛮块。至于说 模仿，则 次序也不对：(终++待续符 父域蛮冠++后续符++...)vs(终++?父域蛮冠?++接续符++...)vs(终++接续符++?父域蛮冠?++后续符++...))
            ++ 中继如冠块(父域定名的如冠块，且是 例外情况，即 特定作为[中继]的[如冠块]，至此完成 内外 合法伪前缀集 的 切换)
        )?-??

        #[更改一：[尾部负载短语<父域中继符>] -> [中继信息短语?-??++父域中继符]：理由：域换符=>禁止 有用语义信息，这里 只能是 中继相关的信息]
        #[更改二：[中继信息短语?-??++父域中继符] -> [父域中继符]：理由：分离式的中继块=>禁止 于其前 设置 中继信息，那么可以在其后 设置？没必要，(始 终续...)->(始 终待 续...(伪续，用作设置) 续...(真续))]
        #[更改三 取消 更改二 并 拆分 中继符 为 (待续符/后续符/接续符)：理由：即使使用 分离式的中继块(插入注释？不分离也行，似无必要；排版换行更自然？类似 英文中连字符，就这样吧。有更重要的原因！块单步 无法后接 待续符/接续符，只能前冠 块单步前置待续符/块单步前置中继符)，也需要 待续符：(终++待续符  蛮冠??++后续符++...)<==>(终++接续符++...)]
        #[更改四：删除 本域循环前冠短语，因为 域终符 由 伪功能伪前缀 变更为 如冠块类型符，见『为何域终符是如冠块类型符』]
        #
        # 域换块 + 『系统性组合 域始符 域终符 得到 域换符』 ==>> 混域终块 不得 含有有用的 语义信息（可以 被 省略，只能是 局域标签）
        # 『系统性组合 域始符 域终符 得到 域换符』 ==>> 域始块 不是 必空类
        #       为了更有效的利用前缀空间，允空类 可继续 细化为：独占型允空类，子伪前缀已知型允空类
        #           非空类？？？
        #           ==>> 实组伪前缀（可空字符串常量）用于 减少 全局语义名，子伪前缀 被当作 负载的一部分(但这样一来，子伪前缀 部分 便 无法 配置)
        #           ==>> 在 不减少 全局语义名 的 前提下，搞个『虚组伪前缀』其 子伪前缀 不被当作 负载的一部分，仍有自己的 全局语义名
        #TODO:组伪前缀=实组伪前缀 | 虚组伪前缀



伪前缀两两互斥
    * 合法伪前缀集 的 合理性
        同一个 合法伪前缀集 中的 合法伪前缀 两两互斥
    * 某域的 所有的 [己暨祖]域终符，各自与该域的 任意 合法伪前缀 互斥
    ====互斥 与 其后块尾空否
    注意『为何有相等的情形』:
        每个 参与互斥伪前缀 都有 相应的 全局语义名
        全局语义名 的 定义体 必须是 唯一的
        按 全局语义名 引用 比较 不同名的 参与互斥伪前缀，所以 可能出现 伪前缀 相等的情形
        ===更新:实组伪前缀
        新版现在是 每个 [某域的]实组伪前缀 指向 全局语义名
        实组伪前缀 之间 没有任何约束关系，自己本身甚至可以是 空字符串
        以下 所谓 参与互斥伪前缀 的 标识 由 『全局语义名』更新为『实组伪前缀 全局语义名+子伪前缀』

    分类 参与互斥伪前缀:
        * 非空类-其后不为空:
            功能非空类前缀
            如冠块类型符囗不透明(<-真如冠块类型符)
            后续符(<-如冠块类型符囗半透明&真如冠块类型符)
        * 必空类-其后为空:
            功能指示符
            [己暨祖]域终符囗必空类
        * 允空类-其后允空(可空可不空):
            功能允空类前缀
            循环前冠#当使用 空的 功能指示符
            [己暨祖]域终符囗允空类#++局域标签++待续符、接续符、空
        *** [子]域始符/域换符、如冠块类型符囗半透明(<-如冠块类型符) 分布于 上述三类中
    这三类之间的 互斥关系:
        *** 例外：不是 同一个 域始块(不是 域始符、域换块) 定名的 [己]域终符(不是 [己暨祖]域终符)，则 两两之间 无关/无任何约束关系
        *** 例外：必空类 可以是 所有类 的 真前缀
        *** 例外：必空类 与 非空类 之间 可以相等
        *** 例外：必空类 本身 可以是 空字符串
        * 一般地说（除去 例外 情形），参与互斥伪前缀 不得是 其他 参与互斥伪前缀 的 前缀
        * 参与互斥伪前缀 本身是 非空字符串常量
        #见『例外情况囗偏好长前缀功能兼容真前缀囗相差后缀无关紧要囗偏序声明』
        #   见『真前缀功能兼容的声明可容许某些配置中的真前缀碰撞作为例外但由于偏好长前缀故剩余后缀无关紧要』


连续中继
    * 混域拟终块
    * 功能非空类前缀-负载-中继...
    TODO... ...
    负载 不是 块尾 或者 负载 必空，则不可以 接续中继
        #bug:必空类 也不行！违反 互斥 假设！即 允许 必空类 为 余者之真前缀
        循环前冠
        必空类 如：功能指示符
        # 部分 域始符/域终符
    负载 是 块尾，则可 自由安排，决定 接续中继与否
        非空类 如：功能非空类前缀
        允空类 如：功能允空类前缀
        # 部分 域始符/域终符
    动态返回值-要求 使用 某域的解析器 接续解析+允空与否
        某域的标识:
            相对:
                本域
                本域的中继域(即 冠以 本域中继符(待续符/后续符/接续符) 的 本域如冠块？/本域块？(蛮块？))
                父域*子域*中继域?
            绝对:
                全局语义名

#]]]]]'''



r'''[[[
循环前冠
    负载空否:bool
功能伪前缀
    负载空否:bool
        #功能非空类前缀囗功能指示符:bool
        功能非空类前缀
        功能指示符
class named_tuple



class 组伪前缀的局域外禀属性:
    #组伪前缀 = 虚组伪前缀 | 实组伪前缀
    全局语义名-内禀属性-跳出用的标识/配置更替用
    #可配置属性，由所在域重新配置：
        局域语义名-外禀属性
        局域伪前缀-外禀属性-允空字符串常量
    .可选 父虚组伪前缀的局域外禀属性
        即 .组伪前缀=.父虚组伪前缀++.局域伪前缀
class 虚组伪前缀的局域外禀属性(组伪前缀的局域外禀属性, IFinal):
    #虚组伪前缀
class 实组伪前缀的局域外禀属性(组伪前缀的局域外禀属性, IFinal):
    #实组伪前缀
    #~实组伪前缀的全局内禀属性.子伪前缀列表
    #可配置属性，由所在域重新配置：
        解析结果语义值由全局含义转化为局域含义(子伪前缀，不透明解析结果全局语义值)->不透明解析结果局域语义值
    #
    例外情况囗偏好长前缀功能兼容真前缀囗相差后缀无关紧要囗偏序声明
        #[(功能更少伪前缀的局域语义名，功能更多伪前缀的局域语义名)]
        #   功能兼容-偏序关系
        #   由于 实际前缀 可配置，只能 比较 语义，必须是 局部语义
        #       一旦 实际前缀 恰巧 是 同方向 真前缀关系，则可 应用 此例外规则
        #见『真前缀功能兼容的声明可容许某些配置中的真前缀碰撞作为例外但由于偏好长前缀故剩余后缀无关紧要』
class 参与互斥伪前缀的局域外禀属性(实组伪前缀的局域外禀属性, IFinal):
    #仅作为 某域的定义体中使用的数据，是 临时跳板

    [[[过时？？
    全局语义名-内禀属性-跳出用的标识
        #用于 标识，以及 关联负载解析
        #跳转至 相应的 参与互斥伪前缀的全局内禀属性

    #可配置属性，由所在域重新配置：
        局域语义名-外禀属性
        局域伪前缀-外禀属性-非空字符串常量

        解析结果语义值由全局含义转化为局域含义(不透明解析结果全局语义值)->不透明解析结果局域语义值
    ]]]

    [[[====???
    伪前缀集 # {字符串常量}
    伪前缀种类:
        * 循环前冠#->循环前冠短语->前冠短语
        * 功能伪前缀
            * 功能非空类前缀
            * 功能指示符 #必空类#负载必空，本身允空
            * 功能允空类前缀
        * 域始符
        * 域换符
        * [己暨祖]域终符
        #xxx * 待续符
        #xxx 从属于 如冠块类型符: * 后续符
        #xxx * 接续符
        * 如冠块类型符
        * 顶层冠区转顶层尾部荒区的终止解析指示符

    ====
    注意：另外，还有：
        * 后续符<--区体全局信息<--(顶层冠区全局信息 | 域体全局信息<--域始符.域头全局名)
        * [己暨祖]域终符<--域尾全局信息<--域始符.域尾全局名
    ]]]

class 实组伪前缀的全局内禀属性:
    #~实组伪前缀的局域外禀属性
    全局语义名-内禀属性-跳入用的标识
    .子伪前缀列表 # 负载的一部分，不具有 全局语义名，不可重新配置
class 参与互斥伪前缀的全局内禀属性(实组伪前缀的全局内禀属性):
    [[[过时？？
    全局语义名-内禀属性-跳入用的标识
        #用于 标识，以及 关联负载解析
    #xxx.伪前缀集 # {字符串常量}
    #   已移至 外禀属性(参与互斥伪前缀的局域外禀属性)
    ]]]
class 循环前冠(参与互斥伪前缀的全局内禀属性):
    #err:class 循环前冠(参与互斥伪前缀的局域外禀属性):
    .前冠短语全局名#->前冠短语全局信息
    [[[====？下面过时
    负载空否:bool
        #没有 允空 状态
        #内禀属性，与 负载解析 相关，故在此处
    #解析负载
    .短语全局名#->短语全局信息.解析短语负载
    ]]]
class 功能非空类前缀(参与互斥伪前缀的全局内禀属性):
    #负载非空/块尾非空
    #解析负载
    .块尾负载全局名#->块尾负载全局信息.解析块尾负载
class 功能允空类前缀(参与互斥伪前缀的全局内禀属性):
    #负载允空/块尾允空
    #解析负载
    .块尾负载全局名#->块尾负载全局信息.解析块尾负载
class 块尾负载全局信息:
    .块尾负载全局名
    块尾负载允空情形 # 允空vs非空vs必空
    解析块尾负载(子伪前缀, iterator块尾)->(消耗的数据量，不透明解析结果全局语义值, 接续解析与否，可选 改用:域混标识xxx接续域的标识的并集，接续解析允空与否(注意:必空类 本身 可空！))
        新版:混域标识-域体全局名/本域相关的相对路径名(只能是 单域，不再接受 域 的 并集，因为 要 进行 互斥 检查，还是 统一的好)
        iterator 用于 计算 消耗的数据量，确保 自定义终结 没有越界读取/检测
        并集 必须 伪前缀互斥/无歧义(静态)！
            若有，可以解决如下：
                * 新建一个域，对 不互斥 部分 进行调整(如：加 前冠短语)
                    比如：部分 使用 区分前冠，颗粒度 为 碰撞的伪前缀
                * 使用 区分前冠，颗粒度 为 并集 的 子集
class 功能指示符(参与互斥伪前缀的全局内禀属性):
    #负载必空/块尾必空
    #无需 解析负载 直接 得到 结果？
    .块尾负载全局名#->块尾负载全局信息.解析块尾负载
        (子伪前缀)->不透明解析结果全局语义值
class 顶层冠区转顶层尾部荒区的终止解析指示符(参与互斥伪前缀的全局内禀属性):
    .块尾负载全局名#->块尾负载全局信息.解析块尾负载
class 域始符(参与互斥伪前缀的全局内禀属性):
    #无需 域体局域名2域体全局名
    #   因为 静态列出所有可能的返回值
    域体局域名2域体全局名

    域头...混域始块
        .域尾全局名/域尾局域名
        .变成域换符的允许情形
            * 不变
            * 允变
                .变域换符的指示符
            * 必变
                * 必变无指示符
                * 必变带指示符
                    .变域换符的指示符
        四种情形<==>
            .是否必变域换符
                默认 否
            .可选 变域换符的指示符
                默认 域终符
                    <<==域尾全局名->默认囗域终符的局域语义名及子伪前缀


        #见下面 静态列出所有可能的返回值
            .域头局域名2域头全局名
            .域体局域名2域体全局名
        负载空否
        * 负载必空，才有以下属性:
            必是 冠域，必无标签
            #(子伪前缀)->(域头全局名/域头局域名,域体全局名/域体局域名)
            #(子伪前缀)->不透明整域语义参数1
            .子伪前缀2域头局域名
            .子伪前缀2域体局域名
            .子伪前缀2不透明整域语义参数1

        * 负载非空/允空，才有以下属性:
        蛮域与否+可选 读取本域蛮冠的设定短语
            若有 变域换符的指示符&&是蛮域
                则需要 .蛮冠的设定短语的前缀 #以区分 变域换符的指示符 是否 跳过
                (只限定 允变?必变 似无必要，但用户可能不小心跳过，解析器 将 蛮冠的设定短语 的一部分 读成 变域换符的指示符，使 蛮冠 变化)
                ##
            !!!现在 正式改为 无论 是否有 变域换符的指示符，都需要 蛮冠的设定短语的前缀
                更好地 协同 上面的 默认值

        #子伪前缀 是 域始符 的 子伪前缀，先于 局域语法。局域语法 只工作于 局部语义(不含) 之后，域终符(不含) 之前
        #
        .子伪前缀2域头局域语法描述短语#->短语全局信息 => (iterator)->不透明解析结果全局语义值囗语法
        解释域头局域语法描述短语(子伪前缀, 不透明解析结果全局语义值囗语法)->(域头局域名, 域体局域名)
            静态列出所有可能的返回值

        .子伪前缀2域头局域语义描述短语#->短语全局信息 =>(iterator)->不透明解析结果全局语义值囗语义
        解释域头局域语义描述短语(子伪前缀, 不透明解析结果全局语义值囗语义)->(可选囗局域标签，不透明整域语义参数1)

        .子伪前缀2域尾局域标签前冠短语全局名#->前冠短语全局信息 => (域尾局域标签的前缀?, 域尾的相应iterator)->局域标签
            # 多个 域尾局域标签的前缀<-域尾局域标签前冠短语全局名[子伪前缀]->前冠2短语全局名
            # 无需再定义 解释()，局域标签 只能是 原貌字符串
            #
        [[[被替换
        可选 读取并解释域头局域语法描述短语(子伪前缀, iterator)->(域头局域名, 域体局域名)
            静态列出所有可能的返回值
        可选 读取并解释域头局域语义描述短语(子伪前缀, iterator)->(可选 局域标签，不透明整域语义参数1)
        .域尾局域标签的前缀
            #必须与上面的 局域标签 匹配
        可选 读取域尾局域标签短语(子伪前缀, 域尾的相应iterator)->局域标签
        ]]]
        #域头全局名-->读取并解释域头头部如冠块()->(不透明整域语义参数2)#头部如冠块
        #域尾全局名->(是否存在 域终符{域换符vs域始符}, 多个 域终符 的 局域语义名/全局语义名)

class 域换符(域始符):
    变成域换符的允许情形===必变无指示符
        .是否必变域换符=是
        .可选 变域换符的指示符=无
class 蛮区域始符(域始符):
    .蛮冠的设定短语的前缀
    .短语全局名#->短语全局信息.解析短语负载
        读取本域蛮冠的设定短语(iterator)->蛮冠
#xxx class 接续符(参与互斥伪前缀的全局内禀属性):
#xxx class 待续符(参与互斥伪前缀的全局内禀属性):
#xxx class 块单步前置接续中继符
class 如冠块类型符(参与互斥伪前缀的全局内禀属性):
class 后续符(如冠块类型符):
class 块单步前置待续符(如冠块类型符):
class 块单步前置中继符(如冠块类型符):


class 域终符(如冠块类型符):
    域尾...混域终块
        默认囗域终符的局域语义名及子伪前缀
        负载空否
        * 负载非空，才有以下属性:

        #xxx 可选 读取局域标签短语(iterator)->局域标签
        #现移至 域始符: .域尾局域标签的前缀，读取域尾局域标签短语
        #   因为 同一个 域终符 可能 用于 多个 域始符
        .中继信息短语全局名#->中继信息短语全局信息
        [[[太复杂 下面取消
        .中继信息短语的所有尾部循环短语的前缀集
            中继信息短语的所有尾部循环短语的前缀集 用于 区分 其后必定出现的 父域中继符(父域待续符/父域接续符)
            某些 中继信息短语 = ...++(尾部循环短语)*
                尾部循环短语~任何不能在(++)之前 决定 数量的 置于尾部的 短语(并集)
        .中继信息短语的前缀集
            中继信息短语的前缀 用于 区分 其前可能出现的 域尾局域标签的前缀
        ]]]

        #单个？多个？读取多个中继信息短语直至并跳过父域中继符(父域中继符, 中继信息短语的前缀, iterator)->不透明中继信息
        #单个，外部负责提前检查 是否 遇到 父域中继符
        读取中继信息短语并跳过父域中继符(父域中继符, 中继信息短语的前缀, iterator)->不透明中继信息
            中继信息短语=中继信息短语的前缀+iterator



class 中继信息短语全局信息:
    #中继信息短语
    .中继信息短语全局名
    .前冠短语全局名#->前冠短语全局信息
class 前冠短语全局信息:
    .前冠短语全局名
    .前冠2短语全局名#->短语全局信息.解析短语负载
        静态列表 不是函数
class 短语全局信息:
    .短语全局名
    前冠2负载空否(前冠)->负载空否#没有 允空 情形，因为 允空 必然 导致 越界检查
    解析短语负载(前冠, iterator)->(消耗的数据量，不透明解析结果全局语义值)
        iterator 用于 计算 消耗的数据量，确保 自定义终结 没有越界读取/检测

class 区体全局信息:
    区的全局名
    .中继相关符(待续符|后续符|接续符|块单步前置待续符 | 块单步前置中继符)

        ##皆 非空，待续符=!=接续符
        后续符 无默认值
            参与互斥！！
        默认 待续符=后续符
            ！！不参与互斥
        默认 接续符=待续符++后续符 #后续符 在后
            ！！不参与互斥
            #由于 待续符 是 必空类，故与 接续符 相容
        块单步前置待续符 无默认值
            参与互斥！！
            #xxx 默认 块单步前置待续符=待续符
            #见『取消块单步前置待续符默认值为待续符』
            #可能的合理实现：块单步前置待续符=返身符++待续符，如：『.-』

        默认 块单步前置中继符=后续符++块单步前置待续符 #后续符 在前
            参与互斥！！
            #注意：块单步前置中继符 默认值(后续符++块单步前置待续符) 与 后续符 碰撞，后续符 是其 真前缀，但幸好 功能也被兼容。
        默认 块单步前置接续中继符=接续符++块单步前置待续符 #接续符 在前
            ！！不参与互斥
            接触 前块，与 待续符/接续符 竞争
            #注意：块单步前置接续中继符 默认值(接续符++块单步前置待续符) 与 接续符 碰撞，接续符 是其 真前缀，但幸好 功能也被兼容。
            #   xxx ==>> 『真前缀功能兼容的声明可容许某些配置中的真前缀碰撞作为例外但剩余后缀也要参与互斥并且功能被兼容』
            #   ==>> 『真前缀功能兼容的声明可容许某些配置中的真前缀碰撞作为例外但由于偏好长前缀故剩余后缀无关紧要』

            #注意：旧版 默认值下，块单步前置待续符=待续符=后续符，到底是 后续 还是 待续？有问题！！！==>>『取消块单步前置待续符默认值为待续符』
            #   #虽然，块单步前置中继符=后续符++块单步前置待续符=后续符++待续符=后续符++后续符=待续符++后续符=接续符，但 前者 不触，后者 接触，没有 竞争关系。这倒没有问题。

    .区中继全局名#->区中继全局信息
        默认 自身
    域体的参与互斥伪前缀的局域外禀属性的列表
        # [参与互斥伪前缀的局域外禀属性]
        # 局域语义名2全局语义名

    引用它区囗囗区体全局名列表
    引用它区囗囗相对路径局域名
        # [(祖域起止范围,可选 [(裔域起止范围,可选 局域名)])]
        # 起止范围 :: 有序不触不空[(起,止)]
class 顶层冠区全局信息(区体全局信息):
    顶层冠区全局名
    .顶层冠区转顶层尾部荒区的终止解析指示符的局域外禀属性的列表
        # 局域语义名2全局语义名
        #顶层冠区
        #顶层尾部荒区
class 域体全局信息(区体全局信息):
    #无 蛮冠 信息，由 域始符 负责
    域体全局名
class 域头全局信息:
    #not bug but mv as member:class 域头全局信息(区体全局信息):
    域头全局名
    .区体全局信息 # 用于 读取 头部如冠块
        读取头部如冠块(iterator块尾)->头部如冠块
class 区中继全局信息:
    区中继全局名
    .区体全局信息 # 用于 读取 中继如冠块
        读取中继如冠块(iterator块尾)->中继如冠块
class 域尾全局信息:
    #bug:class 域尾全局信息(区体全局信息):
    域尾全局名
    默认域终符的局域语义名
        #变域换符的指示符 的 默认值
    域终符的局域外禀属性的列表
        # [参与互斥伪前缀的局域外禀属性]
        # 局域语义名2全局语义名

#]]]'''

#:src_start
from seed.abc.abc import ABC, abstractmethod, override, not_implemented, ABCMeta
from seed.abc.IFinal import IFinal

class 组伪前缀的局域外禀属性(IFinal):
    #.组伪前缀=.父虚组伪前缀++.局域伪前缀
    全局语义名
    局域语义名
    局域伪前缀
    可选囗父虚组伪前缀的局域外禀属性
class 虚组伪前缀的局域外禀属性(组伪前缀的局域外禀属性):
    #虚组伪前缀
    pass
class 实组伪前缀的局域外禀属性(组伪前缀的局域外禀属性):
    #实组伪前缀
    #~实组伪前缀的全局内禀属性
    解析结果语义值由全局含义转化为局域含义(子伪前缀，不透明解析结果全局语义值)->不透明解析结果局域语义值
    例外情况囗偏好长前缀功能兼容真前缀囗相差后缀无关紧要囗偏序声明
        #[(真前缀，长前缀)]
class 参与互斥伪前缀的局域外禀属性(实组伪前缀的局域外禀属性):
    #仅作为 某域的定义体中使用的数据，是 临时跳板

class 实组伪前缀的全局内禀属性:
    #~实组伪前缀的局域外禀属性
    全局语义名
    子伪前缀列表
        # 负载的一部分，不具有 全局语义名，不可重新配置
class 参与互斥伪前缀的全局内禀属性(实组伪前缀的全局内禀属性):
    pass
class 循环前冠(参与互斥伪前缀的全局内禀属性):
    .前冠短语全局名#->前冠短语全局信息
class 功能非空类前缀(参与互斥伪前缀的全局内禀属性):
    #负载非空/块尾非空
    .块尾负载全局名#->块尾负载全局信息.解析块尾负载
class 功能允空类前缀(参与互斥伪前缀的全局内禀属性):
    #负载允空/块尾允空
    .块尾负载全局名#->块尾负载全局信息.解析块尾负载
class 块尾负载全局信息:
    块尾负载全局名
    块尾负载允空情形 # 允空vs非空vs必空
    解析块尾负载(子伪前缀, iterator块尾)->(消耗的数据量，不透明解析结果全局语义值, 接续解析与否，可选囗域混标识，接续解析允空与否)

class 功能指示符(参与互斥伪前缀的全局内禀属性):
    #负载必空/块尾必空
    .块尾负载全局名#->块尾负载全局信息.解析块尾负载
    静态解析(子伪前缀)->不透明解析结果全局语义值
class 顶层冠区转顶层尾部荒区的终止解析指示符(参与互斥伪前缀的全局内禀属性):
    .块尾负载全局名#->块尾负载全局信息.解析块尾负载
class 域始符(参与互斥伪前缀的全局内禀属性):
TODO

