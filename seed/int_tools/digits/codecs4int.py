#__all__:goto
#_history:goto
doing...
TODO:goto
r'''[[[
e ../../python3_src/seed/int_tools/digits/codecs4int.py
view others/数学/编程/设计/自定义字符编码.txt
view others/数学/编程/设计/自定义字符编码-兼容utf8.txt
view others/数学/编程/设计/自定义编码之要点.txt
view ../../python3_src/seed/int_tools/DigitReader.py
view ../../python3_src/seed/int_tools/RadixInfo.py
view ../../python3_src/seed/int_tools/StepDecoder.py

seed.int_tools.digits.codecs4int
py -m nn_ns.app.debug_cmd   seed.int_tools.digits.codecs4int -x # -off_defs
py -m nn_ns.app.doctest_cmd seed.int_tools.digits.codecs4int:__doc__ -ht # -ff -df



[[
view others/数学/编程/设计/自定义字符编码.txt
本模块所有编码器满足以下约束:
    支持词典序#lexicographic order
    分级前置长度#逐步推进分级前置长度型编码方案
    ++{受控范围内胞串内部向外识别两端边界,双端内敛,字节串搜索,字节串词典序}

]]




py_adhoc_call   seed.int_tools.digits.codecs4int   @f
from seed.int_tools.digits.codecs4int import *
]]]'''#'''

#_history =
r'''[[[[[[[
这里是过往历史，归结为:
    view others/数学/编程/设计/自定义编码之要点.txt
    view others/数学/编程/设计/自定义字符编码-兼容utf8.txt
===
[[
view others/数学/编程/设计/自定义字符编码.txt
本模块所有编码器满足以下约束:
    支持词典序#lexicographic order
    分级前置长度#逐步推进分级前置长度型编码方案
    ++{受控范围内胞串内部向外识别两端边界,双端内敛,字节串搜索,字节串词典序}

]]
[[
@20250615
简化设计:
    ===
    假设:充分大之后，躯部为二幂胞串:
        [[充分大] => [躯部::[uint%(2**C)]]]
    ===
    假设:充分大之后，整体分为五部分(只有两层长度):
        [[充分大] => [整编码==固定头部牜充分大(可能含动态爻元=>计入固定偏移量)++动态爻元计数用胞串(长度纟长度纟躯部)++?混合胞?(可能混合含半胞纟动态爻元丶半胞纟长度纟躯部)++胞串纟长度纟负载++胞串纟负载]]
            # [躯部==后四部分|后两部分(没有混合胞)]
            # * [躯部==后两部分]:比如:[码胞::[uint%10]][躯胞::uint%8][用『9』来做动态爻元][没有混合胞]
    ===
]]
[[
@20250708
[编码==宏头胞++躯部]
[宏头胞 :: uint%H]
[躯部 :: [躯胞]]
[躯胞 :: uint%R]
#初版:[分区表纟宏头胞 :: [(总层数/uint,数目/uint,映射)]]
[分区表纟宏头胞 :: [(总层数/uint,数目/uint,[(层序数/uint,映射)])]]
    [映射 :: (偏移量/uint|离散映射表/[uint])]
    [偏移扌(映射;uint%数目) =[def]= ((uint%数目+偏移量)|离散映射表[(uint%数目)])]
        #偏移于某些层
[H==表达空间规模纟宏头胞==sum(map(snd,分区表纟宏头胞))]
    #第0层=>偏移扌(映射;uint%数目) 是 立即数
    #第n+1层=>偏移扌(映射;uint%数目) 是 长度{第n层}
    #以上是 不规则的有限区
    #第-1层=>偏移扌(映射;uint%数目) 是 动态扩展(宏头胞)/规则的无限区
    #   ？自动扩展方案？
    #第-2层=>特殊值区(比如:无穷大)
[编码空间规模纟不规则的有限区 =[def]= 1+max(最大值纟表达{第n层} for n in [0..])]
    作为 阈值 分隔 有限区、无限区
[分区表纟躯胞冃颈胞 :: [(总层数/uint,数目/uint,映射)]]
    => 自动扩展方案
为啥区分出『宏头胞』？
    1. 比如:采用『数字+英文字母』作字母表:
        为避免标识名，令 头胞 为数字
        为避免全数字，简单点，令 颈胞 为字母
        => regex"([69][A-Z])[0-578A-Z]*"
        其中:
            regex"([69][A-Z])" 是 宏头胞(==头胞+颈胞)
            regex"[0-578A-Z]" 是 躯胞
            #若 二幂 => 考虑改动:([0-578A-Z] --> [0-5A-Z]or[0-578A-X])
    2. 为了 前刹(左端内敛)，简单点，令  符集纟头胞 与 符集纟非头胞 无交集。
        或:
        => regex"([89][A-Y])[1-7A-Y]*"
            # 保留[0Z] # 正负无穷大
            # [A-Y]:25:0b11001==16+8+1
        #不简单的方案，比如:多单元联合前缀-单端版
]]
[[
如何表达 任意基数的进位数制？
    基数任意大 => 数字 必须要能 表达 任意自然数
    数字的编码 必须 内敛(前刹&&后刹)
==>>:
radix_digit的一个编码方案:
    字母表:[0-9A-Za-z]
    # [10+26*2==62==30+32==(16+8+4+2)+32]
    头胞集:[0-9A-T] #30
    躯胞集:[U-Za-z] #32
        #颈身躯胞
    # regex"[0-9A-T][U-Za-z]*"
    单胞码: regex"[0-9A-F]"
        # 16==10+6==2**4
    双胞码: regex"[G-N][U-Za-z]"
        # 256==8*32==2**8
    三胞码: regex"[O-R][U-Za-z][U-Za-z]"
        # 4096==4*32*32==2**12
    三层码: regex"[ST][U-Za-z]+"
        # 见下面:『动态爻元 vs 动态苞元』
        # !! 使用 动态爻元 而非 动态苞元
        regex"S([U-Za-z])[U-Za-z]{len==第一层数}"
        regex"S([U-Za-z][U-Za-z]{0})[U-Za-z]{len==第一层数}"
            # [0..<32**31]
            # [0..<2**155]
        [n>=0]:
            # !! 动态爻元
            # 32==16+8+4+2+1+1
            # [U-Za-z]==[U-Za-j]+[k-r]+[s-v]+[wx]+[y]+[z]
            regex"(Tz{n})([U-Za-j][U-Za-z]{(1+5*n+1)-(n+1)})[U-Za-z]{len==第一层数}"
                # [0..<32**(16*32**(4*n+1)-1)]
                # [0..<32**(2**(20*n+9)-1)]
            regex"(Tz{n})([klmnopqr][U-Za-z]{(1+5*n+2)-(n+1)})[U-Za-z]{len==第一层数}"
                # [0..<32**(8*32**(4*n+2)-1)]
                # [0..<32**(2**(20*n+13)-1)]
            regex"(Tz{n})([stuv][U-Za-z]{(1+5*n+3)-(n+1)})[U-Za-z]{len==第一层数}"
                # [0..<32**(4*32**(4*n+3)-1)]
                # [0..<32**(2**(20*n+17)-1)]
            regex"(Tz{n})([wx][U-Za-z]{(1+5*n+4)-(n+1)})[U-Za-z]{len==第一层数}"
                # [0..<32**(2*32**(4*n+4)-1)]
                # [0..<32**(2**(20*n+21)-1)]
            regex"(Tz{n})(y[U-Za-z]{(1+5*n+5)-(n+1)})[U-Za-z]{len==第一层数}"
                # [0..<32**(1*32**(4*n+5)-1)]
                # [0..<32**(2**(20*n+25)-1)]
    => ...
]]
[[
又一个自然数编码:
词典序
字母表:94#ASCII.alnum+punct
    # [printable%95 == alnum%(10+26*2==62) | punctuation%32 | space%1]
    #   view ../../python3_src/seed/text/mk_char_pt_ranges5predicator.py
躯胞集:64==2**6
头胞集:30==94-64==16+8+4+2

[20902: [一-龥] ~ [4E00..9FA5]]
    [2**15==32769 > 20902]
    但发现 在 词典序 前提下 不能优先支持 基位面汉字区:
        !! [ord('龥')==40869>32769==2**15]
            #8000多
        !! [ord('一')==19968<32769==2**15]
            #12000多

偏好支持统合码{字节&基位面}:
    双胞码:4*64==2**8
    三胞码:16*64*64==2**16
    四胞码:4*64*64*64==2**20
    单胞码:4==2**2
    三层码{4}:2*64**?
偏好支持八进制数{字节&基位面}:
    单胞码:8==2**3
    双胞码:4*64==2**8
    三胞码:16*64*64==2**16
    三层码{3}:2*64**?
        或:跳过 四胞码:
            五胞码:1*64*64*64*64==2**24
            三层码{5}:1*64**?
偏好支持十六进制数{字节&xxx基位面汉字区}:
    单胞码:16==2**4
    双胞码:4*64==2**8
    三胞码:8*64*64==2**15
    三层码{3}:2*64**?
        或:跳过 四胞码:
            五胞码:1*64*64*64*64==2**24
            三层码{5}:1*64**?
偏好支持十进制数{字节&xxx基位面汉字区}:
    单胞码:10
    双胞码:4*64==2**8
    三胞码:8*64*64==2**15
    四胞码:6*64*64*64==2**20+2**19
    三层码{4}:2*64**?
<有限:局限于基位面>偏好支持十进制数{字节&基位面}:
    单胞码:10
    双胞码:4*64==2**8
    三胞码:16*64*64==2**16
    <完>

==>>:
细化:三层码{3|4|5}:(1|2)*64**?
三层码{偏移量纟解压值纟宏头胞}:2*64**?
宏头胞集:2==2**1 or 1==2**0
躯胞集:64==2**6
[偏移量纟解压值纟宏头胞 <- {3,4,5}]
    #非 偏移量纟存储值纟宏头胞/offset4macro_head_digit
]]
[[
动态爻元 vs 动态苞元:
    源起:『radix_digit的一个编码方案』从 动态苞元 改为 动态爻元
==>>:
动态爻元 vs 动态苞元:
动态爻元 vs 大步动态爻元 vs 动态苞元:
动态爻元 vs 大步动态爻元 vs 动态苞元 vs 殿后动态苞元:
#######
发现:编码方案{殿后动态苞元}还不错，缺点 可能就是 初始开销占比大
    => 编码方案{偏殿后动态苞元} 以改善 初始开销
    ++变体:融合 大步 => 编码方案{大步偏殿后动态苞元}
    ++变体:动态爻元  => 编码方案{大步固殿后动态爻元}
        ++变体:变长  => 编码方案{变步变殿后动态爻元}
see:IPlugin4InfiniteInterval
#######
前导长度的极限编码效率(由高至低):
    [L:=爻元数纟躯胞]
    [H:=爻元数纟前半躯胞][1<=H<=L]
    [E:=爻元数纟殿后爻元][E>=0] #允许[E>L]
    [step:=步长][step>=1]
    编码方案{变步变殿后动态爻元}
    编码方案{大步固殿后动态爻元}:
        (1-2**-E/(step*L))*L (单位:爻元/躯胞)
    编码方案{大步偏殿后动态苞元}:
        (1-2**-H/(step-(step-1)*2**-H))*L (单位:爻元/躯胞)
    编码方案{殿后动态苞元}
        (1-2**-L)*L (单位:爻元/躯胞)
    编码方案{偏殿后动态苞元}:
        (1-2**-H)*L (单位:爻元/躯胞)
    编码方案{大步动态爻元}:
        (1-1/(step*L))*L (单位:爻元/躯胞)
    编码方案{动态爻元}:
        (1-1/L)*L (单位:爻元/躯胞)
    编码方案{动态苞元}:
        (1-1/2)*L (单位:爻元/躯胞)
<<==:
#######
编码方案{动态爻元}:
    regex"【固定前缀】【最大躯胞】{n}(【躯胞:i动态爻元+k负载爻元】【躯胞】{(n*L+i)-(n+1)+C})【躯胞】{len==第一层数}"
    [L:=爻元数纟躯胞]
    [i+k==L][i>=0][k>0]
    重调次序:
    regex"【固定前缀】(【最大躯胞】{n}【躯胞:i动态爻元+k负载爻元】【躯胞】{n*(L-1)+i})【躯胞】{C-1}【躯胞】{len==第一层数}"
    重调次序，忽略前后缀:
    regex"(【最大躯胞】{n}【躯胞:i动态爻元+(L-i)负载爻元】【躯胞】{n*(L-1)+i})"
    重调次序，忽略前后缀，打散成爻元:
    regex"【动态爻元】{n*L+i}【负载爻元】{(n*(L-1)+i)*L+(L-i)}"
    regex"【动态爻元】{n*L+i}【负载爻元】{(n*L+i)*(L-1)+L}"
    重调次序，忽略前后缀，打散成爻元，再重调次序:
    regex"【动态爻元】{n*L+i}【负载爻元】{(n*L+i)*(L-1)}【负载爻元】{L}"
    regex"(【动态爻元】【负载爻元】{L-1}){n*L+i}【负载爻元】{L}"
    重调次序，忽略前后缀，打散成爻元，再重调次序，忽略后缀:
    regex"(【动态爻元】【负载爻元】{L-1}){n*L+i}"
    => 每L爻元 中 只有(L-1)个 爻元 提供 有效负载
    => 每L躯胞 中 只有(L-1)个 躯胞 提供 有效负载
#######
编码方案{大步动态爻元}:
    regex"【固定前缀】【最大躯胞】{n}(【躯胞:i动态爻元+k负载爻元】【躯胞】{step*(n*L+i)-(n+1)+C})【躯胞】{len==第一层数}"
    [L:=爻元数纟躯胞]
    [i+k==L][i>=0][k>0]
    [step:=步长][step>=1]
    => 每增加step*L爻元 中 只有(step*L-1)个 新增爻元 提供 有效负载
    => 每step*L躯胞 中 只有(step*L-1)个 躯胞 提供 有效负载
#######
编码方案{动态苞元}:
    regex"【固定前缀】【最大躯胞】{n}(【非最大躯胞】【躯胞】{n+C-1})【躯胞】{len==第一层数}"
    重调次序:
    regex"【固定前缀】(【最大躯胞】{n}【躯胞】{n})【非最大躯胞】【躯胞】{C-1}【躯胞】{len==第一层数}"
    重调次序，忽略前后缀:
    regex"(【最大躯胞】{n}【躯胞】{n})"
    重调次序，忽略前后缀，再重调次序，:
    regex"(【最大躯胞】【躯胞】){n}"
    => 每2躯胞 中 只有1个 躯胞 提供 有效负载
#######
编码方案{殿后动态苞元}:
    regex"【固定前缀】(【最大躯胞】{n}【非最大躯胞:值d】)(【躯胞】{(n*(R-1)+d)+C})【躯胞】{len==第一层数}"
    [R:=空间规模纟躯胞][R>=2]
    [0<=d<=R-2]
    重调次序:
    regex"【固定前缀】(【最大躯胞】{n}【非最大躯胞:值d】【躯胞】{(n*(R-1)+d)})【躯胞】{C}【躯胞】{len==第一层数}"
    重调次序，忽略前后缀:
    regex"(【最大躯胞】{n}【非最大躯胞:值d】【躯胞】{(n*(R-1)+d)})"
    => 每((n+1)+(n*(R-1)+d))躯胞 中 只有(n*(R-1)+d)个 躯胞 提供 有效负载
#######
编码方案{偏殿后动态苞元}:
    regex"【固定前缀】(【最大躯胞】{n}【非最大前半躯胞:值d+后半躯胞】)(【躯胞】{(n*(D-1)+d)+C-1})【躯胞】{len==第一层数}"
    [R:=空间规模纟躯胞]
    [D:=空间规模纟前半躯胞]
    [R>=D>=2][R%D==0]
    [0<=d<=D-2]
    重调次序:
    regex"【固定前缀】(【最大躯胞】{n}【非最大躯胞:值d】【躯胞】{(n*(D-1)+d)})【躯胞】{C-1}【躯胞】{len==第一层数}"
    重调次序，忽略前后缀:
    regex"(【最大躯胞】{n}【非最大躯胞:值d】【躯胞】{(n*(D-1)+d)})"
    => 每((n+1)+(n*(D-1)+d))躯胞 中 只有(n*(D-1)+d)个 躯胞 提供 有效负载
#######
编码方案{大步偏殿后动态苞元}:
    regex"【固定前缀】(【最大躯胞】{n}【非最大前半躯胞:值d+后半躯胞】)(【躯胞】{step*(n*(D-1)+d)+C-1})【躯胞】{len==第一层数}"
    [R:=空间规模纟躯胞]
    [D:=空间规模纟前半躯胞]
    [R>=D>=2][R%D==0]
    [0<=d<=D-2]
    [step:=步长][step>=1]
    重调次序:
    regex"【固定前缀】(【最大躯胞】{n}【非最大躯胞:值d】【躯胞】{step*(n*(D-1)+d)})【躯胞】{C-1}【躯胞】{len==第一层数}"
    重调次序，忽略前后缀:
    regex"(【最大躯胞】{n}【非最大躯胞:值d】【躯胞】{step*(n*(D-1)+d)})"
    => 每((n+1)+step*(n*(D-1)+d))躯胞 中 只有step*(n*(D-1)+d)个 躯胞 提供 有效负载
#######
编码方案{大步固殿后动态爻元}:
    regex"【固定前缀】【最大躯胞】{n}(【m个?躯胞:i动态爻元+E殿后爻元(值d)+k负载爻元】【躯胞】{step*((n*L+i)*2**E+d)-(n+m)+C})【躯胞】{len==第一层数}"
    [L:=爻元数纟躯胞]
    [E:=爻元数纟殿后爻元][E>=0] #允许[E>L]
    [0<=i<L]
    [m:=ceil_div(i+E+1,L)]
    [m <= ceil_div((L-1)+E+1,L) == 1+ceil_div(E,L)]
    [k:=m*L-(i+E)]
    [i+E+k==m*L][0<k<=L]
    [0<=d<2**E]
    [step:=步长][step>=1]
    => 每增加step*L*2**E爻元 中 只有(step*L*2**E-1)个 新增爻元 提供 有效负载
    => 每step*L*2**E躯胞 中 只有(step*L*2**E-1)个 躯胞 提供 有效负载
#######
编码方案{变步变殿后动态爻元}:
    regex"【固定前缀】【最大躯胞】{n}(【m_(n*L+i)个?躯胞:i动态爻元+E_(n*L+i)殿后爻元(值d)+k_(n*L+i)负载爻元】【躯胞】{step_(n*L+i)*(offset_(n*L+i)+d)-(n+m_(n*L+i))+C})【躯胞】{len==第一层数}"
    [L:=爻元数纟躯胞]
    # [w==数目纟动态爻元==(n*L+i)]
    [E_(w):=爻元数纟殿后爻元{w}][E_(w)>=0] #允许[E_(w)>L]
    [offset_(w):=sum{2**E_(y) | [y:<-[0..<w]]}]
    [0<=i<L]
    [m_(w):=let [i:=w%L] in ceil_div(i+E_(w)+1,L)]
    [m_(w) <= ceil_div((L-1)+E_(w)+1,L) == 1+ceil_div(E_(w),L)]
    [k_(w):=let [i:=w%L] in m_(w)*L-(i+E_(w))]
        let [i:=w%L] in [i+E_(w)+k_(w)==m_(w)*L][0<k_(w)<=L]
    [0<=d<2**E_(w)]
    [step_(w):=步长][step_(w)>=1]
    => ...???
#######
==>>:
    [前导长度的极限编码效率{动态爻元} == (爻元数纟躯胞-1) (单位:爻元/躯胞)]
        # == L (爻元/躯胞) *(L-1)胞 /(L胞)
        # == L (爻元/躯胞) *(1-1/L)
    [前导长度的极限编码效率{大步动态爻元} == (爻元数纟躯胞-1/步长) (单位:爻元/躯胞)]
        # == L (爻元/躯胞) *(step*L-1)胞 /(step*L胞)
        # == L (爻元/躯胞) *(1-1/(step*L))
    [前导长度的极限编码效率{动态苞元} == (爻元数纟躯胞/2) (单位:爻元/躯胞)]
    [前导长度的极限编码效率{殿后动态苞元} == (爻元数纟躯胞*(1-2**-爻元数纟躯胞)) (单位:爻元/躯胞)]
        # == limit{(L (爻元/躯胞) *(n*(R-1)+d)胞 /(((n+1)+(n*(R-1)+d))胞)) | n-->+oo}
        # == L(爻元/躯胞) / (1/(R-1) +1)
        # == L(爻元/躯胞) *(R-1)/R
        # == L(爻元/躯胞) *(1-1/R)
        # == L(爻元/躯胞) *(1-2**-L)
    [前导长度的极限编码效率{偏殿后动态苞元} == (爻元数纟躯胞*(1-2**-爻元数纟前半躯胞)) (单位:爻元/躯胞)]
        # == limit{(L (爻元/躯胞) *(n*(D-1)+d)胞 /(((n+1)+(n*(D-1)+d))胞)) | n-->+oo}
        # == L(爻元/躯胞) / (1/(D-1) +1)
        # == L(爻元/躯胞) *(D-1)/D
        # == L(爻元/躯胞) *(1-1/D)
        # :> [H:=爻元数纟前半躯胞]
        # == L(爻元/躯胞) *(1-2**-H)
    [前导长度的极限编码效率{大步偏殿后动态苞元} == (爻元数纟躯胞*(1-2**-爻元数纟前半躯胞/(步长-(步长-1)*2**-爻元数纟前半躯胞))) (单位:爻元/躯胞)]
        # == limit{(L (爻元/躯胞) *step*(n*(D-1)+d)胞 /(((n+1)+step*(n*(D-1)+d))胞)) | n-->+oo}
        # == L(爻元/躯胞) / (1/(step*(D-1)) +1)
        # == L(爻元/躯胞) *(1-1/(1+step*(D-1)))
        # == L(爻元/躯胞) *(1-1/(step*D-(step-1)))
        # :> [H:=爻元数纟前半躯胞]
        # == L(爻元/躯胞) *(1-1/(step*2**H-(step-1)))
        # == L(爻元/躯胞) *(1-2**-H/(step-(step-1)*2**-H))
    [前导长度的极限编码效率{大步固殿后动态爻元} == (爻元数纟躯胞*(1-2**-爻元数纟殿后爻元/(步长*爻元数纟躯胞))) (单位:爻元/躯胞)]
        # == limit{(L (爻元/躯胞) *(step*((n*L+i)*2**E+d)-(n+m-k/L)+C)胞 /(step*((n*L+i)*2**E+d)胞)) | n-->+oo}
        # == L(爻元/躯胞) *(step*L*2**E-1)/(step*L*2**E)
        # == L(爻元/躯胞) *(1-1/(step*L*2**E))
        # == L(爻元/躯胞) *(1-2**-E/(step*L))
==>>:
    [前导长度的极限编码效率{动态爻元} == 前导长度的极限编码效率{大步动态爻元}{步长==1}]
    [前导长度的极限编码效率{动态苞元}{胞元==爻元} == 前导长度的极限编码效率{大步动态爻元}{步长==2}{胞元==爻元}]
    [前导长度的极限编码效率{动态苞元}{胞元==爻元} == 前导长度的极限编码效率{殿后动态苞元}{胞元==爻元}]
    [前导长度的极限编码效率{偏殿后动态苞元}{爻元数纟前半躯胞==爻元数纟躯胞} == 前导长度的极限编码效率{殿后动态苞元}]
    [前导长度的极限编码效率{大步偏殿后动态苞元}{步长==1} == 前导长度的极限编码效率{偏殿后动态苞元}]
    [前导长度的极限编码效率{大步动态爻元} == 前导长度的极限编码效率{大步固殿后动态爻元}{爻元数纟殿后爻元==0}]
==>>:
[前导长度的极限编码效率{动态爻元} < 前导长度的极限编码效率{动态苞元}]
    <==> [(爻元数纟躯胞-1) < (爻元数纟躯胞/2)]
    <==> [爻元数纟躯胞 < 2]
    <==> [爻元数纟躯胞 == 1]
==>>:
[前导长度的极限编码效率{大步动态爻元} == 前导长度的极限编码效率{殿后动态苞元}]
    <==> [(爻元数纟躯胞-1/步长) == (爻元数纟躯胞*(1-2**-爻元数纟躯胞))]
    <==> [(L-1/步长) == (L*(1-2**-L))]
    <==> [L/(2**L) == 1/步长]
    <==> [步长 == (2**L)/L]
    <==> [b:=log2(L)][L == 2**b][步长 == 2**(L-b)]
    <==> [(爻元数纟躯胞,步长) <- {(1,2), (2,2), (4,4), (8,32), (16,2**12), (32,2**27), ... ...}]
]]
[[
copy from: e ../../python3_src/seed/int_tools/digits/codecs4int.py
copy to:e ../lots/NOTE/abbr/software.txt
copy to:e others/数学/编程/设计/自定义字符编码.txt
===
@20250721
源起:命名有点乱:歧义:
    胞<字<码#cell<word<code
    爻<胞<码#bit<cell<code
重新命名:
    ######################
    具象物理组构体系:(基粒==)孢<(字==符==)荚<码<包#spore<pod<code<packet
    #######
    [包=[def]=编码方案{整数序列}.码元]
    [码=[def]=编码方案{整数}.码元]
    [荚=[def]=具象物理单元/(存储单元|传输单元|编码方案.字母表)]
    [孢=[def]=最小的幂根{荚}]
        #from seed.math.factor_pint_as_pefect_power_ import factor_pint_as_pefect_power_
    #######
    [包==码串::[码]]
    [码.具象物理组构==荚串::[荚]]
    [荚==孢串::[孢]]
    [孢::uint%radix]
        # eg:[孢:=爻元]
        where:
            [not is_perfect_power(radix)]
    ######################
    抽象逻辑组构体系:(胞|宏胞)==苞<码<包#(cell|macro_cell)==bud<code<packet
    #######
    [苞=[def]=(胞|宏胞)]
    [胞=[def]=有效负载空间{荚{某类码元中某个位置}}]
      # eg:将 编码方案.字母表 分为4个不相交的子集:孤符集,头符集,体符集,尾符集
      #     =>2类码元4类胞元:{孤胞码{孤胞},多胞码{头胞+体胞*+尾胞}}
      #     =>不同类的胞元 对应不同的 字母表，有效负载空间也不必相同。
    [宏胞=[def]=有效负载空间{荚串{某类码元中某些位置}}]
      # 人为边界: 将 某些胞 人为组合起来 统一分配/编码
    #######
    [包==码串::[码]]
    [码.抽象逻辑组构==苞串::[苞]]
    ######################
<<==:
#这一部分已删除，可见于: view ../lots/NOTE/abbr/software.txt
]]

重命名:
    尾胞-->躯胞
    尾部-->躯部
    :%s/尾/躯/g
        除了上面:『尾符集...2类码元4类胞元:...尾胞』

重命名:
    以匹配layer0#从零开始
    第一层-->第零层
    第二层-->第一层
    第三层-->第二层
    或许:甲层，乙层，丙层



[[
TODO
[:doc4IPlugin4InfiniteInterval]:here
    move from:IPlugin4InfiniteInterval.__doc__

######################
汇集处纟约束牜非平凡:
    [:约束牜紧凑乊首层]:goto
######################
主打方案:编码方案{变步变殿后动态爻元}
######################
[首层==第零层==layer0==(dynamic_part{len_dynamic_bits}++follower_part{len_dynamic_bits})]
    [len_dynamic_bits :: uint{>=0}]
    [dynamic_part == regex"1*0"/bits]
    [dynamic_part{len_dynamic_bits} == regex"1{len_dynamic_bits}0"/bits]
    [(dynamic_part,follower_part) ~ (序号纟分段,编码空间纟分段)]
        #采用 分段累积法{len_dynamic_bits==序号纟分段}
每一层 都存储一个 自然数:
    分2种形式:
        *[压缩值==物理存储值]
            [压缩值 是 稠密分布的]
                #eg:第零层:采用 分段累积法{len_dynamic_bits}
            [let [len_dynamic_bits:=classify_compressed_uint6layer0(压缩值{第零层})] in [(len_dynamic_bits+1+num_bits4follower4dynamic_part{len_dynamic_bits}+解压值{第零层})%num_bits4cell6body==0]]
                # [:约束牜紧凑乊首层]:here
                # 即 (dynamic_part++follower_part++payload_bit_block)凑成整躯胞串
        *[解压值==逻辑实用值]
            [解压值 可能是 稀疏分布的]
                #有损压缩:偏移+二分搜索/跃迁
            [解压值{末层} 是 稠密分布的]
                #无损压缩:只能偏移
            #记录 目标自然数
            [解压值{末层}==值纟整编码]
            #记录 第一层 爻元数
            [解压值{第零层}
                >=第一层.压缩值.数目纟爻元
                ==第一层.压缩值.bit_length()
            ]
            #记录 第二层诸后 躯胞数
            #   或许 应该 统一为 爻元数
            [解压值{非末层&&非第零层}
                >=下一层.压缩值.数目纟躯胞
                ==1+floor_log_(2**爻元数纟躯胞;下一层.压缩值)
                ==ceil_log_(2**爻元数纟躯胞;1+下一层.压缩值)
                ==ceil_div_(爻元数纟躯胞;ceil_log2_(1+下一层.压缩值))
                ==ceil_div_(爻元数纟躯胞;下一层.压缩值.bit_length())
            ]
######################

]]
[[
TODO
独力单层编解码器
单层编码器
单层解码器
    只能处理一层:动态爻元、动态苞元、定长爻元串、定长躯胞串

#######
单层解码器{爻元串}:动态爻元,定长爻元串
    内禀属性:(爻元数纟躯胞,最大值纟躯胞)
    输入:(爻元数纟宏头胞,?最大值纟宏头胞?;值纟宏头胞,读者牜躯胞;??定长爻元数纟消耗??)
    输出:(值纟读出;爻元数纟消耗;爻元数纟宏头胞{剩余},?最大值纟宏头胞{剩余}?;值纟宏头胞{剩余},读者牜躯胞{剩余})
        #宏头胞{剩余} 来自于 低爻位{原输入宏头胞|最后读出的躯胞}
#######
单层解码器{苞元串}:动态苞元,定长躯胞串
    内禀属性:(爻元数纟躯胞,最大值纟躯胞)
    输入:(?已读出首躯胞?,读者牜躯胞;??定长躯胞数纟消耗??)
    输出:(值纟读出;躯胞数纟消耗;?已读出首躯胞{剩余}?,读者牜躯胞{剩余})
#######
#######
单层编码器{爻元串}:动态爻元,定长爻元串
    内禀属性:(爻元数纟躯胞,最大值纟躯胞)
    [0 <= 爻元数纟追附 < 爻元数纟躯胞]
    输入:(值纟编入,爻元数纟追附,值纟追附;??定长爻元数纟输出??)
    输出:(爻元数纟追附{剩余},值纟追附{剩余},躯胞串纟输出;??爻元数纟输出??)
        编码=>逆向迭代输出 躯胞串
#######
单层编码器{苞元串}:动态苞元,定长躯胞串
    内禀属性:(爻元数纟躯胞,最大值纟躯胞)
    输入:(值纟编入;??定长躯胞数纟输出??)
    输出:(躯胞串纟输出;??躯胞数纟输出??)
#######
]]
[[
插件:
    *有限区
        *有限区牜有限层
    *无限区
        *无限区牜有限层
            首层:动态爻元++变长殿后爻元 冃 次层爻元数
        *无限区牜无限层
            首层:动态爻元++变长殿后爻元 冃 层数&次层爻元数

TODO:新增:无限区牜无限层
!! 三层码 起初可能对头部空间的紧凑性有较高要求，但编码长度极大之后就不那么高要求了，此时可考虑升级换代(变态)
!! 首层:动态爻元++变长殿后爻元 冃 层数&次层爻元数
=>: threshold4inf_layers
    [[解压值{首层} < threshold4inf_layers] -> [[层数{次层诸后}==2][次层爻元数==解压扌(凡层数:=3,序号纟凡层:=凡零层;三凡层之首层.压缩值:=解压值{首层})]]]
        #首层/超层/混零层/凡零层,次层/混一层/凡一层,末层/混二层/凡二层
        #注意:此况态下[混k层==凡k层]
        #注意:『解压扌(凡层数:=3,序号纟凡层:=凡零层;三凡层之首层.压缩值:=...)』在下面况态中也可能会出现，但那时 凡零层 指的却是 次层
    [[解压值{首层} >= threshold4inf_layers] -> [[层数{次层诸后}==3+解压值{首层}-threshold4inf_layers][次层爻元数==爻元数纟躯胞-首层爻元数%爻元数纟躯胞 <- [1..=爻元数纟躯胞]]]]
        #首层/混零层/超层,次层/混一层/凡零层,...
        #注意:此况态下[混(k+1)层==凡k层]
        外大区平滑特性=>取消压缩，统一单位:躯胞
        => [次层爻元数==1]是有意义的，直接不断编码长度直至[01]，没有任何步骤是浪费的！
外大区平滑特性:
    内三层使用压缩:超层等价于不存在时，凡层数不多于三层，此时称为『内三层』
    外大区取消压缩:超层存在，凡层数不少于三层
        超层存在，凡层数等于三层，此时称为『外三层』
        不仅取消压缩，还统一单位:躯胞
    注意:超层 可以 任意复杂(采用:低效率自然数编码方案)，至少可能是(动态爻元+变长殿后爻元)



负一层==末层
无限区牜无限层:编码:反向处理各层:负一层,负二层,...

[[k>=2] -> [解压值{-k} == 压缩值{-k+1}.bit_length()]]
处理 第-k层:解压值{-k} --> 压缩值{-k}
    if [压缩值{-k} <= 最大值纟次层{总层数==k+1}]:
        ...结束
    else:
        [解压值{-k-1} := 压缩值{-k}.bit_length()]
        递归 处理 第-k-1层:解压值{-k-1}
]]
[[
TODO:
@20250723
二幂情形=>统一使用 爻元数 而非 避免混合使用 躯胞数
    #注意:宏头胞 未必是 二幂
并 标明 爻元串边界必须对齐躯胞欤
==>>:
二幂情形=>统一使用 串长带自定义单位
[自定义单位 =[def]= (步长,内置单位)]
[内置单位 =[def]= (爻元|躯胞)]

]]
[[
===
流程:
流程牜二幂情形:
    三种主模态:单凡层(立即数)、多凡层、超凡层
===
常量:
    最小值纟多凡层
    最小爻元数纟值纟超凡层

    最大值纟宏头胞
    最小值纟宏头胞纟多凡层
        # [首辨苞{多凡层vs单凡层}==宏头胞]
    序号纟首辨苞纟超凡层
    最小值纟首辨苞纟超凡层
        # [首辨苞{多凡层vs超凡层} :: (宏头胞|躯胞)]
    最大值纟躯胞
===
解码流程:
    输入:值纟宏头胞,读者牜躯胞
    if not 值纟宏头胞 <= 最大值纟宏头胞:raise OverflowError
    if 值纟宏头胞 < 最小值纟宏头胞纟多凡层:
        return ...自定义插件{立即数}
    if 0==序号纟首辨苞纟超凡层:
        if 值纟宏头胞 < 最小值纟首辨苞纟超凡层:
            return ...挑选-自定义插件{多凡层}
        else:
            return ...唯一内置插件{超凡层}
    elif not 值纟宏头胞 == 最大值纟宏头胞:
        return ...挑选-自定义插件{多凡层}
    else:
        maxs = 读者牜躯胞.read_le_while(序号纟首辨苞纟超凡层-1, 最大值纟躯胞.__eq__)
        if not len(maxs) == 序号纟首辨苞纟超凡层-1:
            return ...挑选-自定义插件{多凡层}{maxs++读者牜躯胞}
        else:
            值纟首辨苞纟超凡层 = 读者牜躯胞.read1()
            if 值纟首辨苞纟超凡层 < 最小值纟首辨苞纟超凡层
                return ...挑选-自定义插件{多凡层}{maxs++[值纟首辨苞纟超凡层]++读者牜躯胞}
            else:
                return ...唯一内置插件{超凡层}{maxs++[值纟首辨苞纟超凡层]++读者牜躯胞}
    raise 000
===
编码流程:
    输入:值纟编入
    if 值纟编入 < 最小值纟多凡层:
        #有限区:单凡层#特点:手写编码，简单快速
        return ...自定义插件{立即数}
    爻元数纟输入:=值纟编入.bit_length()
    if 爻元数纟输入 >= 最小爻元数纟值纟超凡层:
        #无限区:超凡层#特点:内置插件{极简配置}
        return ...唯一内置插件{超凡层}
    #有限区:多凡层#特点:插件多，压缩配置复杂
    return ...挑选-自定义插件{多凡层}
===
]]
[[
独力单层编解码器:
e ../../python3_src/seed/int_tools/StepDecoder.py
]]
[[
@20250726
微调:增加 保留区，导致 超凡层.超层 不是 第零层，而是 推至 第一层
<<==:
编解码:动态爻元分配:
    +非动态爻元前缀的编码区
    +动态爻元前缀的编码区:
        +动态爻元前缀:
            数纟动态爻元前缀->编解码器
            结尾是 超凡层:[数纟动态爻元前缀==动态爻元截止长度-1] => (偏移量纟层数{<=之前最大层数},第一层是动态爻元{->非固定层数}{躯胞数纟第二层==1躯胞}{各层都是整躯胞}{统一单位:躯胞}{统一不作线性变换})
            非结尾则通常是: (固定层数,爻元数纟第一层,各层线性变换牜不含末层{统一单位:爻元数}，k{第几层起整躯胞，但第k层首躯胞必不完整{允空不允整}},末层相关/((偏移量|...{延续之前最大可编码值}),最大爻元数纟末层{偏移之后}))
            注意:多凡层:负二层 的 负载应当不超出 64bit #否则 负一层 即 被编码的自然数的爻元数 至少是 2**64 完全没有必要 出现在 多凡层，应当 推至 超凡层
    +保留区:动态爻元截止长度

==>>:
透明数据化编解码器{自然数}{解码器{侧重头苞分类{并联}{LL1}}}:
    [数据模型==(基数纟宏头胞,基数纟躯胞)]
    +有限区编解码器:
        [有限区编解码器{基数纟头苞}==([基数纟头苞==1]:有限区编解码器深入型|有限区编解码器基础型{基数纟头苞})]
        [有限区编解码器深入型{基数纟头苞:=1}==深入型{有限区编解码器{基数纟头苞:=基数纟躯胞}}]
            #see:IStepDecoder__skip_macro_header
            # 深入型-前置条件:[所占用编码空间纟头苞:=1]
        [有限区编解码器基础型{基数纟头苞}==基础型{[(占地纟头苞,第零层规模,各层线性变换,整躯胞终末的起始层号,隐藏:囿 带单位值{末层压缩值上尾限})]}]
            #see:IStepDecoder__fixed_size_layers
            #see:IStepDecoder__parallel__partition_space4macro_header
            [囿==惰性数据]
            [带单位值{值名}(无单位值,单位/立即数丷爻元数丷躯胞数)]
            #xxx:[占地纟头苞==(所占用编码空间纟头苞,立即数丷爻元数,欤累计偏移量)]
                # 无用:欤累计偏移量
            [占地纟头苞==(所占用编码空间纟头苞,立即数丷爻元数)]
            [第零层规模==(长度纟第零层,躯胞数丷爻元数,欤头苞另计,头苞偏移量)]
                #多凡层:因为 没有 超层，所以 第零层 是 第零凡层
                # 头苞偏移量:比如:+1则有:([0-8][0-9]*) --> ([1-9][0-9]*)
            [各层线性变换==(非末层层号讠线性变换,末层偏移量)]
                #末层偏移量or累积接力居前末层最大值
                #统统硬编码
            整躯胞终末的起始层号:只用作检查
    +无限区编解码器:
        #see:IStepDecoder__truncated_dynamic_bits_with_may_dynamic_bibits
        [无限区编解码器{基数纟头苞}==([基数纟头苞==1]:无限区编解码器深入型|无限区编解码器基础型{基数纟头苞})]
        [无限区编解码器深入型{基数纟头苞:=1}==深入型{无限区编解码器{基数纟头苞:=基数纟躯胞}}]
        [无限区编解码器基础型==基础型{(占地爻元数纟头苞,超层偏移量,动态爻元截止长度)}]
            #有任何不规则需求,统统归入 有限区
            #超层 是 第零层 是 动态爻元(其间插入保留区)
            #爻元数纟第一层 为 不完整的 头苞，0bit 自动偏移+1 {相当于 (总)凡层数-1，并且 第一层 占 1躯胞}
            #动态爻元截止长度:见下面:无限保留区方案
    +不存在:保留区编解码器:
        见上面:无限区编解码器基础型.
==>>:
透明数据化编解码器{自然数}{编码器}:
    [数据模型==(基数纟宏头胞,基数纟躯胞)]
    缓存化:自然数-->缓存化自然数
        [缓存化自然数(自然数冃末层解压值) =[def]= (自然数冃末层解压值,囿 爻元数,囿 躯胞数, 槑 {末层偏移量{>0}:缓存化自然数(末层压缩值:=自然数冃末层解压值-末层偏移量)})]
    编码器外观:(基数纟头苞,欤可编码巛缓存化自然数扌)
    基础型编码器外观参数:(基数纟头苞,末层偏移量,鬽 带单位值{末层压缩值上尾限})
    并联型编码器:[基础型编码器]
]]
[[
@20250728
无限保留区方案:编码方案{超凡层插入无限个保留区}:
#######
超层动态爻元分配:
    超凡层:regex"(01){n}00{多凡层{n}}"
        结束串:00
    保留区:regex"(01){n}1{保留区{n}}"
        结束串:11
    注意:支持词典序:[00{占用} < 01{继续} < 1b{保留}] => [保留区 永远大于 已编码的自然数]
#######
采用参数:动态爻元截止长度
    #see:IStepDecoder__dynamic_bits.max_num_bits4read
    超凡层:regex"1{0<=n<=动态爻元截止长度-2}0{多凡层{n}}|1{动态爻元截止长度-1}(01){n}00{多凡层{动态爻元截止长度-1+n}}"
        结束串:00
    保留区:regex"1{动态爻元截止长度-1}(01){n}1{保留区{n}}"
        结束串:11
分2步读取:
    + IStepDecoder__dynamic_bits
    + IStepDecoder__dynamic_bibits
    [u := 使用:IStepDecoder__dynamic_bits{max_num_bits4read:=动态爻元截止长度}]
    if u == 动态爻元截止长度:
        return (True, 0) # 保留区0
    if u < 动态爻元截止长度-1:
        return (False, offset4super_layer+u) # 凡层数
    if u == 动态爻元截止长度-1:
        # 已读出前缀: regex"1{动态爻元截止长度}0"
        # !! 之前 "0" 结尾，所以 下面是 "(10)*" 而非 "(01)*"
        # 之后:regex"(10)*(0|11)"
        # 之后:regex"(10){v}(0|11)"
        [(_0_vs_11, v) := 使用:IStepDecoder__dynamic_bibits{body_bibit:="10"}]
        if _0_vs_11:
            # ...11
            return (True, 1+v) # 保留区(1+v)
        else:
            return (False, offset4super_layer+u+v) # 凡层数
    raise 000
#######
e others/数学/编程/设计/自定义编码之要点.txt
]]
[[
move to:
view others/数学/编程/设计/自定义字符编码-兼容utf8.txt
===
@20250726
要是 支持词典序、同时重点优化:ASCII+统合码基位面+统合码 的 编码空间，则兼容utf8是个不错的起点
    由于utf8编码效率低，只有5/8，所以后续必须改变编码方案，以逼近极限效率6/8
    最优:{候选方案辛,候选方案壬{偏好},候选方案癸} <<==:
... ...
]]
]]]]]]]
'''#'''


__all__ = r'''
'''.split()#'''
__all__
___begin_mark_of_excluded_global_names__0___ = ...
from seed.for_libs.for_importlib__reload import clear_later_variables_if_reload_
clear_later_variables_if_reload_(globals(), '')

from functools import cached_property
from itertools import islice
from seed.tiny_.check import check_type_is, check_int_ge


######################
from seed.int_tools.StepDecoder import step_decode__input_, step_decode__head_, step_decode__state_
from seed.int_tools.StepDecoder import incremental_decode__continued_, incremental_decode__init5head_, incremental_decode__init5state_
if 777:
    #__alnum__5over8
    from seed.int_tools.StepDecoder import gmk_step_decoder4int_with_inf__alnum__5over8_ as _58_gmk4int, gmk_std_step_decoder4rational_with_inf__alnum__5over8_ as _58_gmk4rational
    step_decoder4int_with_inf__alnum__5over8 = _58_gmk4int()
    std_step_decoder4rational_with_inf__alnum__5over8 = _58_gmk4rational()


from seed.int_tools.StepDecoder import incremental_decode__ops4iter_headed_digits_
if 777:
    #__alnum__5over8
    from seed.int_tools.StepDecoder import ops4iter_headed_digits__alnum__5over8


#__alnum__5over8
from seed.int_tools.StepDecoder import \
(incremental_std_decode4rational_with_inf__alnum__5over8_
,std_decode4rational_with_inf__alnum__5over8_
,std_encode4rational_with_inf__alnum__5over8_
,    iter_std_encode4rational_with_inf__alnum__5over8_
)
######################




from seed.abc.abc__ver1 import abstractmethod, override, ABC
from seed.helper.lazy_import__func import lazy_import4func_, lazy_import4funcs_
repr_helper = lazy_import4func_('seed.helper.repr_input', 'repr_helper', __name__)
#from seed.helper.repr_input import repr_helper

___end_mark_of_excluded_global_names__0___ = ...

class ITable4Codecs(ABC):
    ___no_slots_ok___ = True
    @cached_property
    #@abstractmethod
    def size4head_cell(sf, /):
        '-> uint{>=1}'
        return len(sf.head_digit2std_token)
    @cached_property
    #@abstractmethod
    def size4body_cell(sf, /):
        '-> uint{>=2}'
        return len(sf.body_digit2std_token)
    @cached_property
    #@abstractmethod
    def size4alphabet(sf, /):
        '-> uint{>=3} # [size4alphabet == size4head_cell+size4body_cell]'
        return sf.size4head_cell+sf.size4body_cell
    @property
    @abstractmethod
    def head_digit2std_token(sf, /):
        '-> [token]{len=size4head_cell}'
    @property
    @abstractmethod
    def body_digit2std_token(sf, /):
        '-> [token]{len=size4body_cell}'
    @property
    @abstractmethod
    def nonstd_token2head_digit(sf, /):
        '-> {token:uint%size4head_cell}{len>=size4head_cell}'
    @property
    @abstractmethod
    def nonstd_token2body_digit(sf, /):
        '-> {token:uint%size4body_cell}{len>=size4body_cell}'

class DecodeError(Exception):pass
class ICodecs(ABC):
    '[codecs{v} :: v <-> [Digit{j}/uint%radix{j}]]'
    __slots__ = ()
    @abstractmethod
    def _encode_(sf, u, /):
        'Value -> Iter (Iter digit{j})'
    @abstractmethod
    def _decode_(sf, digit_reader, /):
        'IDigitReader -> Value|^EOFError|^DecodeError'
    def encode__iter_(sf, u, /):
        'Value -> Iter digit{j}'
        return chains(sf._encode_(u))
    def decode__reader_(sf, digit_reader, /):
        'IDigitReader -> Value|^EOFError|^DecodeError'
        return sf._decode_(digit_reader)
    def decode__seq_(sf, digit_seq, /):
        '[digit{j}] -> Value|^EOFError|^DecodeError'
        TODO
    def decode__iter_(sf, digits, /):
        'Iter digit{j} -> Value|^EOFError|^DecodeError'
        TODO

class ICodecs4int(ABC):
    '[codecs4int :: int <-> [Digit{j}/uint%radix{j}]]'
    __slots__ = ()
    def __(sf, /):
        ...:
__all__
from seed.int_tools.digits.codecs4int import *
