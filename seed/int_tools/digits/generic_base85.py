#__all__:goto
r'''[[[
e ../../python3_src/seed/int_tools/digits/generic_base85.py
view others/数学/编程/generic_base85_encode.txt
    see:proof____base85_padding_style
    view ../../python3_src/py_stdlib_api.txt
      base64.a85encode

view ../../python3_src/seed/for_libs/for_base64.py
view ../../python3_src/seed/int_tools/digits/generic_base85.py







seed.int_tools.digits.generic_base85
py -m nn_ns.app.debug_cmd   seed.int_tools.digits.generic_base85 -x
py -m nn_ns.app.doctest_cmd seed.int_tools.digits.generic_base85:__doc__ -ff -v


[[
a85 padding:
    a85encode:
        data_bs pad 0 until 4s
        bs__a85 pop until len ok
    a85decode:
        bs__a85 pad 84/u until 5s
        data_bs pop until len ok
    good:under big-big setting:stable when len extended
    bad:unclear why this work
]]


>>> import base64
>>> base64.a85encode(b'1111')
b'0ekC;'
>>> base64.b85encode(b'1111')
b'F)=YQ'
>>> impl__base64__a85encode(b'1111')
b'0ekC;'
>>> impl__base64__b85encode(b'1111')
b'F)=YQ'

>>> base64.a85encode(b'1111')
b'0ekC;'
>>> base64.a85encode(b'111')
b'0ekB'
>>> base64.a85encode(b'11')
b'0ei'
>>> base64.a85encode(b'1')
b'0`'
>>> base64.b85encode(b'1')
b'F#'
>>> impl__base64__a85encode(b'1111')
b'0ekC;'
>>> impl__base64__a85encode(b'111')
b'0ekB'
>>> impl__base64__a85encode(b'11')
b'0ei'
>>> impl__base64__a85encode(b'1')
b'0`'
>>> impl__base64__b85encode(b'1')
b'F#'

>>> impl__base64__a85encode__buggy_via_missing_lens_are_eq(b'1111')
b'0ekC;'
>>> impl__base64__a85encode__buggy_via_missing_lens_are_eq(b'111')
b'&62_'
>>> impl__base64__a85encode__buggy_via_missing_lens_are_eq(b'11')
b'"`.'
>>> impl__base64__a85encode__buggy_via_missing_lens_are_eq(b'1')
b'!R'
>>> impl__base64__b85encode__buggy_via_missing_lens_are_eq(b'1')
b'0n'






>>> base64.a85encode(b'\0')
b'!!'
>>> base64.a85decode(b'!!')
b'\x00'
>>> impl__base64__a85encode(b'\0')
b'!!'
>>> impl__base64__a85decode(b'!!')
b'\x00'

main4iter_find_best_parameters4IWordBasedRadixDigitsCodec
iter_find_best_parameters4IWordBasedRadixDigitsCodec

py_adhoc_call   seed.int_tools.digits.generic_base85   @main4check_core_args4IWordBasedRadixDigitsCodec  --str8space_efficient_bg_threshold:9/10  --str8space_efficient_sm_threshold:1/10 --iradix='2**8' --oradix=85 --num_digits4iword=4 --num_digits4oword=5
    ok
py_adhoc_call   seed.int_tools.digits.generic_base85   @main4check_core_args4IWordBasedRadixDigitsCodec  --str8space_efficient_bg_threshold:9/10  --str8space_efficient_sm_threshold:1/10 --iradix='2**8' --oradix=3 --num_digits4iword=3 --num_digits4oword=16
    bad

[[[
py_adhoc_call   seed.int_tools.digits.generic_base85   ,main4iter_find_best_parameters4IWordBasedRadixDigitsCodec  --str8space_efficient_bg_threshold:9/10  --str8space_efficient_sm_threshold:1/10 --iradix='2**8' --max__oradix=95 --max__max1__oword='(2**8)**16' --ver=1 -no_better_and_smaller_setting
===
-> Iter (oradix, num_digits4oword, num_digits4iword)
===
(2, 8, 1)
(4, 4, 1)
(6, 31, 10)
(7, 20, 7)
(8, 8, 3)
(11, 7, 3)
(12, 9, 4)
(13, 13, 6)
(14, 19, 9)
(16, 2, 1)
(18, 25, 13)
(19, 17, 9)
(20, 13, 7)
(21, 11, 6)
(22, 9, 5)
(23, 16, 9)
(23, 23, 13)
(24, 7, 4)
(25, 19, 11)
(26, 12, 7)
(28, 5, 3)
(30, 18, 11)
(31, 13, 8)
(31, 21, 13)
(32, 8, 5)
(35, 11, 7)
(36, 14, 9)
(37, 20, 13)
(41, 3, 2)
(44, 22, 15)
(45, 19, 13)
(46, 16, 11)
(47, 13, 9)
(49, 10, 7)
(51, 17, 12)
(53, 7, 5)
(55, 18, 13)
(57, 11, 8)
(59, 15, 11)
(60, 19, 14)
(64, 4, 3)
(70, 17, 13)
(72, 13, 10)
(75, 9, 7)
(79, 14, 11)
(80, 19, 15)
(85, 5, 4)
(91, 16, 13)
(94, 11, 9)

===
ver1111 +no_better_and_smaller_setting
    ver1/ver2/ver3=>49
    ver1111=>42 #using_cf # filterout:7#
>>> kwds__ver_ = dict(str8space_efficient_bg_threshold='9/10',  str8space_efficient_sm_threshold='1/10', iradix=2**8, max__oradix=95, max__max1__oword=(2**8)**16, to_attach_space_efficient=False, no_better_and_smaller_setting=True)
>>> kwds__ver1 = dict(**kwds__ver_, ver=1)
>>> kwds__ver1111 = dict(**kwds__ver_, ver=1111)

#>>> out__ver1 = {*main4iter_find_best_parameters4IWordBasedRadixDigitsCodec(**kwds__ver1)}
#>>> out__ver1111 = {*main4iter_find_best_parameters4IWordBasedRadixDigitsCodec(**kwds__ver1111)}
#>>> sorted(out__ver1111-out__ver1)
[]
#>>> sorted(out__ver1-out__ver1111)
[(18, 25, 13), (23, 16, 9), (30, 18, 11), (31, 13, 8), (45, 19, 13), (46, 16, 11), (51, 17, 12)]

#>>> for t in main4iter_find_best_parameters4IWordBasedRadixDigitsCodec(str8space_efficient_bg_threshold='9/10',  str8space_efficient_sm_threshold='1/10', iradix=2**8, max__oradix=95, max__max1__oword=(2**8)**16, ver=1111, to_attach_space_efficient=False, no_better_and_smaller_setting=True):t
(2, 8, 1)
(4, 4, 1)
(6, 31, 10)
(7, 20, 7)
(8, 8, 3)
(11, 7, 3)
(12, 9, 4)
(13, 13, 6)
(14, 19, 9)
(16, 2, 1)
(19, 17, 9)
(20, 13, 7)
(21, 11, 6)
(22, 9, 5)
(23, 23, 13)
(24, 7, 4)
(25, 19, 11)
(26, 12, 7)
(28, 5, 3)
(31, 21, 13)
(32, 8, 5)
(35, 11, 7)
(36, 14, 9)
(37, 20, 13)
(41, 3, 2)
(44, 22, 15)
(47, 13, 9)
(49, 10, 7)
(53, 7, 5)
(55, 18, 13)
(57, 11, 8)
(59, 15, 11)
(60, 19, 14)
(64, 4, 3)
(70, 17, 13)
(72, 13, 10)
(75, 9, 7)
(79, 14, 11)
(80, 19, 15)
(85, 5, 4)
(91, 16, 13)
(94, 11, 9)


===
===
]]]
[[[
py_adhoc_call   seed.int_tools.digits.generic_base85   ,main4iter_find_best_parameters4IWordBasedRadixDigitsCodec  --str8space_efficient_bg_threshold:9/10  --str8space_efficient_sm_threshold:1/10 --iradix='2**8' --max__oradix=95 --max__max1__oword='(2**8)**16' --ver=3 -no_better_and_smaller_setting
===
-> Iter (oradix, num_digits4oword, num_digits4iword)
===
(2, 8, 1)
(4, 4, 1)
(16, 2, 1)
(41, 3, 2)
(8, 8, 3)
(11, 7, 3)
(28, 5, 3)
(64, 4, 3)
(12, 9, 4)
(24, 7, 4)
(85, 5, 4)
(22, 9, 5)
(32, 8, 5)
(53, 7, 5)
(13, 13, 6)
(21, 11, 6)
(7, 20, 7)
(20, 13, 7)
(26, 12, 7)
(35, 11, 7)
(49, 10, 7)
(75, 9, 7)
(31, 13, 8)
(57, 11, 8)
(14, 19, 9)
(19, 17, 9)
(23, 16, 9)
(36, 14, 9)
(47, 13, 9)
(94, 11, 9)
(6, 31, 10)
(72, 13, 10)
(25, 19, 11)
(30, 18, 11)
(46, 16, 11)
(59, 15, 11)
(79, 14, 11)
(51, 17, 12)
(18, 25, 13)
(23, 23, 13)
(31, 21, 13)
(37, 20, 13)
(45, 19, 13)
(55, 18, 13)
(70, 17, 13)
(91, 16, 13)
(60, 19, 14)
(44, 22, 15)
(80, 19, 15)
===
]]]
[[[
py_adhoc_call   seed.int_tools.digits.generic_base85   ,main4iter_find_best_parameters4IWordBasedRadixDigitsCodec  --str8space_efficient_bg_threshold:9/10  --str8space_efficient_sm_threshold:1/10 --iradix='2**8' --max__oradix=95 --max__max1__oword='(2**8)**16' --ver=2 -no_better_and_smaller_setting
===
-> Iter (oradix, num_digits4oword, num_digits4iword)
===
(16, 2, 1)
(41, 3, 2)
(4, 4, 1)
(64, 4, 3)
(28, 5, 3)
(85, 5, 4)
(11, 7, 3)
(24, 7, 4)
(53, 7, 5)
(2, 8, 1)
(8, 8, 3)
(32, 8, 5)
(12, 9, 4)
(22, 9, 5)
(75, 9, 7)
(49, 10, 7)
(21, 11, 6)
(35, 11, 7)
(57, 11, 8)
(94, 11, 9)
(26, 12, 7)
(13, 13, 6)
(20, 13, 7)
(31, 13, 8)
(47, 13, 9)
(72, 13, 10)
(36, 14, 9)
(79, 14, 11)
(59, 15, 11)
(23, 16, 9)
(46, 16, 11)
(91, 16, 13)
(19, 17, 9)
(51, 17, 12)
(70, 17, 13)
(30, 18, 11)
(55, 18, 13)
(14, 19, 9)
(25, 19, 11)
(45, 19, 13)
(60, 19, 14)
(80, 19, 15)
(7, 20, 7)
(37, 20, 13)
(31, 21, 13)
(44, 22, 15)
(23, 23, 13)
(18, 25, 13)
(6, 31, 10)
===
]]]
[[[
py_adhoc_call   seed.int_tools.digits.generic_base85   ,main4iter_find_best_parameters4IWordBasedRadixDigitsCodec  --str8space_efficient_bg_threshold:9/10  --str8space_efficient_sm_threshold:1/10 --iradix='2**8' --max__oradix=95 --max__max1__oword='(2**8)**16' --ver=3 +to_attach_space_efficient -no_better_and_smaller_setting
===
-> Iter (oradix, num_digits4oword, num_digits4iword, space_efficient_bg_threshold, space_efficient_sm_threshold)
===
-no_better_and_smaller_setting
#>>> for t in main4iter_find_best_parameters4IWordBasedRadixDigitsCodec(str8space_efficient_bg_threshold='9/10',  str8space_efficient_sm_threshold='1/10', iradix=2**8, max__oradix=95, max__max1__oword=(2**8)**16, ver=3, to_attach_space_efficient=True, no_better_and_smaller_setting=False):t
(2, 8, 1, 1.0, 0.0)
(4, 4, 1, 1.0, 0.0)
(16, 2, 1, 1.0, 0.0)
(41, 3, 2, 0.995479526607698, 0.01356142017690587)
(8, 8, 3, 1.0, 0.0)
(11, 7, 3, 0.9910794045184727, 0.06244416837069178)
(28, 5, 3, 0.9984700688472454, 0.007649655763772856)
(64, 4, 3, 1.0, 0.0)
(12, 9, 4, 0.9917971400929062, 0.07382573916384416)
(24, 7, 4, 0.9970481919338585, 0.02066265646299037)
(85, 5, 4, 0.99853481614224, 0.007325919288799554)
(22, 9, 5, 0.9966392187447798, 0.03024703129698203)
(32, 8, 5, 1.0, 0.0)
(53, 7, 5, 0.9976196002745426, 0.016662798078201924)
(13, 13, 6, 0.9978024163470267, 0.028568587488653208)
(21, 11, 6, 0.9934701761321584, 0.07182806254625795)
(7, 20, 7, 0.997380123902462, 0.052397521950759085)
(20, 13, 7, 0.9967061489958856, 0.042820063053486734)
(26, 12, 7, 0.9928149165823615, 0.08622100101166197)
(35, 11, 7, 0.9925186569138212, 0.08229477394796625)
(49, 10, 7, 0.997380123902462, 0.026198760975379543)
(75, 9, 7, 0.998940976033911, 0.009531215694801531)
(31, 13, 8, 0.9937185800964916, 0.08165845874560951)
(57, 11, 8, 0.997478403339133, 0.0277375632695378)
(14, 19, 9, 0.9953035011935756, 0.08923347732206466)
(19, 17, 9, 0.997025986023409, 0.05055823760204703)
(23, 16, 9, 0.9947912825587668, 0.08333947905973105)
(36, 14, 9, 0.9947643614602498, 0.07329893955650313)
(47, 13, 9, 0.9970965784062977, 0.03774448071813019)
(94, 11, 9, 0.9986064257530426, 0.015329316716531594)
(6, 31, 10, 0.9983298251213977, 0.051775421236673225)
(72, 13, 10, 0.997393996265368, 0.03387804855021592)
(25, 19, 11, 0.9973562397489102, 0.050231444770705735)
(30, 18, 11, 0.9963313413313636, 0.06603585603545525)
(46, 16, 11, 0.9957342822902212, 0.0682514833564607)
(59, 15, 11, 0.997284148883229, 0.040737766751565374)
(79, 14, 11, 0.9971340274694608, 0.04012361542754839)
(51, 17, 12, 0.995528100078393, 0.07602229866731847)
(18, 25, 13, 0.9976198609234268, 0.05950347691432967)
(23, 23, 13, 0.9995970375469735, 0.009268136419610329)
(31, 21, 13, 0.9996335716446851, 0.007694995461612564)
(37, 20, 13, 0.9981853440341129, 0.036293119317743816)
(45, 19, 13, 0.9966916657301883, 0.06285835112642246)
(55, 18, 13, 0.9993804336826676, 0.011152193711982505)
(70, 17, 13, 0.9981015792403012, 0.03227315291487898)
(91, 16, 13, 0.9988022608841175, 0.01916382585412002)
(60, 19, 14, 0.9979424447928168, 0.039093548936481426)
(44, 22, 15, 0.999105004983456, 0.019689890363967066)
(80, 19, 15, 0.9990289954091512, 0.018449087226127148)

===
ver3 +no_better_and_smaller_setting
    result == -no_better_and_smaller_setting
#>>> for t in main4iter_find_best_parameters4IWordBasedRadixDigitsCodec(str8space_efficient_bg_threshold='9/10',  str8space_efficient_sm_threshold='1/10', iradix=2**8, max__oradix=95, max__max1__oword=(2**8)**16, ver=3, to_attach_space_efficient=False, no_better_and_smaller_setting=True):t
(2, 8, 1)
(4, 4, 1)
(16, 2, 1)
(41, 3, 2)
(8, 8, 3)
(11, 7, 3)
(28, 5, 3)
(64, 4, 3)
(12, 9, 4)
(24, 7, 4)
(85, 5, 4)
(22, 9, 5)
(32, 8, 5)
(53, 7, 5)
(13, 13, 6)
(21, 11, 6)
(7, 20, 7)
(20, 13, 7)
(26, 12, 7)
(35, 11, 7)
(49, 10, 7)
(75, 9, 7)
(31, 13, 8)
(57, 11, 8)
(14, 19, 9)
(19, 17, 9)
(23, 16, 9)
(36, 14, 9)
(47, 13, 9)
(94, 11, 9)
(6, 31, 10)
(72, 13, 10)
(25, 19, 11)
(30, 18, 11)
(46, 16, 11)
(59, 15, 11)
(79, 14, 11)
(51, 17, 12)
(18, 25, 13)
(23, 23, 13)
(31, 21, 13)
(37, 20, 13)
(45, 19, 13)
(55, 18, 13)
(70, 17, 13)
(91, 16, 13)
(60, 19, 14)
(44, 22, 15)
(80, 19, 15)


===
]]]

[[[
===
#>>> for t in main4iter_find_best_parameters4IWordBasedRadixDigitsCodec(str8space_efficient_bg_threshold='9/10',  str8space_efficient_sm_threshold='1/10', iradix=2**8, max__oradix=95, max__max1__oword=(2**8)**16, ver=3, to_attach_space_efficient=True, diff__num_digits4oword__num_digits4iword__eq1=True, no_better_and_smaller_setting=False):t
(16, 2, 1, 1.0, 0.0)
(41, 3, 2, 0.995479526607698, 0.01356142017690587)
(64, 4, 3, 1.0, 0.0)
(85, 5, 4, 0.99853481614224, 0.007325919288799554)

===
>>> for t in main4iter_find_best_parameters4IWordBasedRadixDigitsCodec(str8space_efficient_bg_threshold='9/10',  str8space_efficient_sm_threshold='1/10', iradix=2**8, max__oradix=95, max__max1__oword=(2**8)**16, ver=4, to_attach_space_efficient=True, no_better_and_smaller_setting=False):t
(16, 2, 1, 1.0, 0.0)
(41, 3, 2, 0.995479526607698, 0.01356142017690587)
(64, 4, 3, 1.0, 0.0)
(85, 5, 4, 0.99853481614224, 0.007325919288799554)

===
ver4 for PaddingProtocol.base85_padding_style
    #_ver4__iter_find_best_parameters4IWordBasedRadixDigitsCodec:goto

first repeat:oradix:223-->223
    (223, 39, 38, 0.9992272551723718, 0.030137048277502743)
    (223, 40, 39, 0.9998846415244588, 0.0046143390216499824)

first gap:num_digits4iword:153-->157
    (247, 154, 153, 0.9999603335473132, 0.006108633713779454)
    (248, 158, 157, 0.9993928711851161, 0.09592635275166117)

?terminated? by nature:707 < 800? No. there gaps:
    (254, 707, 706, 0.9999999869780596, 9.206511890624824e-06)
    (255, 1276, 1275, 0.9999220663259053, 0.09944336814487542)
>>> ceil_kth_root_(707, 256**706)
254
>>> ceil_kth_root_(708, 256**707)
255

ceil(x**((k-1)/k))
    # [oradix == ceil_kth_root_(num_digits4oword; iradix**num_digits4iword)]
    oradix = ceil_kth_root_(num_digits4oword, max1__iword)
[x <= ceil(x**((k-1)/k))]
    !! [(x**((k-1)/k)) < x]
    <==> [x == ceil(x**((k-1)/k))]
    <==> [x-1 < x**((k-1)/k)]
    <==> [(x-1)**k < x**(k-1)]
    <==> [x * (x-1)**k < x**k]
    <==> [x < (x/(x-1))**k]
    <==> [log2(x) < k*log2(x/(x-1))]
    <==> [log2(x)/log2(x/(x-1)) < k]
>>> f=lambda x:math.ceil(math.log2(x)/math.log2(x/(x-1)))
>>> f(256) # illegal num_digits4oword # min k s.t. [x <= ceil(x**((k-1)/k))]
1417
>>> calc_upperbound4num_digits4oword__if_diff__num_digits4oword__num_digits4iword__eq1(256)
1417
>>> calc_upperbound4num_digits4oword__if_diff__num_digits4oword__num_digits4iword__eq_neg1(256)
2845

#>>> for t in main4iter_find_best_parameters4IWordBasedRadixDigitsCodec(str8space_efficient_bg_threshold='9/10',  str8space_efficient_sm_threshold='1/10', iradix=2**8, max__oradix=99999, max__max1__oword=(2**8)**16, ver=4, to_attach_space_efficient=True, no_better_and_smaller_setting=False):t
... ...
(182, 16, 15, 0.9989617936328516, 0.016611301874373652)
#>>> for t in main4iter_find_best_parameters4IWordBasedRadixDigitsCodec(str8space_efficient_bg_threshold='9/10',  str8space_efficient_sm_threshold='1/10', iradix=2**8, max__oradix=99999, max__max1__oword=(2**8)**800, ver=4, to_attach_space_efficient=True, no_better_and_smaller_setting=False):t
... ...
(254, 707, 706, 0.9999999869780596, 9.206511890624824e-06)
    #big gap:
    #   next is:(255, 1276, 1275, 0.9999220663259053, 0.09944336814487542)
#>>> for t in main4iter_find_best_parameters4IWordBasedRadixDigitsCodec(str8space_efficient_bg_threshold='9/10',  str8space_efficient_sm_threshold='1/10', iradix=2**8, max__oradix=99999, max__max1__oword=(2**8)**1500, ver=4, to_attach_space_efficient=True, no_better_and_smaller_setting=False):t
(16, 2, 1, 1.0, 0.0)
(41, 3, 2, 0.995479526607698, 0.01356142017690587)
(64, 4, 3, 1.0, 0.0)
(85, 5, 4, 0.99853481614224, 0.007325919288799554)
(102, 6, 5, 0.9991369442129828, 0.005178334722103273)
(116, 7, 6, 0.9998777864818653, 0.0008554946269425656)
(128, 8, 7, 1.0, 0.0)
(139, 9, 8, 0.9989001227103288, 0.009898895607040714)
(148, 10, 9, 0.9986887541746203, 0.013112458253797143)
(155, 11, 10, 0.9995331123606817, 0.005135764032502266)
(162, 12, 11, 0.9991121522171803, 0.010654173393836786)
(168, 13, 12, 0.9989581023483052, 0.013544669472032922)
(173, 14, 13, 0.9991853258993125, 0.011405437409624852)
(177, 15, 14, 0.9998742724947061, 0.0018859125794090659)
(182, 16, 15, 0.9989617936328516, 0.016611301874373652)
(185, 17, 16, 0.9997384681919572, 0.004446040736727497)
(189, 18, 17, 0.999115755844576, 0.01591639479763174)
(192, 19, 18, 0.9992069661122871, 0.015067643866544245)
(195, 20, 19, 0.9990364144256544, 0.01927171148691187)
(197, 21, 20, 0.9996058541085895, 0.008277063719621225)
(199, 22, 21, 0.9999658246682297, 0.0007518572989475558)
(202, 23, 22, 0.999211621444261, 0.018132706781997854)
(204, 24, 23, 0.999249432213654, 0.018013626872303234)
(206, 25, 24, 0.9991542930153677, 0.0211426746158061)
(207, 26, 25, 0.9998467190237472, 0.003985305382570914)
(209, 27, 26, 0.9995257223240107, 0.012805497251711984)
(211, 28, 27, 0.9991175512378554, 0.02470856534004895)
(212, 29, 28, 0.9995105379835422, 0.014194398477275882)
(213, 30, 29, 0.999822063534369, 0.00533809396893048)
(215, 31, 30, 0.9991924096573274, 0.025035300622850087)
(216, 32, 31, 0.9993697520225658, 0.02016793527789318)
(217, 33, 32, 0.9994877989270877, 0.016902635406104594)
(218, 34, 33, 0.9995522193760399, 0.015224541214642784)
(219, 35, 34, 0.9995680282756484, 0.015119010352307782)
(220, 36, 35, 0.9995396773984555, 0.016571613655600004)
(221, 37, 36, 0.9994711315946447, 0.01956813099814525)
(222, 38, 37, 0.9993659329673547, 0.024094547240522957)
(223, 39, 38, 0.9992272551723718, 0.030137048277502743)
(223, 40, 39, 0.9998846415244588, 0.0046143390216499824)
(224, 41, 40, 0.9996827512900537, 0.013007197107796742)
(225, 42, 41, 0.9994551444954699, 0.02288393119026466)
(226, 43, 42, 0.9992039217934762, 0.03423136288052575)
(226, 44, 43, 0.9997446165563514, 0.011236871520537761)
(227, 45, 44, 0.9994472320620363, 0.024874557208363512)
(227, 46, 45, 0.9999410301015927, 0.0027126153267360564)
(228, 47, 46, 0.9996038779918297, 0.018617734384001494)
(229, 48, 47, 0.9992511414523343, 0.03594521028795583)
(229, 49, 48, 0.9996850325254789, 0.015433406251531778)
(230, 50, 49, 0.9993002284231163, 0.03498857884418527)
(230, 51, 50, 0.9997001084665029, 0.015294468208352896)
(231, 52, 51, 0.9992873950462887, 0.03705545759298445)
(231, 53, 52, 0.9996570907159321, 0.01817419205559645)
(232, 54, 53, 0.9992200104225857, 0.04211943718037503)
(232, 55, 54, 0.9995627960179279, 0.024046219013968084)
(232, 56, 55, 0.9998933392705792, 0.0059730008475611385)
(233, 57, 56, 0.9994230780192879, 0.032884552900590336)
(233, 58, 57, 0.9997307821689243, 0.015614634202393063)
(234, 59, 58, 0.9992429906192831, 0.04466355346229278)
(234, 60, 59, 0.9995301294096909, 0.028192235418543987)
(234, 61, 60, 0.9998078538135281, 0.011720917374788087)
(235, 62, 61, 0.9992954748060391, 0.04368056202557824)
(235, 63, 62, 0.999555504854128, 0.028003194189935243)
(235, 64, 63, 0.9998074089632143, 0.012325826354285141)
(236, 65, 64, 0.9992743585618498, 0.047166693479766764)
(236, 66, 65, 0.999510929195979, 0.03227867306539167)
(236, 67, 66, 0.9997404380201341, 0.01739065265101658)
(236, 68, 67, 0.9999631965847553, 0.002502632236641489)
(237, 69, 68, 0.9994060805712722, 0.04098044058221717)
(237, 70, 69, 0.9996160398318963, 0.02687721176725688)
(237, 71, 70, 0.999820084747151, 0.012773982952282381)
(238, 72, 71, 0.9992490169378436, 0.05407078047525715)
(238, 73, 72, 0.9994418104969673, 0.04074783372138313)
(238, 74, 73, 0.999629393419358, 0.02742488696750911)
(238, 75, 74, 0.9998119741304847, 0.0141019402136493)
(238, 76, 75, 0.9999897500860556, 0.000778993459775279)
(239, 77, 76, 0.9993971659069051, 0.046418225168309846)
(239, 78, 77, 0.9995657551724089, 0.03387109655210452)
(239, 79, 78, 0.9997300763552418, 0.02132396793589919)
(239, 80, 79, 0.9998902895085038, 0.008776839319693863)
(240, 81, 80, 0.9992846710550888, 0.057941644537805814)
(240, 82, 81, 0.9994370010354326, 0.046165915094519505)
(240, 83, 82, 0.9995856604138403, 0.03439018565124741)
(240, 84, 83, 0.9997307802832386, 0.022614456207961098)
(240, 85, 84, 0.9998724855674742, 0.010838726764689)
(241, 86, 85, 0.9992527897468698, 0.0642600817691914)
(241, 87, 86, 0.9993879152086341, 0.0532513768488343)
(241, 88, 87, 0.9995199696371766, 0.04224267192846298)
(241, 89, 88, 0.9996490565504708, 0.03123396700810588)
(241, 90, 89, 0.9997752748656917, 0.020225262087748774)
(241, 91, 90, 0.9998987191520068, 0.00921655716737746)
(242, 92, 91, 0.99926507645866, 0.0676129658032778)
(242, 93, 92, 0.9993831510275433, 0.0573669544384785)
(242, 94, 93, 0.9994987133715566, 0.0471209430736792)
(242, 95, 94, 0.9996118428241171, 0.0368749317088799)
(242, 96, 95, 0.9997226154130825, 0.026628920344080598)
(242, 97, 96, 0.9998311040311414, 0.016382908979281297)
(242, 98, 97, 0.9999373785957706, 0.006136897614481995)
(243, 99, 98, 0.9992907612121669, 0.07021463999548416)
(243, 100, 99, 0.9993927296571886, 0.06072703428114323)
(243, 101, 100, 0.999492678925081, 0.051239428566816514)
(243, 102, 101, 0.9995906684034069, 0.041751822852489795)
(243, 103, 102, 0.999686755173416, 0.032264217138148865)
(243, 104, 103, 0.9997809941209248, 0.022776611423822146)
(243, 105, 104, 0.999873438040862, 0.013289005709481216)
(243, 106, 105, 0.9999641377358948, 0.0038013999951544974)
(244, 107, 106, 0.9993060301370712, 0.07425477533338665)
(244, 108, 107, 0.9993933210202067, 0.06552132981767045)
(244, 109, 108, 0.999479010235762, 0.05678788430194004)
(244, 110, 109, 0.9995631414655798, 0.04805443878622384)
(244, 111, 110, 0.9996457568173828, 0.03932099327050764)
(244, 112, 111, 0.9997268968950467, 0.030587547754777233)
(244, 113, 112, 0.9998066008651411, 0.021854102239061035)
(244, 114, 113, 0.9998849065199708, 0.013120656723330626)
(244, 115, 114, 0.9999618503373251, 0.004387211207614428)
(245, 116, 115, 0.999293976078156, 0.0818987749339044)
(245, 117, 116, 0.9993682454186301, 0.07391528602028075)
(245, 118, 117, 0.9994412559567232, 0.0659317971066713)
(245, 119, 118, 0.9995130394269491, 0.05794830819304764)
(245, 120, 119, 0.9995836265060049, 0.04996481927942398)
(245, 121, 120, 0.9996530468564808, 0.04198133036581453)
(245, 122, 121, 0.9997213291684247, 0.03399784145219087)
(245, 123, 122, 0.9997885011988734, 0.02601435253856721)
(245, 124, 123, 0.9998545898094762, 0.01803086362495776)
(245, 125, 124, 0.9999196210023094, 0.0100473747113341)
(245, 126, 125, 0.9999836199539863, 0.0020638857977246516)
(246, 127, 126, 0.9993066891700619, 0.0880504754021274)
(246, 128, 127, 0.9993686501502932, 0.08081278076247145)
(246, 129, 128, 0.999429650495172, 0.07357508612281549)
(246, 130, 129, 0.9994897123732067, 0.06633739148313111)
(246, 131, 130, 0.999548857276004, 0.05909969684347516)
(246, 132, 131, 0.9996071060439105, 0.0518620022038192)
(246, 133, 132, 0.9996644788904953, 0.044624307564134824)
(246, 134, 133, 0.9997209954259367, 0.03738661292447887)
(246, 135, 134, 0.9997766746793717, 0.030148918284822912)
(246, 136, 135, 0.9998315351202564, 0.022911223645138534)
(246, 137, 136, 0.9998855946787921, 0.015673529005482578)
(246, 138, 137, 0.9999388707654653, 0.0084358343657982)
(246, 139, 138, 0.99999138028974, 0.0011981397261422444)
(247, 140, 139, 0.9993067647018573, 0.09705294173997459)
(247, 141, 140, 0.999357752342283, 0.09055691973810553)
(247, 142, 141, 0.9994080218469279, 0.08406089773623648)
(247, 143, 142, 0.9994575882815778, 0.07756487573436743)
(247, 144, 143, 0.9995064662935244, 0.07106885373249838)
(247, 145, 144, 0.9995546701259956, 0.06457283173062933)
(247, 146, 145, 0.9996022136319948, 0.05807680972876028)
(247, 147, 146, 0.9996491102875722, 0.05158078772689123)
(247, 148, 147, 0.9996953732045608, 0.04508476572499376)
(247, 149, 148, 0.9997410151427978, 0.03858874372312471)
(247, 150, 149, 0.9997860485218583, 0.03209272172125566)
(247, 151, 150, 0.9998304854323219, 0.025596699719386606)
(247, 152, 151, 0.9998743376465953, 0.019100677717517556)
(247, 153, 152, 0.9999176166293094, 0.012604655715648505)
(247, 154, 153, 0.9999603335473132, 0.006108633713779454)
(248, 158, 157, 0.9993928711851161, 0.09592635275166117)
(248, 159, 158, 0.999432906151714, 0.09016792187748024)
(248, 160, 159, 0.9994724406812294, 0.08440949100329931)
(248, 161, 160, 0.999511484098577, 0.07865106012908996)
(248, 162, 161, 0.9995500454984265, 0.07289262925490902)
(248, 163, 162, 0.9995881337522656, 0.06713419838069967)
(248, 164, 163, 0.9996257575152041, 0.06137576750651874)
(248, 165, 164, 0.9996629252325314, 0.05561733663230939)
(248, 166, 165, 0.9996996451460354, 0.04985890575812846)
(248, 167, 166, 0.9997359253000961, 0.04410047488394753)
(248, 168, 167, 0.9997717735475611, 0.038342044009738174)
(248, 169, 168, 0.9998071975554109, 0.03258361313555724)
(248, 170, 169, 0.9998422048102273, 0.02682518226134789)
(248, 171, 170, 0.9998768026234669, 0.02106675138716696)
(248, 172, 171, 0.9999109981365526, 0.015308320512957607)
(248, 173, 172, 0.9999447983257874, 0.009549889638776676)
(248, 174, 173, 0.9999782100071001, 0.0037914587645957454)
(249, 181, 180, 0.9994722580306442, 0.09552129645339846)
(249, 182, 181, 0.9995027669518296, 0.09049641476701709)
(249, 183, 182, 0.9995329424421823, 0.08547153308063571)
(249, 184, 183, 0.9995627899380746, 0.08044665139428275)
(249, 185, 184, 0.9995923147583357, 0.07542176970790138)
(249, 186, 185, 0.9996215221074112, 0.07039688802152)
(249, 187, 186, 0.9996504170784216, 0.06537200633516704)
(249, 188, 187, 0.9996790046561235, 0.060347124648785666)
(249, 189, 188, 0.9997072897197755, 0.05532224296243271)
(249, 190, 189, 0.9997352770459155, 0.05029736127605133)
(249, 191, 190, 0.9997629713110489, 0.045272479589669956)
(249, 192, 191, 0.9997903770942536, 0.040247597903317)
(249, 193, 192, 0.999817498879705, 0.03522271621693562)
(249, 194, 193, 0.9998443410591207, 0.030197834530582668)
(249, 195, 194, 0.9998709079341322, 0.02517295284420129)
(249, 196, 195, 0.9998972037185826, 0.020148071157819913)
(249, 197, 196, 0.999923232540754, 0.015123189471466958)
(249, 198, 197, 0.9999489984455299, 0.01009830778508558)
(249, 199, 198, 0.9999745053964888, 0.005073426098732625)
(249, 200, 199, 0.9999997572779382, 4.8544412351247956e-05)
(250, 211, 210, 0.9995356418811971, 0.09797956306741185)
(250, 212, 211, 0.9995580932657857, 0.09368422765342643)
(250, 213, 212, 0.9995803338392513, 0.08938889223946944)
(250, 214, 213, 0.9996023665568902, 0.08509355682551245)
(250, 215, 214, 0.9996241943190162, 0.08079822141152704)
(250, 216, 215, 0.9996458199722335, 0.07650288599757005)
(250, 217, 216, 0.9996672463106746, 0.07220755058361306)
(250, 218, 217, 0.9996884760772035, 0.06791221516965606)
(250, 219, 218, 0.999709511964586, 0.06361687975567065)
(250, 220, 219, 0.9997303566166286, 0.05932154434171366)
(250, 221, 220, 0.9997510126292861, 0.05502620892775667)
(250, 222, 221, 0.9997714825517396, 0.05073087351379968)
(250, 223, 222, 0.9997917688874448, 0.046435538099814266)
(250, 224, 223, 0.9998118740951524, 0.042140202685857275)
(250, 225, 224, 0.9998318005899026, 0.037844867271900284)
(250, 226, 225, 0.9998515507439916, 0.03354953185791487)
(250, 227, 226, 0.9998711268879121, 0.02925419644395788)
(250, 228, 227, 0.9998905313112719, 0.02495886103000089)
(250, 229, 228, 0.9999097662636854, 0.0206635256160439)
(250, 230, 229, 0.9999288339556432, 0.016368190202058486)
(250, 231, 230, 0.9999477365593589, 0.012072854788101495)
(250, 232, 231, 0.9999664762095942, 0.007777519374144504)
(250, 233, 232, 0.9999850550044627, 0.0034821839601875126)
(251, 254, 253, 0.9996186915467091, 0.09685234713589352)
(251, 255, 254, 0.9996341859075794, 0.09328259356726676)
(251, 256, 255, 0.9996495592187554, 0.08971283999861157)
(251, 257, 256, 0.9996648128932685, 0.08614308643001323)
(251, 258, 257, 0.9996799483222429, 0.08257333286132962)
(251, 259, 258, 0.9996949668753178, 0.07900357929270285)
(251, 260, 259, 0.9997098699010613, 0.07543382572407609)
(251, 261, 260, 0.9997246587273737, 0.07186407215544932)
(251, 262, 261, 0.9997393346618824, 0.06829431858682256)
(251, 263, 262, 0.9997538989923263, 0.06472456501819579)
(251, 264, 263, 0.9997683529869335, 0.061154811449569024)
(251, 265, 264, 0.9997826978947889, 0.05758505788094226)
(251, 266, 265, 0.9997969349461943, 0.05401530431231549)
(251, 267, 266, 0.9998110653530201, 0.050445550743631884)
(251, 268, 267, 0.9998250903090485, 0.04687579717500512)
(251, 269, 268, 0.9998390109903108, 0.04330604360637835)
(251, 270, 269, 0.9998528285554157, 0.03973629003775159)
(251, 271, 270, 0.9998665441458704, 0.03616653646912482)
(251, 272, 271, 0.9998801588863953, 0.032596782900498056)
(251, 273, 272, 0.9998936738852312, 0.02902702933187129)
(251, 274, 273, 0.9999070902344407, 0.025457275763244525)
(251, 275, 274, 0.9999204090102014, 0.02188752219461776)
(251, 276, 275, 0.9999336312730942, 0.018317768625990993)
(251, 277, 276, 0.9999467580683852, 0.014748015057307384)
(251, 278, 277, 0.9999597904262997, 0.011178261488680619)
(251, 279, 278, 0.9999727293622938, 0.007608507920053853)
(251, 280, 279, 0.9999855758773163, 0.004038754351427087)
(251, 281, 280, 0.9999983309580683, 0.00046900078280032176)
(252, 318, 317, 0.9996944878169388, 0.09715287421346375)
(252, 319, 318, 0.9997043737428687, 0.09430477602489873)
(252, 320, 319, 0.9997141978817616, 0.09145667783627687)
(252, 321, 320, 0.9997239608110665, 0.088608579647655)
(252, 322, 321, 0.9997336631010587, 0.08576048145908999)
(252, 323, 322, 0.9997433053149521, 0.08291238327046813)
(252, 324, 323, 0.9997528880090065, 0.08006428508190311)
(252, 325, 324, 0.999762411732636, 0.07721618689328125)
(252, 326, 325, 0.9997718770285133, 0.07436808870465939)
(252, 327, 326, 0.9997812844326724, 0.07151999051609437)
(252, 328, 327, 0.9997906344746114, 0.0686718923274725)
(252, 329, 328, 0.9997999276773896, 0.06582379413885064)
(252, 330, 329, 0.9998091645577264, 0.06297569595028563)
(252, 331, 330, 0.9998183456260977, 0.060127597761663765)
(252, 332, 331, 0.9998274713868281, 0.0572794995730419)
(252, 333, 332, 0.9998365423381848, 0.054431401384476885)
(252, 334, 333, 0.9998455589724675, 0.051583303195855024)
(252, 335, 334, 0.9998545217760977, 0.048735205007290006)
(252, 336, 335, 0.9998634312297063, 0.045887106818668144)
(252, 337, 336, 0.9998722878082195, 0.04303900863004628)
(252, 338, 337, 0.9998810919809423, 0.040190910441481265)
(252, 339, 338, 0.9998898442116435, 0.0373428122528594)
(252, 340, 339, 0.9998985449586346, 0.03449471406423754)
(252, 341, 340, 0.9999071946748515, 0.031646615875672524)
(252, 342, 341, 0.9999157938079326, 0.028798517687050662)
(252, 343, 342, 0.999924342800296, 0.025950419498485644)
(252, 344, 343, 0.9999328420892155, 0.023102321309863783)
(252, 345, 344, 0.999941292106895, 0.02025422312124192)
(252, 346, 345, 0.9999496932805414, 0.017406124932676903)
(252, 347, 346, 0.9999580460324379, 0.014558026744055041)
(252, 348, 347, 0.9999663507800132, 0.01170992855543318)
(252, 349, 348, 0.9999746079359115, 0.008861830366868162)
(252, 350, 349, 0.9999828179080622, 0.0060137321782463005)
(252, 351, 350, 0.9999909810997447, 0.003165633989624439)
(252, 352, 351, 0.9999990979096561, 0.0003175358010594209)
(253, 424, 423, 0.9997668168957929, 0.09886963618379241)
(253, 425, 424, 0.9997723781074013, 0.09673930435445754)
(253, 426, 425, 0.9997779132100351, 0.09460897252506584)
(253, 427, 426, 0.9997834223871295, 0.09247864069573097)
(253, 428, 427, 0.9997889058204056, 0.09034830886639611)
(253, 429, 428, 0.9997943636898904, 0.0882179770370044)
(253, 430, 429, 0.9997997961739357, 0.08608764520766954)
(253, 431, 430, 0.9998052034492382, 0.08395731337833467)
(253, 432, 431, 0.9998105856908588, 0.08182698154899981)
(253, 433, 432, 0.9998159430722411, 0.0796966497196081)
(253, 434, 433, 0.9998212757652298, 0.07756631789027324)
(253, 435, 434, 0.9998265839400898, 0.07543598606093838)
(253, 436, 435, 0.999831867765524, 0.07330565423154667)
(253, 437, 436, 0.9998371274086906, 0.0711753224022118)
(253, 438, 437, 0.9998423630352218, 0.06904499057287694)
(253, 439, 438, 0.9998475748092404, 0.06691465874348523)
(253, 440, 439, 0.9998527628933769, 0.06478432691415037)
(253, 441, 440, 0.9998579274487873, 0.0626539950848155)
(253, 442, 441, 0.9998630686351687, 0.0605236632554238)
(253, 443, 442, 0.9998681866107764, 0.058393331426088935)
(253, 444, 443, 0.9998732815324397, 0.05626299959675407)
(253, 445, 444, 0.999878353555579, 0.054132667767362364)
(253, 446, 445, 0.9998834028342196, 0.0520023359380275)
(253, 447, 446, 0.9998884295210096, 0.049872004108692636)
(253, 448, 447, 0.9998934337672337, 0.04774167227930093)
(253, 449, 448, 0.9998984157228286, 0.045611340449966065)
(253, 450, 449, 0.9999033755363986, 0.0434810086206312)
(253, 451, 450, 0.9999083133552299, 0.04135067679129634)
(253, 452, 451, 0.9999132293253056, 0.03922034496190463)
(253, 453, 452, 0.9999181235913188, 0.037090013132569766)
(253, 454, 453, 0.9999229962966889, 0.0349596813032349)
(253, 455, 454, 0.999927847583574, 0.032829349473843195)
(253, 456, 455, 0.9999326775928848, 0.03069901764450833)
(253, 457, 456, 0.9999374864642994, 0.028568685815173467)
(253, 458, 457, 0.9999422743362756, 0.02643835398578176)
(253, 459, 458, 0.9999470413460644, 0.024308022156446896)
(253, 460, 459, 0.9999517876297237, 0.022177690327112032)
(253, 461, 460, 0.9999565133221308, 0.020047358497720325)
(253, 462, 461, 0.9999612185569948, 0.01791702666838546)
(253, 463, 462, 0.9999659034668703, 0.015786694839050597)
(253, 464, 463, 0.9999705681831689, 0.01365636300965889)
(253, 465, 464, 0.9999752128361713, 0.011526031180324026)
(253, 466, 465, 0.9999798375550408, 0.009395699350989162)
(253, 467, 466, 0.9999844424678337, 0.007265367521654298)
(253, 468, 467, 0.9999890277015122, 0.005135035692262591)
(253, 469, 468, 0.9999935933819554, 0.0030047038629277267)
(253, 470, 469, 0.9999981396339711, 0.0008743720335928629)
(254, 637, 636, 0.999844335266361, 0.09915843532803592)
(254, 638, 637, 0.9998467993451826, 0.09774201777349845)
(254, 639, 638, 0.9998492557117075, 0.09632560021896097)
(254, 640, 639, 0.9998517044020867, 0.09490918266453718)
(254, 641, 640, 0.9998541454522465, 0.09349276510999971)
(254, 642, 641, 0.9998565788978887, 0.09207634755546223)
(254, 643, 642, 0.9998590047744931, 0.09065993000092476)
(254, 644, 643, 0.9998614231173193, 0.08924351244638729)
(254, 645, 644, 0.9998638339614078, 0.0878270948919635)
(254, 646, 645, 0.999866237341583, 0.08641067733742602)
(254, 647, 646, 0.999868633292453, 0.08499425978288855)
(254, 648, 647, 0.999871021848413, 0.08357784222835107)
(254, 649, 648, 0.9998734030436459, 0.0821614246738136)
(254, 650, 649, 0.999875776912124, 0.08074500711938981)
(254, 651, 650, 0.9998781434876116, 0.07932858956485234)
(254, 652, 651, 0.9998805028036651, 0.07791217201031486)
(254, 653, 652, 0.9998828548936358, 0.07649575445577739)
(254, 654, 653, 0.9998851997906709, 0.07507933690123991)
(254, 655, 654, 0.999887537527715, 0.07366291934670244)
(254, 656, 655, 0.9998898681375118, 0.07224650179227865)
(254, 657, 656, 0.9998921916526062, 0.07083008423774118)
(254, 658, 657, 0.9998945081053446, 0.0694136666832037)
(254, 659, 658, 0.9998968175278776, 0.06799724912866623)
(254, 660, 659, 0.9998991199521604, 0.06658083157412875)
(254, 661, 660, 0.999901415409955, 0.06516441401970496)
(254, 662, 661, 0.9999037039328321, 0.06374799646516749)
(254, 663, 662, 0.999905985552171, 0.062331578910630014)
(254, 664, 663, 0.9999082602991625, 0.06091516135609254)
(254, 665, 664, 0.9999105282048097, 0.059498743801555065)
(254, 666, 665, 0.9999127892999292, 0.05808232624713128)
(254, 667, 666, 0.9999150436151535, 0.0566659086925938)
(254, 668, 667, 0.9999172911809311, 0.05524949113805633)
(254, 669, 668, 0.9999195320275284, 0.05383307358351885)
(254, 670, 669, 0.9999217661850314, 0.05241665602898138)
(254, 671, 670, 0.9999239936833464, 0.05100023847455759)
(254, 672, 671, 0.9999262145522023, 0.049583820920020116)
(254, 673, 672, 0.9999284288211508, 0.04816740336548264)
(254, 674, 673, 0.9999306365195684, 0.04675098581094517)
(254, 675, 674, 0.9999328376766572, 0.04533456825640769)
(254, 676, 675, 0.9999350323214468, 0.043918150701983905)
(254, 677, 676, 0.9999372204827955, 0.04250173314744643)
(254, 678, 677, 0.999939402189391, 0.041085315592908955)
(254, 679, 678, 0.999941577469752, 0.03966889803837148)
(254, 680, 679, 0.9999437463522296, 0.038252480483834006)
(254, 681, 680, 0.9999459088650083, 0.03683606292929653)
(254, 682, 681, 0.9999480650361072, 0.035419645374872744)
(254, 683, 682, 0.9999502148933817, 0.03400322782033527)
(254, 684, 683, 0.9999523584645237, 0.032586810265797794)
(254, 685, 684, 0.9999544957770639, 0.03117039271126032)
(254, 686, 685, 0.9999566268583722, 0.029753975156722845)
(254, 687, 686, 0.999958751735659, 0.028337557602299057)
(254, 688, 687, 0.9999608704359771, 0.026921140047761583)
(254, 689, 688, 0.9999629829862218, 0.025504722493224108)
(254, 690, 689, 0.9999650894131323, 0.024088304938686633)
(254, 691, 690, 0.9999671897432936, 0.02267188738414916)
(254, 692, 691, 0.9999692840031362, 0.02125546982972537)
(254, 693, 692, 0.9999713722189392, 0.019839052275187896)
(254, 694, 693, 0.999973454416829, 0.01842263472065042)
(254, 695, 694, 0.9999755306227825, 0.017006217166112947)
(254, 696, 695, 0.999977600862627, 0.015589799611575472)
(254, 697, 696, 0.9999796651620414, 0.014173382057151684)
(254, 698, 697, 0.9999817235465579, 0.01275696450261421)
(254, 699, 698, 0.9999837760415621, 0.011340546948076735)
(254, 700, 699, 0.999985822672295, 0.00992412939353926)
(254, 701, 700, 0.999987863463853, 0.008507711839001786)
(254, 702, 701, 0.99998989844119, 0.007091294284577998)
(254, 703, 702, 0.999991927629118, 0.005674876730040523)
(254, 704, 703, 0.9999939510523075, 0.004258459175503049)
(254, 705, 704, 0.9999959687352894, 0.002842041620965574)
(254, 706, 705, 0.9999979807024555, 0.0014256240664280995)
(254, 707, 706, 0.9999999869780596, 9.206511890624824e-06)
(255, 1276, 1275, 0.9999220663259053, 0.09944336814487542)
(255, 1277, 1276, 0.9999226804626328, 0.09873704921801618)
(255, 1278, 1277, 0.9999232936382698, 0.09803073029115694)
(255, 1279, 1278, 0.9999239058550711, 0.09732441136407033)
(255, 1280, 1279, 0.9999245171152834, 0.09661809243721109)
(255, 1281, 1280, 0.9999251274211473, 0.09591177351035185)
(255, 1282, 1281, 0.999925736774896, 0.09520545458326524)
(255, 1283, 1282, 0.9999263451787557, 0.094499135656406)
(255, 1284, 1283, 0.999926952634946, 0.09379281672931938)
(255, 1285, 1284, 0.999927559145679, 0.09308649780246014)
(255, 1286, 1285, 0.9999281647131605, 0.0923801788756009)
(255, 1287, 1286, 0.9999287693395893, 0.09167385994851429)
(255, 1288, 1287, 0.9999293730271571, 0.09096754102165505)
(255, 1289, 1288, 0.9999299757780492, 0.09026122209456844)
(255, 1290, 1289, 0.9999305775944436, 0.0895549031677092)
(255, 1291, 1290, 0.9999311784785121, 0.08884858424084996)
(255, 1292, 1291, 0.9999317784324196, 0.08814226531376335)
(255, 1293, 1292, 0.9999323774583241, 0.0874359463869041)
(255, 1294, 1293, 0.9999329755583771, 0.08672962746004487)
(255, 1295, 1294, 0.9999335727347236, 0.08602330853295825)
(255, 1296, 1295, 0.9999341689895015, 0.08531698960609901)
(255, 1297, 1296, 0.9999347643248427, 0.0846106706790124)
(255, 1298, 1297, 0.999935358742872, 0.08390435175215316)
(255, 1299, 1298, 0.999935952245708, 0.08319803282529392)
(255, 1300, 1299, 0.9999365448354629, 0.08249171389820731)
(255, 1301, 1300, 0.9999371365142419, 0.08178539497134807)
(255, 1302, 1301, 0.999937727284144, 0.08107907604448883)
(255, 1303, 1302, 0.9999383171472621, 0.08037275711740222)
(255, 1304, 1303, 0.9999389061056821, 0.07966643819054298)
(255, 1305, 1304, 0.999939494161484, 0.07896011926345636)
(255, 1306, 1305, 0.9999400813167407, 0.07825380033659712)
(255, 1307, 1306, 0.9999406675735197, 0.07754748140973788)
(255, 1308, 1307, 0.9999412529338818, 0.07684116248265127)
(255, 1309, 1308, 0.999941837399881, 0.07613484355579203)
(255, 1310, 1309, 0.9999424209735657, 0.07542852462893279)
(255, 1311, 1310, 0.999943003656978, 0.07472220570184618)
(255, 1312, 1311, 0.9999435854521532, 0.07401588677498694)
(255, 1313, 1312, 0.9999441663611212, 0.07330956784790033)
(255, 1314, 1313, 0.9999447463859048, 0.07260324892104109)
(255, 1315, 1314, 0.9999453255285216, 0.07189692999418185)
(255, 1316, 1315, 0.9999459037909825, 0.07119061106709523)
(255, 1317, 1316, 0.9999464811752922, 0.070484292140236)
(255, 1318, 1317, 0.9999470576834496, 0.06977797321337675)
(255, 1319, 1318, 0.9999476333174478, 0.06907165428629014)
(255, 1320, 1319, 0.9999482080792732, 0.0683653353594309)
(255, 1321, 1320, 0.9999487819709066, 0.06765901643234429)
(255, 1322, 1321, 0.9999493549943226, 0.06695269750548505)
(255, 1323, 1322, 0.9999499271514901, 0.06624637857862581)
(255, 1324, 1323, 0.999950498444372, 0.0655400596515392)
(255, 1325, 1324, 0.9999510688749248, 0.06483374072467996)
(255, 1326, 1325, 0.9999516384450997, 0.06412742179782072)
(255, 1327, 1326, 0.999952207156842, 0.0634211028707341)
(255, 1328, 1327, 0.9999527750120905, 0.06271478394387486)
(255, 1329, 1328, 0.999953342012779, 0.06200846501678825)
(255, 1330, 1329, 0.9999539081608346, 0.06130214608992901)
(255, 1331, 1330, 0.9999544734581796, 0.06059582716306977)
(255, 1332, 1331, 0.9999550379067298, 0.05988950823598316)
(255, 1333, 1332, 0.9999556015083952, 0.05918318930912392)
(255, 1334, 1333, 0.9999561642650807, 0.05847687038226468)
(255, 1335, 1334, 0.9999567261786853, 0.057770551455178065)
(255, 1336, 1335, 0.9999572872511016, 0.057064232528318826)
(255, 1337, 1336, 0.9999578474842175, 0.05635791360123221)
(255, 1338, 1337, 0.9999584068799146, 0.05565159467437297)
(255, 1339, 1338, 0.9999589654400691, 0.05494527574751373)
(255, 1340, 1339, 0.9999595231665519, 0.05423895682042712)
(255, 1341, 1340, 0.9999600800612277, 0.05353263789356788)
(255, 1342, 1341, 0.9999606361259564, 0.05282631896648127)
(255, 1343, 1342, 0.9999611913625915, 0.05212000003962203)
(255, 1344, 1343, 0.9999617457729816, 0.05141368111276279)
(255, 1345, 1344, 0.9999622993589697, 0.050707362185676175)
(255, 1346, 1345, 0.9999628521223931, 0.050001043258816935)
(255, 1347, 1346, 0.9999634040650839, 0.049294724331957696)
(255, 1348, 1347, 0.9999639551888688, 0.04858840540487108)
(255, 1349, 1348, 0.9999645054955686, 0.04788208647801184)
(255, 1350, 1349, 0.9999650549869993, 0.04717576755092523)
(255, 1351, 1350, 0.9999656036649711, 0.04646944862406599)
(255, 1352, 1351, 0.9999661515312891, 0.04576312969720675)
(255, 1353, 1352, 0.999966698587753, 0.04505681077012014)
(255, 1354, 1353, 0.9999672448361571, 0.0443504918432609)
(255, 1355, 1354, 0.9999677902782905, 0.04364417291640166)
(255, 1356, 1355, 0.9999683349159371, 0.042937853989315045)
(255, 1357, 1356, 0.9999688787508751, 0.042231535062455805)
(255, 1358, 1357, 0.9999694217848782, 0.04152521613536919)
(255, 1359, 1358, 0.9999699640197142, 0.04081889720850995)
(255, 1360, 1359, 0.9999705054571458, 0.04011257828165071)
(255, 1361, 1360, 0.9999710460989313, 0.0394062593545641)
(255, 1362, 1361, 0.9999715859468226, 0.03869994042770486)
(255, 1363, 1362, 0.9999721250025673, 0.03799362150084562)
(255, 1364, 1363, 0.9999726632679078, 0.03728730257375901)
(255, 1365, 1364, 0.9999732007445811, 0.03658098364689977)
(255, 1366, 1365, 0.9999737374343193, 0.035874664719813154)
(255, 1367, 1366, 0.9999742733388494, 0.035168345792953914)
(255, 1368, 1367, 0.9999748084598932, 0.034462026866094675)
(255, 1369, 1368, 0.999975342799168, 0.03375570793900806)
(255, 1370, 1369, 0.9999758763583853, 0.03304938901214882)
(255, 1371, 1370, 0.9999764091392521, 0.03234307008528958)
(255, 1372, 1371, 0.9999769411434707, 0.03163675115820297)
(255, 1373, 1372, 0.9999774723727376, 0.03093043223134373)
(255, 1374, 1373, 0.999978002828745, 0.030224113304257116)
(255, 1375, 1374, 0.99997853251318, 0.029517794377397877)
(255, 1376, 1375, 0.9999790614277249, 0.028811475450538637)
(255, 1377, 1376, 0.9999795895740571, 0.028105156523452024)
(255, 1378, 1377, 0.9999801169538486, 0.027398837596592784)
(255, 1379, 1378, 0.9999806435687674, 0.026692518669733545)
(255, 1380, 1379, 0.9999811694204763, 0.02598619974264693)
(255, 1381, 1380, 0.999981694510633, 0.025279880815787692)
(255, 1382, 1381, 0.999982218840891, 0.02457356188870108)
(255, 1383, 1382, 0.9999827424128982, 0.02386724296184184)
(255, 1384, 1383, 0.9999832652282984, 0.0231609240349826)
(255, 1385, 1384, 0.9999837872887307, 0.022454605107895986)
(255, 1386, 1385, 0.999984308595829, 0.021748286181036747)
(255, 1387, 1386, 0.9999848291512228, 0.021041967253950133)
(255, 1388, 1387, 0.9999853489565367, 0.020335648327090894)
(255, 1389, 1388, 0.9999858680133907, 0.019629329400231654)
(255, 1390, 1389, 0.9999863863234006, 0.01892301047314504)
(255, 1391, 1390, 0.9999869038881767, 0.0182166915462858)
(255, 1392, 1391, 0.9999874207093251, 0.017510372619426562)
(255, 1393, 1392, 0.9999879367884477, 0.01680405369233995)
(255, 1394, 1393, 0.9999884521271409, 0.01609773476548071)
(255, 1395, 1394, 0.9999889667269976, 0.015391415838394096)
(255, 1396, 1395, 0.9999894805896049, 0.014685096911534856)
(255, 1397, 1396, 0.9999899937165464, 0.013978777984675617)
(255, 1398, 1397, 0.9999905061094009, 0.013272459057589003)
(255, 1399, 1398, 0.9999910177697422, 0.012566140130729764)
(255, 1400, 1399, 0.9999915286991401, 0.011859821203870524)
(255, 1401, 1400, 0.99999203889916, 0.011153502276783911)
(255, 1402, 1401, 0.9999925483713624, 0.010447183349924671)
(255, 1403, 1402, 0.9999930571173038, 0.009740864422838058)
(255, 1404, 1403, 0.9999935651385357, 0.009034545495978819)
(255, 1405, 1404, 0.9999940724366057, 0.008328226569119579)
(255, 1406, 1405, 0.9999945790130569, 0.007621907642032966)
(255, 1407, 1406, 0.9999950848694278, 0.006915588715173726)
(255, 1408, 1407, 0.9999955900072526, 0.0062092697883144865)
(255, 1409, 1408, 0.9999960944280616, 0.005502950861227873)
(255, 1410, 1409, 0.9999965981333799, 0.004796631934368634)
(255, 1411, 1410, 0.9999971011247291, 0.00409031300728202)
(255, 1412, 1411, 0.9999976034036258, 0.003383994080422781)
(255, 1413, 1412, 0.9999981049715828, 0.0026776751535635412)
(255, 1414, 1413, 0.9999986058301086, 0.001971356226476928)
(255, 1415, 1414, 0.999999105980707, 0.0012650372996176884)
(255, 1416, 1415, 0.999999605424878, 0.0005587183727584488)

===
>>> for t in main4iter_find_best_parameters4IWordBasedRadixDigitsCodec(str8space_efficient_bg_threshold='9/10',  str8space_efficient_sm_threshold='1/10', iradix=8, max__oradix=99999, max__max1__oword=(8)**1024, ver=4, to_attach_space_efficient=True, no_better_and_smaller_setting=False):t
(4, 3, 2, 1.0, 0.0)
(6, 7, 6, 0.9947643614602498, 0.036649469778251564)
(7, 15, 14, 0.997380123902462, 0.039298141463069314)


===
]]]




from seed.int_tools.digits.generic_base85 import iter_find_best_parameters4IWordBasedRadixDigitsCodec
from seed.int_tools.digits.generic_base85 import WordBasedRadixDigitsCodec__oradix_lt_iradix, PaddingProtocol, DigitOrder
from seed.int_tools.digits.generic_base85 import DecodeError











[iradix :: uint{>=2}][idigit := uint%iradix][num_digits4iword :: uint{>=1}][iword := [idigit]{len=num_digits4iword}]
[oradix :: uint{>=2}][odigit := uint%oradix][num_digits4oword :: uint{>=1}][oword := [odigit]{len=num_digits4oword}]
[input_text :: [idigit]]
[output_text :: [odigit]]


[idigit_order<iword> :: digit_order]
[odigit_order<oword> :: digit_order]


[[copy from: view others/数学/编程/generic_base85_encode.txt
[[[
[@[i,N,D :: int] -> [N >= D > 0] -> [i == (i*N //D *D +(D -1)) //N]]
  [[proof:
  [i*N //D *D == i*N - i*N %D]
  !! [D > 0]
  [0 <= i*N %D < D]
  [-(i*N %D) <- [1-D..=0]]
  [i*N //D *D == i*N - i*N %D <- [i*N+1-D..=i*N]]
  [i*N //D *D +(D -1) <- [i*N..<i*N+D]]
  !! [N > 0]
  [(i*N //D *D +(D -1)) //N <- [i..<i+D//N]]
  !! [N >= D > 0]
  [D//N <- {0,1}]
  [(i*N //D *D +(D -1)) //N <- [i..<i+D//N] |<=| [i..<i+1] == [i]]
  [(i*N //D *D +(D -1)) //N == i]
  DONE
  ]]
]]]
[[[
view ../../python3_src/seed/int_tools/digits/generic_base85.py
===
base85_padding_style:here
base85_padding_style in generic_base85.py defined as:
    && [idigit_order is big_endian][odigit_order is big_endian]

    && [num_digits4oword == num_digits4iword+1]
        # hence:[missing_lens_are_eq][min_output__under_len_transform_be_injection][otail_len__ext == itail_len + not (itail_len==0)]



===
proof____base85_padding_style:here
[oradix < iradix][num_digits4oword == num_digits4iword+1][L := missing_len][i := tail-iword-in-big_endian][0 < L < num_digits4iword][0 <= i < iradix**(num_digits4iword-L)]:
  #base85_padding_style decode:
  # encode:pad: i*iradix**L #big_endian
  # encode:pad+cutoff: i*iradix**L //oradix**L
  # decode:pad: i*iradix**L //oradix**L *oradix**L +(oradix**L -1)  #big_endian
  # decode:pad+cutoff: (i*iradix**L //oradix**L *oradix**L +(oradix**L -1)) //iradix**L
  ??? [i =?= (i*iradix**L //oradix**L *oradix**L +(oradix**L -1)) //iradix**L] ???
  [[proof:
  [N := iradix**L]
  [D := oradix**L]
  !! [oradix < iradix][L > 0]
  [N > D > 0]
  !! [@[i,N,D :: int] -> [N >= D > 0] -> [i == (i*N //D *D +(D -1)) //N]]
  [i == (i*N //D *D +(D -1)) //N]
  [i == (i*iradix**L //oradix**L *oradix**L +(oradix**L -1)) //iradix**L]
  DONE
  ]]
===
[2 <= oradix < iradix][using style:min_output__under_len_transform_be_injection or missing_lens_are_eq]:
  !! [oradix < iradix]
  [otail_len__ext == otail_len__mod]
  #     otail__ext_is_mod

  [base85_padding_style-encode/decode ok]
    <==> [@[itail_len <- [1..<num_digits4iword]] -> [otail_len__ext := len_transform(itail_len)] -> [imiss_len := num_digits4iword-itail_len] -> [omiss_len := num_digits4oword-otail_len__ext] -> [oradix**omiss_len < iradix**imiss_len]]
        # see:proof____base85_padding_style::N,D
    <<== [not [?[i <- [1..<num_digits4iword]] -> ?[j <- [1..<num_digits4oword]] -> [[iradix**i <= oradix**j][iradix**(num_digits4iword-i) <= oradix**(num_digits4oword-j)]]]]
        # [=no_better_and_smaller_setting=]
        # hence: [1 == gcd(num_digits4iword, num_digits4oword)]
        <==> [@[i <- [1..<num_digits4iword]] -> @[j <- [1..<num_digits4oword]] -> [iradix**i <= oradix**j] -> [iradix**(num_digits4iword-i) > oradix**(num_digits4oword-j)]]
          # [iradix**i <= oradix**j] ==>> [can be stored]
          # [iradix**(num_digits4iword-i) > oradix**(num_digits4oword-j)] ==>> [cannot split into better&&smaller setting]
===
]]]
]]

#]]]'''
__all__ = r'''
iter_find_best_parameters4IWordBasedRadixDigitsCodec
WordBasedRadixDigitsCodec__oradix_lt_iradix
    PaddingProtocol
DigitOrder
DecodeError





DigitOrder
CodecError
    DecodeError
IWordBasedRadixDigitsCodec
    WordBasedRadixDigitsCodec__oradix_gt_iradix
    WordBasedRadixDigitsCodec__oradix_lt_iradix
        PaddingProtocol

iter_find_best_parameters4IWordBasedRadixDigitsCodec
    calc_upperbound4num_digits4oword__if_diff__num_digits4oword__num_digits4iword__eq1
    calc_upperbound4num_digits4oword__if_diff__num_digits4oword__num_digits4iword__eq_neg1

    main4iter_find_best_parameters4IWordBasedRadixDigitsCodec
        float_calc_space_efficient_bg_threshold
        float_calc_space_efficient_sm_threshold
    main4check_core_args4IWordBasedRadixDigitsCodec




check_space_efficient_xxx_threshold
check_radix
check_digit_
check_digits_
check_num_digits4word
check_otail__ext
check_xtail__mod
check_word_
word_convert_
uint2radix_repr__padding
calc_total4nonempty_xtail__mod



a85_alphabet
b85_alphabet


impl__base64__xx85encode_
impl__base64__xx85decode_

    impl__base64__xx85codec__mod
        impl__base64__a85encode
        impl__base64__a85decode

        impl__base64__b85encode
        impl__base64__b85decode

    impl__base64__xx85codec__mod__buggy_via_missing_lens_are_eq
        impl__base64__a85encode__buggy_via_missing_lens_are_eq
        impl__base64__a85decode__buggy_via_missing_lens_are_eq

        impl__base64__b85encode__buggy_via_missing_lens_are_eq
        impl__base64__b85decode__buggy_via_missing_lens_are_eq

'''.split()#'''
__all__

from itertools import accumulate, islice, pairwise
from enum import Enum, auto
from numbers import Rational
from fractions import Fraction
#from math import gcd
import math
from seed.math.gcd import gcd, gcd_many
from seed.math.floor_ceil import floor_log_, ceil_log_
from seed.math.floor_ceil import floor_log2
from seed.math.floor_ceil import floor_sqrt, ceil_sqrt
from seed.math.floor_ceil import floor_kth_root_, ceil_kth_root_
from seed.math.continued_fraction.continued_fraction_of_log_ import continued_fraction_of_log_, iter_approximate_fractions_le5continued_fraction_of_log_
#def iter_approximate_fractions_le5continued_fraction_of_log_(base, y, /, *, may_max1_denominator=None):

from seed.tiny import check_type_is, check_type_le
from seed.tiny_.check import check_uint_lt, check_int_ge_lt, check_int_ge, check_int_ge_le
from seed.tiny import MapView, chains

from seed.types.NamedReadOnlyProperty import NamedReadOnlyProperty
from seed.iters.PeekableIterator import PeekableIterator
from seed.int_tools.digits.uint2radix_repr import uint2radix_repr
from seed.int_tools.digits.radix_repr2uint import radix_repr2uint
from seed.abc.abc__ver1 import abstractmethod, override, ABC, ABC__no_slots
from seed.seq_tools.bisearch import bisearch
from seed.helper.repr_input import repr_helper
#from seed.tiny import print_err, mk_fprint, mk_assert_eq_f, expectError


class DigitOrder(Enum):
    little_endian = auto()
    big_endian = auto()



def check_space_efficient_xxx_threshold(space_efficient_xxx_threshold, /):
    'smaller => better'
    if 0:check_type_is(Fraction, space_efficient_xxx_threshold)
    check_type_le(Rational, space_efficient_xxx_threshold)
    if not space_efficient_xxx_threshold >= 0: raise TypeError
def check_radix(radix, /):
    check_int_ge(2, radix)
def check_digit_(radix, digit, /):
    check_uint_lt(radix, digit)
def check_digits_(radix, digits, /):
    #digits[:0]
    for digit in digits:
        check_digit_(radix, digit)



def check_num_digits4word(num_digits4word, /):
    check_int_ge(1, num_digits4word)
def check_otail__ext(oradix, num_digits4oword, has_nonplain_otail__ext, otail__ext, /):
    #if not ((len(otail__ext)==1 and otail__ext[0] < oradix-1) if 1==num_digits4oword else (1 <= len(otail__ext) < num_digits4oword or len(otail__ext)==1+num_digits4oword)): raise TypeError
    if 1 == num_digits4oword:
        if not has_nonplain_otail__ext: raise TypeError
        if not (len(otail__ext)==1 and otail__ext[0] < oradix-1): raise TypeError
    else:
        #if not (1 <= len(otail__ext) < num_digits4oword or len(otail__ext)==1+num_digits4oword): raise TypeError
        if has_nonplain_otail__ext:
            if not (2 <= len(otail__ext) < num_digits4oword or len(otail__ext)==1+num_digits4oword): raise TypeError
        else:
            if not (1 <= len(otail__ext) < num_digits4oword): raise TypeError

    otail__ext[:0]
    check_digits_(oradix, otail__ext)
def check_xtail__mod(radix, num_digits4word, xtail, /):
    if not 1 <= len(xtail) < num_digits4word: raise TypeError
    xtail[:0]
    check_digits_(radix, xtail)
def check_word_(radix, num_digits4word, word, /):
    if not len(word) == num_digits4word: raise TypeError
    word[:0]
    check_digits_(radix, word)

def _check_argsX(radix, num_digits4word, digit_order, /):
    check_radix(radix)
    check_num_digits4word(num_digits4word)
    check_type_is(DigitOrder, digit_order)

def _check_args_ex(iradix, num_digits4iword, idigit_order, oradix, num_digits4oword, odigit_order, space_efficient_bg_threshold, space_efficient_sm_threshold, /):
    _check_argsX(iradix, num_digits4iword, idigit_order)
    _check_argsX(oradix, num_digits4oword, odigit_order)

    if not 1 == gcd(num_digits4iword, num_digits4oword):
        raise ValueError('not [1 == gcd(num_digits4iword, num_digits4oword)]')

    max1__iword = iradix**num_digits4iword
    max1__oword = oradix**num_digits4oword
    if not max1__iword <= max1__oword:
        raise ValueError('not [iradix**num_digits4iword <= oradix**num_digits4oword]') # :[oword_space_large_enough_to_hold_iword]

    if not max1__iword > (oradix-1)**num_digits4oword:
        raise ValueError('not [iradix**num_digits4iword > (oradix-1)**num_digits4oword]')

    if not max1__iword*oradix > max1__oword:
        raise ValueError('not [iradix**num_digits4iword > oradix**(num_digits4oword-1)]')

    if not max1__iword*iradix > max1__oword:
        raise ValueError('not [iradix**(num_digits4iword+1) > oradix**num_digits4oword]')



    #[num_digits4iword == floor_log_(iradix; oradix**num_digits4oword)]
    assert num_digits4iword == floor_log_(iradix, max1__oword)
    #[num_digits4oword == ceil_log_(oradix; iradix**num_digits4iword)]
    assert num_digits4oword == ceil_log_(oradix, max1__iword)
    #[oradix == ceil_kth_root_(num_digits4oword; iradix**num_digits4iword)]
    assert oradix == ceil_kth_root_(num_digits4oword, max1__iword)





    check_space_efficient_xxx_threshold(space_efficient_sm_threshold)
    check_space_efficient_xxx_threshold(space_efficient_bg_threshold)

    (MMM, BBB) = space_efficient_bg_threshold.as_integer_ratio()
    (NNN, DDD) = space_efficient_sm_threshold.as_integer_ratio()
        #.numerator
        #.denominator

    # [MMM/BBB:=space_efficient_bg_threshold][iradix**(num_digits4iword*BBB) > oradix**(num_digits4oword*MMM)]
    if not max1__iword**BBB > max1__oword**MMM:
        raise ValueError('not [[MMM/BBB:=space_efficient_bg_threshold][iradix**(num_digits4iword*BBB) > oradix**(num_digits4oword*MMM)]]')

    # [NNN/DDD:=space_efficient_sm_threshold][oradix**(num_digits4oword*DDD - NNN) < iradix**(num_digits4iword*DDD)]
    if not oradix**(num_digits4oword*DDD - NNN) < iradix**(num_digits4iword*DDD):
        raise ValueError('not [[NNN/DDD:=space_efficient_sm_threshold][oradix**(num_digits4oword*DDD - NNN) < iradix**(num_digits4iword*DDD)]]')

def word_convert_(settingI, settingO, iword, /):
    (iradix, num_digits4iword, idigit_order) = settingI
    (oradix, num_digits4oword, odigit_order) = settingO
    ########
    check_word_(iradix, num_digits4iword, iword)
    u = radix_repr2uint(iradix, iword, is_big_endian=idigit_order is DigitOrder.big_endian)
    oword = uint2radix_repr__padding(oradix, num_digits4oword, odigit_order, u)
    return oword

def uint2radix_repr__padding(oradix, num_digits4oword, odigit_order, u, /):
    _oword_ = tuple(uint2radix_repr(oradix, u, is_big_endian=odigit_order is DigitOrder.big_endian))
    if len(_oword_) < num_digits4oword:
        pad = (0,)*(num_digits4oword-len(_oword_))
        if odigit_order is DigitOrder.big_endian:
            oword = pad + _oword_
        else:
            oword = _oword_ + pad
        oword
    elif len(_oword_) == num_digits4oword:
        oword = _oword_
    else:
        assert len(_oword_) > num_digits4oword
        raise ValueError('overflow: iword too big to be hold by oword')

    oword
    check_word_(oradix, num_digits4oword, oword)
    return oword

def calc_total4nonempty_xtail__mod(radix, num_digits4word, /):
    '-> sum~ radix**L ~{L<-[1..<num_digits4word]}'
    return (radix**num_digits4word-1)//(radix-1) -1

def __():
    from seed.types.NamespaceABC import StaticImmutableNamespaceBase, DynamicImmutableNamespace
    class WordBasedRadixDigitsCodec(StaticImmutableNamespaceBase, ordered_user_attr_seq=_attr_nms
    ):
        pass
    pass
_attr_nms = r'''
    iradix
    num_digits4iword
    idigit_order
    oradix
    num_digits4oword
    odigit_order
    space_efficient_bg_threshold
    space_efficient_sm_threshold

    total4nonempty_itail
    total4nonempty_otail__mod
    has_nonplain_otail__ext
    '''.split()#'''
class IWordBasedRadixDigitsCodec(ABC__no_slots):
    _names4extra_input_ = '' # for __repr__
    @abstractmethod
    def _encode_tail_(sf, itail, /):
        '-> otail__ext'
        #see:encode_tail()
    @abstractmethod
    def _decode_tail_(sf, otail__ext, /):
        '-> itail'
        #see:decode_tail()

    def _check_and_init_post_init_IWordBasedRadixDigitsCodec_(sf, /):
        pass


    ########
    def _get_settingI(sf, /):
        return sf.iradix, sf.num_digits4iword, sf.idigit_order
    def _get_settingO(sf, /):
        return sf.oradix, sf.num_digits4oword, sf.odigit_order
        (iradix, num_digits4iword, idigit_order) = sf._get_settingI()
        (oradix, num_digits4oword, odigit_order) = sf._get_settingO()
    ########

    def _get_args_(sf, /):
        settingI = sf._get_settingI()
        settingO = sf._get_settingO()
        args = (*settingI, *settingO, sf.space_efficient_bg_threshold, sf.space_efficient_sm_threshold)
        return args
    def _get_kwargs_(sf, /):
        kwargs = {nm:getattr(sf, nm) for nm in sf._names4extra_input_}
        return kwargs
    def __eq__(sf, ot, /):
        if sf is ot:
            return True
        if not type(sf) is type(ot):
            return False
        if not sf._get_kwargs_() == ot._get_kwargs_():
            return False
        if not sf._get_args_() == ot._get_args_():
            return False
        return True
    def __hash__(sf, /):
        args = sf._get_args_()
        kwargs = sf._get_kwargs_()
        ps = (*sorted(kwargs.items()),)
        return hash((type(sf), args, ps))
    def __repr__(sf, /):
        args = sf._get_args_()
        kwargs = sf._get_kwargs_()
        return repr_helper(sf, *args, **kwargs)

    def __init__(sf, iradix, num_digits4iword, idigit_order, oradix, num_digits4oword, odigit_order, space_efficient_bg_threshold, space_efficient_sm_threshold, /, **extra_kwds4subcls):
        _check_args_ex(iradix, num_digits4iword, idigit_order, oradix, num_digits4oword, odigit_order, space_efficient_bg_threshold, space_efficient_sm_threshold)

        ########cache:
        total4nonempty_itail = calc_total4nonempty_xtail__mod(iradix, num_digits4iword)
        total4nonempty_otail__mod = calc_total4nonempty_xtail__mod(oradix, num_digits4oword)
        has_nonplain_otail__ext = total4nonempty_itail > total4nonempty_otail__mod
        ########init sf:
        d = vars(sf)
        for nm in _attr_nms:
            d[nm] = locals()[nm]
        ########check sf:
        sf._check_and_init_post_init_IWordBasedRadixDigitsCodec_(**extra_kwds4subcls)
        return
        ########
    def calc_otail_len__ext(sf, output_text_is_empty, otail_len__mod, /):
        has_nonplain_otail__ext = sf.has_nonplain_otail__ext
        num_digits4oword = sf.num_digits4oword

        check_uint_lt(num_digits4oword, otail_len__mod)
        if output_text_is_empty and not otail_len__mod == 0: raise ValueError

        otail_len__ext = otail_len__mod+num_digits4oword if (otail_len__mod==1 and has_nonplain_otail__ext) or (num_digits4oword==1 and not output_text_is_empty) else otail_len__mod
            #view others/数学/编程/generic_base85_encode.txt
            #calc_otail_len__ext ... otail_len__mod = if (otail_len__mod==1 and total4nonempty_itail > total4nonempty_otail__mod) or (num_digits4oword==1 and not len(output_text)==0) then otail_len__mod+num_digits4oword else otail_len__mod
              #see:[about____otail_len__ext]
        return otail_len__ext
    def decode(sf, output_text, /):
        'output_text/Iter odigit -> input_text/Iter idigit'
        return chains(sf._decode(output_text))
    def _decode(sf, output_text, /):
        'output_text/Iter odigit -> Iter tuple<idigit>'
        it = PeekableIterator(iter(output_text))
        (oradix, num_digits4oword, odigit_order) = sf._get_settingO()

        def iter_tmay_pre_iword(may_pre_oword, /):
            if not may_pre_oword is None:
                pre_oword = may_pre_oword
                pre_iword = sf.word_decode(pre_oword)
                yield pre_iword
        may_pre_oword = None
        while 1:
            oword_or_otail__mod = it.read_le(num_digits4oword)
            if not len(oword_or_otail__mod) == num_digits4oword:
                otail__mod = oword_or_otail__mod
                break
            oword = oword_or_otail__mod
            yield from iter_tmay_pre_iword(may_pre_oword)
            #####next round:
            may_pre_oword = oword
        may_pre_oword
        otail__mod
        otail_len__mod = len(otail__mod)
        output_text_is_empty = may_pre_oword is None and not otail_len__mod
        otail_len__ext = sf.calc_otail_len__ext(output_text_is_empty, otail_len__mod)
        if otail_len__ext == otail_len__mod:
            yield from iter_tmay_pre_iword(may_pre_oword)
            otail__ext = otail__mod
        else:
            assert not may_pre_oword is None
            pre_oword = may_pre_oword
            otail__ext = pre_oword + otail__mod
        assert len(otail__ext) == otail_len__ext

        if not otail__ext:
            itail = ()
        elif num_digits4oword==1 and otail__ext[0] == (oradix-1):
            itail = ()
        else:
            itail = sf.decode_tail(otail__ext)
                #return #once without "return itail" in .decode_tail()
            #print(itail) ==>> "None"
        itail

        #if itail: # itail be None???
        if len(itail):
            yield itail
        return
    def encode(sf, input_text, /):
        'input_text/Iter idigit -> output_text/Iter odigit'
        return chains(sf._encode(input_text))
    def _encode(sf, input_text, /):
        'input_text/Iter idigit -> Iter tuple<odigit>'
        it = PeekableIterator(iter(input_text))

        oradix = sf.oradix
        (iradix, num_digits4iword, idigit_order) = sf._get_settingI()
        iprefix_is_empty = True
        while 1:
            iword_or_itail = it.read_le(num_digits4iword)
            if not len(iword_or_itail) == num_digits4iword:
                itail = iword_or_itail
                break
            iprefix_is_empty = False
            iword = iword_or_itail
            oword = sf.word_encode(iword)
            yield oword
        itail
        #view others/数学/编程/generic_base85_encode.txt
          #otail__ext = if itail then encode_tail itail else if num_digits4oword==1 and iprefix then [oradix-1] else []
              #see:[append_indicator_when_num_digits4oword_eq1__itail_empty__input_nonempty]
        if itail:
            # [not [words only]]
            otail__ext = sf.encode_tail(itail)
        # [words only]
        elif not iprefix_is_empty and sf.num_digits4oword==1:
            # [words only][nonempty][num_digits4oword==1]
            # pad an indicator
            otail__ext = (oradix-1,)
        else:
            # [words only][[empty]or[num_digits4oword=!=1]]
            otail__ext = ()
        otail__ext

        if otail__ext:
            yield otail__ext
        return
    #def word_by_word_convert
    def word_encode(sf, iword, /):
        settingI = sf._get_settingI()
        settingO = sf._get_settingO()
        oword = word_convert_(settingI, settingO, iword)
        return oword
    def word_decode(sf, oword, /):
        settingI = sf._get_settingI()
        settingO = sf._get_settingO()
        iword = word_convert_(settingO, settingI, oword)
        return iword
    ########
    def decode_tail(sf, otail__ext, /):
        '-> itail'
        #see:_decode_tail_()
        #print(otail__ext)
        (oradix, num_digits4oword, odigit_order) = sf._get_settingO()
        if 1 == num_digits4oword: raise logic-err
        #####
        check_otail__ext(oradix, num_digits4oword, sf.has_nonplain_otail__ext, otail__ext)

        #####
        itail = sf._decode_tail_(otail__ext)

        (iradix, num_digits4iword, idigit_order) = sf._get_settingI()
        #####
        check_xtail__mod(iradix, num_digits4iword, itail)
        return itail #once without "return"


    ########
    def encode_tail(sf, itail, /):
        '-> otail__ext'
        #see:_encode_tail_()
        (iradix, num_digits4iword, idigit_order) = sf._get_settingI()
        #####
        check_xtail__mod(iradix, num_digits4iword, itail)

        #####
        otail__ext = sf._encode_tail_(itail)

        #####
        (oradix, num_digits4oword, odigit_order) = sf._get_settingO()
        check_otail__ext(oradix, num_digits4oword, sf.has_nonplain_otail__ext, otail__ext)
        return otail__ext
    #init class:
if 1:
    def __():
        cls = IWordBasedRadixDigitsCodec
        for nm in _attr_nms:
            setattr(cls, nm, NamedReadOnlyProperty(nm))
    __()
#end-class IWordBasedRadixDigitsCodec:
class CodecError(Exception):pass
class DecodeError(CodecError):pass
class PaddingProtocol(Enum):
    '[oradix < iradix]'
    missing_lens_are_eq = auto()
    min_output__under_len_transform_be_injection = auto()
    otail_space_is_solid = auto()

    base85_padding_style = auto()
        # now proved
        #   see:proof____base85_padding_style
        # old:
        # xxx unprove its correctness
        #
        #
        # now only support@base85_padding_style:
            # [num_digits4oword == num_digits4iword+1] ==>> [missing_lens_are_eq][min_output__under_len_transform_be_injection][otail_len__ext == itail_len + not (itail_len==0)]
            # [idigit_order is big_endian][odigit_order is big_endian]
        #see:_ver4__iter_find_best_parameters4IWordBasedRadixDigitsCodec
def _iter_pows(base, /):
    x = 1
    while 1:
        yield x
        x *= base
def _calc_pows(base, sz, /):
    return [*islice(_iter_pows(base), sz)]

def _find_ceils(i2a, j2b, /):
    'i2a/[a] -> j2b/[b] -> i2j/[uint]'
    if not i2a: raise TypeError
    if not j2b: raise TypeError
    if not i2a[-1] <= j2b[-1]: raise TypeError
    i2j = []
    j = 0
    a_ = i2a[0]
    for i, a in enumerate(i2a):
        if not a_ <= a: raise TypeError
        while j2b[j] < a:
            j += 1
        i2j.append(j)
    return i2j

class _Icommon4WordBasedRadixDigitsCodec(IWordBasedRadixDigitsCodec):
    '[oradix < iradix] or [oradix > iradix]'
    def _init4otail_space_is_solid(sf, /):
        #case: otail_space_is_solid
        # [oradix < iradix] or [oradix > iradix]
        (iradix, num_digits4iword, idigit_order) = sf._get_settingI()
        (oradix, num_digits4oword, odigit_order) = sf._get_settingO()

        itail_len2ispace_sz = _calc_pows(iradix, num_digits4iword+1)
            # [ispace_sz := iradix**itail_len]
        otail_len__ext2ospace_sz = _calc_pows(oradix, num_digits4oword+2)
            # [ospace_sz := oradix**otail_len__ext]
            # <<== [otail_len__ext==otail_len__mod]
        assert itail_len2ispace_sz[-1] <= otail_len__ext2ospace_sz[-2]
        itail_len2ispace_sz[0] = 0
        itail_len2ispace_sz.pop()
            # "+1"

        otail_len__ext2ospace_sz[0] = 0
        otail_len__ext2ospace_sz[-2] = 0
        if sf.has_nonplain_otail__ext and not num_digits4oword==1:
            otail_len__ext2ospace_sz[1] = 0
        else:
            # "+2"
            otail_len__ext2ospace_sz.pop()
            otail_len__ext2ospace_sz.pop()

        itail_len2iacc_space_sz__exclude_words_only = [*accumulate(itail_len2ispace_sz)]
        assert itail_len2iacc_space_sz__exclude_words_only[0] == 0

        otail_len__ext2oacc_space_sz__exclude_words_only= [*accumulate(otail_len__ext2ospace_sz)]
        assert otail_len__ext2oacc_space_sz__exclude_words_only[0] == 0

        #immutable:
        itail_len2iacc_space_sz__exclude_words_only = (*itail_len2iacc_space_sz__exclude_words_only,)
        otail_len__ext2oacc_space_sz__exclude_words_only = (*otail_len__ext2oacc_space_sz__exclude_words_only,)
        #store:
        sf._bisearch_tables4otail_space_is_solid = (itail_len2iacc_space_sz__exclude_words_only, otail_len__ext2oacc_space_sz__exclude_words_only)
        #end-case: otail_space_is_solid
    #end-def _init4otail_space_is_solid(sf, /):


    def _encode_tail__otail_space_is_solid(sf, itail, /):
        '-> otail__ext'
        (iradix, num_digits4iword, idigit_order) = sf._get_settingI()
        (oradix, num_digits4oword, odigit_order) = sf._get_settingO()

        (itail_len2iacc_space_sz__exclude_words_only, otail_len__ext2oacc_space_sz__exclude_words_only) = sf._bisearch_tables4otail_space_is_solid

        itail_len = len(itail)
        offsetI = itail_len2iacc_space_sz__exclude_words_only[itail_len-1]
        _uI = radix_repr2uint(iradix, itail, is_big_endian=idigit_order is DigitOrder.big_endian)
        u = offsetI + _uI
        (eqv_begin, eqv_end) = bisearch(u, otail_len__ext2oacc_space_sz__exclude_words_only)
        assert eqv_end > 0 # <<== [otail_len__ext2oacc_space_sz__exclude_words_only[0]==0]
        otail_len__ext = eqv_end
        offsetO = otail_len__ext2oacc_space_sz__exclude_words_only[otail_len__ext-1]
        _uO = u - offsetO

        otail__ext = uint2radix_repr__padding(oradix, otail_len__ext, odigit_order, _uO)
        return otail__ext
    def _decode_tail__otail_space_is_solid(sf, otail__ext, /):
        '-> itail'
        (iradix, num_digits4iword, idigit_order) = sf._get_settingI()
        (oradix, num_digits4oword, odigit_order) = sf._get_settingO()

        (itail_len2iacc_space_sz__exclude_words_only, otail_len__ext2oacc_space_sz__exclude_words_only) = sf._bisearch_tables4otail_space_is_solid

        otail_len__ext = len(otail__ext)
        offsetO = otail_len__ext2oacc_space_sz__exclude_words_only[otail_len__ext-1]
        _uO = radix_repr2uint(oradix, otail__ext, is_big_endian=odigit_order is DigitOrder.big_endian)
        u = offsetO + _uO
        (eqv_begin, eqv_end) = bisearch(u, itail_len2iacc_space_sz__exclude_words_only)
        assert eqv_end > 0 # <<== [itail_len2iacc_space_sz__exclude_words_only[0]==0]
        itail_len = eqv_end
        if not 1 <= itail_len < num_digits4iword: raise DecodeError('bad output_text content # otail__ext illegal')
        offsetI = itail_len2iacc_space_sz__exclude_words_only[itail_len-1]
        _uI = u - offsetI

        itail = uint2radix_repr__padding(iradix, itail_len, idigit_order, _uI)
        return itail
#end-class _Icommon4WordBasedRadixDigitsCodec(IWordBasedRadixDigitsCodec):



class WordBasedRadixDigitsCodec__oradix_gt_iradix(_Icommon4WordBasedRadixDigitsCodec):
    '[oradix > iradix]; #==>> [num_digits4iword >= 2][num_digits4iword > num_digits4oword >= 1]'
    @override
    def _check_and_init_post_init_IWordBasedRadixDigitsCodec_(sf, /, **remain_kwds):
        super()._check_and_init_post_init_IWordBasedRadixDigitsCodec_(**remain_kwds)

        if not sf.oradix > sf.iradix: raise ValueError
        if not 1 <= sf.num_digits4oword < sf.num_digits4iword: raise logic-err
        sf._init4otail_space_is_solid()
    @override
    def _encode_tail_(sf, itail, /):
        '-> otail__ext'
        #see:encode_tail()
        return sf._encode_tail__otail_space_is_solid(itail)
    @override
    def _decode_tail_(sf, otail__ext, /):
        '-> itail'
        #see:decode_tail()
        return sf._decode_tail__otail_space_is_solid(otail__ext)
#end-class WordBasedRadixDigitsCodec__oradix_gt_iradix(_Icommon4WordBasedRadixDigitsCodec):


class WordBasedRadixDigitsCodec__oradix_lt_iradix(_Icommon4WordBasedRadixDigitsCodec):
    '[oradix < iradix]; #==>> [num_digits4oword >= 2][num_digits4oword > num_digits4iword >= 1] #==>> [otail_len__ext==otail_len__mod], i.e. [not has_nonplain_otail__ext]'
    _names4extra_input_ = 'padding_protocol'.split()
    padding_protocol = NamedReadOnlyProperty('padding_protocol')

    @override
    def _check_and_init_post_init_IWordBasedRadixDigitsCodec_(sf, /, *, padding_protocol, **remain_kwds):
        check_type_is(PaddingProtocol, padding_protocol)
        vars(sf)['padding_protocol'] = padding_protocol

        super()._check_and_init_post_init_IWordBasedRadixDigitsCodec_(**remain_kwds)

        if not sf.oradix < sf.iradix: raise ValueError
        if sf.has_nonplain_otail__ext: raise logic-err
        if not 1 <= sf.num_digits4iword < sf.num_digits4oword: raise logic-err
        if padding_protocol is PaddingProtocol.missing_lens_are_eq:
            pass
        elif padding_protocol is PaddingProtocol.min_output__under_len_transform_be_injection:
            sf._init4min_output__under_len_transform_be_injection()
        elif padding_protocol is PaddingProtocol.otail_space_is_solid:
            sf._init4otail_space_is_solid()
        elif padding_protocol is PaddingProtocol.base85_padding_style:
            sf._check4base85_padding_style()
            sf._partial_prove_correctness4base85_padding_style()
            pass # same as missing_lens_are_eq
        else:
            raise Exception(f'unknown: {padding_protocol!r}')

    def _gen_odata4partial_prove_correctness4base85_padding_style(sf, /):
        'howto mk up legal output_text???'
        return; yield

    def _gen_idata4partial_prove_correctness4base85_padding_style(sf, /):
        (iradix, num_digits4iword, idigit_order) = sf._get_settingI()
        for x in (0, iradix-1):
            for itail_len in range(1, num_digits4iword):
                input_text = (x,)*itail_len
                yield input_text
    def _partial_prove_correctness4base85_padding_style(sf, /):
        for input_text in sf._gen_idata4partial_prove_correctness4base85_padding_style():
            output_text = (*sf.encode(input_text),)
            _input_text = (*sf.decode(output_text),)
            assert _input_text == input_text, (input_text, output_text, _input_text)
            if not _input_text == input_text:raise logic-err
        for output_text in sf._gen_odata4partial_prove_correctness4base85_padding_style():
            input_text = (*sf.decode(output_text),)
            _output_text = (*sf.encode(input_text),)
            if not _output_text == output_text:raise logic-err
    def _check4base85_padding_style(sf, /):
        (iradix, num_digits4iword, idigit_order) = sf._get_settingI()
        (oradix, num_digits4oword, odigit_order) = sf._get_settingO()
        if not num_digits4oword == num_digits4iword+1: raise NotImplementedError
        # [num_digits4oword == num_digits4iword+1] ==>> [missing_lens_are_eq][min_output__under_len_transform_be_injection][otail_len__ext == itail_len + not (itail_len==0)]
        if not idigit_order is DigitOrder.big_endian: raise NotImplementedError
        if not odigit_order is DigitOrder.big_endian: raise NotImplementedError

    def _init4min_output__under_len_transform_be_injection(sf, /):
        #case: min_output__under_len_transform_be_injection
        # [oradix < iradix]
        (iradix, num_digits4iword, idigit_order) = sf._get_settingI()
        (oradix, num_digits4oword, odigit_order) = sf._get_settingO()

        (itail_len2otail_len__ext, otail_len__ext2itail_len) = __class__._init4min_output__under_len_transform_be_injection_(iradix, num_digits4iword, oradix, num_digits4oword)

        #store:
        sf._bijection4min_output__under_len_transform_be_injection = (itail_len2otail_len__ext, otail_len__ext2itail_len)
        #end-case: min_output__under_len_transform_be_injection
    @classmethod
    def _init4min_output__under_len_transform_be_injection_(cls, iradix, num_digits4iword, oradix, num_digits4oword, /, *, oradix_lt_iradix__not_MUST=False):
        if not oradix_lt_iradix__not_MUST:
            if not oradix < iradix: raise logic-err

        itail_len2ispace_sz = _calc_pows(iradix, num_digits4iword+1)
            # "+1" will pop 1
            # [ispace_sz := iradix**itail_len]
        otail_len__ext2ospace_sz = _calc_pows(oradix, num_digits4oword+1)
            # "+1" will pop 1
            # [ospace_sz := oradix**otail_len__ext]
            # <<== [otail_len__ext==otail_len__mod]
        assert itail_len2ispace_sz[-1] <= otail_len__ext2ospace_sz[-1]


        itail_len2otail_len__ext = _find_ceils(itail_len2ispace_sz, otail_len__ext2ospace_sz)
            # [otail_len__ext := ceil_log_(oradix;iradix**itail_len)]

        if not itail_len2otail_len__ext[0] == 0:raise logic-err
        if not itail_len2otail_len__ext[-1] == num_digits4oword:raise logic-err

        if oradix < iradix:
            if not all(a < b for a,b in pairwise(itail_len2otail_len__ext)):raise logic-err
                # !! [oradix < iradix]
            if not itail_len2otail_len__ext[1] >= 2:raise logic-err
                # !! [oradix < iradix]
                # [ceil_log_(oradix; iradix**1) >= 2]
        else:
            if not all(a <= b for a,b in pairwise(itail_len2otail_len__ext)):raise logic-err
            if not itail_len2otail_len__ext[1] >= 1:raise logic-err



        otail_len__ext2itail_len = {
            otail_len__ext: itail_len
            for itail_len, otail_len__ext
            in enumerate(itail_len2otail_len__ext)
            }
        assert len(otail_len__ext2itail_len) == len(itail_len2otail_len__ext)
            # bijection

        if 0:
            otail_len__ext2ospace_sz.pop()
            itail_len2ispace_sz.pop()
        if 1:
            itail_len2otail_len__ext.pop()
            del otail_len__ext2itail_len[num_digits4oword]

        #immutable:
        if 0:
            otail_len__ext2ospace_sz = (*otail_len__ext2ospace_sz,)
            itail_len2ispace_sz = (*itail_len2ispace_sz,)
        itail_len2otail_len__ext = (*itail_len2otail_len__ext,)
        otail_len__ext2itail_len = MapView(otail_len__ext2itail_len)
        return (itail_len2otail_len__ext, otail_len__ext2itail_len)
    #end-def _init4min_output__under_len_transform_be_injection(sf, /):


    def _get8dispatch(sf, prefix, /):
        p = sf.padding_protocol
        nm = f'{prefix}{p.name}'
        return getattr(sf, nm)
    def _check_len_transform_ok(sf, /):
        if sf.padding_protocol is PaddingProtocol.otail_space_is_solid: raise TypeError('unsupport operation when padding_protocol is otail_space_is_solid')

    def itext_len2otext_len(sf, itext_len, /):
        'len(input_text) -> len(output_text)|^TypeError if padding_protocol is otail_space_is_solid'
        num_digits4iword = sf.num_digits4iword
        num_digits4oword = sf.num_digits4oword

        num_iwords, itail_len = divmod(itext_len, num_digits4iword)
        otail_len__ext = sf.itail_len2otail_len__ext(itail_len)
        num_owords = num_iwords
        otext_len = num_digits4oword*num_owords +otail_len__ext
        return otext_len
    def itext_len5otext_len(sf, otext_len, /):
        'len(input_text) -> len(output_text)|^DecodeError-if-bad-otext_len|^TypeError if padding_protocol is otail_space_is_solid'
        num_digits4iword = sf.num_digits4iword
        num_digits4oword = sf.num_digits4oword

        num_owords, otail_len__mod = divmod(otext_len, num_digits4oword)
        otail_len__ext = otail_len__mod
            # !![not has_nonplain_otail__ext]
        itail_len = sf.itail_len5otail_len__ext(otail_len__ext)
            # ^DecodeError
        num_iwords = num_owords
        itext_len = num_digits4iword*num_iwords +itail_len
        return itext_len

    def itail_len2otail_len__ext(sf, itail_len, /):
        'itail_len -> otail_len__ext|^TypeError if padding_protocol is otail_space_is_solid'
        sf._check_len_transform_ok()
        f = sf._get8dispatch('_itail_len2otail_len__ext__')
        return f(itail_len)
    def itail_len5otail_len__ext(sf, otail_len__ext, /):
        'otail_len__ext -> itail_len|^DecodeError-if-bad-otail_len__ext|^TypeError if padding_protocol is otail_space_is_solid'
        sf._check_len_transform_ok()
        f = sf._get8dispatch('_itail_len5otail_len__ext__')
        return f(otail_len__ext)




    def _itail_len2otail_len__ext__missing_lens_are_eq(sf, itail_len, /):
        'itail_len -> otail_len__ext'
        num_digits4iword = sf.num_digits4iword
        num_digits4oword = sf.num_digits4oword

        check_uint_lt(num_digits4iword, itail_len)
        if itail_len == 0:
            otail_len__ext = 0
        else:
            imiss_len = num_digits4iword -itail_len
            omiss_len = imiss_len
            otail_len__ext = num_digits4oword -omiss_len
        return otail_len__ext
    def _itail_len2otail_len__ext__min_output__under_len_transform_be_injection(sf, itail_len, /):
        'itail_len -> otail_len__ext'
        num_digits4iword = sf.num_digits4iword

        check_uint_lt(num_digits4iword, itail_len)
        if itail_len == 0:
            otail_len__ext = 0
        else:
            (itail_len2otail_len__ext, otail_len__ext2itail_len) = sf._bijection4min_output__under_len_transform_be_injection
            otail_len__ext = itail_len2otail_len__ext[itail_len]
        return otail_len__ext
    _itail_len2otail_len__ext__base85_padding_style = _itail_len2otail_len__ext__missing_lens_are_eq



    def _itail_len5otail_len__ext__missing_lens_are_eq(sf, otail_len__ext, /):
        'otail_len__ext -> itail_len|^DecodeError-if-bad-otail_len__ext'
        num_digits4iword = sf.num_digits4iword
        num_digits4oword = sf.num_digits4oword

        check_uint_lt(num_digits4oword, otail_len__ext) # [not has_nonplain_otail__ext]
        if otail_len__ext == 0:
            itail_len = 0
        else:
            omiss_len = num_digits4oword -otail_len__ext
            imiss_len = omiss_len

            itail_len = num_digits4iword -imiss_len
            if itail_len <= 0: raise DecodeError('bad len(output_text)')
        return itail_len
    def _itail_len5otail_len__ext__min_output__under_len_transform_be_injection(sf, otail_len__ext, /):
        'otail_len__ext -> itail_len|^DecodeError-if-bad-otail_len__ext'
        num_digits4oword = sf.num_digits4oword

        check_uint_lt(num_digits4oword, otail_len__ext) # [not has_nonplain_otail__ext]
        if otail_len__ext == 0:
            itail_len = 0
        else:
            (itail_len2otail_len__ext, otail_len__ext2itail_len) = sf._bijection4min_output__under_len_transform_be_injection

            try:
                itail_len = otail_len__ext2itail_len[otail_len__ext]
            except KeyError:
                raise DecodeError('bad len(output_text)')

        return itail_len
    _itail_len5otail_len__ext__base85_padding_style = _itail_len5otail_len__ext__missing_lens_are_eq


    @override
    def _encode_tail_(sf, itail, /):
        '-> otail__ext'
        #see:encode_tail()
        f = sf._get8dispatch('_encode_tail__')
        return f(itail)
    @override
    def _decode_tail_(sf, otail__ext, /):
        '-> itail'
        #see:decode_tail()
        f = sf._get8dispatch('_decode_tail__')
        return f(otail__ext)





    def _encode_tail__if_len_transform_ok(sf, itail, /):
        '-> otail__ext'
        sf._check_len_transform_ok()

        (iradix, num_digits4iword, idigit_order) = sf._get_settingI()
        (oradix, num_digits4oword, odigit_order) = sf._get_settingO()

        itail_len = len(itail)
        otail_len__ext = sf.itail_len2otail_len__ext(itail_len)

        if sf.padding_protocol is PaddingProtocol.base85_padding_style:
            padding = (0,)*(num_digits4iword - itail_len)
            padded_iword = itail + padding
            padded_oword = sf.word_encode(padded_iword)
            otail__ext = padded_oword[:otail_len__ext]
        else:
            settingI = (iradix, itail_len, idigit_order)
            settingO = (oradix, otail_len__ext, odigit_order)
            otail__ext = word_convert_(settingI, settingO, itail)
        return otail__ext
    _encode_tail__missing_lens_are_eq = _encode_tail__if_len_transform_ok
    _encode_tail__min_output__under_len_transform_be_injection = _encode_tail__if_len_transform_ok
    _encode_tail__base85_padding_style = _encode_tail__if_len_transform_ok


    def _decode_tail__if_len_transform_ok(sf, otail__ext, /):
        '-> itail|^DecodeError-if-bad-otail_len__ext'
        sf._check_len_transform_ok()

        (iradix, num_digits4iword, idigit_order) = sf._get_settingI()
        (oradix, num_digits4oword, odigit_order) = sf._get_settingO()

        otail_len__ext = len(otail__ext)
        itail_len = sf.itail_len5otail_len__ext(otail_len__ext)
            # ^DecodeError

        if sf.padding_protocol is PaddingProtocol.base85_padding_style:
            padding = (oradix-1,)*(num_digits4oword - otail_len__ext)
            padded_oword = otail__ext + padding
            padded_iword = sf.word_decode(padded_oword)
            itail = padded_iword[:itail_len]
            #print(otail__ext, padding, padded_iword, itail_len)
            assert 0 < itail_len == otail_len__ext -1
            assert padded_iword
            assert itail
        else:
            settingI = (iradix, itail_len, idigit_order)
            settingO = (oradix, otail_len__ext, odigit_order)
            itail = word_convert_(settingO, settingI, otail__ext)
        return itail
    _decode_tail__missing_lens_are_eq = _decode_tail__if_len_transform_ok
    _decode_tail__min_output__under_len_transform_be_injection = _decode_tail__if_len_transform_ok
    _decode_tail__base85_padding_style = _decode_tail__if_len_transform_ok
#end-class WordBasedRadixDigitsCodec__oradix_lt_iradix(_Icommon4WordBasedRadixDigitsCodec):








def main4check_core_args4IWordBasedRadixDigitsCodec(*, iradix, num_digits4iword, oradix, num_digits4oword, str8space_efficient_bg_threshold, str8space_efficient_sm_threshold):
    check_type_is(str, str8space_efficient_bg_threshold)
    check_type_is(str, str8space_efficient_sm_threshold)

    space_efficient_bg_threshold = Fraction(str8space_efficient_bg_threshold)
    space_efficient_sm_threshold = Fraction(str8space_efficient_sm_threshold)

    idigit_order = odigit_order = DigitOrder.big_endian

    _check_args_ex(iradix, num_digits4iword, idigit_order, oradix, num_digits4oword, odigit_order, space_efficient_bg_threshold, space_efficient_sm_threshold)
    return

def float_calc_space_efficient_bg_threshold(iradix, num_digits4iword, oradix, num_digits4oword, /):
    # [log2(iradix**num_digits4iword)/log2(oradix**num_digits4oword) > space_efficient_bg_threshold]
    space_efficient_bg_threshold = math.log2(iradix)*num_digits4iword/math.log2(oradix)/num_digits4oword
    return space_efficient_bg_threshold
def float_calc_space_efficient_sm_threshold(iradix, num_digits4iword, oradix, num_digits4oword, /):
    # [num_digits4oword - log_(oradix; iradix**num_digits4iword) < space_efficient_sm_threshold]
    space_efficient_sm_threshold = num_digits4oword - num_digits4iword*math.log2(iradix)/math.log2(oradix)
    return space_efficient_sm_threshold
def _attach_space_efficient(iradix, it, /):
    'Iter (oradix, num_digits4oword, num_digits4iword) -> Iter (oradix, num_digits4oword, num_digits4iword, space_efficient_bg_threshold, space_efficient_sm_threshold)'
    for (oradix, num_digits4oword, num_digits4iword) in it:
        space_efficient_bg_threshold = float_calc_space_efficient_bg_threshold(iradix, num_digits4iword, oradix, num_digits4oword)
        space_efficient_sm_threshold = float_calc_space_efficient_sm_threshold(iradix, num_digits4iword, oradix, num_digits4oword)
        yield (oradix, num_digits4oword, num_digits4iword, space_efficient_bg_threshold, space_efficient_sm_threshold)
#def main4iter_find_best_parameters4IWordBasedRadixDigitsCodec(*, iradix, numerator4space_efficient_sm_threshold, denominator4space_efficient_sm_threshold, max__oradix, max__max1__oword):
    #space_efficient_sm_threshold = Fraction(numerator4space_efficient_sm_threshold, denominator4space_efficient_sm_threshold)
def main4iter_find_best_parameters4IWordBasedRadixDigitsCodec(*, iradix, str8space_efficient_bg_threshold, str8space_efficient_sm_threshold, max__oradix, max__max1__oword, ver, to_attach_space_efficient=False, diff__num_digits4oword__num_digits4iword__eq1=False, no_better_and_smaller_setting=True):
    '-> Iter (oradix, num_digits4oword, num_digits4iword) if not to_attach_space_efficient'
    check_type_is(str, str8space_efficient_bg_threshold)
    check_type_is(str, str8space_efficient_sm_threshold)

    space_efficient_bg_threshold = Fraction(str8space_efficient_bg_threshold)
    space_efficient_sm_threshold = Fraction(str8space_efficient_sm_threshold)

    it = iter_find_best_parameters4IWordBasedRadixDigitsCodec(iradix, space_efficient_bg_threshold, space_efficient_sm_threshold, max__oradix, max__max1__oword, ver=ver, diff__num_digits4oword__num_digits4iword__eq1=diff__num_digits4oword__num_digits4iword__eq1, no_better_and_smaller_setting=no_better_and_smaller_setting)
    if to_attach_space_efficient:
        it = _attach_space_efficient(iradix, it)
    return it
def iter_find_best_parameters4IWordBasedRadixDigitsCodec(iradix, space_efficient_bg_threshold, space_efficient_sm_threshold, max__oradix, max__max1__oword, /, *, ver, diff__num_digits4oword__num_digits4iword__eq1, no_better_and_smaller_setting):
    r'''[[[
-> Iter (oradix, num_digits4oword, num_digits4iword)


args:IWordBasedRadixDigitsCodec<iradix, num_digits4iword, idigit_order, oradix, num_digits4oword, odigit_order, space_efficient_bg_threshold, space_efficient_sm_threshold>

# max1__iword == 1+max<iword>
# max1__oword == 1+max<oword>
[max1__iword := iradix**num_digits4iword]
[max1__oword := oradix**num_digits4oword]

select best args:
  input:
    iradix
    space_efficient_bg_threshold
        [log2(iradix**num_digits4iword)/log2(oradix**num_digits4oword) > space_efficient_bg_threshold]
        [the bigger space_efficient_bg_threshold, the better]
    space_efficient_sm_threshold
        [num_digits4oword - log_(oradix; iradix**num_digits4iword) < space_efficient_sm_threshold]
        [the smaller space_efficient_sm_threshold, the better]
    max__oradix
        #可用字母表大小，但同等 空间效率 情形下，有可能 减小oradix 以保留更多字母用作其他用途
        space_efficient
    max__max1__oword
        控制 单元长度，单元长度 越小，局域性越强，运算量 越少
        time_efficient
        [oradix**num_digits4oword <= max__max1__oword]
        ==>>:
        [max1__iword == iradix**num_digits4iword <= oradix**num_digits4oword == max1__oword <= max__max1__oword]

  output:
    oradix
    num_digits4oword
    num_digits4iword

最终稳定满足:
    [oradix == ceil_kth_root_(num_digits4oword; iradix**num_digits4iword)]
    [1 <= num_digits4oword == ceil_log_(oradix; iradix**num_digits4iword)]
    [1 <= num_digits4iword == floor_log_(iradix; oradix**num_digits4oword)]

    [MMM/BBB:=space_efficient_bg_threshold][iradix**(num_digits4iword*BBB) > oradix**(num_digits4oword*MMM)]
    [NNN/DDD:=space_efficient_sm_threshold][oradix**(num_digits4oword*DDD - NNN) < iradix**(num_digits4iword*DDD)]
    [2 <= oradix <= max__oradix]
    [oradix**num_digits4oword <= max__max1__oword]
    [1 == gcd(num_digits4iword, num_digits4oword)]



    #new constraint added:
    #   with new kw:no_better_and_smaller_setting
    [not [?[i <- [1..<num_digits4iword]] -> ?[j <- [1..<num_digits4oword]] -> [[iradix**i <= oradix**j][iradix**(num_digits4iword-i) <= oradix**(num_digits4oword-j)]]]]
        # hence: [1 == gcd(num_digits4iword, num_digits4oword)]
        # &&[oradix < iradix] ==>> [base85_padding_style-encode/decode ok]
        # see:proof____base85_padding_style
    #]]]'''#'''
    check_radix(iradix)
    check_space_efficient_xxx_threshold(space_efficient_bg_threshold)
    check_space_efficient_xxx_threshold(space_efficient_sm_threshold)
    check_radix(max__oradix)
    check_int_ge(iradix, max__max1__oword)
    #####update
    max__oradix = min(max__oradix, max__max1__oword)
    if diff__num_digits4oword__num_digits4iword__eq1:
        # [num_digits4oword == num_digits4iword + 1]
        # [num_digits4oword > num_digits4iword]
        # [oradix < iradix]
        #       #otherwise min locality => reduce num_digits4oword --> num_digits4iword
        max__oradix = min(max__oradix, iradix-1)
        if max__oradix < 2:
            return
        check_radix(max__oradix)
    #####
    (MMM, BBB) = space_efficient_bg_threshold.as_integer_ratio()
    (NNN, DDD) = space_efficient_sm_threshold.as_integer_ratio()
    idigit_order = odigit_order = DigitOrder.big_endian

    nm = f'_ver{ver}__iter_find_best_parameters4IWordBasedRadixDigitsCodec'
    f = globals()[nm]
    it = f(iradix, max__oradix, max__max1__oword, MMM, BBB, NNN, DDD, idigit_order, odigit_order)
    for (oradix, num_digits4oword, num_digits4iword) in it:
        #if oradix == 85 and num_digits4oword==5: print(num_digits4iword) #--> 4

        # [2 <= oradix <= max__oradix]
        if not 2 <= oradix <= max__oradix:
            continue

        if not 1 <= num_digits4oword:
            continue

        if not 1 <= num_digits4iword:
            continue
        if diff__num_digits4oword__num_digits4iword__eq1:
            if not num_digits4oword == num_digits4iword +1:
                continue

        # [1 == gcd(num_digits4iword, num_digits4oword)]
        if not 1 == gcd(num_digits4iword, num_digits4oword):
            continue


        max1__oword = oradix**num_digits4oword
        # [oradix**num_digits4oword <= max__max1__oword]
        if not max1__oword <= max__max1__oword:
            continue

        max1__iword = iradix**num_digits4iword
        # [oradix == ceil_kth_root_(num_digits4oword; iradix**num_digits4iword)]
        if not max1__iword <= max1__oword:
            continue
        if not max1__iword > (oradix-1)**num_digits4oword:
            continue

        # [1 <= num_digits4oword == ceil_log_(oradix; iradix**num_digits4iword)]
        if not max1__iword*oradix > max1__oword:
            continue


        # [1 <= num_digits4iword == floor_log_(iradix; oradix**num_digits4oword)]
        if not max1__iword*iradix > max1__oword:
            continue

        # [MMM/BBB:=space_efficient_bg_threshold][iradix**(num_digits4iword*BBB) > oradix**(num_digits4oword*MMM)]
        if not max1__iword**BBB > max1__oword**MMM:
            continue

        # [NNN/DDD:=space_efficient_sm_threshold][oradix**(num_digits4oword*DDD - NNN) < iradix**(num_digits4iword*DDD)]
        if not oradix**(num_digits4oword*DDD - NNN) < iradix**(num_digits4iword*DDD):
            continue

        if no_better_and_smaller_setting:
            (itail_len2otail_len__ext, otail_len__ext2itail_len) = WordBasedRadixDigitsCodec__oradix_lt_iradix._init4min_output__under_len_transform_be_injection_(iradix, num_digits4iword, oradix, num_digits4oword, oradix_lt_iradix__not_MUST=True)
            for itail_len in range(2, num_digits4iword):
                otail_len__ext = itail_len2otail_len__ext[itail_len]
                if not oradix**(num_digits4oword-otail_len__ext) < iradix**(num_digits4iword-itail_len):
                    continue

        # satisfy all requirements:
        _check_args_ex(iradix, num_digits4iword, idigit_order, oradix, num_digits4oword, odigit_order, space_efficient_bg_threshold, space_efficient_sm_threshold)
        yield (oradix, num_digits4oword, num_digits4iword)
#end-def iter_find_best_parameters4IWordBasedRadixDigitsCodec(iradix, space_efficient_bg_threshold, space_efficient_sm_threshold, max__oradix, max__max1__oword, /):



def calc_upperbound4num_digits4oword__if_diff__num_digits4oword__num_digits4iword__eq_neg1(iradix, /):
    r'''
-> upperbound4num_digits4oword__dfn1/bad__num_digits4oword__dfn1
    [num_digits4oword < upperbound4num_digits4oword__dfn1]

assume [diff__num_digits4oword__num_digits4iword__eq_neg1]
    [num_digits4oword == num_digits4iword - 1]
    ==>> [oradix > iradix]

ceil(x**((k+1)/k)) <<==:
    # [oradix == ceil_kth_root_(num_digits4oword; iradix**num_digits4iword)]
    let [k := num_digits4oword][x := iradix]

[x < ceil(x**((k+1)/k))]
    !! [(x**((k+1)/k)) > x]
[x < ceil(x**((k+1)/k)) <= x**2]
    !! [k >= 1]
        # [num_digits4oword >= 1]
    !! [((k+1)/k) be largest if min k]
[k --> +oo] -> [ceil(x**((k+1)/k)) == x+1]
[ceil(x**((k+1)/k)) == x+1]
    <==> [ceil(x**((k+1)/k)) < x+2]
    <==> [(x**((k+1)/k)) < x+2]
    <==> [(x**(1/k)) < 1+2/x]
    <==> [log2(x)*(1/k) < log2(1+2/x)]
    <==> [log2(x)/log2(1+2/x) < k]
    <==> [k > log(x)/log1p(2/x)]
    <==> [k >= ceil(log(x)/log1p(2/x))]

[oradix==x+1]:
    # [1 <= num_digits4oword == ceil_log_(oradix; iradix**num_digits4iword)]
    [k==ceil_log_(x+1;x**(k+1))]
    [(x+1)**(k-1) < x**(k+1) <= (x+1)**k]

    # [1 <= num_digits4iword == floor_log_(iradix; oradix**num_digits4oword)]
    [k+1==floor_log_(x;(x+1)**k)]
    [x**(k+1) <= (x+1)**k < x**(k+2)]


    [(x+1)**(k-1) < x**(k+1)]:
        <=> [(1+1/x)**k < x*(x+1)]
        <=> [log(1+1/x)*k < log(x*(x+1))]
        <=> [k < log(x*(x+1)) / log1p(1/x)]
    [x**(k+1) <= (x+1)**k]:
        <=> [(1+1/x)**k >= x]
        <=> [k >= log(x) / log1p(1/x)]
    [(x+1)**k < x**(k+2)]:
        <=> [(1+1/x)**k < x*x]
        <=> [k < 2*log(x) / log1p(1/x)]

    [(x+1)**(k-1) < x**(k+1) <= (x+1)**k < x**(k+2)]
        <=> [log(x) / log1p(1/x) <= k < 2*log(x) / log1p(1/x)]

[upperbound4num_digits4oword<-1> = ceil(2*log(x) / log1p(1/x))]
    '''#'''
    x = iradix
    # [upperbound4num_digits4oword<-1> = ceil(2*log(x) / log1p(1/x))]
    k = math.ceil(2*math.log(x) / math.log1p(1.0/x))
    k0 = k
    def is_ok_(num_digits4oword, /):
        num_digits4iword = num_digits4oword+1
        max1__iword = iradix**num_digits4iword
        oradix = ceil_kth_root_(num_digits4oword, max1__iword)
        #useless:return oradix > iradix
        max1__oword = oradix**num_digits4oword
        # [1 <= num_digits4iword == floor_log_(iradix; oradix**num_digits4oword)]
        _num_digits4iword = floor_log_(iradix, max1__oword)
        return _num_digits4iword == num_digits4iword

    while is_ok_(k):
        k += 1
    while not is_ok_(k-1):
        k -= 1
        if k*3 < k0: raise Exception('logic-err or data?')
    assert is_ok_(k-1)
    assert not is_ok_(k)

    bad__num_digits4oword__dfn1 = k
    return bad__num_digits4oword__dfn1


def calc_upperbound4num_digits4oword__if_diff__num_digits4oword__num_digits4iword__eq1(iradix, /):
    r'''
-> upperbound4num_digits4oword__dfp1/bad__num_digits4oword__dfp1
    [num_digits4oword < upperbound4num_digits4oword__dfp1]

assume [diff__num_digits4oword__num_digits4iword__eq1]
    [num_digits4oword == num_digits4iword + 1]
    ==>> [oradix < iradix]

ceil(x**((k-1)/k)) <<==:
    # [oradix == ceil_kth_root_(num_digits4oword; iradix**num_digits4iword)]
    oradix = ceil_kth_root_(num_digits4oword, max1__iword)
        = ceil_kth_root_(num_digits4oword, iradix**num_digits4iword)
        = ceil_kth_root_(num_digits4oword, iradix**(num_digits4oword-1))
        let [k := num_digits4oword][x := iradix]
        = ceil_kth_root_(k, x**(k-1))
        = ceil(kth_root_(k, x**(k-1))
        = ceil(x**((k-1)/k))
[x <= ceil(x**((k-1)/k))]
    !! [(x**((k-1)/k)) < x]
    <==> [x == ceil(x**((k-1)/k))]
    <==> [x-1 < x**((k-1)/k)]
    <==> [(x-1)**k < x**(k-1)]
    <==> [x * (x-1)**k < x**k]
    <==> [x < (x/(x-1))**k]
    <==> [log2(x) < k*log2(x/(x-1))]
    <==> [log2(x)/log2(x/(x-1)) < k]
    ...

    or:
    <==> [x-1 < x**((k-1)/k)]
    <==> [x-1 < x**(1-1/k)]
    <==> [log2(x-1) < log2(x)*(1-1/k)]
    <==> [log2(x-1)/log2(x) < (1-1/k)]
    <==> [1/k < (1-log2(x-1)/log2(x))]
    <==> [1/(1-log2(x-1)/log2(x)) < k]
    <==> [log2(x)/(log2(x)-log2(x-1)) < k]
    <==> [log2(x)/log2(x/(x-1)) < k]
    ...
    <==> [log(x)/log(x/(x-1)) < k]
    <==> [log(x)/-log(1-1/x) < k]
    <==> [-log(x)/log1p(-1/x) < k]
    <==> [floor(-log(x)/log1p(-1/x)) < k]
    <==> [1+floor(-log(x)/log1p(-1/x)) <= k]
[upperbound4num_digits4oword<+1> = 1 +floor(-log(x) / log1p(-1/x))]

[oradix==x-1]:
    # [1 <= num_digits4oword == ceil_log_(oradix; iradix**num_digits4iword)]
    [k==ceil_log_(x-1;x**(k-1))]
    [(x-1)**(k-1) < x**(k-1) <= (x-1)**k]

    # [1 <= num_digits4iword == floor_log_(iradix; oradix**num_digits4oword)]
    [k-1==floor_log_(x;(x-1)**k)]
    [x**(k-1) <= (x-1)**k < x**k]

    [(x-1)**(k-1) < x**(k-1)]:
        !! [x>=2]
        <=> [k >= 2]
    [x**(k-1) <= (x-1)**k]:
        <=> [(1-1/x)**k >= 1/x]
        <=> [k <= -log(x) / log1p(-1/x)]
    [(x-1)**k < x**k]:
        !! [x>=2]
        <=> [k >= 1]

    [(x-1)**(k-1) < x**(k-1) <= (x-1)**k < x**k]
        <=> [2 <= k <= -log(x) / log1p(-1/x)]
        <=> [2 <= k <= floor(-log(x) / log1p(-1/x))]

[upperbound4num_digits4oword<+1> = 1 +floor(-log(x) / log1p(-1/x))]



    '''#'''
    x = iradix
    if 0:
        # [log2(x)/log2(x/(x-1)) < k]
        k = math.ceil(math.log2(x)/math.log2(x/(x-1)))
    else:
        # [upperbound4num_digits4oword<+1> = 1 +floor(-log(x) / log1p(-1/x))]
        k = 1+math.floor(-math.log(x)/math.log1p(-1.0/x))
    #bad__num_digits4oword__dfp1 = k
    k0 = k
    def is_ok_(num_digits4oword, /):
        num_digits4iword = num_digits4oword-1
        max1__iword = iradix**num_digits4iword
        oradix = ceil_kth_root_(num_digits4oword, max1__iword)
        return oradix < iradix

    while is_ok_(k):
        k += 1
    while not is_ok_(k-1):
        k -= 1
        if k*3 < k0: raise Exception('logic-err or data?')
    assert is_ok_(k-1)
    assert not is_ok_(k)

    bad__num_digits4oword__dfp1 = k
    return bad__num_digits4oword__dfp1


def _ver4__iter_find_best_parameters4IWordBasedRadixDigitsCodec(iradix, max__oradix, max__max1__oword, MMM, BBB, NNN, DDD, idigit_order, odigit_order, /):
    'ver4: each column is sorted <<== turnon:[diff__num_digits4oword__num_digits4iword__eq1==True] #see:PaddingProtocol.base85_padding_style'
    diff__num_digits4oword__num_digits4iword__eq1 = True
    if diff__num_digits4oword__num_digits4iword__eq1:
        max__oradix = min(max__oradix, iradix-1)
        if max__oradix < 2:
            return
    bad__num_digits4oword__dfp1 = calc_upperbound4num_digits4oword__if_diff__num_digits4oword__num_digits4iword__eq1(iradix)

    max__num_digits4iword = bad__num_digits4oword__dfp1 -1
    if iradix**max__num_digits4iword > max__max1__oword:
        max__num_digits4iword = floor_log_(iradix, max__max1__oword)
        assert max__num_digits4iword < bad__num_digits4oword__dfp1 -1

    for num_digits4iword, max1__iword in enumerate(islice(_iter_pows(iradix), 1, max__num_digits4iword+1), 1):
        # [diff__num_digits4oword__num_digits4iword__eq1==True]
        num_digits4oword = num_digits4iword + 1
        # [oradix == ceil_kth_root_(num_digits4oword; iradix**num_digits4iword)]
        oradix = ceil_kth_root_(num_digits4oword, max1__iword)
        if not oradix <= max__oradix:
            break
        yield (oradix, num_digits4oword, num_digits4iword)
def _ver3__iter_find_best_parameters4IWordBasedRadixDigitsCodec(iradix, max__oradix, max__max1__oword, MMM, BBB, NNN, DDD, idigit_order, odigit_order, /):
    'ver3: sorted by num_digits4iword'
    # [iradix**num_digits4iword <= oradix**num_digits4oword][oradix**num_digits4oword <= max__max1__oword]
    max__num_digits4iword = floor_log_(iradix, max__max1__oword)
    for num_digits4iword, max1__iword in enumerate(islice(_iter_pows(iradix), 1, max__num_digits4iword+1), 1):
        # [2 <= oradix <= max__oradix]
        # [oradix <= max1__iword] <<== [num_digits4oword >= 1][oradix == ceil_kth_root_(num_digits4oword; iradix**num_digits4iword)]
        for oradix in range(2, min(max1__iword,max__oradix)+1):
            # [1 <= num_digits4oword == ceil_log_(oradix; iradix**num_digits4iword)]
            num_digits4oword = ceil_log_(oradix, max1__iword)
            yield (oradix, num_digits4oword, num_digits4iword)

def _ver2__iter_find_best_parameters4IWordBasedRadixDigitsCodec(iradix, max__oradix, max__max1__oword, MMM, BBB, NNN, DDD, idigit_order, odigit_order, /):
    'ver2: sorted by num_digits4oword'
    # [1 <= num_digits4oword == ceil_log_(oradix; iradix**num_digits4iword)]
    # [oradix**num_digits4oword <= max__max1__oword]
    # [2 <= oradix <= max__oradix]
    max__num_digits4oword = floor_log2(max__max1__oword)
    for num_digits4oword in range(1, max__num_digits4oword+1):
        # [2 <= oradix <= max__oradix]
        for oradix in range(2, min(max__oradix, floor_kth_root_(num_digits4oword, max__max1__oword))+1):
            max1__oword = oradix**num_digits4oword
            # [1 <= num_digits4iword == floor_log_(iradix; oradix**num_digits4oword)]
            num_digits4iword = floor_log_(iradix, max1__oword)

            yield (oradix, num_digits4oword, num_digits4iword)

def _ver1111__iter_find_best_parameters4IWordBasedRadixDigitsCodec(iradix, max__oradix, max__max1__oword, MMM, BBB, NNN, DDD, idigit_order, odigit_order, /):
    'ver1111: sorted by oradix, using_cf'
    # [2 <= oradix <= max__oradix]
    for oradix in range(2, max__oradix+1):
        # [oradix**num_digits4oword <= max__max1__oword]
        max__num_digits4oword = floor_log_(oradix, max__max1__oword)
        # [iradix**num_digits4iword <= oradix**num_digits4oword]
        # [num_digits4iword/num_digits4oword <= log_(iradix;oradix)]
        it = iter_approximate_fractions_le5continued_fraction_of_log_(iradix, oradix, may_max1_denominator=1+max__num_digits4oword)
        for fr in it:
            num_digits4iword, num_digits4oword = fr.as_integer_ratio()
            assert num_digits4oword <= max__num_digits4oword
            if num_digits4iword > 0:
                yield (oradix, num_digits4oword, num_digits4iword)

def _ver1__iter_find_best_parameters4IWordBasedRadixDigitsCodec(iradix, max__oradix, max__max1__oword, MMM, BBB, NNN, DDD, idigit_order, odigit_order, /):
    'ver1: sorted by oradix'
    # [2 <= oradix <= max__oradix]
    for oradix in range(2, max__oradix+1):
        # [oradix**num_digits4oword <= max__max1__oword]
        max__num_digits4oword = floor_log_(oradix, max__max1__oword)
        for num_digits4oword, max1__oword in enumerate(islice(_iter_pows(oradix), 1, max__num_digits4oword+1), 1):
            # [1 <= num_digits4iword == floor_log_(iradix; oradix**num_digits4oword)]
            num_digits4iword = floor_log_(iradix, max1__oword)

            yield (oradix, num_digits4oword, num_digits4iword)



impl__base64__xx85codec__mod__buggy_via_missing_lens_are_eq = WordBasedRadixDigitsCodec__oradix_lt_iradix(256, 4, DigitOrder.big_endian, 85, 5, DigitOrder.big_endian, Fraction(9,10), Fraction(1,10), padding_protocol=PaddingProtocol.missing_lens_are_eq)
impl__base64__xx85codec__mod = WordBasedRadixDigitsCodec__oradix_lt_iradix(256, 4, DigitOrder.big_endian, 85, 5, DigitOrder.big_endian, Fraction(9,10), Fraction(1,10), padding_protocol=PaddingProtocol.base85_padding_style)


b85_alphabet = (b"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                b"abcdefghijklmnopqrstuvwxyz!#$%&()*+-;<=>?@^_`{|}~")
_bs__0_85 = bytes(range(85))
a85_alphabet = bytes(range(ord(' ')+1, ord('v')))
assert len(a85_alphabet) == 85
_table__a85encode = bytes.maketrans(_bs__0_85, a85_alphabet)
_table__a85decode = bytes.maketrans(a85_alphabet, _bs__0_85)

_table__b85encode = bytes.maketrans(_bs__0_85, b85_alphabet)
_table__b85decode = bytes.maketrans(b85_alphabet, _bs__0_85)

def impl__base64__xx85encode_(impl__base64__xx85codec__mod, _table__xx85encode, data_bs, /):
    bs__mod85 = bytes(impl__base64__xx85codec__mod.encode(data_bs))
    bs__xx85 = bs__mod85.translate(_table__xx85encode)
    return bs__xx85
def impl__base64__xx85decode_(impl__base64__xx85codec__mod, _table__xx85decode, bs__xx85, /):
    bs__mod85 = bs__xx85.translate(_table__xx85decode)
    data_bs = bytes(impl__base64__xx85codec__mod.decode(bs__mod85))
    #print(bs__mod85, data_bs)
    return data_bs




def impl__base64__a85encode(data_bs, /):
    return impl__base64__xx85encode_(impl__base64__xx85codec__mod, _table__a85encode, data_bs)
def impl__base64__a85decode(bs__a85, /):
    return impl__base64__xx85decode_(impl__base64__xx85codec__mod, _table__a85decode, bs__a85)
def impl__base64__b85encode(data_bs, /):
    return impl__base64__xx85encode_(impl__base64__xx85codec__mod, _table__b85encode, data_bs)
def impl__base64__b85decode(bs__b85, /):
    return impl__base64__xx85decode_(impl__base64__xx85codec__mod, _table__b85decode, bs__b85)


def impl__base64__a85encode__buggy_via_missing_lens_are_eq(data_bs, /):
    return impl__base64__xx85encode_(impl__base64__xx85codec__mod__buggy_via_missing_lens_are_eq, _table__a85encode, data_bs)
def impl__base64__a85decode__buggy_via_missing_lens_are_eq(bs__a85, /):
    return impl__base64__xx85decode_(impl__base64__xx85codec__mod__buggy_via_missing_lens_are_eq, _table__a85decode, bs__a85)
def impl__base64__b85encode__buggy_via_missing_lens_are_eq(data_bs, /):
    return impl__base64__xx85encode_(impl__base64__xx85codec__mod__buggy_via_missing_lens_are_eq, _table__b85encode, data_bs)
def impl__base64__b85decode__buggy_via_missing_lens_are_eq(bs__b85, /):
    return impl__base64__xx85decode_(impl__base64__xx85codec__mod__buggy_via_missing_lens_are_eq, _table__b85decode, bs__b85)


if __name__ == "__main__":
    pass
__all__


from seed.int_tools.digits.generic_base85 import iter_find_best_parameters4IWordBasedRadixDigitsCodec
from seed.int_tools.digits.generic_base85 import WordBasedRadixDigitsCodec__oradix_lt_iradix, PaddingProtocol, DigitOrder
from seed.int_tools.digits.generic_base85 import DecodeError

from seed.int_tools.digits.generic_base85 import *
