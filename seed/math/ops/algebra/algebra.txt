
e ../../python3_src/seed/math/ops/algebra/algebra.txt

[[[[[[[
[[[[[

[[
view ../../python3_src/nn_ns/math_nn/algebra/is_ring.py
===
is_abelian_group
is_monoid
    commutative rings > integral domains > integrally closed domains > GCD domains > unique factorization domains > principal ideal domains > Euclidean domains > fields > finite fields
Field: a commutative ring which contains a multiplicative inverse for every nonzero element
zero ring v.s. nonzero ring
    zero ring <=> only one element <=> trivial ring
domain is a nonzero ring in which ab = 0 implies a = 0 or b = 0.
    "the zero-product property"
    Equivalently, a domain is a ring in which 0 is the only left zero divisor (or equivalently, the only right zero divisor).
integral domain = commutative domain
integrally closed domain A =
    iff:
        A is a integral domain
        let F = "fraction field of A"
        A.set == "integral closure of A in F"
    1) "monic polynomial over A" = {x^n + sum s[i]*x^i {0<=i<n} |n>0, s <- A^n}
    2) "integral closure of A in B" =
        requires:
            B is a commutative ring
            A is a subring of B
        {b in B.set | f <- "monic polynomial over A", f(b) == 0}
        remark:
            "integral closure of A in B" is a subring of B
                A.set <= "integral closure of A in B" <= B.set
            ZZ is the integral closure of ZZ in QQ
                Note: "monic"
                    x + z = 0 ==>> x = -z ==>> x in ZZ
                    if (x^n + ...) is irreducible and n > 1, then x not in QQ

    3) "fraction field F of integral domain D" =
        F.set = D.set * (D.set\\{0})
===
]]









NOTE:
  [gcd(x,y) :: z -> z -> z|^NotExistError]
  [GCD(x,y) :: z -> z -> {z}]
  [[len(GCD(x,y)) > 0] -> [gcd(x,y) <- GCD(x,y)]]


NOTE:
    K(x) vs K[x]
        ExtensionField vs PolynomialRing
        K(x) the field of fractions of polynomial ring K[x]

    [K(x) =[def]= extension_field(K; {x}) = {Fraction(n,d) | [n,d <- K[x]]}]
    [K[x] =[def]= polynomial_ring(K; x) = {sum~ k*x**e ~{(e,k) <- ps} | [ps :: [(uint,K)]{len finite}]}]



NOTE:
    Quotient Ring =[def]= Ring/Ideal
    but:
    Quotient Field =[def]= field of fractions = field of quotients of an integral domain (D/D{=!=0})
    ===
    Quotient Ring
    [ring/ideal =[def]= quotient_ring(ring; ideal)]
    [CR <- CommutativeRing][f(x) <- CR[x]]:
        #CR[x]/<f(x)> # CR[x]%f(x)
        [quotient_ring_of_polynomial_ring(CR; f(x)) =[def]= quotient_ring(CR[x]; Ideal<f(x)>) = {g(x) + <f(x)> | [g(x) <- CR[x]]}]
    ===
    quotient rings of polynomial rings
    quotient rings are often used to construct field extensions. Suppose K is some field and f is an irreducible polynomial in K[X]. Then L = K[X] / <f> is a field whose minimal polynomial over K is f, which contains K as well as an element x = X + <f>.
    [K <- Field][f(x) <- K[x]][is_irreducible_polynomial_(K; f(x))][deg(f) >= 1]:
        [quotient_ring_of_polynomial_ring(K; f(x)) <- Field]
        [quotient_ring_of_polynomial_ring(K; f(x)) =[def]= extension_field(K; one_arbitrary_root_of_(f))]
    ===
    [K <- Field][f(x) <- K[x]][deg(f) >= 1]:
        [splitting_field(K; f(x)) =[def]= /-\~ F ~{F <- Field | [K <= F][all_roots_of_(f) |<=| F]}]
        [splitting_field(K; f(x)) =[def]= extension_field(K; all_roots_of_(f))]
    ===
    [K <- Field][f(x) <- K[x]][is_irreducible_polynomial_(K; f(x))][deg(f) >= 1]:
        ???[extension_field(K; all_roots_of_(f)) =[def]= splitting_field(K; f(x)) =?= quotient_ring_of_polynomial_ring(K; f(x)) =[def]= extension_field(K; one_arbitrary_root_of_(f))]???
            counterexample:
            [quotient_ring_of_polynomial_ring(QQ; (x^3-2))
            == QQ[x]/<x^3-2>
            ~=~ QQ(2**(1/3))
            == extension_field(QQ; 2**(1/3))
            #  [extension_field(QQ; all_roots_of_(x^3-2)) has one Real root and two conjugation non-Real roots]
            #  [extension_field(QQ; 2**(1/3)) has one Real root]
            !! [(extension_field(QQ; all_roots_of_(x^3-2)):QQ) == deg(x^3-2) * deg(x^2+2**(1/3)*x+2**(2/3)) = 3*2 = 6 = 3!]
            !! [(extension_field(QQ; 2**(1/3)):QQ) == deg(x^3-2) = 3]
            =!= extension_field(QQ; all_roots_of_(x^3-2))
            == splitting_field(QQ; (x^3-2))
            ]
            but true if [K <- FiniteField]
            from:
            https://math.stackexchange.com/questions/4286846/connection-between-splitting-field-and-quotient-ring-of-polynomials
            the standard example in every algebra book is $F=\Bbb{Q}$, $f(x)=x^3-2$. Then $F[x]/\langle x^3-2\rangle\simeq\Bbb{Q}(\root3\of2)$, which is not a splitting field. It is standard because it is the simplest. We need a separable cubic with Galois group $S_3$. –










a GCD domain is an integral domain R with the property that any two elements have a greatest common divisor (GCD); i.e., there is a unique minimal principal ideal containing the ideal generated by two given elements. Equivalently, any two elements of R have a least common multiple (LCM).









https://mathworld.wolfram.com/topics/FieldTheory.html
https://mathworld.wolfram.com/topics/RingTheory.html

[[
https://mathworld.wolfram.com/Ringoid.html
Ringoid
A ringoid is a set R with two binary operators, conventionally denoted addition (+) and multiplication (×), where × distributes over + left and right:

 a(b+c)=ab+ac 
and

 (b+c)a=ba+ca. 
A ringoid can be empty.
]]

[[
https://mathworld.wolfram.com/Ring.html

Ring
A ring in the mathematical sense is a set S together with two binary operators + and * (commonly interpreted as addition and multiplication, respectively) satisfying the following conditions:

1. Additive associativity: For all a,b,c in S, (a+b)+c=a+(b+c),

2. Additive commutativity: For all a,b in S, a+b=b+a,

3. Additive identity: There exists an element 0 in S such that for all a in S, 0+a=a+0=a,

4. Additive inverse: For every a in S there exists -a in S such that a+(-a)=(-a)+a=0,

5. Left and right distributivity: For all a,b,c in S, a*(b+c)=(a*b)+(a*c) and (b+c)*a=(b*a)+(c*a),

6. Multiplicative associativity: For all a,b,c in S, (a*b)*c=a*(b*c) (a ring satisfying this property is sometimes explicitly termed an associative ring).

Conditions 1-5 are always required. Though non-associative rings exist, virtually all texts also require condition 6 (Itô 1986, pp. 1369-1372; p. 418; Zwillinger 1995, pp. 141-143; Harris and Stocker 1998; Knuth 1998; Korn and Korn 2000; Bronshtein and Semendyayev 2004).

Rings may also satisfy various optional conditions:

7. Multiplicative commutativity: For all a,b in S, a*b=b*a (a ring satisfying this property is termed a commutative ring),

8. Multiplicative identity: There exists an element 1 in S such that for all a!=0 in S, 1*a=a*1=a (a ring satisfying this property is termed a unit ring, or sometimes a "ring with identity"),

9. Multiplicative inverse: For each a!=0 in S, there exists an element a^(-1) in S such that for all a!=0 in S, a*a^(-1)=a^(-1)*a=1, where 1 is the identity element.

A ring satisfying all additional properties 6-9 is called a field, whereas one satisfying only additional properties 6, 8, and 9 is called a division algebra (or skew field).

Some authors depart from the normal convention and require (under their definition) a ring to include additional properties. For example, Birkhoff and Mac Lane (1996) define a ring to have a multiplicative identity (i.e., property 8).

Here are a number of examples of rings lacking particular conditions:

1. Without multiplicative associativity (sometimes also called nonassociative algebras): octonions, OEIS A037292,

2. Without multiplicative commutativity: Real-valued 2×2 matrices, quaternions,

3. Without multiplicative identity: Even-valued integers,

4. Without multiplicative inverse: integers.

The word ring is short for the German word 'Zahlring' (number ring). The French word for a ring is anneau, and the modern German word is Ring, both meaning (not so surprisingly) "ring." Fraenkel (1914) gave the first abstract definition of the ring, although this work did not have much impact. The term was introduced by Hilbert to describe rings like

 Z[RadicalBox[2, 3]]={a+bRadicalBox[2, 3]+cRadicalBox[4, 3] such that a,b,c in Z}. 
By successively multiplying the new element RadicalBox[2, 3], it eventually loops around to become something already generated, something like a ring, that is, (RadicalBox[2, 3])^2=RadicalBox[4, 3] is new but (RadicalBox[2, 3])^3=2 is an integer. All algebraic numbers have this property, e.g., eta=sqrt(2)+sqrt(3) satisfies eta^4=10eta^2-1.

A ring must contain at least one element, but need not contain a multiplicative identity or be commutative. The number of finite rings of n elements for n=1, 2, ..., are 1, 2, 2, 11, 2, 4, 2, 52, 11, 4, 2, 22, 2, 4, 4, ... (OEIS A027623 and A037234; Fletcher 1980). If p and q are prime, there are two rings of size p, four rings of size pq, 11 rings of size p^2 (Singmaster 1964, Dresden), 22 rings of size p^2q, 52 rings of size p^3 for p=2, and 53 rings of size p^3 for p>2 (Ballieu 1947, Gilmer and Mott 1973; Dresden).

A ring that is commutative under multiplication, has a unit element, and has no divisors of zero is called an integral domain. A ring whose nonzero elements form a commutative multiplication group is called a field. The simplest rings are the integers Z, polynomials R[x] and R[x,y] in one and two variables, and square n×n real matrices.

Rings which have been investigated and found to be of interest are usually named after one or more of their investigators. This practice unfortunately leads to names which give very little insight into the relevant properties of the associated rings.

Renteln and Dundes (2005) give the following (bad) mathematical joke about rings:

Q: What's an Abelian group under addition, closed, associative, distributive, and bears a curse? A: The Ring of the Nibelung.

SEE ALSO
Abelian Group, Artinian Ring, Chow Ring, Dedekind Ring, Division Algebra, Endomorphism Ring, Field, Gorenstein Ring, Group, Group Ring, Ideal, Integral Domain, Module, Nilpotent Element, Noetherian Ring, Noncommutative Ring, Number Field, Prime Ring, Prüfer Ring, Quotient Ring, Regular Ring, Ring of Integers, Ringoid, Semiprime Ring, Semiring, Semisimple Ring, Simple Ring, Trivial Ring, Unit Ring, Zero Divisor
]]


[[
https://mathworld.wolfram.com/DivisionAlgebra.html
Division Algebra
A division algebra, also called a "division ring" or "skew field," is a ring in which every nonzero element has a multiplicative inverse, but multiplication is not necessarily commutative.
    Every field is therefore also a division algebra.
        In French, the term "corps non commutatif" is used to mean division algebra, while "corps" alone means field.

Explicitly, a division algebra is a set together with two binary operators (S,+,*) satisfying the following conditions:

1. Additive associativity: For all a,b,c in S, (a+b)+c=a+(b+c).

2. Additive commutativity: For all a,b in S, a+b=b+a.

3. Additive identity: There exists an element 0 in S such that for all a in S, 0+a=a+0=a.

4. Additive inverse: For every a in S there exists an element -a in S such that a+(-a)=(-a)+a=0.

5. Multiplicative associativity: For all a,b,c in S, (a*b)*c=a*(b*c).

6. Multiplicative identity: There exists an element 1 in S not equal to 0 such that for all a in S, 1*a=a*1=a.

7. Multiplicative inverse: For every a in S not equal to 0, there exists a^(-1) in S such that a*a^(-1)=a^(-1)*a=1.

8. Left and right distributivity: For all a,b,c in S, a*(b+c)=(a*b)+(a*c) and (b+c)*a=(b*a)+(c*a).

Thus a division algebra (S,+,*) is a unit ring for which (S-{0},*) is a group.
    A division algebra must contain at least two elements.
    A commutative division algebra is called a field.

In 1878 and 1880, Frobenius and Peirce proved that
    the only associative real division algebras are real numbers, complex numbers, and quaternions (Mishchenko and Solovyov 2000).
    The Cayley algebra is the only nonassociative division algebra.
Hurwitz (1898) proved that
    the algebras of real numbers, complex numbers, quaternions, and Cayley numbers are the only ones where multiplication by unit "vectors" is distance-preserving.

Adams (1958, 1960) proved that
    n-dimensional vectors form an algebra in which division (except by 0) is always possible only for n=1, 2, 4, and 8.
Bott and Milnor (1958) proved that
    the only finite-dimensional real division algebras occur for dimensions n=1, 2, 4, and 8.
    Each gives rise to an algebra with particularly useful physical applications (which, however, is not itself necessarily nonassociative), and these four cases correspond to real numbers, complex numbers, quaternions, and Cayley numbers, respectively.

SEE ALSO
Alternative Algebra, Cayley Number, Field, Group, Jordan Algebra, Lie Algebra, Nonassociative Algebra, Power Associative Algebra, Quaternion, Schur's Lemma, Unit Ring, Zero Divisor
]]






[[
https://mathworld.wolfram.com/Field.html
Field
A field is any set of elements that satisfies the field axioms for both addition and multiplication and is a commutative division algebra. An archaic name for a field is rational domain. The French term for a field is corps and the German word is Körper, both meaning "body." A field with a finite number of members is known as a finite field or Galois field.

Because the identity condition is generally required to be different for addition and multiplication, every field must have at least two elements. Examples include the complex numbers (C), rational numbers (Q), and real numbers (R), but not the integers (Z), which form only a ring.

It has been proven by Hilbert and Weierstrass that all generalizations of the field concept to triplets of elements are equivalent to the field of complex numbers.

SEE ALSO
Adjunction, Base Field, Coefficient Field, Cyclotomic Field, Division Algebra, Extension Field, Field Axioms, Field Characteristic, Finite Field, Function Field, Local Field, Mac Lane's Theorem, Module, Number Field, Pythagorean Field, Quadratic Field, Ring, Splitting Field, Subfield, Vector Field
]]

[[
https://mathworld.wolfram.com/GaloisExtensionField.html
Galois Extension Field
The following are equivalent definitions for a Galois extension field (also simply known as a Galois extension) K of F.

1. K is the splitting field for a collection of separable polynomials. When K is a finite extension, then only one separable polynomial is necessary.

2. The field automorphisms of K that fix F do not fix any intermediate fields E, i.e., F subset E subset K.

3. Every irreducible polynomial over F which has a root in K factors into linear factors in K. Also, K must be a separable extension.

4. A field automorphism sigma:F^_->F^_ of the algebraic closure F^_ of F for which sigma(K)=K must fix F. That is to say that sigma must be a field automorphism of K fixing F. Also, K must be a separable extension.

A Galois extension has all of the above properties. For example, consider K=Q(i), the rationals adjoined by the imaginary number i, over F=Q, which is a Galois extension. Note that K contains all of the roots of p(x)=x^2+1, and is generated by them, so it is the splitting field of p. Of course, there are two distinct roots in K so it is separable. The only nontrivial automorphism fixing F is given by complex conjugation

 sigma(a+bi)=a-bi 	
(1)
whose fixed field is F. The only irreducible polynomials with rational coefficients with roots of the form a+bi with a,b in Q are x-a (b=0) and x^2-2ax+a^2+b^2. Both split into linear factors over K. Finally, the algebraic closure F^_ is the set of algebraic numbers in C. Given an automorphism of the algebraic numbers that sends Q(i) to itself, it must fix Q for trivial reasons. In general, it is not so simple to verify all of these properties, which makes their equivalence useful.

There are a couple of ways for an extension not to be a Galois extension. One is for it to not be a normal extension. For instance, Q(2^(1/4)) is not normal, and hence not Galois. It is missing the complex roots of x^4-2. Its only nontrivial automorphism is defined by sigma(2^(1/4))=-2^(1/4), which not only fixes Q but also the subfield Q(sqrt(2)) subset Q(2^(1/4)).

Another possibility for a non-Galois extension is for it to be not separable. The field characteristic of such a field must be finite since all polynomials are separable in characteristic zero. Moreover, all finite fields are perfect, i.e., all algebraic extensions are separable. Consider the field of rational functions with coefficients in F_2={0,1}, infinite in size and characteristic 2 (1+1=0).

 F=F_2(x)={f(x)/g(x):f,g are polynomials 
 with coefficients in F_2}   	
(2)
and the extension

 K=F(sqrt(x)). 	
(3)
For instance, (x^3+x^2+1)/(x+1) in F and (x+sqrt(x))/(x+1) in K. Then K is the splitting field of z^2-x=(z+sqrt(x))(z+sqrt(x)), as sqrt(x)+sqrt(x)=2(sqrt(x))=0 in characteristic 2, and so it is a normal extension. However, K is not separable because z^2-x has repeated roots in its splitting field, K.

SEE ALSO
Extension Field, Galois Theory, Galoisian, Splitting Field
]]

[[
https://mathworld.wolfram.com/SplittingField.html
Splitting Field
The extension field K of a field F is called a splitting field for the polynomial f(x) in F[x] if f(x) factors completely into linear factors in K[x] and f(x) does not factor completely into linear factors over any proper subfield of K containing F (Dummit and Foote 1998, p. 448).

For example, the extension field Q(sqrt(3)i) is the splitting field for x^2+3 since it is the smallest field containing its roots, sqrt(3)i and -sqrt(3)i. Note that it is also the splitting field for x^3+1.
]]

[[
https://mathworld.wolfram.com/FiniteField.html
The order of a finite field is always a prime or a power of a prime (Birkhoff and Mac Lane 1996).
For each prime power, there exists exactly one (with the usual caveat that "exactly one" means "exactly one up to an isomorphism") finite field GF(p^n).

GF(p) is called the prime field of order p, and is the field of residue classes modulo p, where the p elements are denoted 0, 1, ..., p-1. a=b in GF(p) means the same as a=b (mod p). Note, however, that 2×2=0 (mod 4) in the ring of residues modulo 4, so 2 has no reciprocal, and the ring of residues modulo 4 is distinct from the finite field with four elements. Finite fields are therefore denoted GF(p^n), instead of GF(k), where k=p^n, for clarity.

Finite fields are used extensively in the study of error-correcting codes.




When n>1, GF(p^n) can be represented as the field of equivalence classes of polynomials whose coefficients belong to GF(p). Any irreducible polynomial of degree n yields the same field up to an isomorphism. For example, for GF(2^3), the modulus can be taken as x^3+x^2+1 or x^3+x+1. Using the modulus x^3+x+1, the elements of GF(2^3)--written 0, x^0, x^1, ...--can be represented as polynomials with degree less than 3. For instance,

x^3	=	-x-1=x+1	
(1)
x^4	=	x(x^3)=x(x+1)=x^2+x	
(2)
x^5	=	x(x^2+x)=x^3+x^2=x^2-x-1=x^2+x+1	
(3)
x^6	=	x(x^2+x+1)=x^3+x^2+x=x^2-1=x^2+1	
(4)
x^7	=	x(x^2+1)=x^3+x=-1=1=x^0.	
(5)
Now consider the following table which contains several different representations of the elements of a finite field. The columns are the power, polynomial representation, triples of polynomial representation coefficients (the vector representation), and the binary integer corresponding to the vector representation (the regular representation).

power	polynomial	vector	regular
0	0	(000)	0
x^0	1	(001)	1
x^1	x	(010)	2
x^2	x^2	(100)	4
x^3	x+1	(011)	3
x^4	x^2+x	(110)	6
x^5	x^2+x+1	(111)	7
x^6	x^2+1	(101)	5
The set of polynomials in the second column is closed under addition and multiplication modulo x^3+x+1, and these operations on the set satisfy the axioms of finite field. This particular finite field is said to be an extension field of degree 3 of GF(2), written GF(2^3), and the field GF(2) is called the base field of GF(2^3). If an irreducible polynomial generates all elements in this way, it is called a primitive polynomial. For any prime or prime power q and any positive integer n, there exists a primitive irreducible polynomial of degree n over GF(q).

For any element c of GF(q), c^q=c, and for any nonzero element d of GF(q), d^(q-1)=1. There is a smallest positive integer n satisfying the sum condition e+e+...+e_()_(n times)=0 for some element e in GF(q). This number is called the field characteristic of the finite field GF(q). The field characteristic is a prime number for every finite field, and it is true that

 (x+y)^p=x^p+y^p 	
(6)
over a finite field with characteristic p.

SEE ALSO
Field, Field Characteristic, Hadamard Matrix, Irreducible Polynomial, Primitive Polynomial, Ring, Subfield
]]


[[
https://mathworld.wolfram.com/PrimitivePolynomial.html

Primitive Polynomial

A primitive polynomial is a polynomial that generates all elements of an extension field from a base field. Primitive polynomials are also irreducible polynomials. For any prime or prime power q and any positive integer n, there exists a primitive polynomial of degree n over GF(q). There are

 a_q(n)=(phi(q^n-1))/n 	
(1)
primitive polynomials over GF(q), where phi(n) is the totient function.

A polynomial of degree n over the finite field GF(2) (i.e., with coefficients either 0 or 1) is primitive if it has polynomial order 2^n-1. For example, x^2+x+1 has order 3 since

(x+1)/(x^2+x+1)	=	(x+1)/(x^2+x+1) (mod 2)	
(2)
(x^2+1)/(x^2+x+1)	=	1+x/(x^2+x+1) (mod 2)	
(3)
(x^3+1)/(x^2+x+1)	=	x+1 (mod 2).	
(4)
Plugging in q=2 to equation (◇), the numbers of primitive polynomials over GF(2) are

 a_2(n)=(phi(2^n-1))/n, 	
(5)
giving 1, 1, 2, 2, 6, 6, 18, 16, 48, ... (OEIS A011260) for n=1, 2, .... The following table lists the primitive polynomials (mod 2) of orders 1 through 5.

n	primitive polynomials
1	1+x
2	1+x+x^2
3	1+x+x^3, 1+x^2+x^3
4	1+x+x^4, 1+x^3+x^4
5	1+x^2+x^5, 1+x+x^2+x^3+x^5, 1+x^3+x^5, 1+x+x^3+x^4+x^5, 1+x^2+x^3+x^4+x^5, 1+x+x^2+x^4+x^5
Amazingly, primitive polynomials over GF(2) define a recurrence relation which can be used to obtain a new pseudorandom bit from the n preceding ones.

SEE ALSO
Finite Field, Irreducible Polynomial, Polynomial, Polynomial Order, Primitive Element, Primitive Root

]]

[[
https://mathworld.wolfram.com/IrreduciblePolynomial.html
Irreducible Polynomial
A polynomial is said to be irreducible if it cannot be factored into nontrivial polynomials over the same field.

For example, in the field of rational polynomials Q[x] (i.e., polynomials f(x) with rational coefficients), f(x) is said to be irreducible if there do not exist two nonconstant polynomials g(x) and h(x) in x with rational coefficients such that

 f(x)=g(x)h(x) 
(Nagell 1951, p. 160). Similarly, in the finite field GF(2), x^2+x+1 is irreducible, but x^2+1 is not, since (x+1)(x+1)=x^2+2x+1=x^2+1 (mod 2).

Irreducible polynomial checking is implemented in the Wolfram Language as IrreduciblePolynomialQ[poly].

In general, the number of irreducible polynomials of degree n over the finite field GF(q) is given by

 L_q(n)=1/nsum_(d|n)mu(n/d)q^d, 
where mu(n) is the Möbius function.

The number of irreducible polynomials of degree n over GF(2) is equal to the number of n-bead fixed aperiodic necklaces of two colors and the number of binary Lyndon words of length n. The first few numbers of irreducible polynomial (mod 2) for n=1, 2, ... are 2, 1, 2, 3, 6, 9, 18, ... (OEIS A001037). The following table lists the irreducible polynomials (mod 2) of degrees 1 through 5.

n	irreducible polynomials
1	1+x, x
2	1+x+x^2
3	1+x+x^3, 1+x^2+x^3
4	1+x+x^4, 1+x+x^2+x^3+x^4, 1+x^3+x^4
5	1+x^2+x^5, 1+x+x^2+x^3+x^5, 1+x^3+x^5, 1+x+x^3+x^4+x^5, 1+x^2+x^3+x^4+x^5, 1+x+x^2+x^4+x^5
The possible polynomial orders of nth degree irreducible polynomials over the finite field GF(2) listed in ascending order are given by 1; 3; 7; 5, 15; 31; 9, 21, 63; 127; 17, 51, 85, 255; 73, 511; ... (OEIS A059912).

SEE ALSO
Eisenstein's Irreducibility Criterion, Field, Finite Field, Lyndon Word, Necklace, Polynomial, Primitive Polynomial
]]

[[
https://mathworld.wolfram.com/EisensteinsIrreducibilityCriterion.html

Eisenstein's Irreducibility Criterion
Eisenstein's irreducibility criterion is a sufficient condition assuring that an integer polynomial p(x) is irreducible in the polynomial ring Q[x].

The polynomial

 p(x)=a_nx^n+a_(n-1)x^(n-1)+...+a_1x+a_0, 
where a_i in Z for all i=0,...,n and a_n!=0 (which means that the degree of p(x) is n) is irreducible if some prime number p divides all coefficients a_0, ..., a_(n-1), but not the leading coefficient a_n and, moreover, p^2 does not divide the constant term a_0.

This is only a sufficient, and by no means a necessary condition. For example, the polynomial x^2+1 is irreducible, but does not fulfil the above property, since no prime number divides 1. However, substituting x+1 for x produces the polynomial x^2+2x+2, which does fulfill the Eisenstein criterion (with p=2) and shows the polynomial is irreducible.
]]

[[
https://mathworld.wolfram.com/AlgebraicNumberMinimalPolynomial.html
Algebraic Number Minimal Polynomial
The minimal polynomial of an algebraic number zeta is the unique irreducible monic polynomial of smallest degree p(x) with rational coefficients such that p(zeta)=0 and whose leading coefficient is 1. The minimal polynomial can be computed using MinimalPolynomial[zeta, var] in the Wolfram Language package AlgebraicNumberFields` .

For example, the minimal polynomial of sqrt(2) is x^2-2. In general, the minimal polynomial of RadicalBox[p, n], where n>=2 and p is a prime number, is x^n-p, which is irreducible by Eisenstein's irreducibility criterion. The minimal polynomial of every primitive nth root of unity is the cyclotomic polynomial Phi_n(x). For example, Phi_3(x)=x^2+x+1 is the minimal polynomial of

 alpha=-1/2+(sqrt(3))/(2i),    and    alpha^_=-1/2-(sqrt(3))/(2i). 
In general, two algebraic numbers that are complex conjugates have the same minimal polynomial.

Considering the extension field Q(zeta) as a finite-dimensional vector space over the field of the rational numbers, then multiplication by zeta induces a linear transformation T_zeta on Q(zeta). The matrix minimal polynomial of T_zeta, as a linear transformation, is the same as the minimal polynomial of zeta, as an algebraic number.

A minimal polynomial divides any other polynomial with rational coefficients f(x) such that f(alpha)=0. It follows that it has minimal degree among all polynomials f with this property. Its degree is equal to the degree of the extension field Q(alpha) over Q.

SEE ALSO
Algebraic Number, Conjugate Elements, Eisenstein's Irreducibility Criterion, Extension Field Minimal Polynomial, Matrix Minimal Polynomial, Splitting Field
]]

[[
Extension Field Minimal Polynomial
Given a field F and an extension field K superset= F, if alpha in K is an algebraic element over F, the minimal polynomial of alpha over F is the unique monic irreducible polynomial p(x) in F[x] such that p(alpha)=0. It is the generator of the ideal

 {f(x) in F[x]|f(alpha)=0} 
of F[x].

Any irreducible monic polynomial p(x) of F[x] has some root alpha in some extension field K, so that it is the minimal polynomial of alpha. This arises from the following construction. The quotient ring K=F[x]/<p(x)> is a field, since <p(x)> is a maximal ideal, moreover K contains F. Then p(x) is the minimal polynomial of alpha=x^_, the residue class of x in K.

K=F[x^_]=F[alpha], which is also the simple extension field obtained by adding alpha to F. Hence, in this case, F[alpha]=F(alpha) and the extension field coincides with the extension ring.

In general, if beta is any other algebraic element of any extension field of F with the same minimal polynomial p(x), it remains true that F[beta]=F(beta), and this field is isomorphic to F[x]/<p(x)>.

SEE ALSO
Algebraic Number Minimal Polynomial, Conjugate Elements, Matrix Minimal Polynomial
]]

[[
https://mathworld.wolfram.com/QuotientRing.html
Quotient Ring
A quotient ring (also called a residue-class ring) is a ring that is the quotient of a ring A and one of its ideals a, denoted A/a. For example, when the ring A is Z (the integers) and the ideal is 6Z (multiples of 6), the quotient ring is Z_6=Z/6Z.

In general, a quotient ring is a set of equivalence classes where [x]=[y] iff x-y in a.

The quotient ring is an integral domain iff the ideal a is prime. A stronger condition occurs when the quotient ring is a field, which corresponds to when the ideal a is maximal.

The ideals in a quotient ring A/a are in a one-to-one correspondence with ideals in A which contain the ideal a. In particular, the zero ideal in A/a corresponds to a in A. In the example above from the integers, the ideal of even integers contains the ideal of the multiples of 6. In the quotient ring, the evens correspond to the ideal {0,2,4} in Z_6=Z/6Z.
]]

[[
https://mathworld.wolfram.com/Ideal.html
Ideal
An ideal is a subset I of elements in a ring R that forms an additive group and has the property that, whenever x belongs to R and y belongs to I, then xy and yx belong to I. For example, the set of even integers is an ideal in the ring of integers Z. Given an ideal I, it is possible to define a quotient ring R/I. Ideals are commonly denoted using a Gothic typeface.

A finitely generated ideal is generated by a finite list a_1, a_2, ..., a_n and contains all elements of the form sumc_ia_i, where the coefficients c_i are arbitrary elements of the ring. The list of generators is not unique, for instance <4,10>=<2> in the integers.

IdealLattice
In a number ring, ideals can be represented as lattices, and can be given a finite basis of algebraic integers which generates the ideal additively. Any two bases for the same lattice are equivalent. Ideals have multiplication, and this is basically the Kronecker product of the two bases. The illustration above shows an ideal in the Gaussian integers generated by 2 and 1+i, where elements of the ideal are indicated in red.

From the perspective of algebraic geometry, ideals correspond to varieties.

For any ideal I, there is an ideal I_i such that

 II_i=z, 	
(1)
where z is a principal ideal, (i.e., an ideal of rank 1). Moreover there is a finite list of ideals I_i such that this equation may be satisfied for every I. The size of this list is known as the class number. In effect, the above relation imposes an equivalence relation on ideals, and the number of ideals modulo this relation is the class number. When the class number is 1, the corresponding number ring has unique factorization and, in a sense, the class number is a measure of the failure of unique factorization in the original number ring.

In 1871, Dedekind showed that every nonzero ideal in the domain of integers of a field is a unique product of prime ideals, and in fact all ideals of Z are of this form and therefore principal ideals.

Ideals can be added, multiplied and intersected. The union of ideals usually is not an ideal since it may not be closed under addition. From the perspective of algebraic geometry, the addition of ideals corresponds to the intersection of varieties and the intersection of ideals corresponds to the union of varieties. Also, the multiplication of ideals corresponds to the union of varieties.

Intersection and multiplication are different, for instance consider the ideal a=<x> in Z[x,y]. Then

 a^2=a·a=<x^2>. 	
(2)
Sometimes they are the same. If b=<y>, then

 ab=a intersection b=<xy>. 	
(3)
There is also an analog of division, the ideal quotient (a:b), and there is an analog of the radical, also called the ideal radical r(a). Given a ring homomorphism f:A->B, ideals in A extend to ideals in B, while ideals in B contract to ideals in A.

The following formulas summarize operations on ideals, where x^c denotes contract, x^e denotes ideal extension, and (a:b) denotes an ideal quotient:

a(b+c)=ab+ac 	
(4)
(a:b)b subset a 	
(5)
( intersection a_i:b)= intersection (a_i:b) 	
(6)
(a:sumb_i)= intersection (a:b_i) 	
(7)
a subset r(a) 	
(8)
r(r(a))=r(a) 	
(9)
r(ab)=r(a intersection b)=r(a) intersection r(b) 	
(10)
r(a+b)=r(r(a)+r(b)) 	
(11)
a subset a^(ec) 	
(12)
b^(ce) subset b 	
(13)
b^c=b^(cec) 	
(14)
a^e=a^(ece) 	
(15)
(a_1+a_2)^e=a_1^e+a_2^e 	
(16)
b_1^c+b_2^c subset (b_1+b_2)^c 	
(17)
(a_1 intersection a_2)^e subset a_1^e intersection a_2^e 	
(18)
b_1^c intersection b_2^c=(b_1 intersection b_2)^c 	
(19)
a_1^ea_2^e=(a_1a_2)^e 	
(20)
b_1^cb_2^c subset (b_1b_2)^c 	
(21)
(a_1:a_2)^e subset (a_1^e:a_2^e) 	
(22)
(b_1:b_2)^c subset (b_1^c:b_2^c) 	
(23)
r(a)^e subset r(a^e) 	
(24)
r(b)^c=r(b^c) 	
(25)
If A is an algebra, a left (right) ideal of A is a subspace I of A such that ax in I(xa in I) whenever a in A and x in I. A two-sided ideal is a subset of A that is both a left and right ideal. For each algebra A and an element a in A, the sets Aa={ba:b in A} and aA={ab:b in A} are examples of left and right ideals respectively, and AaA={bac:b,c in A} is an example of a two-sided ideal.

SEE ALSO
Dedekind Ring, Hilbert's Nullstellensatz, Left Ideal, Maximal Ideal, Minkowski's Lemma, Prime Ideal, Right Ideal
]]
[[
https://mathworld.wolfram.com/MaximalIdeal.html
Maximal Ideal
A maximal ideal of a ring R is an ideal I, not equal to R, such that there are no ideals "in between" I and R. In other words, if J is an ideal which contains I as a subset, then either J=I or J=R. For example, nZ is a maximal ideal of Z iff n is prime, where Z is the ring of integers.

Only in a local ring is there just one maximal ideal. For instance, in the integers, a=<p> is a maximal ideal whenever p is prime.

A maximal ideal m is always a prime ideal, and the quotient ring A/m is always a field. In general, not all prime ideals are maximal.

SEE ALSO
Maximal Ideal Space, Maximal Ideal Theorem
]]
[[
https://mathworld.wolfram.com/PrimeIdeal.html
Prime Ideal
A prime ideal is an ideal I such that if ab in I, then either a in I or b in I. For example, in the integers, the ideal a=<p> (i.e., the multiples of p) is prime whenever p is a prime number.

In any principal ideal domain, prime ideals are generated by prime elements. Prime ideals generalize the concept of primality to more general commutative rings.

An ideal I is prime iff the quotient ring R/I is an integral domain because x in I iff x=0 (mod I). Technically, some authors choose not to allow the trivial ring R={0} as a commutative ring, in which case they usually require prime ideals to be proper ideals.

A maximal ideal is always a prime ideal, but some prime ideals are not maximal. In the integers, {0} is a prime ideal, as it is in any integral domain. Note that this is the exception to the statement that all prime ideals in the integers are generated by prime numbers. While this might seem silly to allow this case, in some rings the structure of the prime ideals, the Zariski topology, is more interesting. For instance, in polynomials in two variables with complex coefficients C[x,y], the ideals

 <0> subset <(y-x-1)> subset <(x-2),(y-3)> 
are all prime.

One consequence of the definition is that the set of elements not in a prime ideal, R-p, is closed under multiplication. This allows one to localize at p by considering the ring of fractions. This ring is analogous to the construction of the rationals as fractions of integers, except that the denominator must be in R-p. The only maximal ideal in this ring is the ideal extension of p.

From the perspective of algebraic geometry, ideals correspond to varieties. Because multiplication corresponds to union (such as xy=0 implies x=0 or y=0), a prime ideal corresponds to an irreducible variety.

SEE ALSO
Dedekind Ring, Ideal, Irreducible Variety, Krull Dimension, Maximal Ideal, Stickelberger
]]
[[
https://mathworld.wolfram.com/PrincipalIdeal.html
Principal Ideal
An ideal I of a ring R is called principal if there is an element a of R such that

 I=aR={ar:r in R}. 
In other words, the ideal is generated by the element a. For example, the ideals nZ of the ring of integers Z are all principal, and in fact all ideals of Z are principal.

SEE ALSO
Ideal, Principal Ring, Ring
]]
[[
https://mathworld.wolfram.com/LocalRing.html
Local Ring
A local ring is a ring R that contains a single maximal ideal. In this case, the Jacobson radical equals this maximal ideal.

One property of a local ring R is that the subset R-m is precisely the set of ring units, where m is the maximal ideal. This follows because, in a ring, any nonunit belongs to at least one maximal ideal.

SEE ALSO
Jacobson Radical, Localization, Maximal Ideal, Quasilocal Ring, Regular Local Ring, Residue Field, Ring Unit, Semilocal Ring
]]
[[
https://mathworld.wolfram.com/RingUnit.html
Ring Unit
A unit in a ring is an element u such that there exists u^(-1) where u·u^(-1)=1.
]]
[[
https://mathworld.wolfram.com/FractionalIdeal.html
Fractional Ideal
A fractional ideal is a generalization of an ideal in a ring R. Instead, a fractional ideal is contained in the number field F, but has the property that there is an element b in R such that

 a=bf={bx such that x in f} 	
(1)
is an ideal in R. In particular, every element in f can be written as a fraction, with a fixed denominator.

 f={a/b such that a in a} 	
(2)
Note that the multiplication of two fractional ideals is another fractional ideal.

For example, in the field Q(sqrt(-5)), the set

 f={(2a_1+a_2-5a_4+(a_2+2a_3+a_4)sqrt(-5))/(3+sqrt(-5)) 
  such that a_i in Z}   	
(3)
is a fractional ideal because

 (3+sqrt(-5))f=<2,1+sqrt(-5)>. 	
(4)
Note that fp=<1>=R, where

 p={3b_1+b_2-5b_4+(b_2+3b_3+b_4)sqrt(-5) 
  such that b_i in Z}=<3,1+sqrt(-5)>,   	
(5)
and so f is an inverse to p.

Given any fractional ideal a there is always a fractional ideal f such that af=R. Consequently, the fractional ideals form an Abelian group by multiplication. The principal ideals generate a subgroup P, and the quotient group is called the ideal class group.

SEE ALSO
Class Group, Grothendieck Group, Ideal, Number Field
]]
[[
https://mathworld.wolfram.com/ClassGroup.html
Class Group
Let K be a number field, then each fractional ideal I of K belongs to an equivalence class [I] consisting of all fractional ideals J satisfying I=alphaJ for some nonzero element alpha of K. The number of equivalence classes of fractional ideals of K is a finite number, known as the class number of K. Multiplication of equivalence classes of fractional ideals is defined in the obvious way, i.e., by letting [I][J]=[IJ]. It is easy to show that with this definition, the set of equivalence classes of fractional ideals form an Abelian multiplicative group, known as the class group of K.

SEE ALSO
Class Number, Equivalence Class, Fractional Ideal
]]
[[
https://mathworld.wolfram.com/ClassNumber.html
Class Number
For any ideal I in a Dedekind ring, there is an ideal I_i such that

 II_i=z, 	
(1)
where z is a principal ideal, (i.e., an ideal of rank 1). Moreover, for a Dedekind ring with a finite ideal class group, there is a finite list of ideals I_i such that this equation may be satisfied for some I. The size of this list is known as the class number.

Class numbers are usually studied in the context of the orders of number fields. If this order is maximal, then it is the ring of integers of the number field, in which case the class number is equal to the order of the class group of the number field; otherwise it is equal to the order of the Picard group of the nonmaximal order in question.

When the class number of a ring of integers in a number field is 1, the ring corresponding to a given ideal has unique factorization and, in a sense, the class number is a measure of the failure of unique factorization in that ring.

A finite series giving exactly the class number of a ring is known as a class number formula. A class number formula is known for the full ring of cyclotomic integers, as well as for any subring of the cyclotomic integers. Finding the class number is a computationally difficult problem.

The Wolfram Language function NumberFieldClassNumber[Sqrt[d]] gives the class number h(d) for d a fundamental discriminant.

The class number h(d) of an order of a quadratic field with discriminant d<0 is equal to the number of reduced binary quadratic forms of discriminant d. For example, the class number h(-23) of the ring of integers Z((1+sqrt(-23))/2) of the number field Q(-sqrt(23)) is equal to 3 since there are three reduced binary quadratic forms of discriminant -23, namely <1,1,6>, <2,1,3>, and <2,-1,3>. An inefficient way to compute the class number h(d) of the unique order of the quadratic number field Q(sqrt(d)) with discriminant d<0 is to count the number of reduced binary quadratic forms with discriminant d.

Some fairly sophisticated mathematics shows that the class number for discriminant d can be given by the class number formula

 h(d)={-1/(2lneta(d))sum_(r=1)^(d-1)(d/r)lnsin((pir)/d)   for d>0; -(w(d))/(2|d|)sum_(r=1)^(|d|-1)(d/r)r   for d<0, 	
(2)
where (d/r) is the Kronecker symbol, eta(d) is the fundamental unit, w(d) is the number of substitutions which leave the binary quadratic form unchanged

 w(d)={6   for d=-3; 4   for d=-4; 2   otherwise, 	
(3)
and the sums are taken over all terms where the Kronecker symbol is defined (Cohn 1980). The class number for d>0 can also be written

 eta^(2h(d))=product_(r=1)^(d-1)sin^(-(d/r))((pir)/d) 	
(4)
for d>0, where the product is taken over terms for which the Kronecker symbol is defined.

The class number h(d) is related to the Dirichlet L-series by

 h(d)=(L_d(1))/(kappa(d)), 	
(5)
where kappa(d) is the Dirichlet structure constant.

Oesterlé (1985) showed that class number h(-d) satisfies the inequality

 h(-d)>1/(7000)product_(p|d)^*(1-(|_2sqrt(p)_|)/(p+1))lnd, 	
(6)
for -d<0, where |_x_| is the floor function, the product is over primes dividing d, and the * indicates that the greatest prime factor of d is omitted from the product. It is also known that if d is relatively prime to 5077, then the denominator 7000 in (6) can be replaced by 55.

Gauss's class number problem asks to determine a complete list of fundamental binary quadratic form discriminants -d such that the class number is given by h(-d)=n for a given n. This problem has been solved for n<=7 and odd n<=23. Gauss conjectured that the class number h(-d) of an imaginary quadratic field with binary quadratic form discriminant -d tends to infinity with d, an assertion now known as Gauss's class number conjecture.

The negated discriminants d corresponding to imaginary quadratic fields are 3, 4, 7, 8, 11, 15, 19, 20, 23, 24, 31, 35, 39, 40, 43, ... (OEIS A003657), which have corresponding class numbers h(-d)=1, 1, 1, 1, 1, 2, 1, 2, 3, 2, 3, 2, 4, 2, 1, ... (OEIS A006641).

The complete set of negative discriminants having class numbers 1-5 and odd 7-23 are known. Buell (1977) gives the smallest and largest class numbers for fundamental discriminants with d<4000000, partitioned into even discriminants, discriminants 1 (mod 8), and discriminants 5 (mod 8). Arno et al. (1993) give complete lists of values of fundamental d with h(-d)=k for odd k=5, 7, 9, ..., 23. Wagner (1996) gives complete lists of values for k=5, 6, and 7. Lists of negative fundamental discriminants corresponding to imaginary quadratic fields Q(sqrt(-d(n))) having small class numbers h(-d) are given in the table below. In the table, N is the number of fundamental values of -d with a given class number h(-d), where "fundamental" means that -d is not divisible by any square number s^2 such that h(-d/s^2)<h(-d). For example, although h(-63)=2, -63 is not a fundamental discriminant since 63=3^2·7 and h(-63/3^2)=h(-7)=1<h(-63). Even values 8<=h(-d)<=24 have been computed by Weisstein.

The following table lists the fundamental discriminants d having class numbers h<=25 (Cohen 1993, pp. 229 and 514-515; Cox 1997, p. 271). The search was terminated at 50000, 70000, 90000, and 90000 for class numbers 18, 20, 22, and 24, respectively. As far as I know, analytic upper bounds are not currently known for these cases.

h(-d)	N	Sloane	d
1	9	A014602	3, 4, 7, 8, 11, 19, 43, 67, 163
2	18	A014603	15, 20, 24, 35, 40, 51, 52, 88, 91, 115, 123, 148, 187, 232, 235, 267, 403, 427
3	16	A006203	23, 31, 59, 83, 107, 139, 211, 283, 307, 331, 379, 499, 547, 643, 883, 907
4	54	A013658	39, 55, 56, 68, 84, 120, 132, 136, 155, 168, 184, 195, 203, 219, 228, 259, 280, 291, 292, 312, 323, 328, 340, 355, 372, 388, 408, 435, 483, 520, 532, 555, 568, 595, 627, 667, 708, 715, 723, 760, 763, 772, 795, 955, 1003, 1012, 1027, 1227, 1243, 1387, 1411, 1435, 1507, 1555
5	25	A046002	47, 79, 103, 127, 131, 179, 227, 347, 443, 523, 571, 619, 683, 691, 739, 787, 947, 1051, 1123, 1723, 1747, 1867, 2203, 2347, 2683
6	51	A046003	87, 104, 116, 152, 212, 244, 247, 339, 411, 424, 436, 451, 472, 515, 628, 707, 771, 808, 835, 843, 856, 1048, 1059, 1099, 1108, 1147, 1192, 1203, 1219, 1267, 1315, 1347, 1363, 1432, 1563, 1588, 1603, 1843, 1915, 1963, 2227, 2283, 2443, 2515, 2563, 2787, 2923, 3235, 3427, 3523, 3763
7	31	A046004	71, 151, 223, 251, 463, 467, 487, 587, 811, 827, 859, 1163, 1171, 1483, 1523, 1627, 1787, 1987, 2011, 2083, 2179, 2251, 2467, 2707, 3019, 3067, 3187, 3907, 4603, 5107, 5923
8	131	A046005	95, 111, 164, 183, 248, 260, 264, 276, 295, 299, 308, 371, 376, 395, 420, 452, 456, 548, 552, 564, 579, 580, 583, 616, 632, 651, 660, 712, 820, 840, 852, 868, 904, 915, 939, 952, 979, 987, 995, 1032, 1043, 1060, 1092, 1128, 1131, 1155, 1195, 1204, 1240, 1252, 1288, 1299, 1320, 1339, 1348, 1380, 1428, 1443, 1528, 1540, 1635, 1651, 1659, 1672, 1731, 1752, 1768, 1771, 1780, 1795, 1803, 1828, 1848, 1864, 1912, 1939, 1947, 1992, 1995, 2020, 2035, 2059, 2067, 2139, 2163, 2212, 2248, 2307, 2308, 2323, 2392, 2395, 2419, 2451, 2587, 2611, 2632, 2667, 2715, 2755, 2788, 2827, 2947, 2968, 2995, 3003, 3172, 3243, 3315, 3355, 3403, 3448, 3507, 3595, 3787, 3883, 3963, 4123, 4195, 4267, 4323, 4387, 4747, 4843, 4867, 5083, 5467, 5587, 5707, 5947, 6307
9	34	A046006	199, 367, 419, 491, 563, 823, 1087, 1187, 1291, 1423, 1579, 2003, 2803, 3163, 3259, 3307, 3547, 3643, 4027, 4243, 4363, 4483, 4723, 4987, 5443, 6043, 6427, 6763, 6883, 7723, 8563, 8803, 9067, 10627
10	87	A046007	119, 143, 159, 296, 303, 319, 344, 415, 488, 611, 635, 664, 699, 724, 779, 788, 803, 851, 872, 916, 923, 1115, 1268, 1384, 1492, 1576, 1643, 1684, 1688, 1707, 1779, 1819, 1835, 1891, 1923, 2152, 2164, 2363, 2452, 2643, 2776, 2836, 2899, 3028, 3091, 3139, 3147, 3291, 3412, 3508, 3635, 3667, 3683, 3811, 3859, 3928, 4083, 4227, 4372, 4435, 4579, 4627, 4852, 4915, 5131, 5163, 5272, 5515, 5611, 5667, 5803, 6115, 6259, 6403, 6667, 7123, 7363, 7387, 7435, 7483, 7627, 8227, 8947, 9307, 10147, 10483, 13843
11	41	A046008	167, 271, 659, 967, 1283, 1303, 1307, 1459, 1531, 1699, 2027, 2267, 2539, 2731, 2851, 2971, 3203, 3347, 3499, 3739, 3931, 4051, 5179, 5683, 6163, 6547, 7027, 7507, 7603, 7867, 8443, 9283, 9403, 9643, 9787, 10987, 13003, 13267, 14107, 14683, 15667
12	206	A046009	231, 255, 327, 356, 440, 516, 543, 655, 680, 687, 696, 728, 731, 744, 755, 804, 888, 932, 948, 964, 984, 996, 1011, 1067, 1096, 1144, 1208, 1235, 1236, 1255, 1272, 1336, 1355, 1371, 1419, 1464, 1480, 1491, 1515, 1547, 1572, 1668, 1720, 1732, 1763, 1807, 1812, 1892, 1955, 1972, 2068, 2091, 2104, 2132, 2148, 2155, 2235, 2260, 2355, 2387, 2388, 2424, 2440, 2468, 2472, 2488, 2491, 2555, 2595, 2627, 2635, 2676, 2680, 2692, 2723, 2728, 2740, 2795, 2867, 2872, 2920, 2955, 3012, 3027, 3043, 3048, 3115, 3208, 3252, 3256, 3268, 3304, 3387, 3451, 3459, 3592, 3619, 3652, 3723, 3747, 3768, 3796, 3835, 3880, 3892, 3955, 3972, 4035, 4120, 4132, 4147, 4152, 4155, 4168, 4291, 4360, 4411, 4467, 4531, 4552, 4555, 4587, 4648, 4699, 4708, 4755, 4771, 4792, 4795, 4827, 4888, 4907, 4947, 4963, 5032, 5035, 5128, 5140, 5155, 5188, 5259, 5299, 5307, 5371, 5395, 5523, 5595, 5755, 5763, 5811, 5835, 6187, 6232, 6235, 6267, 6283, 6472, 6483, 6603, 6643, 6715, 6787, 6843, 6931, 6955, 6963, 6987, 7107, 7291, 7492, 7555, 7683, 7891, 7912, 8068, 8131, 8155, 8248, 8323, 8347, 8395, 8787, 8827, 9003, 9139, 9355, 9523, 9667, 9843, 10003, 10603, 10707, 10747, 10795, 10915, 11155, 11347, 11707, 11803, 12307, 12643, 14443, 15163, 15283, 16003, 17803
13	37	A046010	191, 263, 607, 631, 727, 1019, 1451, 1499, 1667, 1907, 2131, 2143, 2371, 2659, 2963, 3083, 3691, 4003, 4507, 4643, 5347, 5419, 5779, 6619, 7243, 7963, 9547, 9739, 11467, 11587, 11827, 11923, 12043, 14347, 15787, 16963, 20563
14	95	A046011	215, 287, 391, 404, 447, 511, 535, 536, 596, 692, 703, 807, 899, 1112, 1211, 1396, 1403, 1527, 1816, 1851, 1883, 2008, 2123, 2147, 2171, 2335, 2427, 2507, 2536, 2571, 2612, 2779, 2931, 2932, 3112, 3227, 3352, 3579, 3707, 3715, 3867, 3988, 4187, 4315, 4443, 4468, 4659, 4803, 4948, 5027, 5091, 5251, 5267, 5608, 5723, 5812, 5971, 6388, 6499, 6523, 6568, 6979, 7067, 7099, 7147, 7915, 8035, 8187, 8611, 8899, 9115, 9172, 9235, 9427, 10123, 10315, 10363, 10411, 11227, 12147, 12667, 12787, 13027, 13435, 13483, 13603, 14203, 16867, 18187, 18547, 18643, 20227, 21547, 23083, 30067
15	68	A046012	239, 439, 751, 971, 1259, 1327, 1427, 1567, 1619, 2243, 2647, 2699, 2843, 3331, 3571, 3803, 4099, 4219, 5003, 5227, 5323, 5563, 5827, 5987, 6067, 6091, 6211, 6571, 7219, 7459, 7547, 8467, 8707, 8779, 9043, 9907, 10243, 10267, 10459, 10651, 10723, 11083, 11971, 12163, 12763, 13147, 13963, 14323, 14827, 14851, 15187, 15643, 15907, 16603, 16843, 17467, 17923, 18043, 18523, 19387, 19867, 20707, 22003, 26203, 27883, 29947, 32323, 34483
16	322	A046013	399, 407, 471, 559, 584, 644, 663, 740, 799, 884, 895, 903, 943, 1015, 1016, 1023, 1028, 1047, 1139, 1140, 1159, 1220, 1379, 1412, 1416, 1508, 1560, 1595, 1608, 1624, 1636, 1640, 1716, 1860, 1876, 1924, 1983, 2004, 2019, 2040, 2056, 2072, 2095, 2195, 2211, 2244, 2280, 2292, 2296, 2328, 2356, 2379, 2436, 2568, 2580, 2584, 2739, 2760, 2811, 2868, 2884, 2980, 3063, 3108, 3140, 3144, 3160, 3171, 3192, 3220, 3336, 3363, 3379, 3432, 3435, 3443, 3460, 3480, 3531, 3556, 3588, 3603, 3640, 3732, 3752, 3784, 3795, 3819, 3828, 3832, 3939, 3976, 4008, 4020, 4043, 4171, 4179, 4180, 4216, 4228, 4251, 4260, 4324, 4379, 4420, 4427, 4440, 4452, 4488, 4515, 4516, 4596, 4612, 4683, 4687, 4712, 4740, 4804, 4899, 4939, 4971, 4984, 5115, 5160, 5187, 5195, 5208, 5363, 5380, 5403, 5412, 5428, 5460, 5572, 5668, 5752, 5848, 5860, 5883, 5896, 5907, 5908, 5992, 5995, 6040, 6052, 6099, 6123, 6148, 6195, 6312, 6315, 6328, 6355, 6395, 6420, 6532, 6580, 6595, 6612, 6628, 6708, 6747, 6771, 6792, 6820, 6868, 6923, 6952, 7003, 7035, 7051, 7195, 7288, 7315, 7347, 7368, 7395, 7480, 7491, 7540, 7579, 7588, 7672, 7707, 7747, 7755, 7780, 7795, 7819, 7828, 7843, 7923, 7995, 8008, 8043, 8052, 8083, 8283, 8299, 8308, 8452, 8515, 8547, 8548, 8635, 8643, 8680, 8683, 8715, 8835, 8859, 8932, 8968, 9208, 9219, 9412, 9483, 9507, 9508, 9595, 9640, 9763, 9835, 9867, 9955, 10132, 10168, 10195, 10203, 10227, 10312, 10387, 10420, 10563, 10587, 10635, 10803, 10843, 10948, 10963, 11067, 11092, 11107, 11179, 11203, 11512, 11523, 11563, 11572, 11635, 11715, 11848, 11995, 12027, 12259, 12387, 12523, 12595, 12747, 12772, 12835, 12859, 12868, 13123, 13192, 13195, 13288, 13323, 13363, 13507, 13795, 13819, 13827, 14008, 14155, 14371, 14403, 14547, 14707, 14763, 14995, 15067, 15387, 15403, 15547, 15715, 16027, 16195, 16347, 16531, 16555, 16723, 17227, 17323, 17347, 17427, 17515, 18403, 18715, 18883, 18907, 19147, 19195, 19947, 19987, 20155, 20395, 21403, 21715, 21835, 22243, 22843, 23395, 23587, 24403, 25027, 25267, 27307, 27787, 28963, 31243
17	45	A046014	383, 991, 1091, 1571, 1663, 1783, 2531, 3323, 3947, 4339, 4447, 4547, 4651, 5483, 6203, 6379, 6451, 6827, 6907, 7883, 8539, 8731, 9883, 11251, 11443, 12907, 13627, 14083, 14779, 14947, 16699, 17827, 18307, 19963, 21067, 23563, 24907, 25243, 26083, 26107, 27763, 31627, 33427, 36523, 37123
18	150	A046015	335, 519, 527, 679, 1135, 1172, 1207, 1383, 1448, 1687, 1691, 1927, 2047, 2051, 2167, 2228, 2291, 2315, 2344, 2644, 2747, 2859, 3035, 3107, 3543, 3544, 3651, 3688, 4072, 4299, 4307, 4568, 4819, 4883, 5224, 5315, 5464, 5492, 5539, 5899, 6196, 6227, 6331, 6387, 6484, 6739, 6835, 7323, 7339, 7528, 7571, 7715, 7732, 7771, 7827, 8152, 8203, 8212, 8331, 8403, 8488, 8507, 8587, 8884, 9123, 9211, 9563, 9627, 9683, 9748, 9832, 10228, 10264, 10347, 10523, 11188, 11419, 11608, 11643, 11683, 11851, 11992, 12067, 12148, 12187, 12235, 12283, 12651, 12723, 12811, 12952, 13227, 13315, 13387, 13747, 13947, 13987, 14163, 14227, 14515, 14667, 14932, 15115, 15243, 16123, 16171, 16387, 16627, 17035, 17131, 17403, 17635, 18283, 18712, 19027, 19123, 19651, 20035, 20827, 21043, 21652, 21667, 21907, 22267, 22443, 22507, 22947, 23347, 23467, 23683, 23923, 24067, 24523, 24667, 24787, 25435, 26587, 26707, 28147, 29467, 32827, 33763, 34027, 34507, 36667, 39307, 40987, 41827, 43387, 48427
19	47	A046016	311, 359, 919, 1063, 1543, 1831, 2099, 2339, 2459, 3343, 3463, 3467, 3607, 4019, 4139, 4327, 5059, 5147, 5527, 5659, 6803, 8419, 8923, 8971, 9619, 10891, 11299, 15091, 15331, 16363, 16747, 17011, 17299, 17539, 17683, 19507, 21187, 21211, 21283, 23203, 24763, 26227, 27043, 29803, 31123, 37507, 38707
20	350	A046017	455, 615, 776, 824, 836, 920, 1064, 1124, 1160, 1263, 1284, 1460, 1495, 1524, 1544, 1592, 1604, 1652, 1695, 1739, 1748, 1796, 1880, 1887, 1896, 1928, 1940, 1956, 2136, 2247, 2360, 2404, 2407, 2483, 2487, 2532, 2552, 2596, 2603, 2712, 2724, 2743, 2948, 2983, 2987, 3007, 3016, 3076, 3099, 3103, 3124, 3131, 3155, 3219, 3288, 3320, 3367, 3395, 3496, 3512, 3515, 3567, 3655, 3668, 3684, 3748, 3755, 3908, 3979, 4011, 4015, 4024, 4036, 4148, 4264, 4355, 4371, 4395, 4403, 4408, 4539, 4548, 4660, 4728, 4731, 4756, 4763, 4855, 4891, 5019, 5028, 5044, 5080, 5092, 5268, 5331, 5332, 5352, 5368, 5512, 5560, 5592, 5731, 5944, 5955, 5956, 5988, 6051, 6088, 6136, 6139, 6168, 6280, 6339, 6467, 6504, 6648, 6712, 6755, 6808, 6856, 7012, 7032, 7044, 7060, 7096, 7131, 7144, 7163, 7171, 7192, 7240, 7428, 7432, 7467, 7572, 7611, 7624, 7635, 7651, 7667, 7720, 7851, 7876, 7924, 7939, 8067, 8251, 8292, 8296, 8355, 8404, 8472, 8491, 8632, 8692, 8755, 8808, 8920, 8995, 9051, 9124, 9147, 9160, 9195, 9331, 9339, 9363, 9443, 9571, 9592, 9688, 9691, 9732, 9755, 9795, 9892, 9976, 9979, 10027, 10083, 10155, 10171, 10291, 10299, 10308, 10507, 10515, 10552, 10564, 10819, 10888, 11272, 11320, 11355, 11379, 11395, 11427, 11428, 11539, 11659, 11755, 11860, 11883, 11947, 11955, 12019, 12139, 12280, 12315, 12328, 12331, 12355, 12363, 12467, 12468, 12472, 12499, 12532, 12587, 12603, 12712, 12883, 12931, 12955, 12963, 13155, 13243, 13528, 13555, 13588, 13651, 13803, 13960, 14307, 14331, 14467, 14491, 14659, 14755, 14788, 15235, 15268, 15355, 15603, 15688, 15691, 15763, 15883, 15892, 15955, 16147, 16228, 16395, 16408, 16435, 16483, 16507, 16612, 16648, 16683, 16707, 16915, 16923, 17067, 17187, 17368, 17563, 17643, 17763, 17907, 18067, 18163, 18195, 18232, 18355, 18363, 19083, 19443, 19492, 19555, 19923, 20083, 20203, 20587, 20683, 20755, 20883, 21091, 21235, 21268, 21307, 21387, 21508, 21595, 21723, 21763, 21883, 22387, 22467, 22555, 22603, 22723, 23443, 23947, 24283, 24355, 24747, 24963, 25123, 25363, 26635, 26755, 26827, 26923, 27003, 27955, 27987, 28483, 28555, 29107, 29203, 30283, 30787, 31003, 31483, 31747, 31987, 32923, 33163, 34435, 35683, 35995, 36283, 37627, 37843, 37867, 38347, 39187, 39403, 40243, 40363, 40555, 40723, 43747, 47083, 48283, 51643, 54763, 58507
21	85	A046018	431, 503, 743, 863, 1931, 2503, 2579, 2767, 2819, 3011, 3371, 4283, 4523, 4691, 5011, 5647, 5851, 5867, 6323, 6691, 7907, 8059, 8123, 8171, 8243, 8387, 8627, 8747, 9091, 9187, 9811, 9859, 10067, 10771, 11731, 12107, 12547, 13171, 13291, 13339, 13723, 14419, 14563, 15427, 16339, 16987, 17107, 17707, 17971, 18427, 18979, 19483, 19531, 19819, 20947, 21379, 22027, 22483, 22963, 23227, 23827, 25603, 26683, 27427, 28387, 28723, 28867, 31963, 32803, 34147, 34963, 35323, 36067, 36187, 39043, 40483, 44683, 46027, 49603, 51283, 52627, 55603, 58963, 59467, 61483
22	139	A171724	591, 623, 767, 871, 879, 1076, 1111, 1167, 1304, 1556, 1591, 1639, 1903, 2215, 2216, 2263, 2435, 2623, 2648, 2815, 2863, 2935, 3032, 3151, 3316, 3563, 3587, 3827, 4084, 4115, 4163, 4328, 4456, 4504, 4667, 4811, 5383, 5416, 5603, 5716, 5739, 5972, 6019, 6127, 6243, 6616, 6772, 6819, 7179, 7235, 7403, 7763, 7768, 7899, 8023, 8143, 8371, 8659, 8728, 8851, 8907, 8915, 9267, 9304, 9496, 10435, 10579, 10708, 10851, 11035, 11283, 11363, 11668, 12091, 12115, 12403, 12867, 13672, 14019, 14059, 14179, 14548, 14587, 14635, 15208, 15563, 15832, 16243, 16251, 16283, 16291, 16459, 17147, 17587, 17779, 17947, 18115, 18267, 18835, 18987, 19243, 19315, 19672, 20308, 20392, 22579, 22587, 22987, 24243, 24427, 25387, 25507, 25843, 25963, 26323, 26548, 27619, 28267, 29227, 29635, 29827, 30235, 30867, 31315, 33643, 33667, 34003, 34387, 35347, 41083, 43723, 44923, 46363, 47587, 47923, 49723, 53827, 77683, 85507
23	68	A046020	647, 1039, 1103, 1279, 1447, 1471, 1811, 1979, 2411, 2671, 3491, 3539, 3847, 3923, 4211, 4783, 5387, 5507, 5531, 6563, 6659, 6703, 7043, 9587, 9931, 10867, 10883, 12203, 12739, 13099, 13187, 15307, 15451, 16267, 17203, 17851, 18379, 20323, 20443, 20899, 21019, 21163, 22171, 22531, 24043, 25147, 25579, 25939, 26251, 26947, 27283, 28843, 30187, 31147, 31267, 32467, 34843, 35107, 37003, 40627, 40867, 41203, 42667, 43003, 45427, 45523, 47947, 90787
24	511	A048925	695, 759, 1191, 1316, 1351, 1407, 1615, 1704, 1736, 1743, 1988, 2168, 2184, 2219, 2372, 2408, 2479, 2660, 2696, 2820, 2824, 2852, 2856, 2915, 2964, 3059, 3064, 3127, 3128, 3444, 3540, 3560, 3604, 3620, 3720, 3864, 3876, 3891, 3899, 3912, 3940, 4063, 4292, 4308, 4503, 4564, 4580, 4595, 4632, 4692, 4715, 4744, 4808, 4872, 4920, 4936, 5016, 5124, 5172, 5219, 5235, 5236, 5252, 5284, 5320, 5348, 5379, 5432, 5448, 5555, 5588, 5620, 5691, 5699, 5747, 5748, 5768, 5828, 5928, 5963, 5979, 6004, 6008, 6024, 6072, 6083, 6132, 6180, 6216, 6251, 6295, 6340, 6411, 6531, 6555, 6699, 6888, 6904, 6916, 7048, 7108, 7188, 7320, 7332, 7348, 7419, 7512, 7531, 7563, 7620, 7764, 7779, 7928, 7960, 7972, 8088, 8115, 8148, 8211, 8260, 8328, 8344, 8392, 8499, 8603, 8628, 8740, 8760, 8763, 8772, 8979, 9028, 9048, 9083, 9112, 9220, 9259, 9268, 9347, 9352, 9379, 9384, 9395, 9451, 9480, 9492, 9652, 9672, 9715, 9723, 9823, 9915, 9928, 9940, 10011, 10059, 10068, 10120, 10180, 10187, 10212, 10248, 10283, 10355, 10360, 10372, 10392, 10452, 10488, 10516, 10612, 10632, 10699, 10740, 10756, 10788, 10792, 10840, 10852, 10923, 11019, 11032, 11139, 11176, 11208, 11211, 11235, 11267, 11307, 11603, 11620, 11627, 11656, 11667, 11748, 11752, 11811, 11812, 11908, 11928, 12072, 12083, 12243, 12292, 12376, 12408, 12435, 12507, 12552, 12628, 12760, 12808, 12820, 12891, 13035, 13060, 13080, 13252, 13348, 13395, 13427, 13444, 13512, 13531, 13539, 13540, 13587, 13611, 13668, 13699, 13732, 13780, 13912, 14035, 14043, 14212, 14235, 14260, 14392, 14523, 14532, 14536, 14539, 14555, 14595, 14611, 14632, 14835, 14907, 14952, 14968, 14980, 15019, 15112, 15267, 15339, 15411, 15460, 15483, 15528, 15555, 15595, 15640, 15652, 15747, 15748, 15828, 15843, 15931, 15940, 15988, 16107, 16132, 16315, 16360, 16468, 16563, 16795, 16827, 16872, 16888, 16907, 16948, 17032, 17043, 17059, 17092, 17283, 17560, 17572, 17620, 17668, 17752, 17812, 17843, 18040, 18052, 18088, 18132, 18148, 18340, 18507, 18568, 18579, 18595, 18627, 18628, 18667, 18763, 18795, 18811, 18867, 18868, 18915, 19203, 19528, 19579, 19587, 19627, 19768, 19803, 19912, 19915, 20260, 20307, 20355, 20427, 20491, 20659, 20692, 20728, 20803, 20932, 20955, 20980, 20995, 21112, 21172, 21352, 21443, 21448, 21603, 21747, 21963, 21988, 22072, 22107, 22180, 22323, 22339, 22803, 22852, 22867, 22939, 23032, 23035, 23107, 23115, 23188, 23235, 23307, 23368, 23752, 23907, 23995, 24115, 24123, 24292, 24315, 24388, 24595, 24627, 24628, 24643, 24915, 24952, 24955, 25048, 25195, 25347, 25467, 25683, 25707, 25732, 25755, 25795, 25915, 25923, 25972, 25987, 26035, 26187, 26395, 26427, 26467, 26643, 26728, 26995, 27115, 27163, 27267, 27435, 27448, 27523, 27643, 27652, 27907, 28243, 28315, 28347, 28372, 28459, 28747, 28891, 29128, 29283, 29323, 29395, 29563, 29659, 29668, 29755, 29923, 30088, 30163, 30363, 30387, 30523, 30667, 30739, 30907, 30955, 30979, 31252, 31348, 31579, 31683, 31795, 31915, 32008, 32043, 32155, 32547, 32635, 32883, 33067, 33187, 33883, 34203, 34363, 34827, 34923, 36003, 36043, 36547, 36723, 36763, 36883, 37227, 37555, 37563, 38227, 38443, 38467, 39603, 39643, 39787, 40147, 40195, 40747, 41035, 41563, 42067, 42163, 42267, 42387, 42427, 42835, 43483, 44947, 45115, 45787, 46195, 46243, 46267, 47203, 47443, 47707, 48547, 49107, 49267, 49387, 49987, 50395, 52123, 52915, 54307, 55867, 56947, 57523, 60523, 60883, 61147, 62155, 62203, 63043, 64267, 79363, 84043, 84547, 111763
25	95	A056987	479, 599, 1367, 2887, 3851, 4787, 5023, 5503, 5843, 7187, 7283, 7307, 7411, 8011, 8179, 9227, 9923, 10099, 11059, 11131, 11243, 11867, 12211, 12379, 12451, 12979, 14011, 14923, 15619, 17483, 18211, 19267, 19699, 19891, 20347, 21107, 21323, 21499, 21523, 21739, 21787, 21859, 24091, 24571, 25747, 26371, 27067, 27091, 28123, 28603, 28627, 28771, 29443, 30307, 30403, 30427, 30643, 32203, 32443, 32563, 32587, 33091, 34123, 34171, 34651, 34939, 36307, 37363, 37747, 37963, 38803, 39163, 44563, 45763, 48787, 49123, 50227, 51907, 54667, 55147, 57283, 57667, 57787, 59707, 61027, 62563, 63067, 64747, 66763, 68443, 69763, 80347, 85243, 89083, 93307
The number of negative discriminants having class number 1, 2, 3, ... are 9, 18, 16, 54, 25, 51, 31, ... (OEIS A046125). The largest negative discriminants having class numbers 1, 2, 3, ... are 163, 427, 907, 1555, 2683, ... (OEIS A038552).

The discriminants d corresponding to real quadratic fields are 5, 8, 12, 13, 17, 21, 24, 28, 29, 33, 37, 40, 41, 44, 53, ... (OEIS A003658), corresponding to class numbers h(d)=1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, ... (OEIS A003652).

The table below gives lists of the first few positive fundamental discriminants d having small class numbers h(d), corresponding to real quadratic fields, augmenting the table of Cohn (1980, pp. 271-274) by including terms divisible by 4 (Cohen 1993, pp. 516-519; Cohen 2000, pp. 534-537). In fact, the discriminant of all quadratic number fields is squarefree except for a possible factor of 4.

h(d)	OEIS	d
1	A003656	5, 8, 12, 13, 17, 21, 24, 28, 29, 33, 37, 41, 44, 53, 56, 57, 61, ...
2	A094619	40, 60, 65, 85, 104, 105, 120, 136, 140, 156, 165, 168, 185, 204, ...
3	A094612	229, 257, 316, 321, 469, 473, 568, 733, 761, 892, 993, 1016, 1101, ...
4	A094613	145, 328, 445, 505, 520, 680, 689, 777, 780, 793, 840, 876, 897, 901, ...
5	A094614	401, 817, 1093, 1393, 1429, 1641, 1756, 1897, 1996, 2081, 2153, 2908, ...
The smallest d such that the real quadratic field with discriminant d has class h(d)=n for n=1, 2, ... are 5, 40, 229, 145, 401, 697, 577, 904, 1129, ... (OEIS A081364).

SEE ALSO
Binary Quadratic Form Discriminant, Class Field Theory, Class Group, Class Number Formula, Dirichlet L-Series, Dirichlet Structure Constant, Gauss's Class Number Conjecture, Gauss's Class Number Problem, Heegner Number, Ideal, j-Function, Ring
]]
[[
]]




[[
field of fractions
Fraction Field of Integral Domains
fraction field of polynomial ring

https://mathworld.wolfram.com/FieldofFractions.html

Field of Fractions
The ring of fractions of an integral domain.
The field of fractions of the ring of integers Z is the rational field Q.

The field of fractions of the polynomial ring K[X_1,X_2,...,X_n] over a field K is the field of rational functions
     K(X_1,X_2,...,X_n)={(f(X_1,X_2,...,X_n))/(g(X_1,X_2,...,X_n)): f,g in K[X_1,X_2,...,X_n],g!=0}. 

The field of fractions of an integral domain R is the smallest field containing R, since it is obtained from R by adding the least needed to make R a field, namely the possibility of dividing by any nonzero element.
]]


[[
https://mathworld.wolfram.com/FiniteExtension.html
Finite Extension
An extension field F subset= K is called finite if the dimension of K as a vector space over F (the so-called degree of K over F) is finite. A finite field extension is always algebraic.

Note that "finite" is a synonym for "finite-dimensional"; it does not mean "of finite cardinality" (the field C of complex numbers is a finite extension, of degree 2, of the field R of real numbers, but is obviously an infinite set), and it is not even equivalent to "finitely generated" (a transcendental extension is never a finite extension, but it can be generated by a single element as, for example, the field of rational functions F(x) over a field F).

A ring extension R subset= S is called finite if S is finitely generated as a module over R. An example is the ring of Gaussian integers Z[i], which is generated by 1,i as a module over Z. The polynomial ring Z[x], however, is not a finite ring extension of Z, since all systems of generators of Z[x] as a Z-module have infinitely many elements: in fact they must be composed of polynomials of all possible degrees. The simplest generating set is the sequence 1,x,x^2,....

A finite ring extension is always integral.
]]

[[
https://mathworld.wolfram.com/NumberField.html
Number Field
If r is an algebraic number of degree n, then the totality of all expressions that can be constructed from r by repeated additions, subtractions, multiplications, and divisions is called a number field (or an algebraic number field) generated by r, and is denoted F[r]. Formally, a number field is a finite extension Q(alpha) of the field Q of rational numbers.

The elements of a number field which are roots of a polynomial

 z^n+a_(n-1)z^(n-1)+...+a_0=0 
with integer coefficients and leading coefficient 1 are called the algebraic integers of that field.

The coefficients of an algebraic equations such as the quintic equation can be characterized by the groups of their associated number fields. A database of the groups of number field polynomials is maintained by Klüners and Malle. For example, the polynomial x^5-x^4+2x^3-4x^2+x-1 is associated with the group F(5) of order 20.
]]

[[
https://mathworld.wolfram.com/ExtensionField.html
Extension Field
A field K is said to be an extension field (or field extension, or extension), denoted K/F, of a field F if F is a subfield of K. For example, the complex numbers are an extension field of the real numbers, and the real numbers are an extension field of the rational numbers.

The extension field degree (or relative degree, or index) of an extension field K/F, denoted [K:F], is the dimension of K as a vector space over F, i.e.,

 [K:F]=dim_FK. 	
(1)
Given a field F, there are a couple of ways to define an extension field. If F is contained in a larger field, F subset F^'. Then by picking some elements alpha_i in F^' not in F, one defines F(alpha_i) to be the smallest subfield of F^' containing F and the alpha_i. For instance, the rationals can be extended by the complex number zeta, yielding Q(zeta). If there is only one new element, the extension is called a simple extension. The process of adding a new element is called "adjoining."

Since elements can be adjoined in any order, it suffices to understand simple extensions. Because alpha_i is contained in a larger field, its algebraic operations, such as multiplication and addition, are defined with elements in F. Hence,

 F(alpha)={(f(alpha))/(g(alpha)):f,g are polynomials in F and g(alpha)!=0 in F^'}. 	
(2)
The expression above shows that the polynomials with p(alpha)=0 are important. In fact, there are two possibilities.

1. For some positive integer n, the nth power alpha^n can be written as a (finite) linear combination

 alpha^n=sum_(i=0)^(n-1)c_ialpha^i, 	
(3)
with c_i in F, of powers of alpha less than n. In this case, alpha is called an algebraic number over F and F(alpha) is an algebraic extension. The extension field degree of the extension is the smallest integer n satisfying the above, and the polynomial p(x)=x^n-sum_(i=0)^(n-1) is called the extension field minimal polynomial.

2. Otherwise, there is no such integer n as in the first case. Then alpha is a transcendental number over F and F(alpha) is a transcendental extension of transcendence degree 1.

Note that in the case of an algebraic extension (case 1 above), the extension field can be written

 F(alpha)=F[alpha]={f(alpha): 
 f is a polynomial in F and degf<n}.   	
(4)
Unlike the similar expression above, it is not immediately obvious that the ring F[alpha] is a field. The following argument shows how to divide in this ring. Because no polynomial f of degree less than n can divide the extension field minimal polynomial p, any such polynomial f is relatively prime. That is, there exist polynomials a and b such that af+bp=1, or rather,

 a(x)f(x)=1 (mod p(x)) 	
(5)
and a(alpha) is the multiplicative inverse of f(alpha).

Another method for defining an extension is to use an indeterminate variable x. Then F(x) is the set of rational functions in one variable with coefficients in F, and up to isomorphism is the unique transcendental extension of transcendence degree 1. The polynomials F[x] are the denominators and numerators of the rational functions. Given a nonconstant polynomial p(x) which is irreducible over F, the quotient ring F[x]/(p) are the polynomials mod p. In particular, as in case 1 above, F[x]/(p) is generated by 1,x,...,x^(n-1) where n is the degree of p. The field of fractions of F[x]/(p), written F(x)/(p), is an algebraic extension of F, which is isomorphic to the extension of F by one of the roots of p. For instance, Q(i)=Q(x)/(x^2+1). Consequently, if alpha and beta are different roots of an irreducible polynomial p, then F(alpha)=F(beta). When beta in alpha, this isomorphism reflects a field automorphism, one of the symmetries of the field that form the Galois group.

A number field is a finite algebraic extension of the rational numbers. Mathematicians have been using number fields for hundreds of years to solve equations like x^2-2y^2=k where all the variables are integers, because they try to factor the equation in the extension Q(sqrt(2)). For instance, it is easy to see that the only integer solutions to x^2-y^2=(x+y)(x-y)=5 are (+/-3,+/-2) since there are four ways to write 5 as the product of integers.

 5=5×1=1×5=-1×-5=-5×-1. 	
(6)
Hence, it became necessary to understand what is a prime number in a number field. In fact, it led to some confusion because unique factorization does not always hold. The lack of unique factorization is measured by the class group, and the class number.

It can be shown that any number field can be written Q(zeta) for some zeta, that is every number field is a simple extension of the rationals. Naturally, the choice of zeta is not unique, e.g., Q(zeta)=Q(2+zeta)=Q(-zeta)=....

SEE ALSO
Class Group, Class Number, Extension Field Degree, Extension Ring, Field, Field Automorphism, Galois Theory, Pythagorean Extension, Simple Extension, Splitting Field, Subfield
]]


[[
https://mathworld.wolfram.com/PrimeElement.html
Prime Element
A nonzero and noninvertible element a of a ring R which generates a prime ideal. It can also be characterized by the condition that whenever a divides a product in R, a divides one of the factors. The prime elements of Z are the prime numbers P.

In an integral domain, every prime element is irreducible, but the converse holds only in unique factorization domains. The ring Z[i*sqrt(5)], where i is the imaginary unit, is not a unique factorization domain, and there the element 2 is irreducible, but not prime, since 2 divides the product (1-i*sqrt(5))(1+i*sqrt(5))=6, but it does not divide any of the factors.

SEE ALSO
Irreducible Element, Prime Number, Unique Factorization, Unique Factorization Domain
]]
[[
https://mathworld.wolfram.com/IrreducibleElement.html
Irreducible Element
An element a of a ring which is nonzero, not a unit, and whose only divisors are the trivial ones (i.e., the units and the products ua, where u is a unit). Equivalently, an element a is irreducible if the only possible decompositions of a into the product of two factors are of the form

 a=u^(-1)·ua, 
where u^(-1) is the multiplicative inverse of u.

The prime numbers and the irreducible polynomials are examples of irreducible elements. In a principal ideal domain, the irreducible elements are the generators of the nonzero prime ideals, hence the irreducible elements are exactly the prime elements. In general, however, the two notions are not equivalent.

SEE ALSO
Unique Factorization
]]
==>>:
[[
[is_irreducible_(a) =[def]= [[a=!=0][not [is_ring_unit_(a)]][[x,y :<- ring] -> [x*y==a] -> [[is_ring_unit_(x)]or[is_ring_unit_(y)]]]]]
[is_prime_(p) =[def]= [[a=!=0][not [is_ring_unit_(a)]][[x,y :<- ring] -> [is_left_divisor_of_(x*y;p)] -> [[is_left_divisor_of_(x;p)]or[is_left_divisor_of_(y;p)]]][[x,y :<- ring] -> [is_right_divisor_of_(x*y;p)] -> [[is_right_divisor_of_(x;p)]or[is_right_divisor_of_(y;p)]]]]]
[NOT_ALWAYS [is_prime_ <: is_irreducible_]]
    !! see:PrincipalRing:Z_6 #ZZ%6
[[ring.is_integral_domain()] -> [ring.is_prime_ <: ring.is_irreducible_]]
[[ring.is_unique_factorization_domain()] -> [ring.is_prime_ == ring.is_irreducible_]]
    ZZ[i*sqrt(5)], where i is the imaginary unit, is not a unique factorization domain:
        [6 == 2*3 == (1-i*sqrt(5))(1+i*sqrt(5))]
    [is_irreducible_(ZZ[i*sqrt(5)]; 2)]
    [not is_prime_(ZZ[i*sqrt(5)]; 2)]


===
[integral_domain > pre_Schreier_domain > Schreier_domain > gcd_domain > unique_factorization_domain]
[[ring.is_pre_Schreier_domain()] -> [ ring.is_irreducible_ <: ring.is_prime_]]
!! [[ring.is_integral_domain()] -> [ring.is_prime_ <: ring.is_irreducible_]]
[[ring.is_pre_Schreier_domain()] -> [ring.is_prime_ == ring.is_irreducible_]]
]]

[[UFD
https://mathworld.wolfram.com/UniqueFactorizationDomain.html
Unique Factorization Domain
A unique factorization domain, called UFD for short, is any integral domain in which every nonzero noninvertible element has a unique factorization, i.e., an essentially unique decomposition as the product of prime elements or irreducible elements. In this context, the two notions coincide, since in a unique factorization domain, every irreducible element is prime, whereas the opposite implication is true in every domain.

This definition arises as an application of the fundamental theorem of arithmetic, which is true in the ring of integers Z, to more abstract rings. Other examples of unique factorization domains are the polynomial ring K[x], where K is a field, and the ring of Gaussian integers Z[i]. In general, every principal ideal domain is a unique factorization domain, but the converse is not true, since every polynomial ring K[x_1,...,x_n] is a unique factorization domain, but it is not a principal ideal domain if n>1.

SEE ALSO
Fundamental Theorem of Arithmetic, Unique FactorizationUnique Factorization Domain
]]

[[PID
https://mathworld.wolfram.com/PrincipalIdealDomain.html
Principal Ideal Domain
A principal ideal domain is an integral domain in which every proper ideal can be generated by a single element. The term "principal ideal domain" is often abbreviated P.I.D. Examples of P.I.D.s include the integers, the Gaussian integers, and the set of polynomials in one variable with real coefficients.

Every Euclidean ring is a principal ideal domain, but the converse is not true. Nevertheless, the notion of greatest common divisor arising from the Euclidean algorithm can be extended to the more general context of principal ideal domains as follows. Given two nonzero elements a,b of a principal ideal domain R, a greatest common divisor of a and b is defined as any element d of R such that

 <a,b>=<d>. 
Every principal ideal domain is a unique factorization domain, but not conversely. Every polynomial ring over a field is a unique factorization domain, but it is a principal ideal domain iff the number of indeterminates is one.
]]

[[
https://mathworld.wolfram.com/PrincipalRing.html
Principal Ring
For some authors (e.g., Bourbaki, 1964), the same as principal ideal domain. Most authors, however, do not require the ring to be an integral domain, and define a principal ring (sometimes also called a principal ideal ring) simply as a commutative unit ring (different from the zero ring) in which every ideal is principal, i.e., can be generated by a single element. Examples include the ring of integers Z, any field, and any polynomial ring in one variable over a field. While all Euclidean rings are principal rings, the converse is not true.

If the ideal I of the commutative unit ring R is generated by the element a of R, in any quotient ring R^_ the corresponding ideal I^_ is generated by the residue class a^_ of a. Hence, every quotient ring of a principal ideal ring is a principal ideal ring as well. Since Z is a principal ideal domain, it follows that the rings Z_n are all principal ideal rings, though not all of them are principal ideal domains.

Principal ideal rings which are not domains have abnormal divisibility properties. For example, in Z_6, the identities

 2^_·5^_=4^_,    4^_·5^_=2^_ 
and

 2^_·2^_=4^_,    4^_·2^_=2^_ 
show that two elements (2^_,4^_) which divide each other can differ both by an invertible (5^_) and a noninvertible factor (2^_). Moreover, a prime element need not be irreducible. For example, if 2^_ divides the product of two factors of Z_6, one of these is certainly the residue class of an even number, i.e., it is a multiple of 2^_. Hence 2^_ is prime. On the other hand, in the decomposition 2^_=2^_·4^_, none of the factors is invertible, which shows that 2^_ is not irreducible.

For such reasons, many authors refrain from extending the divisibility notion and the related concepts from principal ideal domains to principal ideal rings.

Principal rings are very useful because in a principal ring, any two nonzero elements have a well-defined greatest common divisor. Furthermore each nonzero, nonunit element in a principal ring has a unique factorization into prime elements (up to unit elements).
]]
[[
https://mathworld.wolfram.com/EuclideanRing.html
Euclidean Ring
A ring without zero divisors in which an integer norm and an associated division algorithm (i.e., a Euclidean algorithm) can be defined. For signed integers, the usual norm is the absolute value and the division algorithm gives the ordinary quotient and remainder. For polynomials, the norm is the degree.

Important examples of Euclidean rings (besides Z) are the Gaussian integers and C[x], the ring of polynomials with complex coefficients. All Euclidean rings are also principal rings.

SEE ALSO
Euclidean Algorithm, Principal Ring, Ring
]]
[[[
[[ring.is_pre_Schreier_domain()] -> [ ring.is_irreducible_ <: ring.is_prime_]]
[gcd_domain < Schreier_domain]
===
https://www.wikiwand.com/en/Schreier_domain
===
In abstract algebra, a Schreier domain, named after Otto Schreier, is an integrally closed domain where every nonzero element is primal; i.e., whenever x divides yz, x can be written as x = x1 x2 so that x1 divides y and x2 divides z.
===
https://planetmath.org/schreierdomain
===
Schreier domain

An integral domain D is a pre-Schreier domain if every non-zero element of D is primal. If in addition D is integrally closed, then D is called a Schreier domain.

Remarks.

1.
Every irreducible element of a pre-Schreier domain is prime.

2.
A gcd domain is a Schreier domain (a proof of this can be found here (http://planetmath.org/ProofThatAGcdDomainIsIntegrallyClosed)).

Title	Schreier domain
Canonical name	SchreierDomain
Date of creation	2013-03-22 14:50:41
Last modified on	2013-03-22 14:50:41
Owner	CWoo (3771)
Last modified by	CWoo (3771)
Numerical id	7
Author	CWoo (3771)
Entry type	Definition
Classification	msc 13G05
Synonym	pre-Schreier
Defines	pre-Schreier domain
Generated on Fri Feb 9 17:33:28 2018 by LaTeXML
]]]
[[[
https://planetmath.org/GcdDomain
===
gcd domain

Throughout this entry, let D be a commutative ring with 1≠0.

A gcd (greatest common divisor) of two elements a,b∈D, is an element d∈D such that:

1.
d∣a and d∣b,

2.
if c∈D with c∣a and c∣b, then c∣d.

For example, 0 is a gcd of 0 and 0 in any D. In fact, if d is a gcd of 0 and 0, then d∣0. But 0∣0, so that 0∣d, which means that, for some x∈D, d=0⁢x=0. As a result, 0 is the unique gcd of 0 and 0.

In general, however, a gcd of two elements is not unique. For example, in the ring of integers, 1 and -1 are both gcd’s of two relatively prime elements. By definition, any two gcd’s of a pair of elements in D are associates of each other. Since the binary relation “being associates” of one anther is an equivalence relation (not a congruence relation!), we may define the gcd of a and b as the set

GCD⁡(a,b):={c∈D∣c⁢ is a gcd of ⁢a⁢ and ⁢b},
For example, as we have seen, GCD⁡(0,0)={0}. Also, for any a∈D, GCD⁡(a,1)=U⁡(D), the group of units of D.

If there is no confusion, let us denote gcd⁡(a,b) to be any element of GCD⁡(a,b).

If GCD⁡(a,b) contains a unit, then a and b are said to be relatively prime. If a is irreducible, then for any b∈D, a,b are either relatively prime, or a∣b.

An integral domain D is called a gcd domain if any two elements of D, not both zero, have a gcd. In other words, D is a gcd domain if for any a,b∈D, GCD⁡(a,b)≠∅.

Remarks

•
A unique factorization domain, or UFD is a gcd domain, but the converse is not true.

•
A Bezout domain is always a gcd domain. A gcd domain D is a Bezout domain if gcd⁡(a,b)=r⁢a+s⁢b for any a,b∈D and some r,s∈D.

•
In a gcd domain, an irreducible element is a prime element.

•
A gcd domain is integrally closed. In fact, it is a Schreier domain.

•
Given an integral domain, one can similarly define an lcm of two elements a,b: it is an element c such that a∣c and b∣c, and if d is an element such that a∣d and b∣d, then c∣d. Then, a lcm domain is an integral domain such that every pair of elements has a lcm. As it turns out, the two notions are equivalent: an integral domain is lcm iff it is gcd.

The following diagram indicates how the different domains are related:

Euclidean domain (http://planetmath.org/EuclideanRing)	⟹	PID	⟹	UFD
⇓		⇓
Bezout domain	⟹	gcd domain
References
1 D. D. Anderson, Advances in Commutative Ring Theory: Extensions of Unique Factorization, A Survey, 3rd Edition, CRC Press (1999)
2 D. D. Anderson, Non-Noetherian Commutative Ring Theory: GCD Domains, Gauss’ Lemma, and Contents of Polynomials, Springer (2009)
3 D. D. Anderson (editor), Factorizations in Integral Domains, CRC Press (1997)
Title	gcd domain
Canonical name	GcdDomain
Date of creation	2013-03-22 14:19:51
Last modified on	2013-03-22 14:19:51
Owner	CWoo (3771)
Last modified by	CWoo (3771)
Numerical id	26
Author	CWoo (3771)
Entry type	Definition
Classification	msc 13G05
Related topic	GreatestCommonDivisor
Related topic	BezoutDomain
Related topic	DivisibilityInRings
Defines	gcd
Defines	greatest common divisor
Defines	relatively prime
Defines	lcm domain
Generated on Fri Feb 9 17:32:45 2018 by LaTeXML [LOGO]
]]]
[[[
Euclidean domain
.   |
.   v
.  PID           -> UFD
.   |                |
.   v                v
.  Bezout domain -> gcd domain

===
Bezout domain

===
https://en.wikipedia.org/wiki/GCD_domain
A Bézout domain (i.e., an integral domain where every finitely generated ideal is principal) is a GCD domain. Unlike principal ideal domains (where every ideal is principal), a Bézout domain need not be a unique factorization domain; for instance the ring of entire functions is a non-atomic Bézout domain, and there are many other examples.
===
]]]
[[[
https://en.m.wikibooks.org/wiki/Commutative_Ring_Theory/B%C3%A9zout_domains
Definition (Bézout domain):
    A Bézout domain is an integral domain whose every finitely generated ideal is principal, ie. generated by a single element.
Proposition (Every Bézout domain is a GCD domain)
[BezoutDomain <: GCD_domain]

https://handwiki.org/wiki/B%C3%A9zout%27s_identity
[[ring <- BezoutDomain] =[def]= [[ring <- IntegralDomain][@[u,v :<- ring] -> ?[k4u,k4v :<- ring] -> [k4u*u+k4v*v == gcd(u,v)]]]]
[ring.does_Bezout_identity_hold() =[def]= [@[u,v :<- ring] -> ?[k4u,k4v :<- ring] -> [k4u*u+k4v*v == gcd(u,v)]]]
[is_Bezout_coefficient_pair_of_(u,v; k4u,k4v) =[def]= [k4u*u+k4v*v == gcd(u,v)]]
[ring.does_Bezout_identity_hold() =[def]= [@[u,v :<- ring] -> ?[k4u,k4v :<- ring] -> [is_Bezout_coefficient_pair_of_(u,v; k4u,k4v)]]]
[[ring <- BezoutDomain] =[def]= [[ring <- IntegralDomain][ring.does_Bezout_identity_hold()]]]
===
https://handwiki.org/wiki/B%C3%A9zout%27s_identity
===
Bézout's identity
From HandWiki
Short description: Relating two numbers and their greatest common divisor

In mathematics, Bézout's identity (also called Bézout's lemma), named after Étienne Bézout, is the following theorem:

Bézout's identity — Let a and b be integers with greatest common divisor d. Then there exist integers x and y such that a*x + b*y = d. Moreover, the integers of the form a*z + b*t are exactly the multiples of d.

Here the greatest common divisor of 0 and 0 is taken to be 0. The integers x and y are called Bézout coefficients for (a, b); they are not unique. A pair of Bézout coefficients can be computed by the extended Euclidean algorithm, and this pair is, in the case of integers one of the two pairs such that [[abs(x) <= abs(b/d)][abs(y) <= abs(a/d)]] and equality occurs only if one of a and b is a multiple of the other.

As an example, the greatest common divisor of 15 and 69 is 3, and 3 can be written as a combination of 15 and 69 as 3 = 15 × (−9) + 69 × 2, with Bézout coefficients −9 and 2.

Many other theorems in elementary number theory, such as Euclid's lemma or the Chinese remainder theorem, result from Bézout's identity.

A Bézout domain is an integral domain in which Bézout's identity holds. In particular, Bézout's identity holds in principal ideal domains. Every theorem that results from Bézout's identity is thus true in all principal ideal domains.


Contents
1	Structure of solutions
1.1	Example
2	Proof
3	Generalizations
3.1	For three or more integers
3.2	For polynomials
3.3	For principal ideal domains
4	History
5	See also
6	Notes
7	External links
Structure of solutions
If a and b are not both zero and one pair of Bézout coefficients (x, y) has been computed (for example, using the extended Euclidean algorithm), all pairs can be represented in the form 
    (x-k*(b/d), y+k*(a/d))
    where k is an arbitrary integer, d is the greatest common divisor of a and b, and the fractions simplify to integers.

If a and b are both nonzero, then exactly two of these pairs of Bézout coefficients satisfy 
    [[abs(x) <= abs(b/d)][abs(y) <= abs(a/d)]]
    and equality may occur only if one of a and b divides the other.

This relies on a property of Euclidean division: given two non-zero integers c and d, if d does not divide c, there is exactly one pair (q, r) such that [[c == d*q+r][0 < r < abs(d)]] and another one such that [[c == d*q+r][0 > r > -abs(d)]]

The two pairs of small Bézout's coefficients are obtained from the given one (x, y) by choosing for k in the above formula either of the two integers next to 
    (x/(b/d))
    .

The extended Euclidean algorithm always produces one of these two minimal pairs.

Example
Let a = 12 and b = 42, then gcd (12, 42) = 6. Then the following Bézout's identities are had, with the Bézout coefficients written in red for the minimal pairs and in blue for the other ones.

a*x       +    b*y     == d
... ...
12*-10    +    42*3    == 6
12*-3     +    42*1    == 6
12*4      +    42*-1   == 6
12*11     +    42*-3   == 6
... ...

If [(x,y)==(18,-5)] is the original pair of Bézout coefficients, then 
    (18/(42/6)) <- Real[>2..<3]
 yields the minimal pairs via k = 2, respectively k = 3; that is, (18 − 2 ⋅ 7, −5 + 2 ⋅ 2) = (4, −1), and (18 − 3 ⋅ 7, −5 + 3 ⋅ 2) = (−3, 1).

Proof
Given any nonzero integers a and b, let  The set S is nonempty since it contains either a or –a (with  and ). Since S is a nonempty set of positive integers, it has a minimum element , by the well-ordering principle. To prove that d is the greatest common divisor of a and b, it must be proven that d is a common divisor of a and b, and that for any other common divisor c, one has 

The Euclidean division of a by d may be written  The remainder r is in , because  					  Thus r is of the form , and hence  However,  and d is the smallest positive integer in S: the remainder r can therefore not be in S, making r necessarily 0. This implies that d is a divisor of a. Similarly d is also a divisor of b, and therefore d is a common divisor of a and b.

Now, let c be any common divisor of a and b; that is, there exist u and v such that  and  One has thus  					  That is, c is a divisor of d. Since  this implies 

Generalizations
For three or more integers
Bézout's identity can be extended to more than two integers: if  then there are integers  such that  has the following properties:

d is the smallest positive integer of this form
  [us :: [ring]{len=L}]:
    sum~ ks[i]*us[i] ~{ks :: [ring]{len=L}}
every number of this form is a multiple of d
For polynomials
Bézout's identity does not always hold for polynomials. For example, when working in the polynomial ring of integers: the greatest common divisor of 2*x and x**2 is x, but there does not exist any integer-coefficient polynomials p and q satisfying 2*x*p + x**2*q = x.

However, Bézout's identity works for univariate polynomials over a field exactly in the same ways as for integers. In particular the Bézout's coefficients and the greatest common divisor may be computed with the extended Euclidean algorithm.

As the common roots of two polynomials are the roots of their greatest common divisor, Bézout's identity and fundamental theorem of algebra imply the following result:

For univariate polynomials f and g with coefficients in a field, there exist polynomials a and b such that af + bg = 1 if and only if f and g have no common root in any algebraically closed field (commonly the field of complex numbers).
The generalization of this result to any number of polynomials and indeterminates is Hilbert's Nullstellensatz.

For principal ideal domains
As noted in the introduction, Bézout's identity works not only in the ring of integers, but also in any other principal ideal domain (PID). That is, if R is a PID, and a and b are elements of R, and d is a greatest common divisor of a and b, then there are elements x and y in R such that  The reason is that the ideal  is principal and equal to 

An integral domain in which Bézout's identity holds is called a Bézout domain.

History
French mathematician Étienne Bézout (1730–1783) proved this identity for polynomials.[1] This statement for integers can be found already in the work of an earlier French mathematician, Claude Gaspard Bachet de Méziriac (1581–1638).[2][3][4]

See also
AF+BG theorem – About algebraic curves passing through all intersection points of two other curves, an analogue of Bézout's identity for homogeneous polynomials in three indeterminates
Euclid's lemma – A prime divisor of a product divides one of the factors
Fundamental theorem of arithmetic – Integers have unique prime factorizations
]]]
[[[
https://en.m.wikibooks.org/wiki/Commutative_Ring_Theory/B%C3%A9zout_domains
===
Commutative Ring Theory/Bézout domains
< Commutative Ring Theory

Definition (Bézout domain):

A Bézout domain is an integral domain whose every finitely generated ideal is principal, ie. generated by a single element.


Proposition (Every Bézout domain is a GCD domain):

Let {\displaystyle R}R be a Bézout domain. Then {\displaystyle R}R is a GCD domain.

Proof: Given any two elements {\displaystyle a,b\in R}{\displaystyle a,b\in R}, we may consider the ideal {\displaystyle I=\langle a,b\rangle }{\displaystyle I=\langle a,b\rangle } generated by {\displaystyle a}a and {\displaystyle b}b. By the definition of Bézout domains, {\displaystyle I=\langle c\rangle }{\displaystyle I=\langle c\rangle } for at least one {\displaystyle c\in R}{\displaystyle c\in R} (which is moreover unique up to similarity). Then {\displaystyle \langle c\rangle \leq \langle a\rangle }{\displaystyle \langle c\rangle \leq \langle a\rangle } and {\displaystyle \langle c\rangle \leq \langle b\rangle }{\displaystyle \langle c\rangle \leq \langle b\rangle }, so that by the characterisation of divisibility by principal ideals, {\displaystyle c}c is a common divisor of {\displaystyle a}a and {\displaystyle b}b. Moreover, if {\displaystyle d\in R}{\displaystyle d\in R} is another common divisor of {\displaystyle a}a and {\displaystyle b}b, then {\displaystyle a,b\in \langle d\rangle }{\displaystyle a,b\in \langle d\rangle }, so that {\displaystyle \langle a,b\rangle =\langle c\rangle \leq \langle d\rangle }{\displaystyle \langle a,b\rangle =\langle c\rangle \leq \langle d\rangle }, so that {\displaystyle d|c}{\displaystyle d|c}. Hence, {\displaystyle c}c is a greatest common divisor of {\displaystyle a}a and {\displaystyle b}b.{\displaystyle \Box }\Box 
]]]






[[[
https://mathworld.wolfram.com/Divisor.html
===
Divisor
A divisor, also called a factor, of a number n is a number d which divides n (written d|n). For integers, only positive divisors are usually considered, though obviously the negative of any positive divisor is itself a divisor. A list of (positive) divisors of a given integer n may be returned by the Wolfram Language function Divisors[n].

Sums and products are commonly taken over only some subset of values that are the divisors of a given number. Such a sum would then be denoted, for example,

 sum_(d|n)f(d). 	
(1)
Such sums are implemented in the Wolfram Language as DivisorSum[n, form, cond].

The following tables lists the divisors of the first few positive integers (OEIS A027750).

n	divisors
1	1
2	1, 2
3	1, 3
4	1, 2, 4
5	1, 5
6	1, 2, 3, 6
7	1, 7
8	1, 2, 4, 8
9	1, 3, 9
10	1, 2, 5, 10
11	1, 11
12	1, 2, 3, 4, 6, 12
13	1, 13
14	1, 2, 7, 14
15	1, 3, 5, 15
The total number of divisors for a given number n (variously written d(n), sigma_0(n), or nu(n)) can be found as follows. Write a number in terms of its prime factorization

 n=p_1^(alpha_1)p_2^(alpha_2)...p_r^(alpha_r). 	
(2)
For any divisor d of n, n=dd^' where

 d=p_1^(delta_1)p_2^(delta_2)...p_r^(delta_r), 	
(3)
so

 d^'=p_1^(alpha_1-delta_1)p_2^(alpha_2-delta_2)...p_r^(alpha_r-delta_r). 	
(4)
Now, delta_1=0,1,...,alpha_1, so there are alpha_1+1 possible values. Similarly, for delta_n, there are alpha_n+1 possible values, so the total number of divisors d(n) of n is given by

 d(n)=product_(n=1)^r(alpha_n+1). 	
(5)
The product of divisors can be found by writing the number n in terms of all possible products

 n={d^((1))d^('(1)); |; d^((nu))d^('(nu)), 	
(6)
so

n^(nu(n))	=	[d^((1))...d^((nu))][d^('(1))d^('(nu))]	
(7)
	=	product_(i=1)^(nu)d_iproduct_(i=1)^(nu)d_i^'	
(8)
	=	(productd)^2,	
(9)
and

 productd=n^(nu(n)/2). 	
(10)
The geometric mean of divisors is

G	=	(productd)^(1/nu(n))	
(11)
	=	[n^(nu(n)/2)]^(1/nu(n))	
(12)
	=	sqrt(n).	
(13)
The arithmetic mean is

 A(n)=(sigma(n))/(nu(n)). 	
(14)
The harmonic mean is

 1/H=1/(nu(n))(sum1/d). 	
(15)
But n=dd^', so 1/d=d^'/n and

sum1/d	=	1/nsumd^'	
(16)
	=	1/nsumd	
(17)
	=	(sigma(n))/n,	
(18)
and we have

 1/(H(n))=1/(nu(n))(sigma(n))/n=(A(n))/n 	
(19)
 n=A(n)H(n). 	
(20)
Given three integers chosen at random, the probability that no common factor will divide them all is

 [zeta(3)]^(-1) approx 1.20206^(-1) approx 0.831907, 	
(21)
where zeta(3) is Apéry's constant.

The smallest numbers having exactly 0, 1, 2, ... divisors (other than 1) are 1, 2, 4, 6, 16, 12, 64, 24, 36, ... (OEIS A005179; Minin 1883-84; Grost 1968; Roberts 1992, p. 86; Dickson 2005, pp. 51-52). Fontené (1902) and Chalde (1903) showed that if p_1^(alpha_1)p_2^(alpha_2)...p_(r-1)^(alpha_(r-1))p_r^(alpha_r) is the prime factorization of the least number with a given number of divisors, then (1) alpha_(r-1) is prime, (2) alpha_r is prime except for the number 2^3·3 which has 8 divisors (Dickson 2005, p. 52).

Let f(n) be the number of elements in the greatest subset of [1,n] such that none of its elements are divisible by two others. For n sufficiently large,

 0.6725...<=(f(n))/n<=0.673... 	
(22)
(Le Lionnais 1983, Lebensold 1976/1977).

SEE ALSO
Divisor Function, Infinitary Divisor, Unitary Divisor
]]]
[[[
[n,b :: pint]:
    [gde_(b;n) =[def]= max{[i :: uint] | [is_divisor_of_(n; d**i)]}]
===from:
https://mathworld.wolfram.com/GreatestCommonDivisor.html
    gde(n,b) is the greatest dividing exponent of b in n (Stehlé and Zimmerman 2004).
===then:
https://mathworld.wolfram.com/GreatestDividingExponent.html
===
Greatest Dividing Exponent
The greatest dividing exponent gde(n,b) of a base b with respect to a number n is the largest integer value of k such that b^k|n, where b^k<=n. It is implemented as the Wolfram Language function IntegerExponent[n, b].

SEE ALSO
Divide, Even Part, Odd Part, p-adic Norm
]]]
[[[
https://mathworld.wolfram.com/UnitaryDivisor.html
===
Unitary Divisor
A divisor d of n for which

 GCD(d,n/d)=1, 	
(1)
where GCD(m,n) is the greatest common divisor. For example, the divisors of 12 are {1,2,3,4,6,12}, so the unitary divisors are {1,3,4,12}. A list of unitary divisors of a number n an be computed in the Wolfram Language using:

  UnitaryDivisors[n_Integer] := Sort[Flatten[Outer[
    Times, Sequence @@ ({1, #}& /@
      Power @@@ FactorInteger[n])
   ]]]
The following table gives the unitary divisors for the first few integers (OEIS A077610).

n	d|_1n
1	1
2	1, 2
3	1, 3
4	1, 4
5	1, 5
6	1, 2, 3, 6
7	1, 7
8	1, 8
9	1, 9
10	1, 2, 5, 10
11	1, 11
12	1, 3, 4, 12
13	1, 13
14	1, 2, 7, 14
15	1, 3, 5, 15
Given the prime factorization

 n=product_(i=1)^kp_i^(a_i), 	
(2)
then

 d=product_(i=1)^kp_i^(c_i) 	
(3)
is a unitary divisor of n if each c_i is 0 or a_i. For a prime power p^y, the unitary divisors are 1 and p^y (Cohen 1990).

The symbol sigma_k^*(n) is used to denote to the unitary divisor function.

The numbers of unitary divisors sigma_0^*(n) of n=1, 2, ... are 1, 2, 2, 2, 2, 4, 2, 2, 2, 4, 2, 4, 2, 4, 4, 2, 2, 4, 2, 4, ... (OEIS A034444). These numbers are also the numbers of squarefree divisors of n. The number of unitary divisors of n is also given by 2^q, where q is the number of different primes dividing n.

SEE ALSO
Biunitary Divisor, Divisor, Greatest Common Divisor, Infinitary Divisor, k-ary divisor, Super Unitary Amicable Pair, Super Unitary Perfect Number, Unitary Aliquot Sequence, Unitary Amicable Pair, Unitary Divisor Function, Unitary Perfect Number
]]]
[[[
[k :: uint][n,d :: pint]:
    [is_k_ary_divisor_of_(k, n; d) =[def]= is_divisor_of_(n;d) if k==0 else [1==max{cd | [is_k_ary_divisor_of_(k-1, n; cd)][is_k_ary_divisor_of_(k-1, d; cd)]}]]
===
https://mathworld.wolfram.com/k-aryDivisor.html
===
k-ary Divisor
Let a divisor d of n be called a 1-ary (or unitary) divisor if d_|_n/d (i.e., d is relatively prime to n/d). Then d is called a k-ary divisor of n, written d|_kn, if the greatest common (k-1)-ary divisor of d and (n/d) is 1 (Cohen 1990).

In this notation, d|n is written d|_0n, and d∥n is written d|_1n.

p^x is an infinitary divisor of p^y (with y>0) if p^x|_(y-1)p^y.

Suryanarayana (1968) unfortunately uses a different and conflicting definition
]]]
[[[
[n,b :: pint]:
    [gde_(b;n) =[def]= max{[i :: uint] | [is_divisor_of_(n; d**i)]}]
[k :: uint][n,d :: pint]:
    [is_k_ary_divisor_of_(k, n; d) =[def]= is_divisor_of_(n;d) if k==0 else [1==max{cd | [is_k_ary_divisor_of_(k-1, n; cd)][is_k_ary_divisor_of_(k-1, d; cd)]}]]
[k :: uint][n,d :: pint]:
    [is_infinitary_divisor_of_(n; d) =[def]= [[p :<- all_prime_factors_of_(d)] -> [[gde_(p;n) >= gde_(p;d) >= 1][is_k_ary_divisor_of_(gde_(p;n)-1, p**gde_(p;n); p**gde_(p;d))]]]]
    [is_infinitary_divisor_of_(n; d) =[def]= [[p :<- all_prime_factors_of_(d)] -> [[gde_(p;n) >= gde_(p;d) >= 1][(gde_(p;n) .&. gde_(p;d)) == gde_(p;d)]]]]
[a,b :: pint]:
    [[(a .&. b) == b] <-> [(a .|. b) == a]]
        # binary repr pint bit-wise and/or

===
https://mathworld.wolfram.com/InfinitaryDivisor.html
===
Infinitary Divisor
p^x is an infinitary divisor of p^y (with y>0) if p^x|_(y-1)p^y, where d|_kn denotes a k-ary Divisor (Guy 1994, p. 54). Infinitary divisors therefore generalize the concept of the k-ary divisor.

Infinitary divisors can also be defined as follows. Compute the prime factorization for each divisor d of n,

 d=product_(i=1)^kp_i^(alpha_i). 
Now make a table of the binary representations (alpha_i)_2 of alpha_i for each prime factor p_i. The infinitary divisors are then those factors d that have zeros in the binary representation of all alpha_is where n itself does. This is illustrated in the following table for the number n=12, which has divisors 1, 2, 3, 4, 6, and 12 and prime factors 2 and 3.

d	p_1	alpha_1	(alpha_1)_2	p_2	alpha_2	(alpha_2)_2
1	2	0	000	3	0	000
2	2	1	001	3	0	000
3	2	0	000	3	1	001
4	2	2	010	3	0	000
6	2	1	001	3	1	001
12	2	2	010	3	1	001
As can be seen from the table, the divisors 1, 3, 4, and 12 have zeros in the binary expansions of alpha_1 (the exponents of 2) in the positions that 12 itself does. Similarly, all divisors have zeros in the leftmost two positions in the binary expansions of alpha_2 (the exponents of 3), as does 12 itself. The intersection of the divisors matching zero in the binary representations in each of the exponents is therefore 1, 3, 4, 12, and these are the infinitary divisors of 12.

The following table lists the infinitary divisors for small integers (OEIS A077609).

n	d|_inftyn
1	1
2	1, 2
3	1, 3
4	1, 4
5	1, 5
6	1, 2, 3, 6
7	1, 7
8	1, 2, 4, 8
9	1, 9
10	1, 2, 5, 10
11	1, 11
12	1, 3, 4, 12
13	1, 13
14	1, 2, 7, 14
15	1, 3, 5, 15
The numbers of infinitary divisors of n for n=1, 2, ... are 1, 2, 2, 2, 2, 4, 2, 4, 2, 4, ... (OEIS A037445).

SEE ALSO
Divisor, Infinitary Perfect Number, k-ary Divisor, Unitary Divisor
]]]
[[[
https://mathworld.wolfram.com/InfinitaryPerfectNumber.html
===
Infinitary Perfect Number
Let sigma_infty(n) be the sum of the infinitary divisors of a number n. An infinitary perfect number is a number n such that sigma_infty(n)=2n. The first few are 6, 60, 90, 36720, ... (OEIS A007357). Cohen (1990) found 14 such numbers, and 155 are known as of January 2004 (Pedersen).

SEE ALSO
Infinitary Divisor, Infinitary Multiperfect Number
]]]
[[[
https://mathworld.wolfram.com/InfinitaryMultiperfectNumber.html
===
Infinitary Multiperfect Number
Let sigma_infty(n) be the sum of the infinitary divisors of a number n. An infinitary k-multiperfect number is a number n such that sigma_infty(n)=kn. Cohen (1990) found 13 infinitary 3-multiperfects, seven 4-multiperfects, and two 5-multiperfects.

SEE ALSO
Infinitary Perfect Number
]]]
[[[
https://oeis.org/A007357
===
(Greetings from The On-Line Encyclopedia of Integer Sequences!)
A007357		Infinitary perfect numbers.
(Formerly M4267)		30
6, 60, 90, 36720, 12646368, 22276800, 126463680, 4201148160, 28770487200, 287704872000, 1446875426304, 2548696550400, 14468754263040, 590325173932032, 3291641594841600, 8854877608980480, 32916415948416000 (list; graph; refs; listen; history; text; internal format)
OFFSET	
1,1
COMMENTS	
Numbers N whose sum of infinitary divisors equals 2*N: A049417(N)=2*N. - Joerg Arndt, Mar 20 2011
6 is the only infinitary perfect number which is also perfect number (A000396). 6 is also the only squarefree infinitary perfect number. - Vladimir Shevelev, Mar 02 2011
REFERENCES	
G. L. Cohen, personal communication.
N. J. A. Sloane and Simon Plouffe, The Encyclopedia of Integer Sequences, Academic Press, 1995 (includes this sequence).
LINKS	
Table of n, a(n) for n=1..17.
G. L. Cohen, On an integer's infinitary divisors, Math. Comp., 54 (1990), 395-411.
A. V. Lelechenko, The Quest for the Generalized Perfect Numbers, in Theoretical and Applied Aspects of Cybernetics, TAAC 2014, Kiev.
David Moews, A database of aliquot cycles - Known infinitary perfect numbers (together with unitary perfect and e-perfect ones).
Jan Munch Pedersen, Known infinitary perfect numbers. [BROKEN LINK]
Eric Weisstein's World of Mathematics, Infinitary Perfect Number.
FORMULA	
{n: A049417(n) = 2*n}. - R. J. Mathar, Mar 18 2011
a(n)==0 (mod 6). Thus there are no odd infinitary perfect numbers. - Vladimir Shevelev, Mar 02 2011
EXAMPLE	
Let n=90. Its unique expansion over distinct terms of A050376 is 90=2*5*9. Thus the infinitary divisors of 90 are 1,2,5,9,10,18,45,90. The number of such divisors is 2^3, i.e., the cardinality of the set of all subsets of the set {2,5,9}. The sum of such divisors is (2+1)*(5+1)*(9+1)=180 and the sum of proper such divisors is 90=n. Thus 90 is in the sequence. - Vladimir Shevelev, Mar 02 2011
MAPLE	
isA007357 := proc(n)
    A049417(n) = 2*n ;
    simplify(%) ;
end proc:
for n from 1 do
    if isA007357(n) then
        printf("%d, \n", n) ;
    end if;
end do: # R. J. Mathar, Oct 05 2017
MATHEMATICA	
infiPerfQ[n_] := 2n == Total[If[n == 1, 1, Sort @ Flatten @ Outer[ Times, Sequence @@ (FactorInteger[n] /. {p_, m_Integer} :> p^Select[Range[0, m], BitOr[m, #] == m&])]]];
For[n = 6, True, n += 6, If[infiPerfQ[n], Print[n]]] (* Jean-François Alcover, Feb 08 2021 *)
CROSSREFS	
Cf. A129656 (infinitary abundant), A129657 (infinitary deficient).
Sequence in context: A323757 A331108 A324707 * A327158 A002827 A331111
Adjacent sequences:  A007354 A007355 A007356 * A007358 A007359 A007360
KEYWORD	
nonn
AUTHOR	
N. J. A. Sloane
EXTENSIONS	
More terms from Eric W. Weisstein, Jan 27 2004
STATUS	
approved
]]]
[[[
https://oeis.org/A064547
===
(Greetings from The On-Line Encyclopedia of Integer Sequences!)
A064547		Sum of binary digits (or count of 1-bits) in the exponents of the prime factorization of n.		69
0, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 2, 1, 1, 2, 1, 2, 2, 2, 1, 3, 1, 2, 2, 2, 1, 3, 1, 2, 2, 2, 2, 2, 1, 2, 2, 3, 1, 3, 1, 2, 2, 2, 1, 2, 1, 2, 2, 2, 1, 3, 2, 3, 2, 2, 1, 3, 1, 2, 2, 2, 2, 3, 1, 2, 2, 3, 1, 3, 1, 2, 2, 2, 2, 3, 1, 2, 1, 2, 1, 3, 2, 2, 2, 3, 1, 3, 2, 2, 2, 2, 2, 3, 1, 2, 2, 2, 1, 3, 1, 3, 3 (list; graph; refs; listen; history; text; internal format)
OFFSET	
1,6
COMMENTS	
This sequence is different from A058061 for n containing 6th, 8th, ..., k-th powers in its prime decomposition, where k runs through the integers missing from A064548.
For n > 1, n is a product of a(n) distinct members of A050376. - Matthew Vandermast, Jul 13 2004
For n > 1: a(n) = length of n-th row in A213925. - Reinhard Zumkeller, Mar 20 2013
Number of Fermi-Dirac factors of n. - Peter Munn, Dec 27 2019
LINKS	
Harry J. Smith (terms 1..2000) & Antti Karttunen, Table of n, a(n) for n = 1..32768
Index entries for sequences related to binary expansion of n
Index entries for sequences computed from exponents in factorization of n
FORMULA	
a(m*n) <= a(m)*a(n). - Reinhard Zumkeller, Mar 20 2013
From Antti Karttunen, Feb 09 2016: (Start)
a(1) = 0, and for n > 1, a(n) = A000120(A067029(n)) + a(A028234(n)).
a(1) = 0, and for n > 1, a(n) = A000120(A007814(n)) + a(A064989(n)).
(End)
a(n) = log_2(A037445(n)). - Vladimir Shevelev, May 13 2016
a(n) = A286574(A156552(n)). - Antti Karttunen, May 28 2017
Additive with a(p^e) = A000120(e). - Jianing Song, Jul 28 2018
a(n) = A000120(A052331(n)). - Peter Munn, Aug 26 2019
From Peter Munn, Dec 18 2019: (Start)
a(A000379(n)) mod 2 = 0.
a(A000028(n)) mod 2 = 1.
A001221(n) <= a(n) <= A001222(n).
A001221(n) < a(n) => a(n) < A001222(n).
a(n) = A001222(n) if and only if n is in A005117.
a(n) = A001221(n) if and only if n is in A138302.
a(n^2) = a(n).
a(A003961(n)) = a(n).
a(A225546(n)) = a(n).
a(n) = a(A007913(n)) + a(A008833(n)).
a(A050376(n)) = 1.
a(A059897(n,k)) + 2 * a(A059895(n,k)) = a(n) + a(k).
a(A059896(n,k)) + a(A059895(n,k)) = a(n) + a(k).
Alternative definition: a(1) = 0; a(n * m) = a(n) + 1 for m = A050376(k) > A223491(n).
(End)
EXAMPLE	
For n = 54, n = 2^1 * 3^3 with exponents (1) and (11) in binary, so a(54) = A000120(1) + A000120(3) = 1 + 2 = 3.
MAPLE	
expts:=proc(n) local t1, t2, t3, t4, i; if n=1 then RETURN([0]); fi; if isprime(n) then RETURN([1]); fi; t1:=ifactor(n); if nops(factorset(n))=1 then RETURN([op(2, t1)]); fi; t2:=nops(t1); t3:=[]; for i from 1 to t2 do t4:=op(i, t1); if nops(t4) = 1 then t3:=[op(t3), 1]; else t3:=[op(t3), op(2, t4)]; fi; od; RETURN(t3); end;
A000120 := proc(n) local w, m, i; w := 0; m := n; while m > 0 do i := m mod 2; w := w+i; m := (m-i)/2; od; w; end:
LamMos:= proc(n) local t1, t2, t3, i; t1:=expts(n); add( A000120(t1[i]), i=1..nops(t1)); end; # N. J. A. Sloane, Dec 20 2007
# alternative Maple program:
A064547:= proc(n) local F;
F:= ifactors(n)[2];
add(convert(convert(f[2], base, 2), `+`), f=F)
end proc:
map(A064547, [$1..100]); # Robert Israel, May 17 2016
MATHEMATICA	
Table[Plus@@(DigitCount[Last/@FactorInteger[k], 2, 1]), {k, 105}]
PROG	
(PARI) SumD(x)= { local(s); s=0; while (x>9, s+=x-10*(x\10); x\=10); return(s + x) }
baseE(x, b)= { local(d, e, f); e=0; f=1; while (x>0, d=x-b*(x\b); x\=b; e+=d*f; f*=10); return(e) }
{ for (n=1, 2000, f=factor(n)~; a=0; for (i=1, length(f), a+=SumD(baseE(f[2, i], 2))); write("b064547.txt", n, " ", a) ) } \\ Harry J. Smith, Sep 18 2009
(PARI) a(n) = {my(f = factor(n)[, 2]); sum(k=1, #f, hammingweight(f[k])); } \\ Michel Marcus, Feb 10 2016
(Haskell)
a064547 1 = 0
a064547 n = length $ a213925_row n  -- Reinhard Zumkeller, Mar 20 2013
(Scheme, two variants, both using memoizing-macro definec)
(definec (A064547 n) (cond ((= 1 n) 0) (else (+ (A000120 (A067029 n)) (A064547 (A028234 n))))))
(definec (A064547 n) (if (= 1 n) 0 (+ (A000120 (A007814 n)) (A064547 (A064989 n)))))
;; Antti Karttunen, Feb 09 2016
(Python)
from sympy import factorint
def wt(n): return bin(n).count("1")
def a(n):
    f=factorint(n)
    return sum([wt(f[i]) for i in f]) # Indranil Ghosh, May 30 2017
CROSSREFS	
Cf. A000028 (positions of odd terms), A000379 (of even terms).
Cf. A050376 (positions of ones), A268388 (terms larger than ones).
Row lengths of A213925.
A000120, A007814, A028234, A037445, A052331, A064989, A067029, A156552, A223491, A286574 are used in formulas defining this sequence.
Cf. A005117, A058061 (to which A064548 relates), A138302.
Cf. other sequences counting factors of n: A001221, A001222.
Cf. other sequences where a(n) depends only on the prime signature of n: A181819, A267116, A268387.
A003961, A007913, A008833, A059895, A059896, A059897, A225546 are used to express relationship between terms of this sequence.
Cf. A176699.
Sequence in context: A065031 A305832 A058061 * A318306 A345935 A214715
Adjacent sequences:  A064544 A064545 A064546 * A064548 A064549 A064550
KEYWORD	
nonn,base
AUTHOR	
Wouter Meeussen, Oct 09 2001
STATUS	
approved
Last modified August 5 23:39 EDT 2023. Contains 364447 sequences. (Running on oeis4.)
]]]
[[[
https://oeis.org/A037445
===
(Greetings from The On-Line Encyclopedia of Integer Sequences!)
A037445		Number of infinitary divisors (or i-divisors) of n.		82
1, 2, 2, 2, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 4, 2, 2, 4, 2, 4, 4, 4, 2, 8, 2, 4, 4, 4, 2, 8, 2, 4, 4, 4, 4, 4, 2, 4, 4, 8, 2, 8, 2, 4, 4, 4, 2, 4, 2, 4, 4, 4, 2, 8, 4, 8, 4, 4, 2, 8, 2, 4, 4, 4, 4, 8, 2, 4, 4, 8, 2, 8, 2, 4, 4, 4, 4, 8, 2, 4, 2, 4, 2, 8, 4, 4, 4, 8, 2, 8, 4, 4, 4, 4, 4, 8, 2, 4, 4, 4, 2, 8, 2, 8, 8 (list; graph; refs; listen; history; text; internal format)
OFFSET	
1,2
COMMENTS	
A divisor of n is called infinitary if it is a product of divisors of the form p^{y_a 2^a}, where p^y is a prime power dividing n and sum_a y_a 2^a is the binary representation of y.
The smallest number m with exactly 2^n infinitary divisors is A037992(n); for these values m, a(m) increases also to a new record. - Bernard Schott, Mar 09 2023
LINKS	
Reinhard Zumkeller, Table of n, a(n) for n = 1..10000
Steven R. Finch, Unitarism and Infinitarism, February 25, 2004. [Cached copy, with permission of the author]
J. O. M. Pedersen, Tables of Aliquot Cycles [Broken link]
J. O. M. Pedersen, Tables of Aliquot Cycles [Via Internet Archive Wayback-Machine]
J. O. M. Pedersen, Tables of Aliquot Cycles [Cached copy, pdf file only]
Eric Weisstein's World of Mathematics, Infinitary Divisor
Index entries for sequences computed from exponents in factorization of n
FORMULA	
Multiplicative with a(p^e) = 2^A000120(e). - David W. Wilson, Sep 01 2001
Let n = q_1*...*q_k, where q_1,...,q_k are different terms of A050376. Then a(n) = 2^k (the number of subsets of a set with k elements is 2^k). - Vladimir Shevelev, Feb 19 2011.
a(n) = Product_{k=1..A001221(n)} A000079(A000120(A124010(n,k))). - Reinhard Zumkeller, Mar 19 2013
From Antti Karttunen, May 28 2017: (Start)
a(n) = A286575(A156552(n)). [Because multiplicative with a(p^e) = A001316(e).]
a(n) = 2^A064547(n). (End)
a(A037992(n)) = 2^n. - Bernard Schott, Mar 10 2023
EXAMPLE	
For n = 8, n = 2^3 = 2^"11" (writing 3 in binary) so the infinitary divisors are 2^"00" = 1, 2^"01" = 2, 2^"10" = 4 and 2^"11" = 8, so a(8) = 4.
For n = 90, n = 2*5*9 where 2,5,9 are in A050376, so a(90) = 2^3 = 8.
MAPLE	
A037445 := proc(n)
    local a, p;
    a := 1 ;
    for p in ifactors(n)[2] do
        a := a*2^wt(p[2]) ;
    end do:
    a ;
end proc: # R. J. Mathar, May 16 2016
MATHEMATICA	
Table[Length@((Times @@ (First[it]^(#1 /. z -> List)) & ) /@
Flatten[Outer[z, Sequence @@ bitty /@
Last[it = Transpose[FactorInteger[k]]], 1]]), {k, 2, 240}]
bitty[k_] := Union[Flatten[Outer[Plus, Sequence @@ ({0, #1} & ) /@ Union[2^Range[0, Floor[Log[2, k]]]*Reverse[IntegerDigits[k, 2]]]]]]
y[n_] := Select[Range[0, n], BitOr[n, # ] == n & ] divisors[Infinity][1] := {1}
divisors[Infinity][n_] := Sort[Flatten[Outer[Times, Sequence @@ (FactorInteger[n] /. {p_, m_Integer} :> p^y[m])]]] Length /@ divisors[Infinity] /@ Range[105] (* Paul Abbott (paul(AT)physics.uwa.edu.au), Apr 29 2005 *)
a[1] = 1; a[n_] := Times @@ Flatten[ 2^DigitCount[#, 2, 1]&  /@ FactorInteger[n][[All, 2]] ]; Table[a[n], {n, 1, 105}] (* Jean-François Alcover, Aug 19 2013, after Reinhard Zumkeller *)
PROG	
(PARI) A037445(n) = factorback(apply(a -> 2^hammingweight(a), factorint(n)[, 2])) \\ Andrew Lelechenko, May 10 2014
(Haskell)
a037445 = product . map (a000079 . a000120) . a124010_row
-- Reinhard Zumkeller, Mar 19 2013
(Scheme) (define (A037445 n) (if (= 1 n) n (* (A001316 (A067029 n)) (A037445 (A028234 n))))) ;; Antti Karttunen, May 28 2017
(Python)
from sympy import factorint
def wt(n): return bin(n).count("1")
def a(n):
    f=factorint(n)
    return 2**sum([wt(f[i]) for i in f]) # Indranil Ghosh, May 30 2017
CROSSREFS	
Cf. A000120, A001316, A004607, A007358, A007357, A037992, A038148, A049417, A064547, A074848, A077609, A124010, A156552, A286575.
Sequence in context: A154851 A281854 A335385 * A318307 A331109 A286324
Adjacent sequences:  A037442 A037443 A037444 * A037446 A037447 A037448
KEYWORD	
nonn,nice,easy,mult
AUTHOR	
Yasutoshi Kohmoto
EXTENSIONS	
Corrected and extended by Naohiro Nomoto, Jun 21 2001
STATUS	
approved
Last modified August 5 23:44 EDT 2023. Contains 364447 sequences. (Running on oeis4.)
]]]
[[[
https://oeis.org/A077609
===
(Greetings from The On-Line Encyclopedia of Integer Sequences!)
A077609		Triangle in which n-th row lists infinitary divisors of n.		44
1, 1, 2, 1, 3, 1, 4, 1, 5, 1, 2, 3, 6, 1, 7, 1, 2, 4, 8, 1, 9, 1, 2, 5, 10, 1, 11, 1, 3, 4, 12, 1, 13, 1, 2, 7, 14, 1, 3, 5, 15, 1, 16, 1, 17, 1, 2, 9, 18, 1, 19, 1, 4, 5, 20, 1, 3, 7, 21, 1, 2, 11, 22, 1, 23, 1, 2, 3, 4, 6, 8, 12, 24, 1, 25, 1, 2, 13, 26, 1, 3, 9, 27, 1, 4, 7, 28, 1, 29, 1 (list; graph; refs; listen; history; text; internal format)
OFFSET	
1,3
COMMENTS	
The first difference from the triangle A222266 (bi-unitary divisors of n) is in row n = 16; indeed, the 16th row of A222266 is (1, 2, 8, 16) while the 16th of this sequence here is (1, 16). - Bernard Schott, Mar 10 2023
LINKS	
Reinhard Zumkeller, Rows n = 1..1000 of table, flattened
Graeme L. Cohen and Peter Hagis, Jr., Arithmetic functions associated with the infinitary divisors of an integer, Internat. J. Math. Math. Sci. 16 (2) (1993) 373-384.
Eric Weisstein's World of Mathematics, Infinitary Divisor.
EXAMPLE	
The first few rows are:
  1;
  1, 2;
  1, 3;
  1, 4;
  1, 5;
  1, 2, 3, 6;
  1, 7;
  1, 2, 4, 8;
  1, 9;
  1, 2, 5, 10;
  1, 11;
  1, 3, 4, 12;
  1, 13;
  1, 2, 7, 14;
  1, 3, 5, 15;
  1, 16;
  1, 17;
MAPLE	
# see the function idivisors() in A049417. # R. J. Mathar, Oct 05 2017
MATHEMATICA	
f[x_] := If[x == 1, 1, Sort@ Flatten@ Outer[Times, Sequence @@ (FactorInteger[x] /. {p_, m_Integer} :> p^Select[Range[0, m], BitOr[m, #] == m &])]] ; Array[f, 30] // Flatten (* Paul Abbott (paul(AT)physics.uwa.edu.au), Apr 29 2005 *) (* edited by Michael De Vlieger, Jun 07 2016 *)
PROG	
(Haskell)
import Data.List ((\\))
a077609 n k = a077609_row n !! (k-1)
a077609_row n = filter
   (\d -> d == 1 || null (a213925_row d \\ a213925_row n)) $ a027750_row n
a077609_tabf = map a077609_row [1..]
-- Reinhard Zumkeller, Jul 10 2013
(PARI) isidiv(d, f) = {if (d==1, return (1)); for (k=1, #f~, bne = binary(f[k, 2]); bde = binary(valuation(d, f[k, 1])); if (#bde < #bne, bde = concat(vector(#bne-#bde), bde)); for (j=1, #bne, if (! bne[j] && bde[j], return (0)); ); ); return (1); }
row(n) = {d = divisors(n); f = factor(n); idiv = []; for (k=1, #d, if (isidiv(d[k], f), idiv = concat(idiv, d[k])); ); idiv; } \\ Michel Marcus, Feb 15 2016
CROSSREFS	
Cf. A027750, A037445 (row lengths), A049417 (row sums).
Cf. A222266.
Sequence in context: A180184 A330752 A222266 * A077610 A329534 A317746
Adjacent sequences:  A077606 A077607 A077608 * A077610 A077611 A077612
KEYWORD	
nonn,tabf
AUTHOR	
Eric W. Weisstein, Nov 11 2002
STATUS	
approved
Last modified August 5 23:39 EDT 2023. Contains 364447 sequences. (Running on oeis4.)
]]]





[[[
===
]]]
[[[
===
]]]
[[[
===
]]]





[[
]]

[[
]]



















[[[
===
]]]
[[[
https://mathworld.wolfram.com/GreatestCommonDivisor.html
===
Greatest Common Divisor
The greatest common divisor, sometimes also called the highest common divisor (Hardy and Wright 1979, p. 20), of two positive integers a and b is the largest divisor common to a and b. For example, GCD(3,5)=1, GCD(12,60)=12, and GCD(12,90)=6. The greatest common divisor GCD(a,b,c,...) can also be defined for three or more positive integers as the largest divisor shared by all of them. Two or more positive integers that have greatest common divisor 1 are said to be relatively prime to one another, often simply just referred to as being "relatively prime."

Various notational conventions are summarized in the following table.

notation	source
GCD(a,b)	this work, Zwillinger (1996, p. 91), Råde and Westergren (2004, p. 54)
gcd(a,b)	Gellert et al. (1989, p. 25), D'Angelo and West (1990, p. 13), Graham et al. (1990, p. 103), Bressoud and Wagon (2000, p. 7), Yan (2002, p. 30), Bronshtein et al. (2007, pp. 323-324), Wolfram Language
g.c.d.(a,b)	Andrews 1994, p. 22
(a,b)	
The greatest common divisor of a, b, ... is implemented in the Wolfram Language as GCD[a, b, ...].

GreatestCommonDivisor
The plot above shows GCD(1,b) with rational b=m/n. Here, GCD(r_1,r_2,...) is the greatest rational number r for which all the r_i/r are integers. It is easy to see that if r_i=p_i/q_i, where GCD(p_i,q_i)=1, then GCD(r_1,r_2,...)=GCD(p_1,p_2,...)/LCM(q_1,q_2,...). Furthermore, if GCD(1,b) is extended by setting it equal to 0 if b is irrational, the resulting function is continuous at the irrationals, discontinuous at the rationals, and has Riemann integral equal to 0 over any finite interval.

GCDArray
The above plots show a number of visualizations of GCD(i,j) in the (i,j)-plane. The figure on the left is simply GCD(i,j), the figure in the middle is the absolute values of the two-dimensional discrete Fourier transform of GCD(i,j) (Trott 2004, pp. 25-26), and the figure at right is the absolute value of the transform of 1/GCD(i,j).

If d is the greatest common divisor of a and b, then d is the largest possible integer satisfying

a	=	dx	
(1)
b	=	dy,	
(2)
with x and y positive integers.

The Euclidean algorithm can be used to find the greatest common divisor of two integers and to find integers x and y such that

 ax+by=d. 	
(3)
The notion can also be generalized to more general rings than simply the integers Z. However, even for Euclidean rings, the notion of GCD of two elements of a ring is not the same as the GCD of two ideals of a ring. This is sometimes a source of confusion when studying rings other than Z, such as polynomial rings in several variables.

To compute the GCD, write the prime factorizations of a and b,

a	=	product_(i)p_i^(alpha_i)	
(4)
b	=	product_(i)p_i^(beta_i),	
(5)
where the p_is are all prime factors of a and b, and if p_i does not occur in one factorization, then the corresponding exponent is taken as 0. Then the greatest common divisor GCD(a,b) is given by

 GCD(a,b)=product_(i)p_i^(min(alpha_i,beta_i)), 	
(6)
where min denotes the minimum. For example, consider GCD(12,30).

12	=	2^2·3^1·5^0	
(7)
30	=	2^1·3^1·5^1,	
(8)
so

 GCD(12,30)=2^1·3^1·5^0=6. 	
(9)
The GCD is distributive

 GCD(ma,mb)=mGCD(a,b) 	
(10)
 GCD(ma,mb,mc)=mGCD(a,b,c), 	
(11)
and associative

GCD(a,b,c)	=	GCD(GCD(a,b),c)	
(12)
	=	GCD(a,GCD(b,c))	
(13)
GCD(ab,cd)	=	GCD(a,c)GCD(b,d)×GCD(a/(GCD(a,c)),d/(GCD(b,d)))×GCD(c/(GCD(a,c)),b/(GCD(b,d))).	
(14)
If a=a_1GCD(a,b) and b=b_1GCD(a,b), then

GCD(a,b)	=	GCD(a_1GCD(a,b),b_1GCD(a,b))	
(15)
	=	GCD(a,b)GCD(a_1,b_1),	
(16)
so GCD(a_1,b_1)=1. The GCD is also idempotent

 GCD(a,a)=a, 	
(17)
commutative

 GCD(a,b)=GCD(b,a), 	
(18)
and satisfies the absorption law

 LCM(a,GCD(a,b))=a. 	
(19)
GCDRecurrence
A recurrence equation that converges to GCD(a,b) for positive odd a and b is given by

 x_n=(x_(n-1)+x_(n-2))/(2^(gde(x_(n-1)+x_(n-2),2))) 	
(20)
with x_1=a and x_2=b, where gde(n,b) is the greatest dividing exponent of b in n (Stehlé and Zimmerman 2004). The plot above shows the number of iterations required to converge for odd 1<=a,b<=199.

The probability that two integers picked at random are relatively prime is [zeta(2)]^(-1)=6/pi^2, where zeta(z) is the Riemann zeta function. Polezzi (1997) observed that GCD(m,n)=k, where k is the number of lattice points in the plane on the straight line connecting the vectors (0, 0) and (m,n) (excluding (m,n) itself). This observation is intimately connected with the probability of obtaining relatively prime integers, and also with the geometric interpretation of a reduced fraction y/x as a string through a lattice of points with ends at (1,0) and (x,y). The pegs it presses against (x_i,y_i) give alternate convergents y_i/x_i of the continued fraction for y/x, while the other convergents are obtained from the pegs it presses against with the initial end at (0, 1).

Knuth showed that

 GCD(2^p-1,2^q-1)=2^(GCD(p,q))-1. 	
(21)
SEE ALSO
Bézout Numbers, Bézout's Theorem, Dirichlet Function, Euclid's Orchard, Euclidean Algorithm, Extended Greatest Common Divisor, Gauss's Lemma, Greatest Common Divisor Theorem, Half-GCD, Least Common Multiple, Least Prime Factor, Orchard-Planting Problem, Relatively Prime, Star of David Theorem
]]]
[[[
https://mathworld.wolfram.com/ExtendedGreatestCommonDivisor.html
===
Extended Greatest Common Divisor
The extended greatest common divisor of two integers m and n can be defined as the greatest common divisor GCD(m,n) of m and n which also satisfies the constraint GCD(m,n)=rm+sn for r and s given integers. It is used in solving linear Diophantine equations, and is implemented in the Wolfram Language as ExtendedGCD[m, n].

SEE ALSO
Greatest Common Divisor
]]]
[[[
https://mathworld.wolfram.com/Half-GCD.html
===
Half-GCD
Given integers a and b with close to 2n bits each, the half-GCD of a and b is a 2×2 matrix

 [u v; u^' v^'] 
with determinant equal to -1 or 1 such that ua+vb=r and u^'a+v^'b=r^', where r and r^' each have a number of bits close to n.

The half-GCD results by performing roughly half the Euclidean algorithm for computing the greatest common divisor GCD(a,b). There is an efficient algorithm for computing the half-GCD of two large numbers which, when applied recursively, allows the greatest common divisor to be computed faster than using the Euclidean algorithm.

SEE ALSO
Euclidean Algorithm, Greatest Common Divisor
]]]
[[[
https://lemire.me/blog/2013/12/26/fastest-way-to-compute-the-greatest-common-divisor/
===
Fastest way to compute the greatest common divisor
Given two positive integers x and y, the greatest common divisor (GCD) z is the largest number that divides both x and y. For example, given 64 and 32, the greatest common divisor is 32.

There is a fast technique to compute the GCD called the binary GCD algorithm or Stein’s algorithm. According to Wikipedia, it is 60% faster than more common ways to compute the GCD.

I have honestly never written a program where computing the GCD was the bottleneck. However, Pigeon wrote a blog post where the binary GCD fared very poorly compared to a simple implementation of Euler’s algorithm with remainders:

unsigned gcd_recursive(unsigned a, unsigned b)
{
    if (b)
        return gcd_recursive(b, a % b);
    else
        return a;
}
Though Pigeon is a great hacker, I wanted to verify for myself. It seems important to know whether an algorithm that has its own wikipedia page is worth it. Unfortunately, the code on Wikipedia’s page implementing the binary GCD algorithm is either inefficient or slightly wrong. Here is a version using a GCC intrinsic function (__builtin_ctz) to find the number of trailing zeros:

unsigned int gcd(unsigned int u, unsigned int v) {
  int shift;
  if (u == 0)
    return v;
  if (v == 0)
    return u;
  shift = __builtin_ctz(u | v);
  u >>= __builtin_ctz(u);
  do {
    unsigned m;
    v >>= __builtin_ctz(v);
    v -= u;
    m = (int)v >> 31;
    u += v & m;
    v = (v + m) ^ m;
  } while (v != 0);
  return u << shift;
}
My result? Using integers in [0,2000), the simple version Pigeon proposed does 25 millions GCDs per second, whereas my binary GCD does 39 millions GCDs per second, a difference of 55% on an Intel core i7 desktop. Why do my results disagree with Pigeon? His version of the binary GCD did not make use of the intrinsic __builtin_ctz and used an equivalent loop instead. When I implemented something similarly inefficient, I also got a slower result (17 millions GCDs per second) which corroborates Pigeon’s finding.

My benchmarking code is available.

On a 64-bit machine, you probably can adapt this technique using the __builtin_ctzll intrinsic.

Update: You can read more about sophisticated GCD algorithms in the gmplib manual.

Conclusion: The Binary GCD is indeed a faster way to compute the GCD for 32-bit integers, but only if you use the right instructions (e.g., __builtin_ctz). And someone ought to update the corresponding Wikipedia page.

PUBLISHED BY

Daniel Lemire
A computer science professor at the University of Quebec (TELUQ). View all posts by Daniel Lemire 

34 thoughts on “Fastest way to compute the greatest common divisor”
Steven Pigeonsays:
December 26, 2013 at 6:53 pm
What I don’t get is that you have a speedup only on numbers of the form m—2^k and n—2^j, and the speed-up is proportional to min(j,k). How do you explain doubling the speed if asymptotically few pairs of numbers are of that form?

REPLY
lecteur habituelsays:
December 26, 2013 at 5:45 pm
euclyd, not euler.

Thanks for the post!

REPLY
Maths Branesays:
December 12, 2018 at 9:18 pm
Yea, I heart Euler, but this is Euclid, all day.

REPLY
Leonid Boytsovsays:
December 26, 2013 at 6:21 pm
Another excellent example of shaving off constants!

REPLY
Steven Pigeonsays:
December 27, 2013 at 9:27 am
They’re not quadratic, they’re O(lg min(a,b)).

see:

http://en.wikipedia.org/wiki/Euclidean_algorithm#Algorithmic_efficiency

REPLY
Per Perssonsays:
December 27, 2013 at 12:39 pm
“And someone ought to update the corresponding Wikipedia page.”

Why don’t you do it yourself?

REPLY
Per Perssonsays:
December 27, 2013 at 1:32 pm
By the way, the numbers you used for testing are relatively small. More complicated algorithms are often slower for small numbers and don’t show their efficiency until the numbers are bigger. Without using anything bigger than uint32 you could test numbers of size ~1’000’000’000.

REPLY
Mikesays:
December 27, 2013 at 9:07 am
If you care about asymptotics, then both of these are quadratic. For a subquadratic algorithm, you need something like a half-gcd based algorithm.

REPLY
Daniel Lemiresays:
December 27, 2013 at 9:51 am
@Pigeon

It is not necessary for the numbers to be divisible by two for them to benefit from the binary GCD.

Take 3 and 5. After the first pass in the loop you get 3 and 2. The 2 gets back to 1 due to the ctz shift.

The nice thing with the binary GCD is that it does not use any expensive operation (ctz is quite cheap on recent Intel processors) whereas the basic GCD relies on integer division.

REPLY
Mikesays:
December 27, 2013 at 10:04 am
They are quadratic when considering operations with integers that are larger than an unsigned int/long.

For example, see: https://gmplib.org/manual/Greatest-Common-Divisor-Algorithms.html and https://gmplib.org/manual/Binary-GCD.html

REPLY
Ralph Corderoysays:
December 27, 2013 at 10:53 am
Hi Daniel, I can trim another 12% off your gcd() above by removing the two redundant shifts by “shift” of “u” and “v” that occur before the loop.

REPLY
Daniel Lemiresays:
December 27, 2013 at 11:10 am
@Ralph

Well done. I have updated my blog post and credited you for the gains.

REPLY
KWilletssays:
December 27, 2013 at 12:46 pm
I wonder if you could save a cmpl by reusing the u > v comparison for the loop break as well. That is:

if( u == v)
break;
else if (u > v)
…

This will shorten the last iteration and probably speed up the speculative execution.

REPLY
Reply to KWilletsCancel reply
Your email address will not be published.

COMMENT *

NAME *

EMAIL *

WEBSITE

 Save my name, email, and website in this browser for the next time I comment.

 RECEIVE EMAIL NOTIFICATIONS?

no, do not subscribe

instantly
Or, you can subscribe without commenting.
Daniel Lemiresays:
December 27, 2013 at 1:29 pm
@KWillets

With clang, your version is faster. With GCC, the version in the blog post is faster. The difference is within 10%.

If I played with compiler flags, there might be other differences as well.

In any case, your version is on github if you want to benchmark it.

REPLY
Daniel Lemiresays:
December 27, 2013 at 1:46 pm
@Persson

I have added a test in my code with large numbers but it makes no difference. Of course, these are word-size integers… results would differ with big integers.

REPLY
Ralph Corderoysays:
December 28, 2013 at 5:57 am
Hi again Daniel, I can save a further 7.5% on my earlier suggestion by altering the loop to

do {
unsigned m;
v >>= __builtin_ctz(v);
m = (v ^ u) & -(v < u);
u ^= m;
v ^= m;
v -= u;
} while (v);

REPLY
Steven Pigeonsays:
December 28, 2013 at 12:37 pm
I have re-run tests with a version using the built-ins. The speed-ups are there indeed: 40% on larger numbers.

http://hbfs.wordpress.com/2013/12/10/the-speed-of-gcd/

(and @Mike I think the state of the art for fast division is O(n^log_2(3)), which is still more than linear, but subquadratic.)

REPLY
KWilletssays:
December 28, 2013 at 11:38 am
For my tweak the assembler output from gcc has the comparison, then a branch to the top of the loop, then the same comparison :(. The second comparison isn’t reachable by any other path either.

Maybe some syntactic shuffling would trigger the optimization; I may give it a few tries later.

REPLY
KWilletssays:
December 28, 2013 at 8:22 pm
This is faster on my version of gcc:

{
int shift, uz, vz;
uz = __builtin_ctz(u);
if ( u == 0) return v;

vz = __builtin_ctz(v);
if ( v == 0) return u;

shift = uz > vz ? vz : uz;

u >>= uz;

do {
v >>= vz;

if (u > v) {

unsigned int t = v;
v = u;
u = t;
}

v = v – u;
vz = __builtin_ctz(v);
} while( v != 0 );

return u << shift;
}

Results:

gcd between numbers in [1 and 2000]
26.4901 17.6991 32.7869 25.974 24.3902 31.746 36.6972

I was actually trying to get it to utilize the fact that ctz sets the == 0 flag when its argument is 0, so a following test against 0 should not need an extra instruction. However the compiler didn't notice. Instead it set up some interesting instruction interleaving so that the v != 0 test is actually u == v before the subtraction; I believe this is to enable ILP.

Also, using an inline xchg instruction for the swap doubles the speed:

gcd between numbers in [1 and 2000]
26.1438 16.3934 33.6134 25.974 25.4777 30.5344 72.7273
gcd between numbers in [1000000001 and 1000002000]
26.1438 16 33.8983 25.974 25.3165 29.6296 72.7273

REPLY
Daniel Lemiresays:
December 29, 2013 at 1:09 pm
@KWillets

Thanks. I have added your code to the benchmark.

Do you have the code for the version with the xchg instruction?

REPLY
Daniel Lemiresays:
December 29, 2013 at 1:09 pm
@Ralph

I added your version to the benchmark.

REPLY
KWilletssays:
December 29, 2013 at 1:23 pm
Here’s the asm for the swap; I just replaced the part inside the brackets with xswap(u,v):

#define xswap(a,b) __asm__ (\
“xchg %0, %1\n”\
: : “r”(a), “r” (b));

Unfortunately I don’t understand if this is correctly defined (I copied it from some poorly-documented examples), but the assembler output looks good.

REPLY
Daniel Lemiresays:
December 29, 2013 at 2:46 pm
@KWillets

I have checked into github a version with your inline assembly (slightly tweaked to be more standard). It is not faster.

When I ran your code “as is” I got failed tests.

https://github.com/lemire/Code-used-on-Daniel-Lemire-s-blog/blob/master/2013/12/26/gcd.cpp

REPLY
KWilletssays:
December 30, 2013 at 12:54 pm
Looking at Steven’s asm listings, I realized that my compiler was significantly behind, so I downloaded 3G of Apple “updates” last night. These results are now from clang-500.2.79.

I started playing around with various ways of getting abs(v-u) (especially when unsigned) and also realized that bsfl(x) == bsfl(-x), so this works for the inner loop on gcdwikipedia5fast:

do {
v >>= vz;
unsigned int diff =v;
diff -= u;
vz = __builtin_ctz(diff);
if( diff == 0 ) break;
if ( v < u ) {
u = v;
v = 0 – diff;
} else
v = diff;

} while( 1 );

If diff is signed 32-bit it's slightly faster, abs(diff) can be used, and the v < u test can be switched to diff < 0 for a slight gain. But it becomes a 31-bit algorithm. I haven't tried signed 64-bit yet.

Using bsfl(diff) instead of v seems to speed it up significantly; it's probably ILP again since it doesn't have to wait for v to finalize.

REPLY
KWilletssays:
December 30, 2013 at 1:02 pm
Hold on, I just tried signed 64-bit and got a huge boost:

do {
v >>= vz;
long long int diff = v ;
diff -= u;
vz = __builtin_ctz(diff);
if( diff == 0 ) break;
if ( diff < 0 )
u = v;
v = abs(diff);

} while( 1 );

REPLY
Daniel Lemiresays:
December 30, 2013 at 1:26 pm
@KWillets

I added these two alternatives to the benchmark.

I find that results vary a lot depending on the compiler and processor. It is hard to identify a clear winner… except that they are all faster than the Euclidean algorithm with remainder.

REPLY
KWilletssays:
December 30, 2013 at 2:37 pm
I checked the new revision and the 64-bit version (7) should use abs() and a few other edits.

Should I be submitting edits to github?

REPLY
Taeseung Leesays:
December 30, 2016 at 3:19 pm
Thanks for the post!

REPLY
detailyangsays:
April 29, 2019 at 1:54 pm
It’s cool and it’ faster 3x than mod in my golang implement

REPLY
George Spelvinsays:
December 15, 2020 at 2:15 pm
It’s possible to slightly improve Ralph Corderoy’s branch-free code above (Dec. 28 comment) by using a difference delta rather than an xor delta.

If you don’t mind limiting the input range to INT_MAX, the sign of (int)(v-u) can be used to control the swap:

v -= u;
mask = (int)v >> 31;
u += v & mask; /* u + (v - u) = v */
v = (v + mask) ^ mask; /* Conditional negate ~(v - 1) = -v */

If you want to accept inputs up to UINT_MAX, it’s still possible to combine the subtract and mask formation with a bit of asm magic (x86 AT&T syntax) to get access to the carry flag:

asm("sub %2,%1; sbb %0,%0" : "=r" (mask), "+r" (v) : "g" (u));

Depending on the CPU, it may be worth spending an instruction to clear the mask to avoid a false dependency on its previous value. Add
, “0” (0)
to the end of the list of input parameters. (For those not familiar with GCC asm syntax, the 0 in quotes means that this input operand should be in the same register as output operand 0, the mask. The 0 in parens is the operand value. GCC will generate an xorl instruction to zero the mask.)

REPLY
Daniel Lemiresays:
December 15, 2020 at 3:06 pm
Your proposal was added to the benchmark. Here are the numbers on my laptop:

❯ ./gcd
gcd between numbers in [1 and 2000]
Running tests... Ok!
We proceed to report timings (smaller values are better).
basicgcd                    54.0541
gcdwikipedia2               23.5294
gcdwikipedia2fast           66.6667
gcd_recursive               54.0541
gcd_iterative_mod           53.3333
gcdFranke                   68.9655
gcdwikipedia3fast           66.6667
gcdwikipedia4fast           54.0541
gcdwikipedia5fast           66.6667
gcdwikipedia2fastswap       64.5161
gcdwikipedia7fast           86.9565
gcdwikipedia7fast32         85.1064
gcdwikipedia8Spelvin        58.8235

gcd between numbers in [1000000001 and 1000002000]
Running tests... Ok!
We proceed to report timings (smaller values are better).
basicgcd                    54.0541
gcdwikipedia2               23.6686
gcdwikipedia2fast           66.6667
gcd_recursive               53.3333
gcd_iterative_mod           54.0541
gcdFranke                   68.9655
gcdwikipedia3fast           65.5738
gcdwikipedia4fast           54.7945
gcdwikipedia5fast           66.6667
gcdwikipedia2fastswap       64.5161
gcdwikipedia7fast           86.9565
gcdwikipedia7fast32         83.3333
gcdwikipedia8Spelvin        58.8235
REPLY
Clinton Ingramsays:
March 12, 2022 at 10:13 pm
I’ve just noticed your benchmarks don’t change the number range between runs — the offset is used only in the tests. With the benchmarks corrected, the mod approach shows faster on the larger value range.

Also noting the label on the results is misleading. The benchmark appears to be calculating ops per ms, not the timings directly, so larger is better.

Results on my TGL-H laptop after corrections:


gcd between numbers in [1 and 2000]
Running tests... Ok!
Kops/ms (larger values are better).
basicgcd 50
gcdwikipedia2 20.3046
gcdwikipedia2fast 44.4444
gcd_recursive 50
gcd_iterative_mod 48.1928
gcdFranke 46.5116
gcdwikipedia3fast 45.4545
gcdwikipedia4fast 61.5385
gcdwikipedia5fast 44.9438
gcdwikipedia2fastswap 43.0108
gcdwikipedia7fast 48.1928
gcdwikipedia7fast32 76.9231
gcdwikipedia8Spelvin 64.5161

gcd between numbers in [1000000001 and 1000002000]
Running tests... Ok!
Kops/ms (larger values are better).
basicgcd 37.7358
gcdwikipedia2 7.15564
gcdwikipedia2fast 16.4609
gcd_recursive 37.037
gcd_iterative_mod 37.7358
gcdFranke 16.5289
gcdwikipedia3fast 16.3934
gcdwikipedia4fast 22.3464
gcdwikipedia5fast 16.4609
gcdwikipedia2fastswap 16.3265
gcdwikipedia7fast 18.3486
gcdwikipedia7fast32 31.746
gcdwikipedia8Spelvin 23.3918

I’ve submitted a PR with the fixes

REPLY
Daniel Lemiresays:
March 25, 2022 at 1:32 am
Thanks. Here are my results after merging your fix.

❯ ./gcd
gcd between numbers in [1 and 2000]
Running tests... Ok! 
We proceed to report kops/ms (larger values are better).
basicgcd                    40.404
gcdwikipedia2               20.1005
gcdwikipedia2fast           54.7945
gcd_recursive               42.5532
gcd_iterative_mod           42.5532
gcdFranke                   38.0952
gcdwikipedia3fast           53.3333
gcdwikipedia4fast           42.1053
gcdwikipedia5fast           53.3333
gcdwikipedia2fastswap       55.5556
gcdwikipedia7fast           67.7966
gcdwikipedia7fast32         51.2821
gcdwikipedia8Spelvin        46.5116
gcd_mod_faster              43.956

gcd between numbers in [1000000001 and 1000002000]
Running tests... Ok! 
We proceed to report kops/ms (larger values are better).
basicgcd                    30.5344
gcdwikipedia2               7.28597
gcdwikipedia2fast           19.802
gcd_recursive               30.0752
gcd_iterative_mod           30.303
gcdFranke                   14.0351
gcdwikipedia3fast           18.4332
gcdwikipedia4fast           14.2857
gcdwikipedia5fast           18.5185
gcdwikipedia2fastswap       18.7793
gcdwikipedia7fast           23.9521
gcdwikipedia7fast32         18.5185
gcdwikipedia8Spelvin        46.5116
gcd_mod_faster              32.5203
REPLY
Hakuna Matatasays:
October 23, 2022 at 12:26 pm
Tested on random unsigned ints from full 32-bit range. `gcdwikipedia4fast()` is the fastest. Not every algorithm survived the test, btw.

REPLY
You may subscribe to this blog by email.

Post navigation
PREVIOUS
Previous post:
On human intelligence… a perspective from computer science
NEXT
Next post:
When delegating… consider quality, maintenance and learning
Terms of use Proudly powered by WordPress
#pad:]
]]]
[[[
https://gmplib.org/manual/Greatest-Common-Divisor-Algorithms
===
15.3 Greatest Common Divisor
    Binary GCD
    Lehmer’s algorithm
    Subquadratic GCD
    Extended GCD
    Jacobi Symbol
===
https://gmplib.org/manual/Binary-GCD
===
Next: Lehmer’s algorithm, Previous: Greatest Common Divisor, Up: Greatest Common Divisor   [Index]

15.3.1 Binary GCD
At small sizes GMP uses an O(N^2) binary style GCD. This is described in many textbooks, for example Knuth section 4.5.2 algorithm B. It simply consists of successively reducing odd operands a and b using

    a,b = abs(a-b),min(a,b)
    strip factors of 2 from a

The Euclidean GCD algorithm, as per Knuth algorithms E and A, repeatedly computes the quotient q = floor(a/b) and replaces a,b by v, u - q v. The binary algorithm has so far been found to be faster than the Euclidean algorithm everywhere. One reason the binary method does well is that the implied quotient at each step is usually small, so often only one or two subtractions are needed to get the same effect as a division. Quotients 1, 2 and 3 for example occur 67.7% of the time, see Knuth section 4.5.3 Theorem E.

When the implied quotient is large, meaning b is much smaller than a, then a division is worthwhile. This is the basis for the initial a mod b reductions in mpn_gcd and mpn_gcd_1 (the latter for both Nx1 and 1x1 cases). But after that initial reduction, big quotients occur too rarely to make it worth checking for them.


The final 1x1 GCD in mpn_gcd_1 is done in the generic C code as described above. For two N-bit operands, the algorithm takes about 0.68 iterations per bit. For optimum performance some attention needs to be paid to the way the factors of 2 are stripped from a.

Firstly it may be noted that in two’s complement the number of low zero bits on a-b is the same as b-a, so counting or testing can begin on a-b without waiting for abs(a-b) to be determined.

A loop stripping low zero bits tends not to branch predict well, since the condition is data dependent. But on average there’s only a few low zeros, so an option is to strip one or two bits arithmetically then loop for more (as done for AMD K6). Or use a lookup table to get a count for several bits then loop for more (as done for AMD K7). An alternative approach is to keep just one of a and b odd and iterate

    a,b = abs(a-b), min(a,b)
    a = a/2 if even
    b = b/2 if even

This requires about 1.25 iterations per bit, but stripping of a single bit at each step avoids any branching. Repeating the bit strip reduces to about 0.9 iterations per bit, which may be a worthwhile tradeoff.

Generally with the above approaches a speed of perhaps 6 cycles per bit can be achieved, which is still not terribly fast with for instance a 64-bit GCD taking nearly 400 cycles. It’s this sort of time which means it’s not usually advantageous to combine a set of divisibility tests into a GCD.

Currently, the binary algorithm is used for GCD only when N < 3.

Next: Lehmer’s algorithm, Previous: Greatest Common Divisor, Up: Greatest Common Divisor   [Index]
===
https://gmplib.org/manual/Lehmer_0027s-Algorithm
===
Next: Subquadratic GCD, Previous: Binary GCD, Up: Greatest Common Divisor   [Index]

15.3.2 Lehmer’s algorithm
Lehmer’s improvement of the Euclidean algorithms is based on the observation that the initial part of the quotient sequence depends only on the most significant parts of the inputs. The variant of Lehmer’s algorithm used in GMP splits off the most significant two limbs, as suggested, e.g., in “A Double-Digit Lehmer-Euclid Algorithm” by Jebelean (see References). The quotients of two double-limb inputs are collected as a 2 by 2 matrix with single-limb elements. This is done by the function mpn_hgcd2. The resulting matrix is applied to the inputs using mpn_mul_1 and mpn_submul_1. Each iteration usually reduces the inputs by almost one limb. In the rare case of a large quotient, no progress can be made by examining just the most significant two limbs, and the quotient is computed using plain division.

The resulting algorithm is asymptotically O(N^2), just as the Euclidean algorithm and the binary algorithm. The quadratic part of the work are the calls to mpn_mul_1 and mpn_submul_1. For small sizes, the linear work is also significant. There are roughly N calls to the mpn_hgcd2 function. This function uses a couple of important optimizations:

It uses the same relaxed notion of correctness as mpn_hgcd (see next section). This means that when called with the most significant two limbs of two large numbers, the returned matrix does not always correspond exactly to the initial quotient sequence for the two large numbers; the final quotient may sometimes be one off.
It takes advantage of the fact that the quotients are usually small. The division operator is not used, since the corresponding assembler instruction is very slow on most architectures. (This code could probably be improved further, it uses many branches that are unfriendly to prediction.)
It switches from double-limb calculations to single-limb calculations half-way through, when the input numbers have been reduced in size from two limbs to one and a half.
Next: Subquadratic GCD, Previous: Binary GCD, Up: Greatest Common Divisor   [Index]
===
https://gmplib.org/manual/Subquadratic-GCD
===
Next: Extended GCD, Previous: Lehmer’s algorithm, Up: Greatest Common Divisor   [Index]

15.3.3 Subquadratic GCD
For inputs larger than GCD_DC_THRESHOLD, GCD is computed via the HGCD (Half GCD) function, as a generalization to Lehmer’s algorithm.

Let the inputs a,b be of size N limbs each. Put S = floor(N/2) + 1. Then HGCD(a,b) returns a transformation matrix T with non-negative elements, and reduced numbers (c;d) = T^{-1} (a;b). The reduced numbers c,d must be larger than S limbs, while their difference abs(c-d) must fit in S limbs. The matrix elements will also be of size roughly N/2.

The HGCD base case uses Lehmer’s algorithm, but with the above stop condition that returns reduced numbers and the corresponding transformation matrix half-way through. For inputs larger than HGCD_THRESHOLD, HGCD is computed recursively, using the divide and conquer algorithm in “On Schönhage’s algorithm and subquadratic integer GCD computation” by Möller (see References). The recursive algorithm consists of these main steps.

    * Call HGCD recursively, on the most significant N/2 limbs. Apply the resulting matrix T_1 to the full numbers, reducing them to a size just above 3N/2.
    * Perform a small number of division or subtraction steps to reduce the numbers to size below 3N/2. This is essential mainly for the unlikely case of large quotients.
    * Call HGCD recursively, on the most significant N/2 limbs of the reduced numbers. Apply the resulting matrix T_2 to the full numbers, reducing them to a size just above N/2.
    * Compute T = T_1 T_2.
    * Perform a small number of division and subtraction steps to satisfy the requirements, and return.

GCD is then implemented as a loop around HGCD, similarly to Lehmer’s algorithm. Where Lehmer repeatedly chops off the top two limbs, calls mpn_hgcd2, and applies the resulting matrix to the full numbers, the sub-quadratic GCD chops off the most significant third of the limbs (the proportion is a tuning parameter, and 1/3 seems to be more efficient than, e.g., 1/2), calls mpn_hgcd, and applies the resulting matrix. Once the input numbers are reduced to size below GCD_DC_THRESHOLD, Lehmer’s algorithm is used for the rest of the work.

The asymptotic running time of both HGCD and GCD is O(M(N)*log(N)), where M(N) is the time for multiplying two N-limb numbers.

Next: Extended GCD, Previous: Lehmer’s algorithm, Up: Greatest Common Divisor   [Index]
===
https://gmplib.org/manual/Extended-GCD
===
Next: Jacobi Symbol, Previous: Subquadratic GCD, Up: Greatest Common Divisor   [Index]

15.3.4 Extended GCD
The extended GCD function, or GCDEXT, calculates gcd(a,b) and also cofactors x and y satisfying a*x+b*y=gcd(a,b). All the algorithms used for plain GCD are extended to handle this case. The binary algorithm is used only for single-limb GCDEXT. Lehmer’s algorithm is used for sizes up to GCDEXT_DC_THRESHOLD. Above this threshold, GCDEXT is implemented as a loop around HGCD, but with more book-keeping to keep track of the cofactors. This gives the same asymptotic running time as for GCD and HGCD, O(M(N)*log(N)).

One difference to plain GCD is that while the inputs a and b are reduced as the algorithm proceeds, the cofactors x and y grow in size. This makes the tuning of the chopping-point more difficult. The current code chops off the most significant half of the inputs for the call to HGCD in the first iteration, and the most significant two thirds for the remaining calls. This strategy could surely be improved. Also the stop condition for the loop, where Lehmer’s algorithm is invoked once the inputs are reduced below GCDEXT_DC_THRESHOLD, could maybe be improved by taking into account the current size of the cofactors.
===
https://gmplib.org/manual/Jacobi-Symbol
===
Previous: Extended GCD, Up: Greatest Common Divisor   [Index]

15.3.5 Jacobi Symbol
Jacobi symbol (a/b)

Initially if either operand fits in a single limb, a reduction is done with either mpn_mod_1 or mpn_modexact_1_odd, followed by the binary algorithm on a single limb. The binary algorithm is well suited to a single limb, and the whole calculation in this case is quite efficient.

For inputs larger than GCD_DC_THRESHOLD, mpz_jacobi, mpz_legendre and mpz_kronecker are computed via the HGCD (Half GCD) function, as a generalization to Lehmer’s algorithm.

Most GCD algorithms reduce a and b by repeatedly computing the quotient q = floor(a/b) and iteratively replacing

a, b = b, a - q * b

Different algorithms use different methods for calculating q, but the core algorithm is the same if we use Lehmer’s algorithm or HGCD.

At each step it is possible to compute if the reduction inverts the Jacobi symbol based on the two least significant bits of a and b. For more details see “Efficient computation of the Jacobi symbol” by Möller (see References).

A small set of bits is thus used to track state

current sign of result (1 bit)
two least significant bits of a and b (4 bits)
a pointer to which input is currently the denominator (1 bit)
In all the routines sign changes for the result are accumulated using fast bit twiddling which avoids conditional jumps.

The final result is calculated after verifying the inputs are coprime (GCD = 1) by raising (-1)^e.

Much of the HGCD code is shared directly with the HGCD implementations, such as the 2x2 matrix calculation, See Lehmer’s algorithm basecase and GCD_DC_THRESHOLD.

The asymptotic running time is O(M(N)*log(N)), where M(N) is the time for multiplying two N-limb numbers.

Previous: Extended GCD, Up: Greatest Common Divisor   [Index]
===
===
]]]
[[[
https://oeis.org/A071647
===
(Greetings from The On-Line Encyclopedia of Integer Sequences!)
A071647		a(n) is the maximum number of elements among the continued fractions for n/1, n/2, n/3, n/4, ..., n/n.		2
1, 1, 2, 2, 3, 2, 3, 4, 3, 3, 4, 4, 5, 4, 4, 4, 4, 5, 5, 4, 6, 4, 5, 4, 5, 5, 5, 5, 6, 6, 6, 5, 5, 7, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 6, 7, 7, 6, 6, 6, 5, 8, 6, 6, 6, 6, 7, 6, 6, 6, 7, 7, 7, 7, 7, 7, 6, 7, 6, 7, 7, 7, 8, 6, 6, 8, 8, 8, 7, 7, 6, 7, 7, 7 (list; graph; refs; listen; history; text; internal format)
OFFSET	
1,3
COMMENTS	
a(n)/log(n) is bounded.
Apart from initial term, same as A034883. - Franklin T. Adams-Watters, Nov 14 2006
LINKS	
Jinyuan Wang, Table of n, a(n) for n = 1..1000
EXAMPLE	
Continued fractions for 5/1 = [5]; 5/2 = [2, 2]; 5/3 = [1, 1, 2]; 5/4 = [1, 4]; 5/5 = [1] hence a(5) = 3.
PROG	
(PARI) for(n=1, 150, print1( vecmax(vector(n, i, length(contfrac(n/i)))), ", "))
CROSSREFS	
Cf. A034883.
Sequence in context: A181948 A238943 A070081 * A034883 A338643 A051125
Adjacent sequences:  A071644 A071645 A071646 * A071648 A071649 A071650
KEYWORD	
nonn,easy
AUTHOR	
Benoit Cloitre, Jun 22 2002
STATUS	
approved
Last modified August 5 23:52 EDT 2023. Contains 364454 sequences. (Running on oeis4.)
]]]
[[[
https://oeis.org/A034883
===
(Greetings from The On-Line Encyclopedia of Integer Sequences!)
A034883		Maximum length of Euclidean algorithm starting with n and any nonnegative i<n.		9
0, 1, 2, 2, 3, 2, 3, 4, 3, 3, 4, 4, 5, 4, 4, 4, 4, 5, 5, 4, 6, 4, 5, 4, 5, 5, 5, 5, 6, 6, 6, 5, 5, 7, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 6, 7, 7, 6, 6, 6, 5, 8, 6, 6, 6, 6, 7, 6, 6, 6, 7, 7, 7, 7, 7, 7, 6, 7, 6, 7, 7, 7, 8, 6, 6, 8, 8, 8, 7, 7, 6, 7, 7, 7, 7, 9, 6, 7, 7, 7, 7, 7, 6, 8, 7, 7, 7 (list; graph; refs; listen; history; text; internal format)
OFFSET	
1,3
COMMENTS	
Apart from initial term, same as A071647. - Franklin T. Adams-Watters, Nov 14 2006
Records occur when n is a Fibonacci number. For n>1, the smallest i such that the algorithm requires a(n) steps is A084242(n). The maximum number of steps a(n) is greater than k for n > A188224(k). - T. D. Noe, Mar 24 2011
Largest term in n-th row of A051010. - Reinhard Zumkeller, Jun 27 2013
a(n)+1 is the length of the longest possible continued fraction expansion (in standard form) of any rational number with denominator n. - Ely Golden, May 18 2020
LINKS	
T. D. Noe, Table of n, a(n) for n=1..1000
Eric Weisstein's World of Mathematics, Euclidean Algorithm
MATHEMATICA	
GCDSteps[n1_, n2_] := Module[{a = n1, b = n2, cnt = 0}, While[b > 0, cnt++; {a, b} = {Min[a, b], Mod[Max[a, b], Min[a, b]]}]; cnt]; Table[Max @@ Table[GCDSteps[n, i], {i, 0, n - 1}], {n, 100}] (* T. D. Noe, Mar 24 2011 *)
PROG	
(Haskell)
a034883 = maximum . a051010_row  -- Reinhard Zumkeller, Jun 27 2013
(Python)
def euclid_steps(a, b):
    step_count = 0
    while(b != 0):
        a , b = b , a % b
        step_count += 1
    return step_count
for n in range(1, 1001):
    l = 0
    for i in range(n): l = max(l, euclid_steps(n, i))
    print(str(n)+" "+str(l)) # Ely Golden, May 18 2020
CROSSREFS	
Sequence in context: A238943 A070081 A071647 * A338643 A051125 A321126
Adjacent sequences:  A034880 A034881 A034882 * A034884 A034885 A034886
KEYWORD	
easy,nonn
AUTHOR	
Erich Friedman
STATUS	
approved
Lookup | Welcome | Wiki | Register | Music | Plot 2 | Demos | Index | Browse | More | WebCam
Contribute new seq. or comment | Format | Style Sheet | Transforms | Superseeker | Recents
The OEIS Community | Maintained by The OEIS Foundation Inc.
License Agreements, Terms of Use, Privacy Policy. .
Last modified August 5 23:52 EDT 2023. Contains 364454 sequences. (Running on oeis4.)
]]]

[[[
https://mathworld.wolfram.com/EuclideanAlgorithm.html
===
Euclidean Algorithm
The Euclidean algorithm, also called Euclid's algorithm, is an algorithm for finding the greatest common divisor of two numbers a and b. The algorithm can also be defined for more general rings than just the integers Z. There are even principal rings which are not Euclidean but where the equivalent of the Euclidean algorithm can be defined. The algorithm for rational numbers was given in Book VII of Euclid's Elements. The algorithm for reals appeared in Book X, making it the earliest example of an integer relation algorithm (Ferguson et al. 1999).

The Euclidean algorithm is an example of a P-problem whose time complexity is bounded by a quadratic function of the length of the input values (Bach and Shallit 1996).

Let a=bq+r, then find a number u which divides both a and b (so that a=su and b=tu), then u also divides r since

 r=a-bq=su-qtu=(s-qt)u. 	
(1)
Similarly, find a number v which divides b and r (so that b=s^'v and r=t^'v), then v divides a since

 a=bq+r=s^'vq+t^'v=(s^'q+t^')v. 	
(2)
Therefore, every common divisor of a and b is a common divisor of b and r, so the procedure can be iterated as follows:

 q_1=|_a/b_|  a=bq_1+r_1  r_1=a-bq_1 ; q_2=|_b/(r_1)_|  b=q_2r_1+r_2  r_2=b-q_2r_1 ; q_3=|_(r_1)/(r_2)_|  r_1=q_3r_2+r_3  r_3=r_1-q_3r_2 ; q_4=|_(r_2)/(r_3)_|  r_2=q_4r_3+r_4  r_4=r_2-q_4r_3 ; q_n=|_(r_(n-2))/(r_(n-1))_|  r_(n-2)=q_nr_(n-1)+r_n  r_n=r_(n-2) ;    -q_nr_(n-1); q_(n+1)=|_(r_(n-1))/(r_n)_|  r_(n-1)=q_(n+1)r_n+0  r_n=r_(n-1)/q_(n+1)  	
(3)
For integers, the algorithm terminates when q_(n+1) divides r_(n-1) exactly, at which point r_n corresponds to the greatest common divisor of a and b, GCD(a,b)=r_n. For real numbers, the algorithm yields either an exact relation or an infinite sequence of approximate relations (Ferguson et al. 1999).

An important consequence of the Euclidean algorithm is finding integers x and y such that

 ax+by=GCD(a,b). 	
(4)
This can be done by starting with the equation for r_n, substituting for r_(n-1) from the previous equation, and working upward through the equations.

Note that the r_i are just remainders, so the algorithm can be easily applied by hand by repeatedly computing remainders of consecutive terms starting with the two numbers of interest (with the larger of the two written first). As an example, consider applying the algorithm to (a,b)=(42,30). This gives 42, 30, 12, 6, 0, so GCD(42,30)=6. Similarly, applying the algorithm to (144, 55) gives 144, 55, 34, 21, 13, 8, 5, 3, 2, 1, 0, so GCD(144,55)=1 and 144 and 55 are relatively prime.

A concise Wolfram Language implementation can be given as follows.

  Remainder[a_, b_] := Mod[a, b]
  Remainder[a_, 0] := 0
  EuclideanAlgorithmGCD[a_, b_] := FixedPointList[
    {Last[#], Remainder @@ #}&, {a, b}][[-3, 1]]
Lamé showed that the number of steps needed to arrive at the greatest common divisor for two numbers less than n is

 steps<=(lnn)/(lnphi)+(lnsqrt(5))/(lnphi) 	
(5)
where phi is the golden ratio. Numerically, Lamé's expression evaluates to

 steps<=4.785log_(10)n+1.6723, 	
(6)
which, for n>=1, is always <=5 times the number of digits in the smaller number (Wells 1986, p. 59). As shown by Lamé's theorem, the worst case occurs when the algorithm is applied to two consecutive Fibonacci numbers. Heilbronn showed that the average number of steps is 12ln2/pi^2lnn=0.843lnn for all pairs (n,b) with b<n. Kronecker showed that the shortest application of the algorithm uses least absolute remainders. The quotients obtained are distributed as shown in the following table (Wagon 1991).

quotient	%
1	41.5
2	17.0
3	9.3
Let T(m,n) be the number of divisions required to compute GCD(m,n) using the Euclidean algorithm, and define T(m,0)=0 if m>=0. Then the function T(m,n) is given by the recurrence relation

 T(m,n)={1+T(n,m mod n)   for m>=n; 1+T(n,m)   for m<n. 	
(7)
Tabulating this function for 0<=m<n gives

 0     ; 0 1    ; 0 1 2   ; 0 1 1 2  ; 0 1 2 3 2 ; 0 1 1 1 2 2 	
(8)
(OEIS A051010). The maximum numbers of steps for a given n=1, 2, 3, ... are 1, 2, 2, 3, 2, 3, 4, 3, 3, 4, 4, 5, ... (OEIS A034883).

EuclideanAlgorithmT
Consider the function

 T(n)=1/nsum_(0<=m<n)T(m,n) 	
(9)
giving the average number of steps when n is fixed and m chosen at random (Knuth 1998, pp. 344 and 353-357). The first few values of T(n) are 0, 1/2, 1, 1, 8/5, 7/6, 13/7, 7/4, ... (OEIS A051011 and A051012). Norton (1990) showed that

 T(n)=(12ln2)/(pi^2)[lnn-sum_(d|n)(Lambda(d))/d]+C+1/nsum_(d|n)phi(d)O(d^(-1/6+epsilon)), 	
(10)
where Lambda(d) is the Mangoldt function and C is Porter's constant (Knuth 1998, pp. 355-356).

EuclideanAlgorithmTau
The related function

 tau(n)=1/(phi(n))sum_(0<=m<n; GCD(m,n)=1)T(m,n) 	
(11)
where phi(n) is the totient function, gives the average number of divisions when n is fixed and m is a random number coprime to n. Porter (1975) showed that

 tau(n)=(12ln2)/(pi^2)lnn+C+O(n^(-1/6)+epsilon) 	
(12)
(Knuth 1998, pp. 354-355).

Finally, define

 A(N)=1/(N^2)sum_(1<=m<=N; 1<=n<=N)T(m,n), 	
(13)
as the average number of divisions when m and n are both chosen at random in [1,N] Norton (1990) proved that

 A(N)=(12ln2)/(pi^2)[lnN-1/2+6/(pi^2)zeta^'(2)]+C-1/2+O(N^(-1/6+epsilon)), 	
(14)
where zeta^'(z) is the derivative of the Riemann zeta function.

There exist 21 quadratic fields in which there is a Euclidean algorithm (Inkeri 1947, Barnes and Swinnerton-Dyer 1952).

For additional details, see Uspensky and Heaslet (1939) and Knuth (1998).

Although various attempts were made to generalize the algorithm to find integer relations between n>=3 variables, none were successful until the discovery of the Ferguson-Forcade algorithm (Ferguson et al. 1999). Several other integer relation algorithms have now been discovered.

SEE ALSO
Blankinship Algorithm, Euclidean Ring, Ferguson-Forcade Algorithm, Half-GCD, Integer Relation, Quadratic Field
]]]

[[[
https://mathworld.wolfram.com/IntegerRelation.html
===
Integer Relation
A set of real numbers x_1, ..., x_n is said to possess an integer relation if there exist integers a_i such that

 a_1x_1+a_2x_2+...+a_nx_n=0, 
with not all a_i=0. For historical reasons, integer relation algorithms are sometimes called generalized Euclidean algorithms or multidimensional continued fraction algorithms.

An interesting example of such a relation is the 17-vector (1, x, x^2, ..., x^(16)) with x=3^(1/4)-2^(1/4), which has an integer relation (1, 0, 0, 0, -3860, 0, 0, 0, -666, 0, 0, 0, -20, 0, 0, 0, 1), i.e.,

 1-3860x^4-666x^8-20x^(12)+x^(16)=0. 
This is a special case of finding the polynomial of degree n=rs satisfied by x=3^(1/r)-2^(1/s).

Integer relations can be found in the Wolfram Language using FindIntegerNullVector[{x1, x2, ...}].

Integer relation algorithms can be used to solve subset sum problems, as well as to determine if a given numerical constant is equal to a root of a univariate polynomial of degree n or less (Bailey and Ferguson 1989, Ferguson and Bailey 1992).

One of the simplest cases of an integer relation between two numbers is the one inherent in the definition of the greatest common divisor. The well-known Euclidean algorithm solves this problem, as well as the more general problem of an integer relation between two real numbers, yielding either an exact relation or an infinite sequence of approximate relations (Ferguson et al. 1999). Although attempts were made to generalize the algorithm to n>=3 by Hermite (1850), Jacobi (1868), Poincaré (1884), Perron (1907), Brun (1919, 1920, 1957), and Szekeres (1970), all such routines were known to fail in certain cases (Ferguson and Forcade 1979, Forcade 1981, Hastad et al. 1989). The first successful integer relation algorithm was developed by Ferguson and Forcade (1979) (Ferguson and Bailey 1992, Ferguson et al. 1999).

Algorithms for finding integer relations include the Ferguson-Forcade algorithm, HJLS algorithm, LLL algorithm, PSLQ algorithm, PSOS algorithm, and the algorithm of Lagarias and Odlyzko (1985). Perhaps the simplest (and unfortunately most inefficient) such algorithm is the greedy algorithm.

Plouffe's "Inverse Symbolic Calculator" site includes a huge database of 54 million real numbers which are algebraically related to fundamental mathematical constants. The Ferguson-Forcade algorithm has shown that there are no algebraic equations of degree <=8 with integer coefficients having Euclidean norms below certain bounds for e/pi, e+pi, lnpi, gamma, e^gamma, gamma/e, gamma/pi, and lngamma, where e is the base for the natural logarithm, pi is pi, and gamma is the Euler-Mascheroni constant (Bailey 1988).

Constant	Bound
e/pi	6.1030×10^(14)
e+pi	2.2753×10^(18)
lnpi	8.7697×10^9
gamma	3.5739×10^9
e^gamma	1.6176×10^(17)
gamma/e	1.8440×10^(11)
gamma/pi	6.5403×10^9
lngamma	2.6881×10^(10)
SEE ALSO
Constant Problem, Ferguson-Forcade Algorithm, Greedy Algorithm, Hermite-Lindemann Theorem, HJLS Algorithm, Knapsack Problem, Lattice Reduction, Lindemann-Weierstrass Theorem, LLL Algorithm, PSLQ Algorithm, PSOS Algorithm, Richardson's Theorem, Real Number, Subset Sum Problem
]]]
[[[
https://mathworld.wolfram.com/PSLQAlgorithm.html
===
PSLQ Algorithm
An algorithm which can be used to find integer relations between real numbers x_1, ..., x_n such that

 a_1x_1+a_2x_2+...+a_nx_n=0, 
with not all a_i=0. Although the algorithm operates by manipulating a lattice, it does not reduce it to a short vector basis, and is therefore not a lattice reduction algorithm. PSLQ is based on a partial sum of squares scheme (like the PSOS algorithm) implemented using QR decomposition. It was developed by Ferguson and Bailey (1992). A much simplified version of the algorithm was subsequently developed by Ferguson et al. (1999), which also extends the algorithm to complex numbers and quaternions. Ferguson et al. (1999) also demonstrated that PSLQ is distinct from the HJLS algorithm.

The PSLQ algorithm terminates after a number of iterations bounded by a polynomial in n and uses a numerically stable matrix reduction procedure (Ferguson and Bailey 1992). PSLQ tends to be faster than the Ferguson-Forcade algorithm and LLL algorithm because of clever techniques that allow machine arithmetic to be used at many intermediate steps. The LLL algorithm, by comparison, must use moderate precision, although generally not as much as the HJLS algorithm.

While the LLL algorithm is a more general lattice reduction algorithm than PSLQ, using LLL to obtain integer relations is in some sense a "trick," whereas with PSLQ one gets either a relation or lower bounds on degrees of polynomials and sizes of coefficients for which such a relation must satisfy.

SEE ALSO
Ferguson-Forcade Algorithm, Integer Relation, LLL Algorithm, PSOS Algorithm
]]]
[[[
https://mathworld.wolfram.com/PSOSAlgorithm.html
===
PSOS Algorithm
An integer-relation algorithm which is based on a partial sum of squares approach, from which the algorithm takes its name.

SEE ALSO
Ferguson-Forcade Algorithm, HJLS Algorithm, Integer Relation, LLL Algorithm, PSLQ Algorithm
]]]
[[[
https://mathworld.wolfram.com/HJLSAlgorithm.html
===
HJLS Algorithm
An algorithm for finding integer relations whose running time is bounded by a polynomial in the number of real variables (Ferguson and Bailey 1992). Unfortunately, it is numerically unstable and therefore requires extremely high numeric precision. The cause of this instability is not known, but is believed to derive from its reliance on Gram-Schmidt orthonormalization (Ferguson and Bailey 1992), which is known to be numerically unstable (Golub and Van Loan 1989).

Rössner and Schnorr (1994) have developed a stable variation of HJLS (Ferguson et al. 1999).

SEE ALSO
Ferguson-Forcade Algorithm, Gram-Schmidt Orthonormalization, Integer Relation, LLL Algorithm, PSLQ Algorithm, PSOS Algorithm
]]]
[[[
https://mathworld.wolfram.com/LLLAlgorithm.html
===
LLL Algorithm
A lattice reduction algorithm, named after discoverers Lenstra, Lenstra, and Lovasz (1982), that produces a lattice basis of "short" vectors. It was noticed by Lenstra et al. (1982) that the algorithm could be used to obtain factors of univariate polynomials, which amounts to the determination of integer relations. However, this application of the algorithm, which later came to be one of its primary applications, was not stressed in the original paper.

For a complexity analysis of the LLL algorithm, see Storjohann (1996).

The Wolfram Language command LatticeReduce[matrix] implements the LLL algorithm to perform lattice reduction. The Wolfram Language's implementation requires the input to consist of rational numbers, so Rationalize may need to be called first.

More recently, other algorithms such as PSLQ, which can be significant faster than LLL, have been developed for finding integer relations. PSLQ achieves its performance because of clever techniques that allow machine arithmetic to be used at many intermediate steps, whereas LLL must use moderate precision (although generally not as much as the HJLS algorithm).

SEE ALSO
Ferguson-Forcade Algorithm, HJLS Algorithm, Integer Relation, Lattice Reduction, PSLQ Algorithm, PSOS Algorithm
]]]
[[[
PSLQ Algorithm
https://arminstraub.com/downloads/math/pslq.pdf
    gentle introduction to PSLQ
https://arxiv.org/pdf/1707.05037.pdf
    THE PSLQ ALGORITHM FOR EMPIRICAL DATA
https://www.davidhbailey.com/dhbpapers/pslq-comp-alg.pdf
    PSLQ: An Algorithm to Discover Integer Relations
https://www.davidhbailey.com/dhbpapers/pslq.pdf
    A Polynomial Time, Numerically Stable Integer Relation…
https://www.davidhbailey.com/dhbpapers/cpslq.pdf
    ANALYSIS OF PSLQ, AN INTEGER RELATION FINDING ALGORITHM
https://chamberland.math.grinnell.edu/papers/pslq.pdf
    USING INTEGER RELATIONS ALGORITHMS FOR FINDING RELATIONSHIPS…
https://www.davidhbailey.com/dhbtalks/dhb-carma-20100824.pdf
    The PSLQ Algorithm: Techniques for Efficient Computation

cd /sdcard/Download/
wget https://arminstraub.com/downloads/math/pslq.pdf
wget https://arxiv.org/pdf/1707.05037.pdf
wget https://www.davidhbailey.com/dhbpapers/pslq-comp-alg.pdf
wget https://www.davidhbailey.com/dhbpapers/pslq.pdf -O pslq2.pdf
wget https://www.davidhbailey.com/dhbpapers/cpslq.pdf
wget https://chamberland.math.grinnell.edu/papers/pslq.pdf -O pslq3.pdf
wget https://www.davidhbailey.com/dhbtalks/dhb-carma-20100824.pdf
curl -L -C - -f -S  --output dhb-carma-20100824.pdf https://www.davidhbailey.com/dhbtalks/dhb-carma-20100824.pdf

===
]]]


[[
]]







]]]]]









[[[[[

[[
???[[(a*10+b)%13==0] <-> [(a+4*b)%13==0]]???
    proof:
    [(a*10+b)%13==0]
        <==> [(a*10+b)%13==0]
        <==> [4*(a*10+b)%13==0]
        <==> [(a+4*b)%13==0]
[M >= 2][gcd(10,M) == 1]:
    [(a*10+b)%M==0]
        <==> [(a+inv_mod_(M;10)*b)%M==0]
    [0 < inv_mod_(M;10) <= 10]:
        * [10%M == 1]:
            [9%M == 0]
            [M <- {3,9}]
        * [20%M == 1]:
            [M == 19]
        ...
        * [90%M == 1]:
        * [100%M == 1]:
    [0 < inv_mod_(M;10) <= 10]:
        inv_mod_(M;10):M...
        1:3,9
        2:19
        3:29
        4:3,13
        5:7
        6:59
        7:3,23
        8:79
        9:89
        10:3,9,11,33,99
        M:inv_mod_(M;10)...
        3:1,4,7,10
        7:5
        9:1,10
        11:10
        13:4
        19:2
        23:7
        29:3
        33:10
        59:6
        79:8
        89:9
        99:10
    [0 > inv_mod_(M;10) >= 10]:
        * [-10%M == 1]:
            [-11%M == 0]
            [M == 11]
        * [-20%M == 1]:
            [-21%M == 0]
            [M <- {3,7}]
        ...
        * [-90%M == 1]:
        * [-100%M == 1]:
    [0 > inv_mod_(M;10) >= 10]:
        inv_mod_(M;10):M...
        -1:11
        -2:3,7
        -3:31
        -4:41
        -5:3,17,51
        -6:61
        -7:71
        -8:3,9,27,81
        -9:7,13,91
        -10:101
        M:inv_mod_(M;10)...
        3:-2,-5,-8
        7:-2,-9
        9:-8
        11:-1
        13:-9
        17:-5
        27:-8
        31:-3
        41:-4
        51:-5
        61:-6
        71:-7
        81:-8
        91:-9
        101:-10
    [-10 <= inv_mod_(M;10) <= 10]:
        !! [M >= 2][gcd(10,M) == 1]
        M:inv_mod_(M;10)...
        3:1     :1,4,7,10,-2,-5,-8
        7:-2    :5,-2,-9
        9:1     :1,10,-8
        11:-1   :10,-1
        13:4    :4,-9
        17:-5
        19:2
        23:7
        27:-8
        29:3
        31:-3
        33:10
        41:-4
        51:-5
        59:6
        61:-6
        71:-7
        79:8
        81:-8
        89:9
        91:-9
        99:10
        101:-10

===
https://byjus.com/maths/divisibility-rules/

Divisibility Rules

Divisibility rules or Divisibility tests have been mentioned to make the division procedure easier and quicker. If students learn the division rules in Maths or the divisibility tests for 1 to 20, they can solve the problems in a better way. For example, divisibility rules for 13 help us to know which numbers are completely divided by 13. Some numbers like 2, 3, 4, 5 have rules which can be understood easily. But rules for 7, 11, 13, are a little complex and need to be understood in-depth.

Mathematics is not easy for some of us. At times, the need for tricks and shorthand techniques is felt, to solve Maths problems faster and easily without lengthy calculation. It will also help students to score better marks in exams. These rules are a great example of such shorthand techniques. In this article, let us discuss the division rules in Maths with many examples.

Table of Contents:

Definition
Divisibility of 1
Divisibility of 2
Divisibility of 3
Divisibility of 4
Divisibility of 5
Divisibility of 6
Divisibility of 7
Divisibility of 8
Divisibility of 9
Divisibility of 10
Divisibility of 11
Divisibility of 12
Divisibility of 13

Divisibility Test (Division Rules in Maths)
As the name suggests, divisibility tests or division rules in Maths help one to check whether a number is divisible by another number without the actual method of division. If a number is completely divisible by another number then the quotient will be a whole number and the remainder will be zero.

Since every number is not completely divisible by every other number such numbers leave remainder other than zero. These rules are certain ones, which help us to determine the actual divisor of a number just by considering the digits of the number.

The division rules from 1 to 13 in Maths are explained here in detail with many solved examples. Go through the below article to learn the shortcut methods to divide the numbers easily.

Multiplication And Division
Dividend
Divisor
Quotient

Divisibility Rule of 1
Every number is divisible by 1. Divisibility rule for 1 doesn’t have any condition. Any number divided by 1 will give the number itself, irrespective of how large the number is. For example, 3 is divisible by 1 and 3000 is also divisible by 1 completely.

Divisibility Rule of 2
If a number is even or a number whose last digit is an even number i.e.  2,4,6,8 including 0, it is always completely divisible by 2.

Example: 508 is an even number and is divisible by 2 but 509 is not an even number, hence it is not divisible by 2. Procedure to check whether 508 is divisible by 2 or not is as follows:

Consider the number 508
Just take the last digit 8 and divide it by 2
If the last digit 8 is divisible by 2 then the number 508 is also divisible by 2.

Divisibility Rules for 3
Divisibility rule for 3 states that a number is completely divisible by 3 if the sum of its digits is divisible by 3.

Consider a number, 308. To check whether 308 is divisible by 3 or not, take sum of the digits (i.e. 3+0+8= 11). Now check whether the sum is divisible by 3 or not. If the sum is a multiple of 3, then the original number is also divisible by 3. Here, since 11 is not divisible by 3, 308 is also not divisible by 3.

Similarly, 516 is divisible by 3 completely as the sum of its digits i.e. 5+1+6=12, is a multiple of 3.

Divisibility Rule of 4
If the last two digits of a number are divisible by 4, then that number is a multiple of 4 and is divisible by 4 completely.

Example: Take the number 2308. Consider the last two digits i.e.  08. As 08 is divisible by 4, the original number 2308 is also divisible by 4.

Divisibility Rule of 5
Numbers, which last with digits, 0 or 5 are always divisible by 5.
Example: 10, 10000, 10000005, 595, 396524850, etc.

Divisibility Rule of 6
Numbers which are divisible by both 2 and 3 are divisible by 6. That is, if the last digit of the given number is even and the sum of its digits is a multiple of 3, then the given number is also a multiple of 6.

Example: 630, the number is divisible by 2 as the last digit is 0.
The sum of digits is 6+3+0 = 9, which is also divisible by 3.
Hence, 630 is divisible by 6.

Divisibility Rules for 7
The rule for divisibility by 7 is a bit complicated which can be understood by the steps given below:

Example: Is 1073 divisible by 7?

From the rule stated remove 3 from the number and double it, which becomes 6.
Remaining number becomes 107, so 107-6 = 101.
Repeating the process one more time, we have 1 x 2 = 2.
Remaining number 10 – 2 = 8.
As 8 is not divisible by 7, hence the number 1073 is not divisible by 7.

Divisibility Rule of 8
If the last three digits of a number are divisible by 8, then the number is completely divisible by 8.

Example: Take number 24344. Consider the last two digits i.e.  344. As 344 is divisible by 8, the original number 24344 is also divisible by 8.

Divisibility Rule of 9
The rule for divisibility by 9 is similar to divisibility rule for 3. That is, if the sum of digits of the number is divisible by 9, then the number itself is divisible by 9.

Example: Consider 78532, as the sum of its digits (7+8+5+3+2) is 25, which is not divisible by 9, hence 78532 is not divisible by 9.

Divisibility Rule of 10
Divisibility rule for 10 states that any number whose last digit is 0, is divisible by 10.

Example: 10, 20, 30, 1000, 5000, 60000, etc.

Divisibility Rules for 11
If the difference of the sum of alternative digits of a number is divisible by 11, then that number is divisible by 11 completely.

i.e., Sum of digits in odd places – Sum of digits in even places = 0 or a multiple of 11

In order to check whether a number like 2143 is divisible by 11, below is the following procedure.

Group the alternative digits i.e. digits which are in odd places together and digits in even places together. Here 24 and 13 are two groups.
Take the sum of the digits of each group i.e. 2+4=6 and 1+3= 4
Now find the difference of the sums; 6-4=2
If the difference is divisible by 11, then the original number is also divisible by 11. Here 2 is the difference which is not divisible by 11.
Therefore, 2143 is not divisible by 11.
A few more conditions are there to test the divisibility of a number by 11. They are explained here with the help of examples:

If the number of digits of a number is even, then add the first digit and subtract the last digit from the rest of the number. 

Example: 3784

Number of digits = 4

Now, 78 + 3 – 4 = 77 = 7 × 11

Thus, 3784 is divisible by 11.

If the number of digits of a number is odd, then subtract the first and the last digits from the rest of the number. 

Example: 82907

Number of digits = 5

Now, 290 – 8 – 7 = 275 × 11

Thus, 82907 is divisible by 11.

Form the groups of two digits from the right end digit to the left end of the number and add the resultant groups. If the sum is a multiple of 11, then the number is divisible by 11.

Example: 3774 := 37 + 74 = 111 := 1 + 11 = 12 

3774 is not divisible by 11.

253 := 2 + 53 = 55 = 5 × 11

253 is divisible by 11.

Subtract the last digit of the number from the rest of the number. If the resultant value is a multiple of 11, then the original number will be divisible by 11.

Example: 9647

9647 := 964 – 7 = 957

957 := 95 – 7 = 88 = 8 × 11

Thus, 9647 is divisible by 11.

Divisibility Rule of 12
If the number is divisible by both 3 and 4, then the number is divisible by 12 exactly. 

Example: 5864

Sum of the digits = 5 + 8 + 6 + 4 = 23 (not a multiple of 3)

Last two digits = 64 (divisible by 4)

The given number 5864 is divisible by 4 but not by 3; hence, it is not divisible by 12.

Divisibility Rules for 13
For any given number, to check if it is divisible by 13, we have to add four times of the last digit of the number to the remaining number and repeat the process until you get a two-digit number.  Now check if that two-digit number is divisible by 13 or not. If it is divisible, then the given number is divisible by 13.

For example: 2795 → 279 + (5 x 4) 

→ 279 + (20) 

→ 299 

→ 29 + (9 x 4) 

→ 29 + 36 

→65

Number 65 is divisible by 13, 13 x 5 = 65.

Video Lesson
Divisibility Models
1,152
Solved Examples
Example 1:

Check if 288 is divisible by 2.

Solution:

Given, 288 is a number.

If the last digit of 288 is divisible by 2, then 288 is also divisible by 2.

The last digit of 288 is 8, which is divisible by 2, such that;

8/2 = 4

Hence, 288 satisfy the divisibility rule for 2.

Example 2:

Check is 195 is divisible by 4 or not.

Solution:

As we can see, the last digit of 195 is 5, which is not divisible by 4.

Hence, 195 is not divisible by 4.

 

26,297
Frequently Asked Questions on Divisibility Rules
Q1
What is meant by divisibility rules?
A divisibility test is an easy way to identify whether the given number is divided by a fixed divisor without actually performing the division process. If a number is completely divided by another number, then the quotient should be a whole number and the remainder should be zero.

Q2
What is the divisibility rule for 2 and 5?
Divisibility rule for 2: The last/unit digit of the given number should be an even number or the multiples of 2. (i.e.,) 0, 2, 4, 6, and 8.
Divisibility Rule for 5: The unit digit of the given number should be 0 or 5.

Q3
What is the divisibility rule for 7 and give an example?
The difference between twice the unit digit of the given number and the remaining part of the given number should be a multiple of 7 or it should be zero. For example, 147 is divisible by 7. Here, the unit digit is 7. When it is multiplied by 2, we get 14, and the remaining part is 14. Therefore, the difference between 14 and 14 is 0.

Q4
Write down the divisibility rule for 9.
The sum of the digits of the given number should be divisible by 9. For example, 2979 is divisible by 9. (i.e.,) 2+9+7+9 = 27, which is divisible by 9.

Q5
What is the divisibility rule for 13?
The sum/addition of four times of the unit digit and the remaining part of the given number should be a multiple of 13. For example, 1092 is divisible by 13. Here, the unit digit is 2. When it is multiplied by 4, we get 8, and the remaining part of the number is 109. Hence, the sum of 109 and 8 is 117, which is divisible by 13.

]]

[[
https://gioretikto.github.io/mat/algebra/index.html
===
Home
Algebra
Mathematical Analysis
Index of names

Chapters: 5. Polynomials, 6. Rings, 7. Groups   8. Fields;  

1. Sets
Sets
Exercises on sets
Relations
Functions
Composite Function; Inverse Functions
Exercises on functions
ℕ: natural numbers; Peano axioms - The principle of mathematical induction
Exercises on induction
Cardinality: Cantor's Theorem
Useful Formulas
Number Theory
2. ℤ: Integers
ℤ: The set of integer numbers; Commutative Ring
Divisibility in ℤ; Integral Domain
Gcd: The greatest common divisor
Euclidean Algorithm
Commensurable and Incommensurable magnitudes
Linear Diophantine equations
Exercises on integers
The Fundamental Theorem of Arithmetic
Least common multiple
3. ℚ Rational Numbers
ℚ: Rational Numbers
Exercises on rational numbers
Fibonacci sequence
Exercises su Fibonacci
Representation of rationals as fractions, decimal and percent
4. Congruence
Modular congruence; Residue Classes; ℤn
Modular Arithmetic: Operations on ℤn
Fermat’s little theorem
Divisibility criteria; Casting out nines
Exercises on congruence; Divisibility criteria
Linear Congruences; Invertible elements
Methods for solving linear congruences;
System of congruences;
The Chinese remainder theorem
Exercises on linear congruences; System of congruences; CRT
Euler's function and theorem;
Primality test; Wilson's Theorem; Sieve of Eratosthenes
Cryptology
Representation of numbers in arbitrary bases
ℂ: The Field of Complex Numbers
5. Polynomials
Polynomials
Divisibility of polynomials
Gcd of polynomials; Irreducible Polynomials; Unique Factorization Theorem
Ruffini's Theorem
Exercises on polynomials, Unique Factorization Theorem
Irreducibility of polynomials; Fundamental theorem of algebra
Irreducibility of polynomials in ℚ; Gauss's Lemma
Eisenstein’s irreducibility criterion
Exercises on factorization
Cubic equation and Cardano's Formula
Quartic Equations
Symmetric Polynomilas
Rational functions
Partial Fraction Decomposition
Exercises on symmetric polynomials and rational functions
6. Rings
Rings and Rings Isomorphism; fields and integral domains
Subrings; ℤ[i]; ℤ[√d]
Exercises on rings
Direct Sums of Rings
Ring Homomorphisms; kernel; Ideals
Equivalence relations in a ring; Quotient rings modulo an ideal
Exercises on ring homomorphisms, quotient rings and ideals
Fundamental theorem of ring homorpshims and isomorphism
Exercises on the fundamental morphism theorems
Ideal generated by a subset
Exercises on Ideal generated by a subset
The Chinese remainder theorem revisited
Quotient field of integral domains
Euclidean domain: ℤ[i]; ℤ[√-5]
Exercises on euclidean domain
Factorial domains
Exercises on UFD
Quadratic Extensions of the Integers: ℤ[√d]
Fermat's Two-Square Theorem
The Characteristic of an integral domain
7. Groups
Groups
Subgroups; The Center Z(G)
Cyclic Groups
The nth roots of unity and the ℤ/nℤ group
Exercises on Groups
Cyclotomic Polynomials
Exercises on Cyclotomic Polynomials
Order in Abelian Groups
Transformation Groups;Isometries
𝓢n: The symmetric group
Exercises on 𝓢n
Conjugacy
Exercises on Conjugate classes
Dihedral groups: Dn; Klein Group
Cosets
Group Isomorpshim
Lagrange’s Theorem
Group Homomorphism
Compatible relations and normal subgroups, quotient group G/N
The Normalizer and Normal Closure Subgroups
Exercises on Normal subgroups
Fundamental Homorphism Theorem for Groups
Exercises Fundamental Homomorphism Theorem for Groups
Isomorphism theorems
Group actions
Exercises on group action
Cauchy and Sylow theorems
Generalized Cayley's Theorem
Exercises Sylow
Direct Products
Exercises on direct products
Solvable groups and composition series
Wallpaper groups
Finite abelian groups: Fundamental theorem of finitely generated abelian groups
8. Fields
Fields
Field Extensions
Quotient rings of polynomial rings
Simple Extensions
Exercises on field extensions
Splitting Field
Exercises on splitting fields
Finite fields
Wedderburn's theorem
Normal extensions
Finite extensions of characteristic zero
9. Galois theory
Constructible points
F-automorphisms; Galois groups
Galois Extensions; The Fundamental Theorem of Galois Theory
Exercises on Galois correspondence theorem
Applications of Galois correspondence theorem
Fundamental theorem of Algebra
===



Algebra






href="../../index.html"
Home

href="index.html"
Algebra

href="../analysis/index.html"
Mathematical Analysis






href="index_names.html"
Index of names


Chapters: 
href="index.html#5"
5. Polynomials, 
href="index.html#6"
6. Rings,  
href="index.html#7"
7. Groups   
href="index.html#8"
8. Fields;   

1. Sets


href="sets.html"
Sets


href="ex_sets.html"
Exercises on sets


href="relations.html"
Relations

href="functions.html"
Functions

href="composite_functions.html"
Composite Function; Inverse Functions


href="ex_functions.html"
Exercises on functions


href="Peano.html"
ℕ: natural numbers; Peano axioms - The principle of mathematical induction


href="ex_induction.html"
Exercises on induction


href="cardinality.html"
Cardinality: Cantor's Theorem

href="useful_formulas.html"
Useful Formulas

href="number_theory.html"
Number Theory


2. ℤ: Integers


href="Z.html"
ℤ: The set of integer numbers; Commutative Ring

href="Z_divisibility.html"
Divisibility in ℤ; Integral Domain

href="gcd.html"
Gcd: The greatest common divisor

href="euclidean_algorithm.html"
Euclidean Algorithm

href="commensurability.html"
Commensurable and Incommensurable magnitudes

href="diophantine.html"
Linear Diophantine equations


href="ex_integers.html"
Exercises on integers


href="fund_theo_arithmetic.html"
The Fundamental Theorem of Arithmetic

href="lcm.html"
Least common multiple


3. ℚ Rational Numbers


href="Q.html"
ℚ: Rational Numbers


href="ex_on_Q.html"
Exercises on rational numbers


href="fibonacci.html"
Fibonacci sequence


href="esercizi_fibo.html"
Exercises su Fibonacci


href="fractions.html"
Representation of rationals as fractions, decimal and percent


4. Congruence


href="modulo.html"
Modular congruence; Residue Classes; ℤn

href="modular_arithmetic.html"
Modular Arithmetic: Operations on ℤn

href="fermat_little.html"
Fermat’s little theorem

href="divisibility_criteria.html"
Divisibility criteria; Casting out nines


href="ex_congruence.html"
Exercises on congruence; Divisibility criteria


href="linear_congruences.html"
Linear Congruences; Invertible elements

href="inverse.html"
Methods for solving linear congruences;

href="system_congruences.html"
System of congruences;

href="chinese.html"
The Chinese remainder theorem


href="ex_linear_congruence.html"
Exercises on linear congruences; System of congruences; CRT


href="Euler.html"
Euler's function and theorem;

href="Wilson.html"
Primality test; Wilson's Theorem; Sieve of Eratosthenes

href="cryptology.html"
Cryptology

href="different_bases.html"
Representation of numbers in arbitrary bases

href="C.html"
ℂ: The Field of Complex Numbers


5. Polynomials

href="polynomials.html"
Polynomials

href="pol_divisibility.html"
Divisibility of polynomials

href="pol_gcd.html"
Gcd of polynomials; Irreducible Polynomials; Unique Factorization Theorem

href="Ruffini.html"
Ruffini's Theorem


href="pol_exercises.html"
Exercises on polynomials, Unique Factorization Theorem


href="poly_irreducibility.html"
Irreducibility of polynomials; Fundamental theorem of algebra

href="pol_irr_Q.html"
Irreducibility of polynomials in ℚ; Gauss's Lemma

href="Eisenstein.html"
Eisenstein’s irreducibility criterion


href="ex_pol_fact.html"
Exercises on factorization


href="cardano.html"
Cubic equation and Cardano's Formula

href="quartic_equations.html"
Quartic Equations

href="symmetric_polynomials.html"
Symmetric Polynomilas

href="rational_functions.html"
Rational functions


href="partial_fractions.html"
Partial Fraction Decomposition


href="ex_symmetric_poly.html"
Exercises on symmetric polynomials and rational functions


6. Rings


href="rings.html"
Rings and Rings Isomorphism; fields and integral domains

href="subrings.html"
Subrings; ℤ[i]; ℤ[√d]


href="ex_rings.html"
Exercises on rings


href="rings_direct_sum.html"
Direct Sums of Rings

href="ring_homomorphism.html"
Ring Homomorphisms; kernel; Ideals

href="quotient_rings.html"
Equivalence relations in a ring; Quotient rings modulo an ideal


href="ex_ring_homomorphism.html"
Exercises on ring homomorphisms, quotient rings and ideals


href="fund_theorem_homomorphism.html"
Fundamental theorem of ring homorpshims and isomorphism


href="ex_morphism_theo.html"
Exercises on the fundamental morphism theorems


href="ideal_generated.html"
Ideal generated by a subset


href="ex_ideal_generated.html"
Exercises on Ideal generated by a subset


href="crt_revisited.html"
The Chinese remainder theorem revisited

href="quotient_field_integral.html"
Quotient field of integral domains

href="euclidean_domain.html"
Euclidean domain: ℤ[i]; ℤ[√-5]


href="ex_euclidean_domain.html"
Exercises on euclidean domain


href="factorial_domains.html"
Factorial domains


href="ex_UFD.html"
Exercises on UFD


href="quadratic_integers.html"
Quadratic Extensions of the Integers: ℤ[√d]

href="fermat_two_square.html"
Fermat's Two-Square Theorem

href="char.html"
The Characteristic of an integral domain

7. Groups


href="groups.html"
Groups

href="subgroups.html"
Subgroups; The Center Z(G)

href="cyclic_groups.html"
Cyclic Groups

href="nth_roots_unity.html"
The nth roots of unity and the ℤ/nℤ group


href="ex_groups.html"
Exercises on Groups


href="cyclotomic_polynomials.html"
Cyclotomic Polynomials


href="ex_cyclotomic_poly.html"
Exercises on Cyclotomic Polynomials


href="abelian_groups_order.html"
Order in Abelian Groups

href="isometries.html"
Transformation Groups;Isometries

href="Sn.html"
𝓢n: The symmetric group


href="ex_Sn.html"
Exercises on 𝓢n


href="conjugacy.html"
Conjugacy


href="ex_conjugate_classes.html"
Exercises on Conjugate classes


href="dihedral_groups.html"
Dihedral groups: Dn; Klein Group

href="cosets.html"
Cosets

href="group_isomorphism.html"
Group Isomorpshim

href="Lagrange.html"
Lagrange’s Theorem

href="group_homomorphism.html"
Group Homomorphism

href="normal_subgroups.html"
Compatible relations and normal subgroups, quotient group G/N

href="normalizer.html"
The Normalizer and Normal Closure Subgroups


href="ex_normal_subgroups.html"
Exercises on Normal subgroups


href="fund_theo_group_homo.html"
Fundamental Homorphism Theorem for Groups


href="ex_fund_theo_group_homo.html"
Exercises Fundamental Homomorphism Theorem for Groups


href="group_isomorphism_theo.html"
Isomorphism theorems

href="group_actions.html"
Group actions


href="ex_group_action.html"
Exercises on group action


href="Cauchy_Sylow.html"
Cauchy and Sylow theorems

href="Cayley.html"
Generalized Cayley's Theorem


href="ex_Sylow.html"
Exercises Sylow


href="direct_products.html"
Direct Products


href="ex_direct_products.html"
Exercises on direct products


href="solvable_groups.html"
Solvable groups and composition series

href="wallpaper_groups.html"
Wallpaper groups

href="finite_abelian_groups.html"
Finite abelian groups: Fundamental theorem of finitely generated abelian groups

8. Fields


href="fields.html"
Fields

href="field_extension.html"
Field Extensions

href="quotient_fields.html"
Quotient rings of polynomial rings

href="simple_extensions.html"
Simple Extensions


href="ex_field_extensions.html"
Exercises on field extensions


href="splitting_field.html"
Splitting Field


href="ex_splitting_fields.html"
Exercises on splitting fields


href="finite_fields.html"
Finite fields

href="Wedderburn.html"
Wedderburn's theorem

href="normal_extensions.html"
Normal extensions

href="separable_extensions.html"
Finite extensions of characteristic zero


9. Galois theory


href="constructible_points.html"
Constructible points

href="Galois.html"
F-automorphisms; Galois groups

href="Galois_extensions.html"
Galois Extensions; The Fundamental Theorem of Galois Theory


href="ex_Galois_correspondence.html"
Exercises on Galois correspondence theorem


Applications of Galois correspondence theorem


href="fund_theo_algebra.html"
Fundamental theorem of Algebra






===
]]


[[
Field of quotients of an integral domain
quotient field of D
field of fractions
Fraction Field of Integral Domains
fraction field of polynomial ring
===
https://gioretikto.github.io/mat/algebra/quotient_field_integral.html
Algebra
Field of quotients of an integral domain
Any integral domain D can be embedded in a field F, known as quotient field of D. As we have studied ℤ can be embdedded in ℚ which is its quotient field and the ring of polynomials can be embedded in the field of rational functions. As you may remember the definition of quotient field is the following:

4.7.1 Definition. Let R a subring of a field F. We say that F is a quotient field of R is every element a ∈ F can be written in the form a = r ⋅ s−1, with r and s in R, s ≠ 0.

For example if q is any rational number (m/n), then there exists some nonzero integer n such that nq ∈ ℤ.

Remark. The ring ℤ of integers is a subring of the field ℝ of real numbers but this latter is not the quotient field of ℤ, since it is not true that any real number can be written as quotient of two integers (with the second not null). We know the quotient field of ℤ to be ℚ.

It is evident that if a ring R is contained in a field, R is necessarily an integral domain. We are interested in understanding if for every integral domain D there exists a field F, having D as subring and such that F is the quotient field of D. We now explain why this is the case by the following theorem.

4.7.1 Theorem. Let D an integral domain. Then there exists a field Q(D) containing a subring Ď; isomorphic to D and such that every element of Q(D) is of the form ab−1, with a,b ∈ Ď, b ≠ 0.

Proof. Consider the set D x D*, the Cartesian product of D with itself-in which the second component is not allowed to be 0. Introduce in this set the following relation

(a,b) ρ (c,d)   ⇐⇒   ad = bc

This relation is an equivalence one, hence we can consider the quotient set

Q(D) := (D x D*)/ ρ.

To show that Q(D) is a field, we must endow it with an addition and multiplication. We define in Q(D) the following operations:

(a,b) + (c,d) := (ad + bc, bd)

(a,b) ⋅ (c,d) := (ac,bd)

The two operations are well-defined and with respect to these operations, Q(D) is a field. What acts as 1 in Q(D)? We claim that for any a ≠ 0, b ≠ 0 in D, (a,a)) = (b,b) (since ab = ba) and (c, d) (a, a) = (ca, da) = (c, d) , since (ca)d = (da)c. So (a, a) acts as 1, and we write it simply as 1 = (a, a) (for all a ≠ 0 in D). Notice how (b,a) is the multiplicative inverse of (a,b) and (−a,b) is the additive inverse for (a,b) in Q(D).

The application

φ: D ⟶ Q(D)

  a ⟼ (ax,x)

The map φ is a monomorphism of D into Q(D): Let a ≠ 0, It is certainly 1-1, for if φ(a) = (ax, x) = 0, then xa = 0, so x = 0, since D is an integral domain. This means that φ a ring homomorphism with kernel 0, (trivial kernel "only" means injective mappings). By restricting the codomain to the image of the mapping i.e. letting Ď = Im φ, Ď we have a surjective mapping (If f: X ⟶ Y is any injective set map, then f is also a bijection of X with the set Im f = f(i) (a certain subset of Y). Thus, Ď is isomorphic to D. Hence Q(D) contains a copy of D, that is D is embedded in the field Q(D).

To prove that Q(D) is a quotient field of D, we must show that each element (a,b) ∈ Q(D) can be written as quotient of two elements of Ď

(a,b) = (ax,x) ⋅ (x,bx) = (ax,x) (bx,x)−1 = φ(a) ⋅ φ(b)−1,   x ≠ 0.□

4.7.2 Theorem. The quotient fields of two isomorphic integral domains are isomorphic.

Proof. Let D and C be isomorphic integral domains and f: D → C an isomorphism. Consider the map φ: F → F' defined by

φ(a/b) = f(a)/f(b)   ∀a/b ∈ F

First we shall show that the mapping φ is well defined i.e., if

a/b = c/d   then φ(a/b) = φ(c/d).

We have

a/b = c/d   ⇒   ad = bc

f(ad) = f(bc) ⇒ f(a)f(d) = f(b) f(c)

f(a)/f(b) = f(c)/f(d)   ⇒   φ(a/b) = φ(c/d).

thus φ is well-defined.

φ is one-one as

φ(a/b) = φ(c/d)   ⇒   f(a)/f(b) = f(c)/f(d).

f(a) f(d) = f(b) f(c) ⇒ f(ad) = f(bc)

ad = bc

a/b = c/d

Also φ is onto F'. If f(a)/f(b) ∈ F', then

φ(a/b) = f(a)/f(b)   with a/b ∈ F

Let c/d, d ≠ 0, be anything at all in F'. Since f isomorphism, there must exist a, b in F with b nonzero (this uses f being injective) such that f(a) = c, f(b) = d. Thus φ(a/b) = f(a)/f(b) = c/d. Hence φ is onto.

Further

ϕ ( a b + c d ) = ϕ ( a d + b c b d ) = f ( a d + b c f ( b d ) = f ( a d ) + f ( b c ) f ( b ) f ( d ) = f ( a ) f ( d ) + f ( b ) f ( c ) f ( b ) f ( d ) = f ( a ) f ( b ) + f ( c ) f ( d ) = ϕ ( a b ) + ϕ ( c d )
Also

ϕ ( a b c d ) = ϕ ( a c b d ) = f ( a c ) f ( b d ) = f ( a ) f ( c ) f ( b ) f ( d ) = f ( a ) f ( c ) f ( b ) f ( d ) = ϕ ( a b ) ϕ ( c d )
thus φ is an homomorphism of F onto F'.□

4.7.3 Corollary. For any integral domain D, the quotient field Q(D) is unique (up to isomorphim).

«Ring and ring's isomorphisms
Index
Exercises on ideals generated by a subset »
]]

[[
https://gioretikto.github.io/mat/algebra/quotient_fields.html
Algebra
Quotient Rings of Polynomial Rings
If (R, +, ·) is any ring and (S, +) is any subgroup of the abelian group (R, +), then the quotient group (R/S, +) has already been defined. However, R/S does not have a ring structure induced on it by R unless S is a special kind of subgroup called an ideal.
A nonempty subset I of a ring R is called an ideal of R if the following conditions are satisfied for all x, y ∈ I and r ∈ R:

x − y ∈ I.

x · r and r · x ∈ I.

Condition (i) implies that (I, +) is a subgroup of (R, +). In any ring R, R itself is an ideal, and {0} is an ideal.

Let F be a field, and suppose p(x) ∈ F[x]. ⟨p(x)⟩ is the set of all multiples (by polynomials) of p(x), F[x] the (principal) ideal generated by p(x), that is the set ⟨p(x)⟩ = {q(x) p(x)| q(x) in F[x]}. When you form the quotient ring, it is as if you’ve set ⟨p(x)⟩ multiples of p(x) equal to 0.
If a(x) ∈ F[x], then a(x) + ⟨p(x)⟩ is the coset of ⟨p(x)⟩ represented by a(x).
Define a(x) = b(x) (mod p(x)) (a(x) is congruent to b(x) mod p(x)) to mean that

p(x) | a(x) − b(x)

In words, this means that a(x) and b(x) are congruent mod p(x) if they differ by a multiple of p(x). In equation form, this says a(x) − b(x) = k(x) · p(x) for some k(x) ∈ F[x], or a(x) = b(x) + k(x) · p(x) for some k(x) ∈ F[x].

Lemma 8.2.1. Let R be a commutative ring, and suppose a(x), b(x), p(x) ∈ R[x]. Then a(x) = b(x) (mod p(x)) if and only if a(x) + ⟨p(x) = b(x) + ⟨p(x).

Proof. Suppose a(x) = b(x) (mod p(x)). Then a(x) = b(x) + k(x) · p(x) for some k(x) ∈ R[x]. Hence,

a(x) + ⟨p(x) = b(x) + k(x) · p(x) + ⟨p(x) = b(x) + ⟨p(x)

Conversely, suppose a(x) + ⟨p(x)⟩ = b(x) + ⟨p(x)⟩. Then

a(x) ∈ a(x) + ⟨p(x)⟩ = b(x) + ⟨p(x)⟩

Hence,

a(x) = b(x) + k(x) · p(x)   for some k(x) ∈ R[x].

This means that a(x) = b(x) (mod p(x)).  □

Depending on the situation, it can be written a(x) = b(x) (mod p(x)) or a(x) + ⟨p(x)⟩ = b(x) + ⟨p(x)⟩.

Remark. In analogy to what we studied with ℤ/nℤ the set of residue classes modulo an integer n (the construction here is based on the polynomial ring K[x] rather than the ring ℤ), we can identify a congruence class by those polynomials which admit the same remainder r(x) when divided by p(x), as the next lemma shows.

Lemma 8.2.2. f(x) ≡ g(x) mod(p(x)) if and only if f(x) and g(x) have the same remainder when divided by p(x).

Proof. Let f(x) = q(x) · p(x) + r(x) and g(x) = s(x) · p(x) + t(x), where r(x) and t(x) are zero or have degrees less than that of p(x). Now the lemma follows because the following statements are equivalent:

f(x) ≡ g(x) mod(p(x)).

f(x) − g(x) ∈ (p(x)).

p(x)|f(x) − g(x).

p(x)|[{q(x) − s(x)} · p(x) + (r(x) − t(x))].

p(x)|[r(x) − t(x)].

r(x) = t(x).

Theorem 10.8. If F is a field, let P be the ideal ⟨p(x)⟩ in F[x] generated by the polynomial p(x) of degree n > 0. The different elements of F[x]/⟨p(x)⟩ are precisely those of the form ⟨p(x)⟩ + a0 + a1x + ··· + an−1 xn−1 where a0, a1, ..., an−1 ∈ F.

Proof. Let f(x) + P be any element of F[x]/⟨p(x)⟩ and let r(x) be the remainder when f(x) is divided by p(x). Then, by Lemma 8.2.2, f(x) + P = r(x) + P, which is of the required form. Suppose that r(x) + P = t(x) + P, where r(x) and t (x) are zero or have degree less than n. Then

r(x) ≡ t(x) mod(p(x)), and by Lemma 8.2.2, r(x) = t(x).  □

Example 8.2.3. Write down the tables for ℤ2[x]/(x2 + x + 1).

Solution. Let P = (x2 + x + 1), so that

ℤ2[x]/(x2 + x + 1) = {P + a0 + a1 x|a0, a1 ∈ ℤ2} = {P , P + 1, P + x, P + x + 1}.

The tables for the quotient ring are given in Table 10.2. The addition table is straightforward to calculate. Multiplication is computed as follows:

(P + x)2 = P + x2 = P + (x2 + x + 1) + (x + 1) = P + x + 1
and
(P + x)(P + x + 1) = P + x2 + x = P + (x2 + x + 1) + 1 = P + 1.

The multiplicative inverse of x is x + 1, since x(x + 1) = x2 + x = (x + 1) + x = 1.  ■

Nota bene. We have usually written the elements of ℤn = ℤ/(n) simply as 0, 1, ..., n − 1, or [0], [1], ..., [n − 1] instead of as 0 + (n), 1 + (n), ..., n − 1 + (n).

Quotient Polynomial rings that are fields
We shall see in next theorem that F[x]/⟨p(x)⟩ is a field when p(x) is irreducible.  ■

Theorem 8.2.4. Let a be an element of the euclidean ring R. The quotient ring R/(a) is a field if and only if a is irreducible in R.

Proof. Suppose that a is an irreducible element of R and let (a) + b be a nonzero element of R/(a). Then b is not a multiple of a, and since a is irreducible, gcd(a, b) = 1. By Theorem 9.9, there exist s, t ∈ R such that

sa + tb = 1.

Now sa ∈ (a), so [(a) + t] · [(a) + b] = (a) + 1, the identity of R/(a). Hence (a) + t is the inverse of (a) + b in R/(a) and R/(a) is a field.

Now suppose that a is not irreducible in R so that there exist elements s and t, which are not invertible, with st = a. By Lemma 4.8.3, δ(s) < δ(st) = δ(a) and δ(t) < δ(st) = δ(a) (where δ is the Euclidean valuation). Hence s is not divisible by a, and s ∉ (a). Similarly, t ∉ (a), and neither (a) + s nor (a) + t is the zero element of R/(a). However,

[(a) + s] · [(a) + t] = (a) + st = (a),   the zero element of R/(a).

Therefore, the ring R/(a) has zero divisors and cannot possibly be a field. □

Example 8.2.4. The polynomial x2 − 1 is clearly not irreducible in ℝ[x]. The quotient ℝ[x]/⟨x2 − 1⟩ is not a field. In fact,

Exercises
Take p(x) = x − 2 in Q[x]. Show that 2x2 + 3x + 5 = x2 + 4x + 7 (mod x − 2).

Find a rational number r such that x3 − 4x2 + x + 12 = r   (mod x − 2).

Solutions
Two polynomials are congruent mod x − 2 if they differ by a multiple of x − 2. The difference between the two polynomials is x2 − x −2 = (x − 2)(x+1), hence they are congruent modulo x − 2. ■

If the two polynomials differ by a multiple of x − 2, then 2 must be a root of their difference, then r = 6. ■

«Simple extensions
Index
Splitting Field»
]]





[[
https://gioretikto.github.io/mat/algebra/splitting_field.html
Splitting Field
A splitting field of a polynomial f is a ‘smallest’ field containing all the roots of f. This is only defined over a ‘base field’ F containing the coefficients of f. For example, if we regard x2 + 1 as a real polynomial, its splitting field is ℝ(i) = ℂ; but if we regard it as a rational polynomial, its splitting field is the much smaller field ℚ(i) = {a + bi : a, b ∈ ℚ}. Our goal in this section is to show that splitting fields exist and are unique (over a specified base field), up to isomorphism.

If p(x) ∈ F[x] is a polynomial of positive degree n over the field F, there exists an extension field E of F that contains n roots of p(x).

Definition 8.2.1 (Splitting Field) Let E be an extension field of F and let f(x) ∈ F[x] with degree at least 1. We say that f(x) splits in E if there are elements a ∈ F and a1, a2, ... ,an ∈ E such that

f(x) = a(x − a1)(x − a2) ... (x − an)

We call E a splitting field for f(x) over F if

E = F(a1, a2, ... , an).

E is called the splitting field (or root field) of p(x) because it is the “smallest” field over which p(x) “splits” into first-degree factors, that is there are no proper subfields of E, over which the polynomial splits.  □

Note that a splitting field of a polynomial over a field depends not only on the polynomial but on the field as well. Indeed, a splitting field of p(x) over F is just a smallest extension field of F in which f(x) splits. Just as it makes no sense to say "p(x) is irreducible,” it makes no sense to say "E is a splitting field for p(x).” In each case, the underlying field must be specified; that is, one must say "p(x) is irreducible over F" and "E is a splitting field for p(x) over F."

Example 8.2.2 x2 + 1 = (x + √−1) (x − √−1), splits in ℂ. When considering x2 + 1 as a polynomial over the field ℝ of real numbers, then ℝ(i), or the field ℂ of complex numbers, is the splitting field for x2 + 1 where

x2 + 1 = (x − i)(x + i).

However, if x2 + 1 is considered a polynomial over the field Q of rational numbers, then the splitting field of x2 + 1 is ℚ(i) = {r + si | r, s ∈ ℚ}.  ■

Example 8.2.3. Consider the polynomial p(x) = x2 − 5 ∈ ℚ[x]. The field ℚ(√5) is an extension of ℚ, contaning the roots ±√3 of f(x), thus p(x) splits over ℚ(√5) in linear factors

x2 − 5 = (x − √5) (x + √5)

Moreover ℚ(√5) is the smallest field containing a complete set of roots of p(x) and thus ℚ(√5) is a splitting field for the the polynomial x2 − 5. ■

Example 8.2.4. If we consider x2 + 1 as a polynomial with rational coefficients, then to obtain a splitting field we only need to adjoin i to ℚ. Thus ℚ(i) is a splitting field for x2 + 1 over ℚ. If we instead think to it as a polynomial with real coefficients, its splitting field is ℝ(i) = ℂ.  ■

As seen in the last examples it is important to specify over which field the polynomials splits. Further if of a polynomial p(x) ∈ F[x] we know the roots, the splitting field is easily found by adjoining the roots of p(x) to F. In other casese the task can be more difficult for example finding the splitting field of p(x) = x2 + x + 1 over ℤ2[x]. Such a polynomial has no roots in the field ℤ2. Another instance is a polynomial of large degree n over ℚ, with no rational roots; finding a field containing all roots of such a polynomial can be a daunting task. Our task in this section is to determine the splitting field of a polynomial p(x) ∈ F we do not know explicitly the roots.

We start off by considering a simpler problem: given a polynomial find a field containing a root of the polynomial. Take again the polynomial x2 − 5 ∈ ℚ[x]. Consider the ring

K = ℚ[x]/(x2 − 5)

The following properties hold

K is a field since x2 − 5 is irreducibile over ℚ.

K is an extension of ℚ; Consider the canonical projection

Ψ: ℚ[x] ⟶ ℚ[x]/(x2 − 5)
f(x) ⟼ f(x) + (x2 − 5)

The set ℚ̅ = {a + (x2 − 5) | a ∈ ℚ} is a field isomorphic to ℚ: indeed let a,b ∈ ℚ, a + (x2 − 5) = b + (x2 − 5) if and only if a = b. Thus

K = ℚ[x]/(x2 − 5) ⊇ ℚ̅ ≃ ℚ.

K contains a root α of x2 − 5; let α = to the class x + (x2 − 5), then

α2 − 5 = (x + (x2 − 5))2 − 5 = x2 + (x2 − 5) − 5
= x2 − 5 + (x2 − 5) = (x2 − 5)

which is the null class of ℚ[x]/(x2 − 5).

8.2.5. Example. From last example it is clear how to proceed to find a field containing all roots of the polynomial x2 + x + 1 ∈ ℤ2[x]. Being f(x) irreducible over ℤ2, ℤ2/(x2 + x + 1) is a field. The quotient field ℤ2[x]/(p(x)) consists of residue classes. By the division algorithm

f(x) = q(x)p(x) + r(x)   deg(r(x)) < deg(p(x))

Since f(x) = q(x)p(x) + r(x) and q(x)p(x) is already in the ideal (p(x)), then

f(x) + (p(x)) = r(x) + (p(x))   ∂r(x) < ∂p(x)

It results, ℤ2[x]/(x2 + x + 1) has four elements, and represents an extension of ℤ2:

Z2[x]/((p(x)) = {0 + (p(x)), 1 + (p(x)), x + (p(x)), 1 + x + (p(x))} ≃ ℤ2(ξ) = {a + bξ | a,b ∈ ℤ2, ξ2 + ξ + 1 = 0}

The last equality ℤ2(ξ) ≃ ℤ2[x]/(x2 + x + 1) by theorem 8.1.16 Theorem (c). Note how 0 + (p(x)) is the zero of the field and same element as x2 + x + 1 + (p(x)). The following are also the same elements x2 and x + 1 since x2 − (x + 1) = x2 + x + 1 as 1 = −1 in ℤ2, so we write x2 = x + 1 mod(x2 + x + 1).
1 + (p(x)) is the multiplicative identity of the field i.e. the multiplicative inverse of (x + 1) + (p(x)) is x + (p(x)) since (x+1)x = x2 + x = 1 mod (p(x)) or (x + 1 + (p(x))) (x + (p(x))) = 1 + (p(x))) ■

We can now consider the general case proving that for every polynomial f(x) ∈ F[x], with F an arbitrary field we are able to find a field containing a root of f(x). Then with an inductive method we shall prove that there exists a field containing all roots of f(x).

Lemma 8.2.6. Let p(x) ∈ F[x] an irreducible polynomial of degree n ≥ 1. Then there exists an extension E of F with [E:F] = n in which p(x) has a root.

Proof. We proceed analogously to what we have done in the example above. The field we are looking for is

F[x]/(p(x))

Indeed it is a field because (p(x)) is maximal being p(x) irreducible (see theorem 1.6.10); It is also an extension of F since the homomorphism Ψ

Ψ: ℚ[x] ⟶ ℚ[x]/(p(x))
f(x) ⟼ f(x) + (p(x))

it results that F[x]/(p(x)) contains a F̅ = {a + (p(x)) | a ∈ F} which is isomorphic to F. It is further a finite extension of degree n of F, since one of its basis is

1 + (p(x)),   x + (p(x)),  ...,  xn − 1 + (p(x))

Ultimately, the class α = x + (p(x)) is a root of p(x), since p(x) = xn + an − 1 + ... + a1x + a0, then

p(α) = α^n + a[n − 1]*α^(n − 1) + ... + a[1]*α + a[0]
p(α) = αn + an − 1αn − 1 + ... + a1 α + a0
= (x + (p(x))n + an − 1(x + (p(x)))n − 1 + ... + a1(x + (p(x))) + a0
= xn + (p(x)) + an − 1(xn − 1 + (p(x))) + ... + a1(x + (p(x))) + a0
= xn + an − 1 + ... + a1x + a0 + (p(x)) = (p(x)) = 0F[x]/(p(x)).  □

Lemma 8.2.7. Let f(x) ∈ F[x] an arbitrary polynomial of degree n ≥ 1. Then there exists a finite extension E of F in which f(x) has a root. We have further

[E : F] ≤ n

Proof. Let p(x) an irriducible factor of f(x). By the previous lemma there exists an extension E of F in which p(x) has a root (hence f(x) as well has a root), and [E : F] = ∂p(x) ≤ n.  □

Example 8.2.8. Let f(x) = 2x4 − 2x2 −4, it results f(x) = (2x2 − 4)(x2 + 1). Both factors of f are irreducible over ℚ. Let's consider 2x2 − 4. We just showed that the field E = ℚ[x]/(2x2 − 4) has a root of 2x2 − 4, hence it possesses a root of f(x) as well. It results [E : ℚ] = 2 < 4 = ∂f(x). □

Recalling the definition of algebrically closed field, the properties expressed by the following theorem hold

Theorem 8.2.9. Let K a field. The following propositions are equivalent

K is algebrically closed.

every non-constant polynomial f(x) ∈ K[x] can be factorized in terms of linear factors in K[x].

every non-constant polynomial f(x) ∈ K[x] has a root in K.

Proof. (a) ⇒ (b). By induction on the degree n of f. If n = 1, f is linear and there's nothing to prove. Let now n > 1 and suppose the theorem true for all polynomial of degree n < 1. Adjoining to K a root α of f, we obtain the extension K(α) = K, that is α ∈ K. Then there exists a g(x) ∈ K[x] such that f(x) = (x − α)g(x). The result follows by induction.

(b) ⇒ (c) is obvious.

(c) ⇒ (a). Suppose by contradiction that there exists a proper algebraic extension E of F: let α ∈ E \ F an element (obviously algebraic over K). Then α satisfies an irreducible polynomial of degree > 1 in F[x]: but this contradicts that by hyphothesis such a polynomial must have a root in F (thus it cannot be irreducible). □

Theorem 8.2.10. Let f(x) ∈ F[x] a polynomial of degree n ≥ 1. Then there exists an extension E of F of degree ≤ n! where f(x) has all the roots.

Proof. We proceed by induction on the degree n of the polynomial. For n = 1 the polynomial has all roots (i.e. only one) in F and thus E = F. Suppose to have proved the theorem for all polynomials of degree n − 1, and we prove it for polynomials of degree n. By the previous lemma, there exists an extension E0 of F, with [E0 : F] ≤ n, where f(x) has a root α. The in E0[x] we have the following factorization:

f(x) = (x − α)g(x),   g(x) ∈ E0,  ∂g(x) = n − 1.

By induction there exists a finite extension E of E0 with [E : E0] ≤ (n − 1)!, in which g(x) has n − 1 roots. Since the roots of f(x) are either the root α or the roots of g(x) it follows that the E is an extension of F which contains all roots of f(x).  □

Once that is proved that there exist a finite extension of F containg all roots of f(x), there eixits for sure a minimal field extension with the same property. Thus the theorem just proved guarantees the existence of a splitting field for every polynoial f(x) ∈ F[x]. The same theorem guarantees that the degree [E: F] has the upper bound n!, with n the degree of the polynomial.

Theorem 8.2.11. All splitting fields of a polynomial f(x) ∈ F[x] are isomorphic.

Before proving the theorem we need some additional definitions.

8.2.12 Definition. Let φ an isomorphism between two fields F and F'. If R and R' are two rings (or two fields) such that R ⊇ F and R' ⊇ F', then a isomorphism ψ between R and R' is called an extension of the isomorphism between F and F' if ψ|F coincides with φ.

Let now F and F' two isomorphic fields by an isomorphism τ. It is possible to extend such an isomorphism τ to an isomorphism τ̅ between F[x] and F'[x] by letting

τ̅̅: F[x] ⟶ F'[x]
x ⟼ x
a ⟼ τ(a)   ∀a ∈ F

If f(x) = ∑ni=1 aixi, then τ̅̅(f(x)) = ∑ni=1τ(ai)xi.

Theorem 8.2.13. Let τ a isomorphism between two fields F and F' and let f(x) and f'(x) two polynomials such that f'(x) = τ̅̅(f(x)), with τ̅̅ the isomorphism defined above. Let E a splitting field for f(x) and E' a splitting field for f'(x). Then the isomorphism τ between F and F' can be extended to a isomorphism Ψ between E and E'.

Proof. We proceed by induction on k, the number of roots of f(x) not belonging to F. If k = 0, then all roots of f(x) are in F, hence f(x) is splitted in F into linear factors and E = F. By the isomorphism τ̅̅, f(x) = τ̅̅f)(x) is splitted as well in F', hence E' = F' and Ψ = τ.
Suppose now to have proved the theorem for every polynomial with at last k − 1 roots not in F, then we have to prove it for the case of f(x) having k roots not in F. By factorizing f(x) in irreducible factors on F:

f(x) = p1(x)p2(x) ... pr(x),   pi ∈ F[x]

and let

f'(x) = p1'(x)p2'(x) ... pr'(x),   pi' ∈ F'[x]

the corresponding (through τ̅̅) factorization of f'(x). At least on of the two factors pi(x) (let it p1(x)) must have degree strictly greater than 1, otherwise all roots would in F and k = 0, a case which has already been proved. Let α a root of p1(x). Then f'(x) = τ̅̅f((x)) as well, has an irreducible factor, p'(x), of degree strictly greater than 1, and let α' a root of p'(x). Let n = deg(p1(x)), the mapping

F[x]/(p1(x)) ⟶ F'[x]/(p'1(x))
∑n−1i=0 aixi + (p1(x)) ⟼ ∑n−1i=0 a'ixi + (p'1(x)),   ai' = τ(ai)

is an isomorphism (verify it). On the other hand the following isomprhisms hold

F(α) ≃ F[x]/(p1(x))
a0 + a1 α + ... + an−1αn−1 ⟼ a0 + a1 x + ... + an−1xn−1 + (p1(x))

and

F(α) ≃ F'[x]/(p1(x))
a'0 + a1' α + ... + a'n−1αn−1 ⟼ a'0 + a1' x + ... + a'n−1xn−1 + (p'1(x))

By the transitivity property of the isomorphism, it follows that

F(α) ≃ F'(α')
a'0 + a1' α + ... + a'n−1αn−1 ⟼ a0 + a1 α + ... + an−1αn−1

The last isomorphism that we call Ψ is an extension of τ. Let's sart now by the field F(α) and F'(α') = Ψ(F(α)). Then f(x) has at last k − 1 roots not in F'(a'). Thus Ψ, by the inductive hyphotesis can be externded to an isomorphism Ψ̅̅ between E and E'. This isomorphim Ψ̅̅ is clearly as well an extension of the isomorphism τ.  □

Corollary 8.2.14. All splitting fields of a polynomial f(x) ∈ F[x] are isomorphic to an isomorphism that fixes F.

Proof. In the previous theorem let F' = F and τ is the identity mapping. If E and E' are two splitting fields of f(x) then E ≃ E' by the previous theorem.  □

Corollary 8.2.15. Let p(x) ∈ F[x] an irreducible polynomial and let α and β two roots of p(x). Then

F(α) ≃ F(β)

by an isomorphism that maps α to β leaving fixed the remaining elements of F.

Proof. The isomoprhisms of Theorem 8.2.13 become

F(α) ≃ F[x]/(p(x)) ≃ F(β)
α0 + a1 α + ... + an−1αn−1 ⟼ a0 + a1 x + ... + an−1xn−1 + (p1(x))
⟼a0 + a1 β + ... + an−1βn−1 □

For example the three roots of the irreducible polynomial x3 − 2 over ℚ are ∛2, ∛2ζ, ∛2ζ2, with ζ primitive root of unity. It results

ℚ(∛2) ≃ ℚ(∛2ζ) ≃ ℚ(∛2ζ2)

Every isomorpshim fixes the elements of ℚ and maps a root to another root. Note that the hyphotesis that p(x) is essential and also that all the three extensions do not represent a splitting field for x3 − 2, which instead is ℚ(∛2, ζ) and has degree 6: looking at the subfield tower (Theorem 8.1.4) we compute their degrees [ℚ(∛2, ζ) : ℚ] = [ℚ(∛2, ζ) : ℚ(∛2)] ⋅ [ℚ(∛2) : ℚ], the last term is 3 by Theorem 8.1.17 point d), whilst the first is 2.

Proposition 8.2.16. For every positive integer n ∈ ℕ, the splitting field of xn − 1 over ℚ, is ℚ(ζ) with ζ an arbritary primitive n-th root of unity. It results [ℚ(ζ): ℚ] = φ(n), with φ(n) Euler function of n.

Proof. Let ζ be a primitive root of unity, so it satisfies xn − 1 = 0 for some n, hence it is algebraic over ℚ. All the n-th roots of units are powers of a primitice root of unity, thus to obtain the splitting field it suffices to adjoin to ℚ an arbitrary primitive n-th root of unity. Further it results [ℚ(ζ): ℚ] = φ(n) since the minimal polynomial of ζ is the n-th polynomial, Φn(x), which is irreducible over ℚ and has degree φ(n).  □

«Field Extensions
Index
Exercises on splitting fields»
]]

[[
https://gioretikto.github.io/mat/algebra/simple_extensions.html
Simple Extensions
We shall se now how given a field F and one of its extension K, is possible to obtain intermidiate extensions between K and F. Usually if you just add a random element to a field, you lose the closure property and the inverse property unless you also add a whole slew of other elements; thus we follow a different path.
Starting with a field F and a subfield K. If u ∈ F, what can be said about the subfields of F that contain both u and K? Is there a smallest such subfield? The answer to the first two questions is quite easy. Let F be an extension field of K and u ∈ F. Let K(u) denote the intersection of all subfields of F that contain both K and u (this family of subfields is nonempty since F at least is in it). Since the intersection of any family of subfields of F is itself a field (Exercise 1), K(u) is a field. By its definition, K(u) is contained in every subfield of F that contains K and u, and, hence, K(u) is the smallest subfield of F containing K and u. K(u) is said to be a simple extension of K.
It turns out that the structure of K(u) depends on whether or not u is the root of some polynomial in F[x].

Definition 8.2.1. Let F a field, and let a1, a2, ..., an be elements of some extension E of F. We use F(a1, a2, ..., an) to denote the smallest subfield of E that contains F and the set {a1, a2, ..., an}. Next theorem shows that F(a1, a2, ..., an) is the intersection of all subfields of E that contain F and the set {a1, a2, ..., an}.

Let K an extension of F and let S a subset of K. We indicate as

F[S]   the intersection of all subrings of K containing F and S
F(S)   the intersection of all subfields of K containing F and S

Then it results

F[S] ⊆ F(S) ⊆ K

In addition F(S) is the quotient field of F[S]. On the other hand, a union of subfields is not in general a subfield as the following figure shows

Q adjoined with square roots of 2
Adjoining ±√2 to ℚ, does not create a field, since there are elements as 1 + √2 and 3 ⋅ √2. So ℚ ∪ {+√2} ∪ {−√2} is not a field. Instead ℚ(√2) is a field.
Example 8.2.2. Let F be any field and let x1, ..., xn be independent variables. The polynomial ring F[x1, ..., xn] is an integral domain (see Proposition 4.3). The quotient field of F[x1, ..., xn] is denoted F(x1, ..., xn). It consists of all fractions f/g, with f,g ∈ F[x1, ..., xn] and g ≠ 0, and the usual addition and multiplication. Then F(x) is an extension of F. ■

We now want to know which are the elements of F(S). We start by adding a single elements to a field F, i.e we study the case S = {a} that is F(S) is a simple extension. The standard procedure for constructing the complex numbers from the real numbers is to ‘adjoin’ a square root of −1; that is, an element i satisfying i2 + 1 = 0. We will now describe this procedure, ‘adjoining the root of a polynomial’, in more detail.

8.2.3 Proposition. Let K an extension of F and let a ∈ K. Then F(a) = T where T is the defined as the set

T = { α 0 + α 1 a + α 2 a 2 + … + α s a s ( β 0 + β 1 a + β 2 a 2 + … + β t a t ) ≠ 0 | a i , β j ∈ F , s , t ∈ N }
Proof. Given an extension field K of F and an element a ∈ K, any subfield that contains F and a must be closed under sums and products, so it must contain all elements of the form α0 + α1 a + ... + αnan, where αi ∈ F for 0 ≤ i ≤ n. Furthermore, since it must be closed under division, it must contain all elements of the form

(α0 + α1 a + ... + αnan) / (β0 + β1 a + ... + βnan)

such that the denominator is nonzero. We clearly have

T ⊆ F(a)

since that T is a field containing F and a. The reverse inclusion holds as well, F(a) ⊆ T, since the elements of T must be contained in every field containing F and a.  □

Example 8.2.4. Let F = ℚ, K = ℝ and a = π, then

Q ( π ) = { α 0 + α 1 π + α 2 π 2 + … + α s π s ( β 0 + β 1 π + β 2 π 2 + … + β t π t ) ≠ 0 | a i , β j ∈ Q , s , t ∈ N }
ℚ(π) means the smallest possible subfield of ℝ containing π and all ℚ. Notice how ℚ is a field, but the set ℚ ∪ {π} is not even a ring, much less a field.  ■

Example 8.2.5. Let F = ℚ, K = ℝ and a = √3, then

Q ( 3 ) = { α 0 + α 1 3 + α 2 3 2 + … + α s 3 s β 0 + β 1 3 + β 2 3 2 + … + β t 3 s | α i , β j ∈ Q , s , t ∈ N , β 0 + β 1 3 + β 2 3 2 + … + β t 3 t ≠ 0 }
However given that √32 = 3, the expressions inside ℚ(√3) can be reduced to

Q ( 3 ) = { α 0 + α 1 3 ( β 0 + β 1 3 ) ≠ 0 | α i , β j ∈ Q }
But

1 β 0 + 3 = β 0 − β 1 3 β 0 2 − 3 β 1 2 = β 0 β 0 2 − 3 β 1 2 − ( β 1 β 0 2 − 3 β 1 2 ) 3
and

β 0 β 0 2 − 3 β 1 2 , β 1 β 0 2 − 3 β 1 2
are bot elements of ℚ. Thus the elements of ℚ(√3) can be all be written in the form q0 + q1 √3, with q0, q1 ∈ ℚ. Then

ℚ(√3) = {q0 + q1√3 | q0, q1 ∈ ℚ} □

In the last case we have seen that the extension can be simplified, whilst in the first case it wasn't possible. The reason behind this behavior lies down to the specific nature of the element a we are adjoining.

Definition 8.2.14. Let K be an extension field of F and let a ∈ K. If there exists a nonzero polynomial f(x) ∈ F[x] such that f(a) = 0, then a is said to satisfy the polynomial f(x) and to be algebraic over F. Otherwise, a is said transcendental over F.  □

Remark. When a real number is called transcendental, it usually means that it is transcendental over ℚ. For example, it was proved by Lindemann that π is a transcendental number; there is no nozero f(x) ∈ ℚ[x] with f(π) = 0. ■

Example 8.2.6. For instance, the number √2 is an element of ℝ that is algebraic over ℚ, because it is a root of x2 − 2 ∈ ℚ[x]. Of course, √2 is also a zero of x3 − 2x and of x4 − 3x2 + 2 = (x2 − 2)(x2 − 1). Both these other polynomials having 2 as a zero were multiples of x2 − 2. Another example is ∛2 and (4 + √2)1/5 are algebraic over ℚ since they are zeros of x3 − 2 and (x5 − 4)2 − 2 respectively. ■

Example 8.2.7. In the extension field ℂ of ℝ, i is algebraic over ℝ because i is the root of x2 + 1 ∈ ℝ[x]. You can easily verify that element 2 + i of ℂ is a root of x3 − x2 − 7x + 15 ∈ ℚ[x]. Thus 2 + i is algebraic over 0.  ■

Example 8.2.8. Every element c in a field F is algebraic over F because c is the root of x − c ∈ F[x].  ■

The familiar constants e and π are transcendental over ℚ. The analytic proofs lie beyond the scope of this book. That e is transcendental was proved by Charles Hermite (1822–1882) in 1873, and the corresponding result for π was proved by the German mathematician Ferdinand Lindemann (1852–1939) in 1882. It is well known that eπ is transcendental, while it is not known the nature of πe.

Theorem 8.2.9. Let F a field and K an extension of F. Let a ∈ K, the mapping

Ψa: F[x] ⟶ K
f(x) ⟼ f(a)

is a ring homomorphism with Im Ψa = F[a] known as the evaluation homomorphism.

Proof. For every f,g ∈ F[x] it results

Ψa(f+g) = (f + g)(a) = f(a) + g(a) = Ψa(f) + Ψa(g)
Ψa(fg) = (fg)(a) = f(a) g(a) = Ψa(f) Ψa(g)

Thus this is a ring homomorphism.

The image of the homomorhism Im Ψa is a subring of K which contains F and a, thus it contains F[a]. On the other hand, if t is an element in Im Ψa, then t = Ψa(f) for some f ∈ F[x]. If

f(x) = ∑ni=0 αixi,   αi ∈ F

then

t = Ψa(f) = ∑ni=0 αixi ∈ F[a]

thus Im Ψa = F[a]. □

Corollary 8.2.10. Let F a field and let K an extension of F. Given a ∈ K and Ψa the evaluation homomorphism, a results algebraic if and only if Ker Ψa ≠ 0 (thus a is transcendental if and only if Ker Ψa ≠ 0).

Theorem 8.2.11. Let F a field, K an extension of F and a transcendental over F, then there exists an isomorphism between F(a) and the field of rational functions F(x) with coefficient in F. In particular, [F(a) : F] is infinite.

Proof. From theorem 8.2.9, corollary 8.2.10 and the fundamental homomorphism ring theorem, follows that

F[a] ≃ F[x]

Then their quotient fields are isomorphic as well, i.e.:

F(a) ≃ F(x)

[F(a) : F] is infinite because: 1, a, a2, ..., ai, ... are linearly independent over F.  □

Remark. The vectors 1 = a0, a, a2, ..., ai are linearly independent only when a is transcendental. If a were algebraic over F, e.g. consider the algebraic a = √2, over the reals, we'd have a2 − 2 = 0, which is linear dependent combinations of powers. □

Thus if K is an extension of F, all the extension of F(a) with a transcendental over F are mutually isomorphic; the element a can be regarded as an unknown x and F(a) can be identified with rational function in the indeterminate x.

Next theorem shows how the finite or infinite nature F(a) over F determines whether a is algebraic or transcendental over F.

Definition 8.2.12. Let K be an extension of a field F. Let α ∈ K be algebraic over F. We define the minimal polynomial of α over F as the unique monic, irreducible polynomial p in F[x] that has α as a root. □

8.2.13 Theorem. Let K an extension F and let a an algebraic element over F. Then, if Ψa is the evaluation homomorphism from F to K,

Ker (Ψa) = (p(x)) where p(x) is a monic irreducible polynomial in F[x] known as the minimal polynomial of a over F.

A polynomial f(x) ∈ F[x] has a zero in a, if and only if p(x) divides f(x);

F(a) = F[a] and F(a) ≃ F[x]/(p(x));

[F(a) : F] = deg p(x) and F(a) has basis 1, a, a2, ..., an − 1

Proof.

From the fundamental theorem on ring homomorphism, we have

F[a] ≃ F[x]/ Ker Ψa

Now, F[a] as subring of a field, is an integral domain (see Proposition 6.1.5), hence by Theorem 1.6.11 Ker Ψa is a prime ideal hence generated by an irreducible element; The division of this polynomial by its leading coefficient yields a monic polynomial with minimal degree zeroed by a.

A polynomial f(x) ∈ F[x] is such that f(a) = 0 if and only if f(x) ∈ Ker Ψa and thus if and only if p(x) | f(x).

It results F(a) = F[a], since under current hypothesis (Ker Ψa is generated by an irreducible element) the quotient F[x]/ Ker Ψa, and thus F[a] are fields. Since F[a] contains are F and a, it follows that F[a] = F(a) and F(a) ≃ F[x]/p(x).

Let n the degree of p(x). We prove that the element 1, a, a2, ..., an − 1 are a basis for F[a] (= F(a)). We prove first the linear independence; Let

∑ i = 0 n − 1 α i a i = 0 , α i ∈ F
and consider the polynomial f(x) = ∑n − 1i=0 αixi ∈ F[x]. Since f is a polynomial zeroed by a, it belongs to Ker Ψa, thus a multiple of p(x) (by point a) being a zero of f is the same as being in Ker(Ψa), and this is the ideal ⟨p(x⟩ which is exactly all the multiples in F[x] of the polynomial p(x)).
Being, n the degree of p(x), whilst n − 1 that of f(x), f(x) must necessarily be a null polynomial thus all the αi must be null. The linear independence of 1, a, a2, ..., an − 1 is thus proved. We now prove that the 1, a, a2, ..., an − 1 are generators of F[x]. If s is an element of F[a], there exists a polynomial f(x) ∈ F[x], such that s = Ψa(f(x)) = f(a). Dividing f(x) by p(x) we obtain

f(x) = q(x)p(x) + r(x),   r = 0 or deg(r(x)) < deg(p(x))

Evaluating the relation in a we obtain

f(a) = q(a)p(a) + r(x) = q(a) ⋅ 0 = r(a)

We managed to express s = f(a) as linear combination of elements 1, a, a2, ..., an − 1, which are thus generators.  □

Notice how the writing f(a) = α0 + α1a + α2 a2 + ... + αn −1an − 1 of every element F[a] is unique, since the elements 1, a, a2, ..., an − 1 represent a basis.

8.2.14 Corollary. Let K an extension of the field F and let a ∈ K. Then a is algebraic if and only if F(a) is a finite extension, whilst is transcendental if and only if F(a) is an infinite extension.

Proof. If a is transcendental, by theorem 8.2.11 we know that F[x] ≃ F(a), and [F(a) : F] is infinite because: 1, a, a2, ..., ai, ... are linearly independent over F.

If a is algebraic, by theorem 8.2.13(c) we know that in this case F[a] is a field such that F[a] = F(a). The minimal polynomial has degree n = [F(a) : F] and F(a) has the finite basis: 1, a, a2, ..., an − 1.  □

Nota bene: "simple" doesn't mean finite in the sense of degree, = vector-space dimension. ℚ(π) is a simple extension of ℚ, since {π} has just one element, but it's infinite-dimensional since π is transcendental.

8.2.15 Example. We've thus characterized simple extensions. Suppose now to build the extension ℚ(S), with S = {√3, √5} and calculate its degree in ℚ. We proceed in this way: we adjoin first √3 obtaining the extension ℚ(√3) and then adjoin the element √5 to ℚ(√3). With the aid of theorem 8.2.16 we can easily calculate the degree of the extension. √3 is algebraic over ℚ, of degree 2 since its minimal polynomial is x2 − 3; By theorem 8.2.16 ℚ(√3) ≃ ℚ([x]/(x2 − 3). We now adjoin √5 to ℚ(√3). The polynomial x2 − 5 is irreducible (not only over ℚ, but also) over ℚ(√3) (Why? see the exercises). Thus the extension ℚ(√3,√5) = (ℚ(√3))(√5) has degree two over ℚ(√3). Then by theorem 8.2.4 we have

[ℚ(√3)(√5) : ℚ] = [ℚ(√3,√5) : ℚ(√3)][ℚ(√3) : ℚ] = 2 ⋅ 2 = 4.

Since a basis of ℚ(√3,√5) over ℚ(√3) is {1, √5} and a basis over ℚ(√3) over ℚ is {1,√3}, a basis of ℚ(√3,√5) over ℚ is given (se theorem ) by

1, √3, √5, √3√5 = √15

and

ℚ(√3)(√5) = {a + b√3 + c√5 + d√15 | a,b,c,d ∈ ℚ}

If we had ℚ(√2)(√3), then we would have also added √6 "accidentally".

Algebraically Closed Fields and Algebraic Closures
We are now able to prove the following theorem.

8.2.16 Theorem. Let K an extension of F. Then the algebraic elements of K, over F make a subfield of K.

Proof. It suffices to prove that if a and b are algebraic over F, then are so a ± b, ab and a/b.
Let a of degree n, and b of degree m. Then

[F(a) : F] = n

Since b is algebraic of degree m over F, it is algebraic of degree ≤ m over F(a), (Say F is ℚ, a = √2, b = √a = 21/4. The minimal polynomial of b over ℚ is x4 − 2, but over ℚ(a) = ℚ(√2), it's x2 − √2, with degree 2 < 4)

It follows that

[F(a,b) : F] = [F(a,b) : F(a)] [F(a) : F] ≤ nm

Now, a ± b, ab and a/b are all in F(a,b) that is F(a ± b), F(ab), F(a/b) which is a finite extension of F. By corollary 8.2.17 a ± b, ab and a/b are all algebraic over F.  □

Remark 8.2.17. In the previous theorem we proved that if a and b are algebraic respectevely of degree n and m then a ± b, ab and a/b are algebraic of ≤ nm. □

Remark 8.2.18. The set A of all algebraic numbers over ℚ is the field of algebraic numbers. This field is an extension of ℚ, in which every element a ∈ A is algebraic and thus [ℚ(a) : ℚ] < ∞, and

[A : ℚ] = ∞

Suppose instead that [A : ℚ] = n. We shall show there exists an element a in ℚ of degree greater than n. It suffices to take for example

a = 21/(n + 1)

which is the root of the polynomial (irreducible over ℚ) xn+1 − 2. Thus this polynomial is the minimal polynomial for a having degree n + 1. It results then

[ℚ(a) : ℚ] = n + 1 > [A : ℚ] = n

contradicting the fact that a ∈ A.  □

So A is a subfield of ℂ which is algebraic over ℚ i.e. consists of algebraic numbers. It contains 1,2,3/5,sqrt(2),i,1/2+cbrt(7/3)/5 etc..

Definition 8.2.19. An extension K of a field F is said algebraic if every element of K is algebraic over F.  □

For example, the field of complex numbers ℂ is an algebraic extension of ℝ as every element a + ib in ℂ, satisfies the polynomial in ℝ[x]:

x2 − 2ax + (a2 + b2)

Every finite extension of a field F is an algebraic extension, but the converse is not true: indeed for example A is an algebraic extension, but infinite.

Theorem 8.2.20. Let L an algebraic extension of K and let K an algebraic extension of F. Then L is an algebraic extension over F.

Proof. To prove the theorem it suffices to show that every element of L belongs to a finite extension of F. Let l ∈ L. Since l is algebraic over K, then l is a root of the polynomial

k0 + k1x + k2x2 + ... + knxn   ki ∈ K

Now, every ki, as element of K, which is algebraic over F, is algebraic over F and thus

[F(k0) : F] < ∞,   [F(k0, k1) : F] < ∞, ..., [F(k0, k1, ..., kn): F] < ∞

Adjoining now l to F(k0, k1, ..., kn), it results

[F(k0, k1, ..., kn)(l):F] =
[F(k0,k1, ..., kn)(l) : F(k0,k1, ..., kn)] [F(k0,k1, ..., kn):F]

The first term on the R.H.S. is < ∞, since l is algebraic over F(k0,k1, ..., kn) because it satisfies a polynomial with coefficient in F(k0,k1, ..., kn), the second term is < ∞ for what said before. As element of a finite extension of F, l is algebraic over F.  □

Definition 8.2.21. A field F is said algebraic closed if it has no proper algebraic extensions, that is, no algebraic extensions E with F < E.  □

A field is algebraically closed if every non-constant polynomial in F[x] has a root in F, that is a field F is algebrically closed if every polynomial splits in linear factors over F.

ℝ is not algebraically closed, because the polynomial equation x2 + 1 = 0 has no solution in real numbers, even though all its coefficients (1 and 0) are real. No finite field F is algebraically closed, indeed it sufficed to consider a polynomial of finite degree whose roots are all elements of the field. Adding a unit to it, we get a polynomial that has no root: (x − a1)(x − a2) ⋯ (x − an) + 1, has no zero in F. By contrast, the fundamental theorem of algebra states that the field of complex numbers is algebraically closed. Another example of an algebraically closed field is the field of (complex) algebraic numbers.

Theorem 8.2.22. The field A of all algebraic numbers over ℚ is algebraic closed.

Proof. It suffices to prove that the roots of every polynomial with algebraic numbers are algebraic. Let f(x) = xn + an−1xn−1 + ... + a0 a polynomial with coefficients in A. We consider the extension

K = ℚ(a0, a1, ..., an−1)

It is a finite extension of ℚ. Let s an arbitrary root of f(x). Then K(s) is a finite extension of K, because s is algebraic over K. But then K(s) is a finite extension of ℚ as well, and s is algebraic. □

|K(s) : ℚ| finite means |ℚ(s) : ℚ| is also finite (it's no bigger than that first number), and this is what s being algebraic over ℚ means. ℚ(s) is a vector subspace of K(s), which is finite-dimensional over ℚ. So ℚ(s) is also finite-dimensional. ℚ(s) is finite-dimensional over ℚ iff s is algebraic over ℚ.

The most familiar example of an algebraically closed field is ℂ, which is so by the fundamental theorem of algebra.

«Quotient rings of polynomial rings
Index
Splitting Field»
]]

[[
https://gioretikto.github.io/mat/algebra/quotient_rings.html
Home
Index
Equivalence relations in a ring; Quotient rings
Let (R, +, ⋅) a ring. Analogously to the definition of congruences on ℤ we give the following definition:

6.3.0 Definition A relation ρ defined in a ring R is said to be compatible with the operations of R if for each a1, a2, b1, b2 ∈ R.

a1 ρ a2,   b1 ρ b2  ⇒  	(a1 + b1) ρ (a2 + b2)
(a1 ⋅ b1) ρ (a2 ⋅ b2)
The equivalence relation defined on ℤ as we have seen is compatible with both operations of ℤ.

We observe now, that assigning in a ring R an equivalence relation combpatible with both operation is equivalent to assigning to it a two-sided ideal.

6.3.1 Definition Let ρ an equivalence relation definef on R compatible with its operations. Then the subset

I := {x ∈ R | x ρ 0}

is a two-sided ideal.

Proof. We have to prove that for each x,y ∈ I, and r ∈ R, we have x − y ∈ I and xr ∈ I, rx ∈ I.

x,y ∈ I   ⇒   x ρ 0, y ρ 0 ⇒ x ρ y,   −y ρ −y.

since ρ is compatible with regards to addition, it follows that (x − y) ρ 0, hence xr ∈ I. Thus, if x ∈ I and r ∈ R,

x ρ 0

r ρ r

imply owning to the compatibility of ρ with regards to multiplication, that xr ρ 0, hence xr ∈ I. Analogously, we prove that rx ∈ I.□

6.3.2 Proposition. Let I a two-sided ideal of a ring R. The relation ρ defined on R as

x ρ y   ⇐⇒   x − y ∈ I

is an equivalence relation compatible with the operation of R called the congruence modulo I.

Proof. That ρ is an equivalence relation is easy to verify. Let's prove the compatibility with the operations. Let x1 ρ x2 and y1 ρ y2. Then

x1 ρ x2   ⇐⇒   x1 − x2 ∈ I

y1 ρ y2   ⇐⇒   i1 − y2 ∈ I

yields since an ideal is an additive subgroup to

(x1 + y1) − (x2 + y2) = (x1 − x2) + (y1 − y2) ∈ I.

thus x1 + y1 ρ x2 + y2 and ρ is compatible with addition. Moreover

x1y1 = x1y1 − x1y2 + x1y2 = x1 (y1 − y2) + (x1 − x2) y2 ∈ I.

hence ρ is compatible with multiplication too.□

We define the following sets

𝓡 := {equivalence relations defined on R, compatible with the operation on R}

𝓘 := {two-ideals of R}

The map

Ψ: 𝓡 ⟶ 𝓘

             ρ ⟼ I = {x ∈ R | x ρ 0}

is a biunique map between 𝓡 and 𝓘 which inverse is.

Ψ*: 𝓘 ⟶ 𝓡

             I ⟼ ρ   where x ρ y ⇐⇒ x − y ∈ I

To sum up, we've the following proposition

6.3.3 Proposition. All and the only relations compatible defined on a ring R are the congruences modulo an ideal.

6.3.4 Proposition. The relations in ℤ compatible with addition and multiplicatoin are exactly congrunces modulo n. The ideals are all and only the subset In of the form nℤ

x ρ y   ⇐⇒   x − y ∈ In = nℤ

hence x − y = kn for some k ∈ ℤ.

If ρ is an equivalence relation defined on the ring R and compatible with the operations of R, in the quotient set

R/ρ = {a̅ | a ∈R},   with a̅ = {x ∈ R | x ρ a}

we introduce the following operations

a̅ + b̅ := a + b,   a̅ ⋅ b̅ := a⋅b

compatibility of equivalence relations guarantee that these two operations are well-defined: indeed if they are well-defined it is implied that given a2 related to a1 and given b2 related to b1, then a1 + b1 is related to a2 + b2 and a1 ⋅ b1 is related to a2 ⋅ b2 which is exaclty the meaning of compatible equivalence relation.

Since an equivalence relation on R, corresponds to an ideal I of R, in such a way that ρ is defined by

x ρ y   ⇐⇒   x − y ∈ I

the quotient R/ρ can be indicated as R/I, where

R/ρ := {a + I | a ∈ R}

with

[a] = a + I := {a + i | i ∈ I} = {x ∈ R | x ρ a}

Endowed with the operations defined above, R/I has the structure of ring called quotient ring modulo an ideal I or factor ring. The zero of this ring is the class I, the opposite of the class a + I is the class −a + I, etc. Note that

r + I = s + I   iff   r − s ∈ I.

Example 6.3.5. For R = ℤ, I = 4ℤ, we have that

I = {..., −4, 0, 4, 8,...}

1 + I = {...,,−3, 1, 5, 9 ,...}

2 + I = {..., −2, 2, 6, 10,...}

3 + I = {...,,−1, 3, 7, 11, ...}

There are 4 different cosets, the equivalence classes for

[r] ∼ [s]   ⇐⇒   r ≡ s mod 4.

So 2 + I = 6 + I, 3 + I = −1 + I, etc.

Moreover owning to the definition of the operations in R/I, the application π from R to R/I which maps every element a of R to the class a + I to which it belongs and called quotient homomorphism or canonical projection. This is a surjective ring homomorphism hence an epimorphism.

To sum up what presented in this paragraph we state the following proposition

6.3.6 Proposition. Let I an ideal of a ring R.

The relation

x ρ y   ⇐⇒   x − y ∈ I

is an equivalence relation compatible with the operation in R.

Indicating the equivalence classes as

a̅ = a + I = {a + i | i ∈ I}

and defining the operations

a̅ + b̅ := a + b,   a̅ ⋅ b̅ := a ⋅ b

or equivantely as

(a + I) + (b + I) = (a + b) + I,   (a + I) (b + I) = ab + I

The quotient set R/I = {a̅ | a ∈ R} becomes a ring, known as the quotient ring of R modulo an ideal I.

The canonical projection

π: a ∈ R ⟼ a̅ ∈ R/I

is easily seen to be an epimorphism of rings, with kernel I.

Lemma 6.3.7 Lemma R a ring with unit with quotient ring R/I. Let a be a unit of R. Then a + I is a unit of R/I.

Proof. (a + I)(b + I) = ab + I if a is the unit we get b + I.□

Example 6.3.8 (ℤ/nℤ). The most familiar quotient ring is ℤ/nℤ, for which we will continue to use the notation ℤn (they are the same) whose elements can be written as cosets of the form a + nℤ.

a + nℤ = [a] = {..., a −2n, a − n, a, a + n, a + 2n, ...}

and we recognize [a] as a residue class of ℤn.

Addition and multiplication of cosets is then just addition and multiplication modulo n, as we can see, that this is just a formalization of the ring ℤn, that we have already looked at. Recall that ℤn is an integral domain if and only if n is prime and ℤn is a field for precisely the same n. If n = 0 then ℤ/nℤ is the same as ℤ.

Operations with ideals
If A and I are two ideals of the ring R, then their sum A + I is the set

A + I = {a + i | a ∈ A, i ∈ I}

It is easy to see that A + I is an ideal of R, the minimal ideal of A which contains both I and A. Equivalentely, A + I is the ideal generated by A ∪ I.

The product AI is the ideal generated by all products ai, the set of all possible sums

a1i1 + a2i2 + ... + anin

that is

IJ := {∑ni=0 aibi | n ∈ ℕ, ai ∈ I, bi ∈ J}

The product AI is contained in the ideal intersection A ∩ I.

6.3.9 Proposition. Let R a ring, I one of its ideal and A a subring of R such that A ⊇ I. Then A = (A + I).

Proof. We prove by showing double inclusion. For a ∈ A, and i ∈ I, a + i in A, so we have A + I ⊂ A; this is because A is an additive subgroup of R so if you sum two elements of it, it remains in A (closusre under +). Conversely, we have for a ∈ A that a = a + 0, and 0 is an element of I, so a ∈ A + I, which gives us A ⊂ A + I. □

«Ring and ring's isomorphisms
Index
The Fundamental ring homorpshims theorem»
]]

[[
]]


[[
]]

[[
]]

[[
]]

quotient_rings
[[
]]
[[
cd /sdcard/Download/
wget https://gioretikto.github.io/mat/algebra/quotient_fields.html
view /sdcard/Download/quotient_fields.html
../../style.css
https://gioretikto.github.io/style.css
wget https://gioretikto.github.io/style.css
view /sdcard/Download/style.css
    background: #1e2a37;
    background:#d1d1d1;
    background-color:#F2F2F2;
    background-color: #374936;
    background: #751414;
    background: rgba(0,0,0,0.1);

wget https://gioretikto.github.io/mat/algebra/index.html
{get_text,list_tags,www_zhihu_com}
html2text -i /sdcard/Download/index.html -o ~/my_tmp/out4py/html2text/gioretikto.github.io.mat.algebra.index.html.-get_textout.txt
view ../../../tmp/out4py/html2text/gioretikto.github.io.mat.algebra.index.html.-get_textout.txt
html2text -i /sdcard/Download/index.html -ver list_tags
a
article
body
h2
h3
head
html
i
li
link
meta
nav
p
sub
title
ul
html2text -i /sdcard/Download/index.html -o ~/my_tmp/out4py/html2text/gioretikto.github.io.mat.algebra.index.html.-www_zhihu_com.txt -ver www_zhihu_com
view ../../../tmp/out4py/html2text/gioretikto.github.io.mat.algebra.index.html.-www_zhihu_com.txt

wget  https://en.wikipedia.org/wiki/Quotient_ring
    fail
]]

]]]]]
]]]]]]]
