#__all__:goto
r'''[[[
e ../../python3_src/seed/math/uint_partition.py
view script/拆分冫幂方纟奇数.py
    泛化:3**3==27==1+6+12+8#魔方

十五爻元密钥纟三爻元置换:goto
十二爻元密钥纟三爻元置换:goto

三爻元密钥纟二爻元置换:goto
四爻元密钥纟二爻元置换:goto
    #对立互补

seed.math.uint_partition
py -m nn_ns.app.debug_cmd   seed.math.uint_partition -x # -off_defs
py -m nn_ns.app.doctest_cmd seed.math.uint_partition:__doc__ -ht # -ff -df

[[
源起:拆分阶乘，尝试找出部分和为二幂
view others/数学/编程/密码学/我的设计冫加密框架.txt
>>> from math import *
>>> f=factorial
>>> c=comb
>>> f4=f(4)
>>> f4
24
>>> s4=f(3)
>>> s1111=1
>>> s31=4*f(2)
>>> s22=c(4,2)/2
>>> s22
3.0
>>> s211=c(4,2)
>>> s4+s31+s22+s211+s1111
24.0
>>> [s4,s31,s22,s211,s1111]
[6, 8, 3.0, 6, 1]
>>> s4+s22+s211+s1111
16.0

]]


    #def print_iterable_with_lineno_(max_sz, xs, /, *, offset=0, to_str=repr):
    #def print_iterable_(max_sz, xs, /, *, to_str=repr, may_min_lineno=None):
>>> from seed.tiny_.print_iterable_with_lineno_ import print_iterable_with_lineno_, print_iterable_# print_iterable_with_linenoT, print_iterableT

>>> [uint2num_uint_partitions_(u, cache=...) for u in range(20)]
[1, 1, 2, 3, 5, 7, 11, 15, 22, 30, 42, 56, 77, 101, 135, 176, 231, 297, 385, 490]
>>> print_iterable_with_lineno_(99999, [uint2num_uint_partitions_(u, cache=...) for u in range(20)], offset=0)
0:1
1:1
2:2
3:3
4:5
5:7
6:11
7:15
8:22
9:30
10:42
11:56
12:77
13:101
14:135
15:176
16:231
17:297
18:385
19:490
>>> tmp_cache2 = []
>>> uint2num_uint_partitions__len_le_(max4num_parts:=16, u:=20, cache2=tmp_cache2)
620
>>> print_iterable_with_lineno_(99999, tmp_cache2, offset=0)
0:[[1]]
1:[[0], [1]]
2:[[0], [1], [1, 2]]
3:[[0], [1], [], [1, 2, 3]]
4:[[0], [1], [], [], [1, 3, 4, 5]]
5:[[0], [1], [], [], [], [1, 3, 5, 6, 7]]
6:[[0], [1], [], [], [], [], [1, 4, 7, 9, 10, 11]]
7:[[0], [1], [], [], [], [], [], [1, 4, 8, 11, 13, 14, 15]]
8:[[0], [1], [], [], [], [], [], [], [1, 5, 10, 15, 18, 20, 21, 22]]
9:[[0], [1], [], [], [], [], [], [], [], [1, 5, 12, 18, 23, 26, 28, 29, 30]]
10:[[0], [1], [], [], [], [], [], [], [], [], [1, 6, 14, 23, 30, 35, 38, 40, 41, 42]]
11:[[0], [1], [], [], [], [], [], [], [], [], [], [1, 6, 16, 27, 37, 44, 49, 52, 54]]
12:[[0], [1], [], [], [], [], [], [], [], [], [], [], [1, 7, 19, 34, 47, 58, 65, 70]]
13:[[0], [1], [], [], [], [], [], [], [], [], [], [], [], [1, 7, 21, 39, 57, 71, 82]]
14:[[0], [1], [], [], [], [], [], [], [], [], [], [], [], [7], [1, 8, 24, 47, 70, 90]]
15:[[0], [1], [], [], [], [], [], [], [], [], [], [], [], [], [7], [1, 8, 27, 54, 84]]
16:[[0], [1], [], [], [], [], [], [], [], [], [], [], [], [], [7], [8, 29, 63]]
17:[[0], [1], [], [], [], [], [], [], [], [], [], [], [], [], [], [7, 31]]
18:[[0], [1], [], [], [], [], [], [], [], [], [], [], [], [], [], [7]]
19:[[0], [1]]
20:[[0], [1], [], [], [], [], [], [], [], [], [], [], [], [], [], [], [7, 38, 101, 185, 275, 357, 427, 481, 523, 553, 575, 590, 601, 608, 613, 616, 618, 619, 620]]
>>> print_iterable_with_lineno_(99999, [[uint2num_uint_partitions__len_le_(max4num_parts, u, cache2=tmp_cache2) for max4num_parts in range(u+1)] for u in range(20)], offset=0)
0:[1]
1:[0, 1]
2:[0, 1, 2]
3:[0, 1, 2, 3]
4:[0, 1, 3, 4, 5]
5:[0, 1, 3, 5, 6, 7]
6:[0, 1, 4, 7, 9, 10, 11]
7:[0, 1, 4, 8, 11, 13, 14, 15]
8:[0, 1, 5, 10, 15, 18, 20, 21, 22]
9:[0, 1, 5, 12, 18, 23, 26, 28, 29, 30]
10:[0, 1, 6, 14, 23, 30, 35, 38, 40, 41, 42]
11:[0, 1, 6, 16, 27, 37, 44, 49, 52, 54, 55, 56]
12:[0, 1, 7, 19, 34, 47, 58, 65, 70, 73, 75, 76, 77]
13:[0, 1, 7, 21, 39, 57, 71, 82, 89, 94, 97, 99, 100, 101]
14:[0, 1, 8, 24, 47, 70, 90, 105, 116, 123, 128, 131, 133, 134, 135]
15:[0, 1, 8, 27, 54, 84, 110, 131, 146, 157, 164, 169, 172, 174, 175, 176]
16:[0, 1, 9, 30, 64, 101, 136, 164, 186, 201, 212, 219, 224, 227, 229, 230, 231]
17:[0, 1, 9, 33, 72, 119, 163, 201, 230, 252, 267, 278, 285, 290, 293, 295, 296, 297]
18:[0, 1, 10, 37, 84, 141, 199, 248, 288, 318, 340, 355, 366, 373, 378, 381, 383, 384, 385]
19:[0, 1, 10, 40, 94, 164, 235, 300, 352, 393, 423, 445, 460, 471, 478, 483, 486, 488, 489, 490]
>>> (_50:=[uint2num_uint_partitions__len_le_(..., u, cache2=tmp_cache2) for u in range(50)]) == [uint2num_uint_partitions_(u, cache=...) for u in range(50)]
True
>>> _50
[1, 1, 2, 3, 5, 7, 11, 15, 22, 30, 42, 56, 77, 101, 135, 176, 231, 297, 385, 490, 627, 792, 1002, 1255, 1575, 1958, 2436, 3010, 3718, 4565, 5604, 6842, 8349, 10143, 12310, 14883, 17977, 21637, 26015, 31185, 37338, 44583, 53174, 63261, 75175, 89134, 105558, 124754, 147273, 173525]


>>> from math import *
>>> log2(comb(231, 5))
32.28899078630452
>>> log2(comb(231, 4))
26.78437039390096
>>> log2(comb(231, 3))
20.95148037973622
>>> log2(comb(231, 2))
14.697239092360432
>>> log2(factorial(16))
44.25014046988262
>>> factorial(16)
20922789888000
>>> 2**44
17592186044416
>>> factorial(16) -2**44
3330603843584
>>> log2(factorial(16) -2**44)
41.598920902481765
>>> show = lambda u, /, **kwds:print_iterable_with_lineno_(99999, uint2iter_uint_partitions_(u, **kwds), offset=1)

#>>> show(0)
#>>> show(1)
#>>> show(2)
#>>> show(3)
#>>> show(4)
#>>> show(5)
#>>> show(6)
#>>> show(7, to_expand=False)
#>>> show(8, to_expand=False)

>>> show(0)
1:()
>>> show(1)
1:(1,)
>>> show(2)
1:(2,)
2:(1, 1)
>>> show(3)
1:(3,)
2:(2, 1)
3:(1, 1, 1)
>>> show(4)
1:(4,)
2:(3, 1)
3:(2, 2)
4:(2, 1, 1)
5:(1, 1, 1, 1)
>>> show(5)
1:(5,)
2:(4, 1)
3:(3, 2)
4:(3, 1, 1)
5:(2, 2, 1)
6:(2, 1, 1, 1)
7:(1, 1, 1, 1, 1)
>>> show(6)
1:(6,)
2:(5, 1)
3:(4, 2)
4:(4, 1, 1)
5:(3, 3)
6:(3, 2, 1)
7:(3, 1, 1, 1)
8:(2, 2, 2)
9:(2, 2, 1, 1)
10:(2, 1, 1, 1, 1)
11:(1, 1, 1, 1, 1, 1)

>>> show(7, to_expand=False)
1:((7, 1),)
2:((6, 1), (1, 1))
3:((5, 1), (2, 1))
4:((5, 1), (1, 2))
5:((4, 1), (3, 1))
6:((4, 1), (2, 1), (1, 1))
7:((4, 1), (1, 3))
8:((3, 2), (1, 1))
9:((3, 1), (2, 2))
10:((3, 1), (2, 1), (1, 2))
11:((3, 1), (1, 4))
12:((2, 3), (1, 1))
13:((2, 2), (1, 3))
14:((2, 1), (1, 5))
15:((1, 7),)
>>> show(8, to_expand=False)
1:((8, 1),)
2:((7, 1), (1, 1))
3:((6, 1), (2, 1))
4:((6, 1), (1, 2))
5:((5, 1), (3, 1))
6:((5, 1), (2, 1), (1, 1))
7:((5, 1), (1, 3))
8:((4, 2),)
9:((4, 1), (3, 1), (1, 1))
10:((4, 1), (2, 2))
11:((4, 1), (2, 1), (1, 2))
12:((4, 1), (1, 4))
13:((3, 2), (2, 1))
14:((3, 2), (1, 2))
15:((3, 1), (2, 2), (1, 1))
16:((3, 1), (2, 1), (1, 3))
17:((3, 1), (1, 5))
18:((2, 4),)
19:((2, 3), (1, 2))
20:((2, 2), (1, 4))
21:((2, 1), (1, 6))
22:((1, 8),)

>>> show2 = lambda u, /, **kwds:print_iterable_with_lineno_(99999, partition_uint_factorial_(u, **kwds), offset=1)

#>>> show2(0)
#>>> show2(1)
#>>> show2(2)
#>>> show2(3)
#>>> show2(4)
#>>> show2(5, to_expand=False)
#>>> show2(6, to_expand=False)
#>>> show2(7, to_expand=False)
#>>> show2(8, to_expand=False)

>>> show2(0)
1:(1, ())
>>> show2(1)
1:(1, (1,))
>>> show2(2)
1:(1, (2,))
2:(1, (1, 1))
>>> show2(3)
1:(2, (3,))
2:(3, (2, 1))
3:(1, (1, 1, 1))
>>> show2(4)
1:(6, (4,))
2:(8, (3, 1))
3:(3, (2, 2))
4:(6, (2, 1, 1))
5:(1, (1, 1, 1, 1))
>>> show2(5, to_expand=False)
1:(24, ((5, 1),))
2:(30, ((4, 1), (1, 1)))
3:(20, ((3, 1), (2, 1)))
4:(20, ((3, 1), (1, 2)))
5:(15, ((2, 2), (1, 1)))
6:(10, ((2, 1), (1, 3)))
7:(1, ((1, 5),))
>>> show2(6, to_expand=False)
1:(120, ((6, 1),))
2:(144, ((5, 1), (1, 1)))
3:(90, ((4, 1), (2, 1)))
4:(90, ((4, 1), (1, 2)))
5:(40, ((3, 2),))
6:(120, ((3, 1), (2, 1), (1, 1)))
7:(40, ((3, 1), (1, 3)))
8:(15, ((2, 3),))
9:(45, ((2, 2), (1, 2)))
10:(15, ((2, 1), (1, 4)))
11:(1, ((1, 6),))
>>> show2(7, to_expand=False)
1:(720, ((7, 1),))
2:(840, ((6, 1), (1, 1)))
3:(504, ((5, 1), (2, 1)))
4:(504, ((5, 1), (1, 2)))
5:(420, ((4, 1), (3, 1)))
6:(630, ((4, 1), (2, 1), (1, 1)))
7:(210, ((4, 1), (1, 3)))
8:(280, ((3, 2), (1, 1)))
9:(210, ((3, 1), (2, 2)))
10:(420, ((3, 1), (2, 1), (1, 2)))
11:(70, ((3, 1), (1, 4)))
12:(105, ((2, 3), (1, 1)))
13:(105, ((2, 2), (1, 3)))
14:(21, ((2, 1), (1, 5)))
15:(1, ((1, 7),))
>>> show2(8, to_expand=False)
1:(5040, ((8, 1),))
2:(5760, ((7, 1), (1, 1)))
3:(3360, ((6, 1), (2, 1)))
4:(3360, ((6, 1), (1, 2)))
5:(2688, ((5, 1), (3, 1)))
6:(4032, ((5, 1), (2, 1), (1, 1)))
7:(1344, ((5, 1), (1, 3)))
8:(1260, ((4, 2),))
9:(3360, ((4, 1), (3, 1), (1, 1)))
10:(1260, ((4, 1), (2, 2)))
11:(2520, ((4, 1), (2, 1), (1, 2)))
12:(420, ((4, 1), (1, 4)))
13:(1120, ((3, 2), (2, 1)))
14:(1120, ((3, 2), (1, 2)))
15:(1680, ((3, 1), (2, 2), (1, 1)))
16:(1120, ((3, 1), (2, 1), (1, 3)))
17:(112, ((3, 1), (1, 5)))
18:(105, ((2, 4),))
19:(420, ((2, 3), (1, 2)))
20:(210, ((2, 2), (1, 4)))
21:(28, ((2, 1), (1, 6)))
22:(1, ((1, 8),))

view others/数学/编程/密码学/我的设计冫加密框架.txt
>>> ns8 = (5040, 5760, 3360, 3360, 2688, 4032, 1344, 1260, 3360, 1260, 2520, 420, 1120, 1120, 1680, 1120, 112, 105, 420, 210, 28, 1)
>>> to_delss = ([5760, 1344, 420, 28], [5760, 1260, 112, 420], [5760, 1680, 112])
>>> idcss4del = ([2, 7, '12/19', 21], [2, '8/10', 17, '12/19'], [2, 15, 17])
>>> to_dels = [28, 112, 420, 1260, 1344, 1680, 5760]
>>> [[j for j, v in enumerate(ns8) if v==u] for u in to_dels]
[[20], [16], [11, 18], [7, 9], [6], [14], [1]]

[1, 6, 7, 9, 11, 14, 16, 18, 20]
[2, 7, 8, 10, 12, 15, 17, 19, 21]
\<\(2\|7\|8\|10\|12\|15\|17\|19\|21\)\>
###>>> show2(8, to_expand=False)
#1:(5040, ((8, 1),))
2:(5760, ((7, 1), (1, 1)))
7:(1344, ((5, 1), (1, 3)))
8:(1260, ((4, 2),))
10:(1260, ((4, 1), (2, 2)))
12:(420, ((4, 1), (1, 4)))
15:(1680, ((3, 1), (2, 2), (1, 1)))
17:(112, ((3, 1), (1, 5)))
19:(420, ((2, 3), (1, 2)))
21:(28, ((2, 1), (1, 6)))
>>> factorial(8) -2**15   -sum([5760, 1344, 420, 28])
0
>>> factorial(8) -2**15   -sum([5760, 1260, 112, 420])
0
>>> factorial(8) -2**15   -sum([5760, 1680, 112])
0

-2:(5760, ((7, 1), (1, 1)))
-15:(1680, ((3, 1), (2, 2), (1, 1)))
-17:(112, ((3, 1), (1, 5)))
十五爻元密钥纟三爻元置换:here
<<==:
    (8, 15, [5040, 3360, 3360, 2688, 4032, 1260, 3360, 1260, 2520, 420, 1120, 1120, 1680, 1120, 112, 105, 210, 1])
    (8, 15, [5040, 3360, 3360, 2688, 4032, 1344, 1260, 3360, 2520, 420, 1120, 1120, 1680, 1120, 105, 210, 28, 1])
    (8, 15, [5040, 3360, 3360, 2688, 4032, 1344, 1260, 3360, 1260, 2520, 420, 1120, 1120, 1120, 105, 420, 210, 28, 1])



\<\(3360\|420\|105\|210\|1\)\>
###>>> show2(8, to_expand=False)
#1:(5040, ((8, 1),))
3:(3360, ((6, 1), (2, 1)))
4:(3360, ((6, 1), (1, 2)))
9:(3360, ((4, 1), (3, 1), (1, 1)))
12:(420, ((4, 1), (1, 4)))
18:(105, ((2, 4),))
19:(420, ((2, 3), (1, 2)))
20:(210, ((2, 2), (1, 4)))
22:(1, ((1, 8),))
>>> 2**12   -sum([3360, 420, 105, 210, 1])
0

+9:(3360, ((4, 1), (3, 1), (1, 1)))
+12:(420, ((4, 1), (1, 4)))
+18:(105, ((2, 4),))
+20:(210, ((2, 2), (1, 4)))
+22:(1, ((1, 8),))
十二爻元密钥纟三爻元置换:here
<<==:
    (8, 12, [420, 1120, 1120, 1120, 105, 210, 1])
    (8, 12, [1260, 1260, 1120, 112, 105, 210, 28, 1])
    (8, 12, [1260, 420, 1680, 105, 420, 210, 1])
    (8, 12, [1260, 2520, 105, 210, 1])
    (8, 12, [3360, 420, 105, 210, 1])





+2:(8, (3, 1))
三爻元密钥纟二爻元置换:here

+1:(6, (4,))
+3:(3, (2, 2))
+4:(6, (2, 1, 1))
+5:(1, (1, 1, 1, 1))
四爻元密钥纟二爻元置换:here
<<==:
    (4, 4, [6, 3, 6, 1])
    (4, 3, [8])
    #恰好对立互补




>>> show2(16, to_expand=False)
1:(1307674368000, ((16, 1),))
2:(1394852659200, ((15, 1), (1, 1)))
3:(747242496000, ((14, 1), (2, 1)))
4:(747242496000, ((14, 1), (1, 2)))
5:(536481792000, ((13, 1), (3, 1)))
6:(804722688000, ((13, 1), (2, 1), (1, 1)))
7:(268240896000, ((13, 1), (1, 3)))
8:(435891456000, ((12, 1), (4, 1)))
9:(581188608000, ((12, 1), (3, 1), (1, 1)))
10:(217945728000, ((12, 1), (2, 2)))
11:(435891456000, ((12, 1), (2, 1), (1, 2)))
12:(72648576000, ((12, 1), (1, 4)))
13:(380414361600, ((11, 1), (5, 1)))
14:(475517952000, ((11, 1), (4, 1), (1, 1)))
15:(317011968000, ((11, 1), (3, 1), (2, 1)))
16:(317011968000, ((11, 1), (3, 1), (1, 2)))
17:(237758976000, ((11, 1), (2, 2), (1, 1)))
18:(158505984000, ((11, 1), (2, 1), (1, 3)))
19:(15850598400, ((11, 1), (1, 5)))
20:(348713164800, ((10, 1), (6, 1)))
21:(418455797760, ((10, 1), (5, 1), (1, 1)))
22:(261534873600, ((10, 1), (4, 1), (2, 1)))
23:(261534873600, ((10, 1), (4, 1), (1, 2)))
24:(116237721600, ((10, 1), (3, 2)))
25:(348713164800, ((10, 1), (3, 1), (2, 1), (1, 1)))
26:(116237721600, ((10, 1), (3, 1), (1, 3)))
27:(43589145600, ((10, 1), (2, 3)))
28:(130767436800, ((10, 1), (2, 2), (1, 2)))
29:(43589145600, ((10, 1), (2, 1), (1, 4)))
30:(2905943040, ((10, 1), (1, 6)))
31:(332107776000, ((9, 1), (7, 1)))
32:(387459072000, ((9, 1), (6, 1), (1, 1)))
33:(232475443200, ((9, 1), (5, 1), (2, 1)))
34:(232475443200, ((9, 1), (5, 1), (1, 2)))
35:(193729536000, ((9, 1), (4, 1), (3, 1)))
36:(290594304000, ((9, 1), (4, 1), (2, 1), (1, 1)))
37:(96864768000, ((9, 1), (4, 1), (1, 3)))
38:(129153024000, ((9, 1), (3, 2), (1, 1)))
39:(96864768000, ((9, 1), (3, 1), (2, 2)))
40:(193729536000, ((9, 1), (3, 1), (2, 1), (1, 2)))
41:(32288256000, ((9, 1), (3, 1), (1, 4)))
42:(48432384000, ((9, 1), (2, 3), (1, 1)))
43:(48432384000, ((9, 1), (2, 2), (1, 3)))
44:(9686476800, ((9, 1), (2, 1), (1, 5)))
45:(461260800, ((9, 1), (1, 7)))
46:(163459296000, ((8, 2),))
47:(373621248000, ((8, 1), (7, 1), (1, 1)))
48:(217945728000, ((8, 1), (6, 1), (2, 1)))
49:(217945728000, ((8, 1), (6, 1), (1, 2)))
50:(174356582400, ((8, 1), (5, 1), (3, 1)))
51:(261534873600, ((8, 1), (5, 1), (2, 1), (1, 1)))
52:(87178291200, ((8, 1), (5, 1), (1, 3)))
53:(81729648000, ((8, 1), (4, 2)))
54:(217945728000, ((8, 1), (4, 1), (3, 1), (1, 1)))
55:(81729648000, ((8, 1), (4, 1), (2, 2)))
56:(163459296000, ((8, 1), (4, 1), (2, 1), (1, 2)))
57:(27243216000, ((8, 1), (4, 1), (1, 4)))
58:(72648576000, ((8, 1), (3, 2), (2, 1)))
59:(72648576000, ((8, 1), (3, 2), (1, 2)))
60:(108972864000, ((8, 1), (3, 1), (2, 2), (1, 1)))
61:(72648576000, ((8, 1), (3, 1), (2, 1), (1, 3)))
62:(7264857600, ((8, 1), (3, 1), (1, 5)))
63:(6810804000, ((8, 1), (2, 4)))
64:(27243216000, ((8, 1), (2, 3), (1, 2)))
65:(13621608000, ((8, 1), (2, 2), (1, 4)))
66:(1816214400, ((8, 1), (2, 1), (1, 6)))
67:(64864800, ((8, 1), (1, 8)))
68:(106748928000, ((7, 2), (2, 1)))
69:(106748928000, ((7, 2), (1, 2)))
70:(166053888000, ((7, 1), (6, 1), (3, 1)))
71:(249080832000, ((7, 1), (6, 1), (2, 1), (1, 1)))
72:(83026944000, ((7, 1), (6, 1), (1, 3)))
73:(149448499200, ((7, 1), (5, 1), (4, 1)))
74:(199264665600, ((7, 1), (5, 1), (3, 1), (1, 1)))
75:(74724249600, ((7, 1), (5, 1), (2, 2)))
76:(149448499200, ((7, 1), (5, 1), (2, 1), (1, 2)))
77:(24908083200, ((7, 1), (5, 1), (1, 4)))
78:(93405312000, ((7, 1), (4, 2), (1, 1)))
79:(124540416000, ((7, 1), (4, 1), (3, 1), (2, 1)))
80:(124540416000, ((7, 1), (4, 1), (3, 1), (1, 2)))
81:(93405312000, ((7, 1), (4, 1), (2, 2), (1, 1)))
82:(62270208000, ((7, 1), (4, 1), (2, 1), (1, 3)))
83:(6227020800, ((7, 1), (4, 1), (1, 5)))
84:(18450432000, ((7, 1), (3, 3)))
85:(83026944000, ((7, 1), (3, 2), (2, 1), (1, 1)))
86:(27675648000, ((7, 1), (3, 2), (1, 3)))
87:(20756736000, ((7, 1), (3, 1), (2, 3)))
88:(62270208000, ((7, 1), (3, 1), (2, 2), (1, 2)))
89:(20756736000, ((7, 1), (3, 1), (2, 1), (1, 4)))
90:(1383782400, ((7, 1), (3, 1), (1, 6)))
91:(7783776000, ((7, 1), (2, 4), (1, 1)))
92:(10378368000, ((7, 1), (2, 3), (1, 3)))
93:(3113510400, ((7, 1), (2, 2), (1, 5)))
94:(296524800, ((7, 1), (2, 1), (1, 7)))
95:(8236800, ((7, 1), (1, 9)))
96:(72648576000, ((6, 2), (4, 1)))
97:(96864768000, ((6, 2), (3, 1), (1, 1)))
98:(36324288000, ((6, 2), (2, 2)))
99:(72648576000, ((6, 2), (2, 1), (1, 2)))
100:(12108096000, ((6, 2), (1, 4)))
101:(69742632960, ((6, 1), (5, 2)))
102:(174356582400, ((6, 1), (5, 1), (4, 1), (1, 1)))
103:(116237721600, ((6, 1), (5, 1), (3, 1), (2, 1)))
104:(116237721600, ((6, 1), (5, 1), (3, 1), (1, 2)))
105:(87178291200, ((6, 1), (5, 1), (2, 2), (1, 1)))
106:(58118860800, ((6, 1), (5, 1), (2, 1), (1, 3)))
107:(5811886080, ((6, 1), (5, 1), (1, 5)))
108:(54486432000, ((6, 1), (4, 2), (2, 1)))
109:(54486432000, ((6, 1), (4, 2), (1, 2)))
110:(48432384000, ((6, 1), (4, 1), (3, 2)))
111:(145297152000, ((6, 1), (4, 1), (3, 1), (2, 1), (1, 1)))
112:(48432384000, ((6, 1), (4, 1), (3, 1), (1, 3)))
113:(18162144000, ((6, 1), (4, 1), (2, 3)))
114:(54486432000, ((6, 1), (4, 1), (2, 2), (1, 2)))
115:(18162144000, ((6, 1), (4, 1), (2, 1), (1, 4)))
116:(1210809600, ((6, 1), (4, 1), (1, 6)))
117:(21525504000, ((6, 1), (3, 3), (1, 1)))
118:(24216192000, ((6, 1), (3, 2), (2, 2)))
119:(48432384000, ((6, 1), (3, 2), (2, 1), (1, 2)))
120:(8072064000, ((6, 1), (3, 2), (1, 4)))
121:(24216192000, ((6, 1), (3, 1), (2, 3), (1, 1)))
122:(24216192000, ((6, 1), (3, 1), (2, 2), (1, 3)))
123:(4843238400, ((6, 1), (3, 1), (2, 1), (1, 5)))
124:(230630400, ((6, 1), (3, 1), (1, 7)))
125:(908107200, ((6, 1), (2, 5)))
126:(4540536000, ((6, 1), (2, 4), (1, 2)))
127:(3027024000, ((6, 1), (2, 3), (1, 4)))
128:(605404800, ((6, 1), (2, 2), (1, 6)))
129:(43243200, ((6, 1), (2, 1), (1, 8)))
130:(960960, ((6, 1), (1, 10)))
131:(27897053184, ((5, 3), (1, 1)))
132:(52306974720, ((5, 2), (4, 1), (2, 1)))
133:(52306974720, ((5, 2), (4, 1), (1, 2)))
134:(23247544320, ((5, 2), (3, 2)))
135:(69742632960, ((5, 2), (3, 1), (2, 1), (1, 1)))
136:(23247544320, ((5, 2), (3, 1), (1, 3)))
137:(8717829120, ((5, 2), (2, 3)))
138:(26153487360, ((5, 2), (2, 2), (1, 2)))
139:(8717829120, ((5, 2), (2, 1), (1, 4)))
140:(581188608, ((5, 2), (1, 6)))
141:(43589145600, ((5, 1), (4, 2), (3, 1)))
142:(65383718400, ((5, 1), (4, 2), (2, 1), (1, 1)))
143:(21794572800, ((5, 1), (4, 2), (1, 3)))
144:(58118860800, ((5, 1), (4, 1), (3, 2), (1, 1)))
145:(43589145600, ((5, 1), (4, 1), (3, 1), (2, 2)))
146:(87178291200, ((5, 1), (4, 1), (3, 1), (2, 1), (1, 2)))
147:(14529715200, ((5, 1), (4, 1), (3, 1), (1, 4)))
148:(21794572800, ((5, 1), (4, 1), (2, 3), (1, 1)))
149:(21794572800, ((5, 1), (4, 1), (2, 2), (1, 3)))
150:(4358914560, ((5, 1), (4, 1), (2, 1), (1, 5)))
151:(207567360, ((5, 1), (4, 1), (1, 7)))
152:(12915302400, ((5, 1), (3, 3), (2, 1)))
153:(12915302400, ((5, 1), (3, 3), (1, 2)))
154:(29059430400, ((5, 1), (3, 2), (2, 2), (1, 1)))
155:(19372953600, ((5, 1), (3, 2), (2, 1), (1, 3)))
156:(1937295360, ((5, 1), (3, 2), (1, 5)))
157:(3632428800, ((5, 1), (3, 1), (2, 4)))
158:(14529715200, ((5, 1), (3, 1), (2, 3), (1, 2)))
159:(7264857600, ((5, 1), (3, 1), (2, 2), (1, 4)))
160:(968647680, ((5, 1), (3, 1), (2, 1), (1, 6)))
161:(34594560, ((5, 1), (3, 1), (1, 8)))
162:(1089728640, ((5, 1), (2, 5), (1, 1)))
163:(1816214400, ((5, 1), (2, 4), (1, 3)))
164:(726485760, ((5, 1), (2, 3), (1, 5)))
165:(103783680, ((5, 1), (2, 2), (1, 7)))
166:(5765760, ((5, 1), (2, 1), (1, 9)))
167:(104832, ((5, 1), (1, 11)))
168:(3405402000, ((4, 4),))
169:(18162144000, ((4, 3), (3, 1), (1, 1)))
170:(6810804000, ((4, 3), (2, 2)))
171:(13621608000, ((4, 3), (2, 1), (1, 2)))
172:(2270268000, ((4, 3), (1, 4)))
173:(18162144000, ((4, 2), (3, 2), (2, 1)))
174:(18162144000, ((4, 2), (3, 2), (1, 2)))
175:(27243216000, ((4, 2), (3, 1), (2, 2), (1, 1)))
176:(18162144000, ((4, 2), (3, 1), (2, 1), (1, 3)))
177:(1816214400, ((4, 2), (3, 1), (1, 5)))
178:(1702701000, ((4, 2), (2, 4)))
179:(6810804000, ((4, 2), (2, 3), (1, 2)))
180:(3405402000, ((4, 2), (2, 2), (1, 4)))
181:(454053600, ((4, 2), (2, 1), (1, 6)))
182:(16216200, ((4, 2), (1, 8)))
183:(2690688000, ((4, 1), (3, 4)))
184:(16144128000, ((4, 1), (3, 3), (2, 1), (1, 1)))
185:(5381376000, ((4, 1), (3, 3), (1, 3)))
186:(6054048000, ((4, 1), (3, 2), (2, 3)))
187:(18162144000, ((4, 1), (3, 2), (2, 2), (1, 2)))
188:(6054048000, ((4, 1), (3, 2), (2, 1), (1, 4)))
189:(403603200, ((4, 1), (3, 2), (1, 6)))
190:(4540536000, ((4, 1), (3, 1), (2, 4), (1, 1)))
191:(6054048000, ((4, 1), (3, 1), (2, 3), (1, 3)))
192:(1816214400, ((4, 1), (3, 1), (2, 2), (1, 5)))
193:(172972800, ((4, 1), (3, 1), (2, 1), (1, 7)))
194:(4804800, ((4, 1), (3, 1), (1, 9)))
195:(113513400, ((4, 1), (2, 6)))
196:(681080400, ((4, 1), (2, 5), (1, 2)))
197:(567567000, ((4, 1), (2, 4), (1, 4)))
198:(151351200, ((4, 1), (2, 3), (1, 6)))
199:(16216200, ((4, 1), (2, 2), (1, 8)))
200:(720720, ((4, 1), (2, 1), (1, 10)))
201:(10920, ((4, 1), (1, 12)))
202:(717516800, ((3, 5), (1, 1)))
203:(1345344000, ((3, 4), (2, 2)))
204:(2690688000, ((3, 4), (2, 1), (1, 2)))
205:(448448000, ((3, 4), (1, 4)))
206:(2690688000, ((3, 3), (2, 3), (1, 1)))
207:(2690688000, ((3, 3), (2, 2), (1, 3)))
208:(538137600, ((3, 3), (2, 1), (1, 5)))
209:(25625600, ((3, 3), (1, 7)))
210:(302702400, ((3, 2), (2, 5)))
211:(1513512000, ((3, 2), (2, 4), (1, 2)))
212:(1009008000, ((3, 2), (2, 3), (1, 4)))
213:(201801600, ((3, 2), (2, 2), (1, 6)))
214:(14414400, ((3, 2), (2, 1), (1, 8)))
215:(320320, ((3, 2), (1, 10)))
216:(151351200, ((3, 1), (2, 6), (1, 1)))
217:(302702400, ((3, 1), (2, 5), (1, 3)))
218:(151351200, ((3, 1), (2, 4), (1, 5)))
219:(28828800, ((3, 1), (2, 3), (1, 7)))
220:(2402400, ((3, 1), (2, 2), (1, 9)))
221:(87360, ((3, 1), (2, 1), (1, 11)))
222:(1120, ((3, 1), (1, 13)))
223:(2027025, ((2, 8),))
224:(16216200, ((2, 7), (1, 2)))
225:(18918900, ((2, 6), (1, 4)))
226:(7567560, ((2, 5), (1, 6)))
227:(1351350, ((2, 4), (1, 8)))
228:(120120, ((2, 3), (1, 10)))
229:(5460, ((2, 2), (1, 12)))
230:(120, ((2, 1), (1, 14)))
231:(1, ((1, 16),))


/:[^,]*[^0],
==>>:
    #只有5项 不能整除十
131:(27897053184, ((5, 3), (1, 1)))
140:(581188608, ((5, 2), (1, 6)))
167:(104832, ((5, 1), (1, 11)))
223:(2027025, ((2, 8),))
231:(1, ((1, 16),))
>>> factorial(16)
20922789888000
>>> 2**44
17592186044416
>>> factorial(16) -2**44
3330603843584

==>>:
    排除: 131|(231,223,140)
        #%10:4|(1,5,8)
    =>
    包含: (167,231,223,140)|(131,167)
        #%100:66|16
>>> 2**44 -sum([104832,1,2027025,581188608])
17591602723950
>>> 2**44 -sum([27897053184,104832])
17564288886400


[27897053184, 581188608, 104832, 2027025, 1
#
, 418455797760, 2905943040, 69742632960, 5811886080, 960960, 52306974720, 52306974720
    , 23247544320, 69742632960, 23247544320, 8717829120, 26153487360, 8717829120, 4358914560
    , 207567360, 1937295360, 968647680, 34594560, 1089728640, 726485760, 103783680, 5765760
    , 720720, 10920, 320320, 87360, 1120, 7567560, 1351350, 120120, 5460, 120
#
, 1394852659200, 380414361600, 15850598400, 348713164800, 261534873600, 261534873600
    , 116237721600, 348713164800, 116237721600, 43589145600, 130767436800, 43589145600
    , 232475443200, 232475443200, 9686476800, 461260800, 174356582400, 261534873600, 87178291200
    , 7264857600, 1816214400, 64864800, 149448499200, 199264665600, 74724249600, 149448499200
    , 24908083200, 6227020800, 1383782400, 3113510400, 296524800, 8236800, 174356582400
    , 116237721600, 116237721600, 87178291200, 58118860800, 1210809600, 4843238400, 230630400
    , 908107200, 605404800, 43243200, 43589145600, 65383718400, 21794572800, 58118860800
    , 43589145600, 87178291200, 14529715200, 21794572800, 21794572800, 12915302400, 12915302400
    , 29059430400, 19372953600, 3632428800, 14529715200, 7264857600, 1816214400, 1816214400
    , 454053600, 16216200, 403603200, 1816214400, 172972800, 4804800, 113513400, 681080400
    , 151351200, 16216200, 717516800, 538137600, 25625600, 302702400, 201801600, 14414400
    , 151351200, 302702400, 151351200, 28828800, 2402400, 16216200, 18918900
#
, 1307674368000, 747242496000, 747242496000, 536481792000, 804722688000, 268240896000
    , 435891456000, 581188608000, 217945728000, 435891456000, 72648576000, 475517952000
    , 317011968000, 317011968000, 237758976000, 158505984000, 332107776000, 387459072000
    , 193729536000, 290594304000, 96864768000, 129153024000, 96864768000, 193729536000
    , 32288256000, 48432384000, 48432384000, 163459296000, 373621248000, 217945728000
    , 217945728000, 81729648000, 217945728000, 81729648000, 163459296000, 27243216000
    , 72648576000, 72648576000, 108972864000, 72648576000, 6810804000, 27243216000, 13621608000
    , 106748928000, 106748928000, 166053888000, 249080832000, 83026944000, 93405312000
    , 124540416000, 124540416000, 93405312000, 62270208000, 18450432000, 83026944000
    , 27675648000, 20756736000, 62270208000, 20756736000, 7783776000, 10378368000, 72648576000
    , 96864768000, 36324288000, 72648576000, 12108096000, 54486432000, 54486432000, 48432384000
    , 145297152000, 48432384000, 18162144000, 54486432000, 18162144000, 21525504000, 24216192000
    , 48432384000, 8072064000, 24216192000, 24216192000, 4540536000, 3027024000, 3405402000
    , 18162144000, 6810804000, 13621608000, 2270268000, 18162144000, 18162144000, 27243216000
    , 18162144000, 1702701000, 6810804000, 3405402000, 2690688000, 16144128000, 5381376000
    , 6054048000, 18162144000, 6054048000, 4540536000, 6054048000, 567567000, 1345344000
    , 2690688000, 448448000, 2690688000, 2690688000, 1513512000, 1009008000
#
]

py_adhoc_call   seed.math.uint_partition   ,partition_uint_factorial_  =4
(6, (4,))
(8, (3, 1))
(3, (2, 2))
(6, (2, 1, 1))
(1, (1, 1, 1, 1))

py_adhoc_call   seed.math.uint_partition   ,_iter_all_subsets_of_seq_  ='range(4)'
()
(3,)
(2,)
(2, 3)
(1,)
(1, 3)
(1, 2)
(1, 2, 3)
(0,)
(0, 3)
(0, 2)
(0, 2, 3)
(0, 1)
(0, 1, 3)
(0, 1, 2)
(0, 1, 2, 3)

py_adhoc_call   seed.math.uint_partition   ,_find_zpows  =3
(3, 2, [3, 1])
(3, 1, [2])
(3, 0, [1])

py_adhoc_call   seed.math.uint_partition   ,_find_zpows4us  ='range(9)' > /sdcard/0my_files/tmp/0tmp
view /sdcard/0my_files/tmp/0tmp
(0, 0, [1])
(1, 0, [1])
(2, 1, [1, 1])
(2, 0, [1])
(2, 0, [1])
(3, 2, [3, 1])
(3, 1, [2])
(3, 0, [1])
(4, 4, [6, 3, 6, 1])
(4, 3, [8])
(4, 2, [3, 1])
(4, 0, [1])
(5, 6, [24, 20, 20])
(5, 6, [24, 30, 10])
(5, 4, [15, 1])
(5, 0, [1])
(6, 8, [90, 120, 45, 1])
(6, 8, [90, 90, 15, 45, 15, 1])
(6, 8, [120, 120, 15, 1])
(6, 8, [120, 90, 45, 1])
(6, 4, [15, 1])
(6, 0, [1])
(7, 9, [280, 210, 21, 1])
(7, 9, [210, 280, 21, 1])
(7, 9, [420, 70, 21, 1])
(7, 0, [1])
(8, 15, [5040, 3360, 3360, 2688, 4032, 1260, 3360, 1260, 2520, 420, 1120, 1120, 1680, 1120, 112, 105, 210, 1])
(8, 15, [5040, 3360, 3360, 2688, 4032, 1344, 1260, 3360, 2520, 420, 1120, 1120, 1680, 1120, 105, 210, 28, 1])
(8, 15, [5040, 3360, 3360, 2688, 4032, 1344, 1260, 3360, 1260, 2520, 420, 1120, 1120, 1120, 105, 420, 210, 28, 1])
(8, 12, [420, 1120, 1120, 1120, 105, 210, 1])
(8, 12, [1260, 1260, 1120, 112, 105, 210, 28, 1])
(8, 12, [1260, 420, 1680, 105, 420, 210, 1])
(8, 12, [1260, 2520, 105, 210, 1])
(8, 12, [3360, 420, 105, 210, 1])
(8, 0, [1])

from seed.math.uint_partition import *
]]]'''#'''
__all__ = r'''
partition_uint_factorial_
    uint2iter_uint_partitions_
    num_permutations5uint_partition_
    uint2num_uint_partitions_
    uint2num_uint_partitions__len_le_
num_set_partitions5uint_partition_      num_unordered_choices5uint_partition_
    num_ordered_choices5uint_partition_







uint2iter_uint_partitions_
    uint2num_uint_partitions_
    uint2num_uint_partitions__len_le_

iter_parts5uint_partition_
    iter_parts5zipped_uint_partition_
iter_counted_parts5uint_partition_
    iter_counted_parts5expanded_uint_partition_
num_set_partitions5uint_partition_
    num_unordered_choices5uint_partition_
    num_ordered_choices5uint_partition_
num_permutations5uint_partition_
partition_uint_factorial_

'''.split()#'''
__all__
___begin_mark_of_excluded_global_names__0___ = ...
from enum import Enum, auto
from math import factorial, comb, perm
from itertools import repeat, groupby, compress# permutation# islice
from seed.tiny_.check import check_type_is, check_int_ge
from seed.debug.print_err import print_err

___end_mark_of_excluded_global_names__0___ = ...


_global_cache2 = []
def uint2num_uint_partitions__len_le_(emay_max4num_parts, u, /, *, cache2, max4part=None):
    '[O(u**2)] => emay_max4num_parts/uint -> u/uint -> (kw:max4part/uint) -> (kw:cache2/(None=>local|...=>global|[[[uint]]])) -> num_uint_partitions{all parts <= max4part}/uint{==cache2[u][max4num_parts][offsetted_max4part]} # [cache2==u2max4num_parts2offsetted_max4part2num_uint_partitions :: [[[uint]]] / list{list{list{uint}}}]'
    check_int_ge(0, u)
    # [u>=0]

    max4part = u if max4part is None else max4part
    check_int_ge(0, max4part)
    max4part = min(u, max4part)
    # [0 <= max4part <= u]

    max4num_parts = u if emay_max4num_parts is ... else emay_max4num_parts
    check_int_ge(0, max4num_parts)
    max4num_parts = min(u, max4num_parts)
    # [0 <= max4num_parts <= u]
    # xxx:[(max4num_parts-1)*1+1*max4part <= u] =>: [(max4num_parts+max4part <= u+1]
    #   !! [max4part =[def]= upperbound4part] not [max4part =[def]= max(parts4u, default=0)]

    if not u <= max4num_parts*max4part:
        return 0
    # [u <= max4num_parts*max4part]
    _3 = [u, max4num_parts, max4num_parts]
    assert all(_3) is any(_3)

    if cache2 is None:
        cache2 = []
    elif cache2 is ...:
        cache2 = _global_cache2
    check_type_is(list, cache2)
    if not cache2:
        cache2.append([[1]])
    #assert cache2
    #assert cache2[0]
    #assert cache2[0][0]
    assert cache2[0][0][0] == 1
    # (_recur4uint2num_uint_partitions__len_le_, _loop4uint2num_uint_partitions__len_le_)
    return _loop4uint2num_uint_partitions__len_le_(cache2, u, max4num_parts, max4part)
class _Case4uint2num_uint_partitions__len_le_(Enum):
    RETURN = auto()
    RECUR4A = auto()
    RECUR4B = auto()

def __():
    def calc_offsetted_max4part_ex_(u, max4num_parts, max4part, /):
        # [0 <= max4num_parts <= u]
        # [0 <= max4part <= u]
        # [u <= max4num_parts*max4part]or[max4num_parts==0==max4part]
        if max4num_parts:
            # [max4num_parts >= 1]
            # !! [u <= max4num_parts*max4part]
            # [u/max4num_parts <= max4part]
            # [max4part >= ceil(u/max4num_parts) == 1+(u-1)//max4num_parts == min4max4part]
            min4max4part = 1+ (u-1)//max4num_parts
        else:
            min4max4part = 0
            assert max4part == 0
        min4max4part
        offsetted_max4part = max4part-min4max4part
        assert offsetted_max4part >= 0, ((u, max4num_parts, max4part), (min4max4part, offsetted_max4part))
        return (min4max4part, offsetted_max4part)
    C = _Case4uint2num_uint_partitions__len_le_
    def set_(cache2, u, max4num_parts, min4max4part, offsetted_max4part, num_uint_partitions, /):
        check_int_ge(0, num_uint_partitions)
        assert max4num_parts >= 2
        if len(cache2) < u+1:
            if not cache2:
                cache2.append([[1]])
            for v in range(len(cache2), u+1):
                cache2.append([[0], [1]])
        m2o2n = cache2[u]
        if len(m2o2n) < 2:
            m2o2n += [[0], [1]][len(m2o2n):]
            assert len(m2o2n) == 2
        assert len(m2o2n) >= 2
        if len(m2o2n) <= max4num_parts:
            for _max4num_parts in range(len(m2o2n), max4num_parts+1):
                #o = (u%_max4num_parts==0)
                    # [u==_max4num_parts*_min4max4part]
                #m2o2n.append([] if not o else [1])
                m2o2n.append([])
        #.assert len(m2o2n) >= max4num_parts, (u, max4num_parts, offsetted_max4part, num_uint_partitions, len(m2o2n))
        #.if len(m2o2n) == max4num_parts:
        #.    o = int(u == max4num_parts*min4max4part)
        #.    assert offsetted_max4part == o, (u, max4num_parts, offsetted_max4part, num_uint_partitions)
        #.    m2o2n.append([] if o==0 else [1])
        assert len(m2o2n) > max4num_parts
        o2n = m2o2n[max4num_parts]
        if len(o2n) < offsetted_max4part:
            assert len(o2n)+1 == offsetted_max4part == 1, (u, max4num_parts, offsetted_max4part, num_uint_partitions, len(o2n))
            assert (u == max4num_parts*min4max4part), (u, max4num_parts, offsetted_max4part, num_uint_partitions)
            o2n.append(1)
        assert len(o2n) == offsetted_max4part, (u, max4num_parts, offsetted_max4part, num_uint_partitions, len(o2n))
        o2n.append(num_uint_partitions)
        assert cache2[u][max4num_parts][offsetted_max4part] == num_uint_partitions
    def imay_get_(x, /, *ks):
        #def imay_get_(cache2, u, max4num_parts, offsetted_max4part, /):
        #lookup
        for k in ks:
            if not k < len(x):
                return -1
            x = x[k]
        x
        assert x >= 0
        return x
    def prepare(cache2, u, max4num_parts, max4part, /):
        # [u >= 0]
        # [max4num_parts >= 0]
        # [max4part >= 0]
        assert u >= 0
        assert max4num_parts >= 0
        assert max4part >= 0
        max4num_parts = min(u, max4num_parts)
        max4part = min(u, max4part)
        # [0 <= max4num_parts <= u]
        # [0 <= max4part <= u]

        diff = max4num_parts*max4part -u
        ######################
        if diff >= 0:
            # [diff >= 0]
            # [u <= max4num_parts*max4part]
            pass
        else:
            max4num_parts = 0
            max4part = 0
            # [max4num_parts==0==max4part]
        (min4max4part, offsetted_max4part) = calc_offsetted_max4part_ex_(u, max4num_parts, max4part)
            # required:[u <= max4num_parts*max4part]or[max4num_parts==0==max4part]
        ######################
        if diff < 0:
            # [u > max4num_parts*max4part]
            imay_num_uint_partitions = 0
        elif diff == 0:
            # [u == max4num_parts*max4part]
            imay_num_uint_partitions = 1
        else:
            # [diff > 0]
            # [0 <= u < max4num_parts*max4part]
            # =>:
            # [max4num_parts*max4part > 0]
            # [max4num_parts > 0]
            # [max4part > 0]

            #imay_num_uint_partitions = -1
            imay_num_uint_partitions = imay_get_(cache2, u, max4num_parts, offsetted_max4part)
        imay_num_uint_partitions # imay num_uint_partitions
        check_int_ge(-1, imay_num_uint_partitions)
        # [imay_num_uint_partitions >= 0] ==>> [diff <= 0]or[diff > 0][lookup cache2 success]
        # [imay_num_uint_partitions == -1] ==>> [diff > 0][lookup cache2 failure]
        # [diff > 0] ==>>:
            # [0 <= u < max4num_parts*max4part]
            # [0 < max4num_parts <= u]
            # [0 < max4part <= u]
        return (u, max4num_parts, max4part, min4max4part, offsetted_max4part, diff, imay_num_uint_partitions)
    def recur(cache2, u, max4num_parts, max4part, /):
        (u, max4num_parts, max4part, min4max4part, offsetted_max4part, diff, imay_num_uint_partitions) = prepare(cache2, u, max4num_parts, max4part)
        if not imay_num_uint_partitions == -1:
            num_uint_partitions = imay_num_uint_partitions
            return num_uint_partitions
        # [imay_num_uint_partitions == -1]
        # [diff > 0][lookup cache2 failure]
        # [0 <= u < max4num_parts*max4part]
        # [0 < max4num_parts <= u]
        # [0 < max4part <= u]
        a = recur(cache2, u-max4part, max4num_parts-1, max4part)
            # case:[max_part==max4part]
        b = recur(cache2, u, max4num_parts, max4part-1)
            # case:[max_part<max4part]
        num_uint_partitions = a+b
        set_(cache2, u, max4num_parts, min4max4part, offsetted_max4part, num_uint_partitions)
        return num_uint_partitions
    #end-def recur(cache2, u, max4num_parts, max4part, /):

    b_debug = 0b0000#False#True#0b0001
    def put_RECUR(stk, cache2, u, max4num_parts, max4part, /):
        if b_debug:saved = (u, max4num_parts, max4part)
        result5prepare = (u, max4num_parts, max4part, min4max4part, offsetted_max4part, diff, imay_num_uint_partitions) = prepare(cache2, u, max4num_parts, max4part)
        if b_debug:print_err('put_RECUR', saved, (u, max4num_parts, max4part), (min4max4part, offsetted_max4part))
        if not imay_num_uint_partitions == -1:
            num_uint_partitions = imay_num_uint_partitions
            case = C.RETURN
            payload = num_uint_partitions
        else:
            # [imay_num_uint_partitions == -1]
            # [diff > 0][lookup cache2 failure]
            # [0 <= u < max4num_parts*max4part]
            # [0 < max4num_parts <= u]
            # [0 < max4part <= u]
            case = C.RECUR4A
            payload = result5prepare
        stk.append((case, payload))

    def loop(cache2, u, max4num_parts, max4part, /):
        stk = []
            #stack :: [(case, payload)]
            # [(case, payload) == (RETURN, num_uint_partitions)|(RECUR4A,result5prepare)|(RECUR4B,(result5prepare,a))]
        put_RECUR(stk, cache2, u, max4num_parts, max4part)
        while 1:
            (case, payload) = stk[-1]
            #############
            match case:
                case C.RECUR4A:
                    result5prepare = payload
                    (u, max4num_parts, max4part, min4max4part, offsetted_max4part, diff, imay_num_uint_partitions) = result5prepare
                    put_RECUR(stk, cache2, u-max4part, max4num_parts-1, max4part)
                        #a = recur(cache2, u-max4part, max4num_parts-1, max4part)
                        # case:[max_part==max4part]
                    continue
                case C.RECUR4B:
                    (result5prepare, a) = payload
                    (u, max4num_parts, max4part, min4max4part, offsetted_max4part, diff, imay_num_uint_partitions) = result5prepare
                    put_RECUR(stk, cache2, u, max4num_parts, max4part-1)
                        #b = recur(cache2, u, max4num_parts, max4part-1)
                        # case:[max_part<max4part]
                    continue
                case C.RETURN:
                    num_uint_partitions = payload
                case _:
                    raise 000
            #############
            #case:RETURN
            assert case == C.RETURN
            num_uint_partitions
            #############
            stk.pop()
            if not stk:
                break
                return num_uint_partitions
            #############
            (case, payload) = stk[-1]
            match case:
                case C.RECUR4A:
                    a = num_uint_partitions
                    payload = (payload, a)
                    case = C.RECUR4B
                case C.RECUR4B:
                    b = num_uint_partitions
                    ((u, max4num_parts, max4part, min4max4part, offsetted_max4part, diff, imay_num_uint_partitions), a) = payload
                    num_uint_partitions = a+b
                    payload = num_uint_partitions
                    case = C.RETURN
                    if 1:
                        set_(cache2, u, max4num_parts, min4max4part, offsetted_max4part, num_uint_partitions)
                    else:
                        try:
                            set_(cache2, u, max4num_parts, min4max4part, offsetted_max4part, num_uint_partitions)
                        except AssertionError as e:
                            raise AssertionError(e, stk)
                case _:
                    raise 000
            #############
            stk[-1] = (case, payload)
            #############
        #end-while 1:
        return num_uint_partitions
    #end-def loop(cache2, u, max4num_parts, max4part, /):
    return (recur, loop)
#end-def __():
(_recur4uint2num_uint_partitions__len_le_, _loop4uint2num_uint_partitions__len_le_) = __()


_global_cache = []
def uint2num_uint_partitions_(u, /, *, cache, max4part=None):
    '[O(u**2)] => u/uint -> (kw:max4part/uint) -> (kw:cache/(None=>local|...=>global|[[uint]])) -> num_uint_partitions{all parts <= max4part}/uint{==cache[u][max4part]} # [cache==u2max4part2num_uint_partitions :: [[uint]] / list{list{uint}}]'
    #if not max4num_parts is None: return uint2num_uint_partitions__len_le_(u, cache2=???cache)
    check_int_ge(0, u)

    max4part = u if max4part is None else max4part
    check_int_ge(0, max4part)
    max4part = min(u, max4part)

    if cache is None:
        cache = []
    elif cache is ...:
        cache = _global_cache
    check_type_is(list, cache)
    if not cache:
        cache.append([1])
    #assert cache
    #assert cache[0]
    assert cache[0][0] == 1

    for v in range(len(cache), u+1):
        _4u2m2n(cache, v)
    return cache[u][max4part]
def _4u2m2n(cache, u, /):
    '[u > 0][len(cache) == u]'
    assert len(cache) == u > 0
    ls = [0, 1]
    cache.append(ls)
    for max4part in range(2, u+1):
        #bug:
        #_, v = divmod(u, max4part)
        #n = cache[v][v]

        v = u-max4part
        n = cache[v][min(v, max4part)]
        n += ls[-1]
        ls.append(n)
    #assert cache[u] is ls
    #assert len(ls) == u+1
    #ls[u]
    #cache[u][u]

def uint2iter_uint_partitions_(u, /, *, to_expand=True, max4part=None, max4num_parts=None):
    'u/uint -> (kw:to_expand/bool) -> Iter ([part] if to_expand else [(part, count)]) # in decreasing order'
    ##############
    # @20250508:++kw:max4part
    # @20250508:++kw:max4num_parts
    ##############
    check_type_is(bool, to_expand)
    check_int_ge(0, u)
    ##############
    if None is max4part:
        max4part = u
    check_int_ge(0, max4part)
    #max4part = min(u, max4part)
    # [0 <= max4part]
    # but:[u <?> max4part]
    ##############
    if None is max4num_parts:
        max4num_parts = u
    check_int_ge(0, max4num_parts)
    max4num_parts = min(u, max4num_parts)
    # [0 <= max4num_parts <= u]
    ##############
    #.if 0:
    #.    if max4num_parts == 0:
    #.        if u > 0: return null_iter
    #.        if u == 0:return iter([()])
    #.    if max4num_parts == 1:
    #.        if u > 0: return iter([(u,)])
    #.        if u == 0:return iter([()])
    ##############

    ls = []
        # :: [part] if to_expand else [(part, count)]
    ##############
    if to_expand:
        put = ls.append
        pop = ls.pop
    else:
        def put(max4part, /):
            if ls and ls[-1][0] == max4part:
                _, sz = ls.pop()
                sz += 1
            else:
                sz = 1
            ls.append((max4part, sz))
        def pop():
            max4part, sz = ls.pop()
            sz -= 1
            if sz:
                ls.append((max4part, sz))
    ##############
    put
    pop
    ##############
    def recur_iter_partss4u_(u, max4part, /):
        # precondition:[len(ls) <= max4num_parts][u >= 0][max4part >= 0]
        #   but:[u <?> max4part]
        ##############
        # [u >= 0]
        # [max4part >= 0]
        # [len(ls) <= max4num_parts]
        ##############
        if u == 0:
            yield tuple(ls)
            # [len(ls) <= max4num_parts]
            return
        # [u > 0]
        if not len(ls) < max4num_parts:
            # [len(ls) == max4num_parts]
            # [u > 0]
            return
        # [len(ls) < max4num_parts]
        # [u > 0]
        # [max4part >= 0]
        # [u <?> max4part]
        max4part = min(max4part, u)
        # [0 <= max4part <= u]
        for max4part in reversed(range(1, max4part+1)):
            # [1 <= new-max4part <= old-max4part <= u]
            #######
            #bug:sz, v = divmod(u, max4part)
            #if sz:ls += [max4part]*sz
                #UnboundLocalError: cannot access local variable 'ls' where it is not associated with a value
            #######
            v = u-max4part
            # !! [1 <= new-max4part <= u]
            # [0 <= v < u]
            # [v >= 0]
            # but:[v <?> max4part]
            # !! [len(ls) < max4num_parts]
            put(max4part)
            # [len(ls) <= max4num_parts]
            yield from recur_iter_partss4u_(v, max4part)
            # [len(ls) <= max4num_parts]
            pop()
            # [len(ls) < max4num_parts]
        # [len(ls) < max4num_parts]
    #end-def recur_iter_partss4u_(u, max4part, /):
    # [len(ls) == 0 <= max4num_parts]
    # [len(ls) <= max4num_parts]
    # [u >= 0]
    # [max4part >= 0]
    # but:[u <?> max4part]
    return recur_iter_partss4u_(u, max4part)
    return recur_iter_partss4u_(u, u)

def iter_parts5uint_partition_(uint_partition, /, *, zipped_vs_expanded=False):
    '([part] if zipped_vs_expanded else [(part, count)]) -> Iter part'
    check_type_is(bool, zipped_vs_expanded)
    f = iter if zipped_vs_expanded else iter_parts5zipped_uint_partition_
    return f(uint_partition)
def iter_parts5zipped_uint_partition_(zipped_uint_partition, /):
    '[(part, count)] -> Iter part'
    for part, count in zipped_uint_partition:
        yield from repeat(part, count)
def iter_counted_parts5uint_partition_(uint_partition, /, *, zipped_vs_expanded=False):
    '([part] if zipped_vs_expanded else [(part, count)]) -> Iter (part, count)'
    check_type_is(bool, zipped_vs_expanded)
    f = iter_counted_parts5expanded_uint_partition_ if zipped_vs_expanded else iter
    return f(uint_partition)
def iter_counted_parts5expanded_uint_partition_(expanded_uint_partition, /):
    '[part] -> Iter (part, count)'
    for part, it in groupby(expanded_uint_partition):
        parts = tuple(it)
        count = len(parts)
        yield (part, count)
def num_permutations5uint_partition_(uint_partition, /, *, zipped_vs_expanded=True):
    '([part] if zipped_vs_expanded else [(part, count)]) -> num_permutations/uint'
    # [整数拆分 == 置换环节表达 的 置换环节 的 长度]
    expanded_uint_partition = iter_counted_parts5uint_partition_(uint_partition, zipped_vs_expanded=zipped_vs_expanded)

    r = 1
    u = 0
    for part, count in expanded_uint_partition:
        for _ in range(count):
            u += part
            #no:r *= comb(u, part)#see:num_set_partitions5uint_partition_()
            #选出一个 置换环节
            r *= (perm(u, part) // part)#有序但周期性循环
        r //= factorial(count)
    return r
def num_set_partitions5uint_partition_(uint_partition, /, *, zipped_vs_expanded=True):
    '([part] if zipped_vs_expanded else [(part, count)]) -> num_set_partitions/uint'
    # [整数拆分 == 集合拆分 的 子集 的 规模]
    #parts = iter_parts5uint_partition_(uint_partition, zipped_vs_expanded=zipped_vs_expanded)
    expanded_uint_partition = iter_counted_parts5uint_partition_(uint_partition, zipped_vs_expanded=zipped_vs_expanded)

    r = 1
    u = 0
    for part, count in expanded_uint_partition:
        for _ in range(count):
            u += part
            #选出一个 子集
            r *= comb(u, part)#无序<==>递增
        r //= factorial(count)
    return r
num_unordered_choices5uint_partition_ = num_set_partitions5uint_partition_
    #vs:num_ordered_choices5uint_partition_
def num_ordered_choices5uint_partition_(uint_partition, /, *, zipped_vs_expanded=True):
    '([part] if zipped_vs_expanded else [(part, count)]) -> num_ordered_choices/uint'
    # [整数拆分 == 集合拆分 的 预着色-子集 的 规模#即 各部分依次序预先着色，等规模子集 并不等价]
    #parts = iter_parts5uint_partition_(uint_partition, zipped_vs_expanded=zipped_vs_expanded)
    expanded_uint_partition = iter_counted_parts5uint_partition_(uint_partition, zipped_vs_expanded=zipped_vs_expanded)

    r = 1
    u = 0
    for part, count in expanded_uint_partition:
        for _ in range(count):
            u += part
            #选出一个 子集
            r *= comb(u, part)#无序<==>递增
        #no:r //= factorial(count)
            # !! "ordered"
    return r

def partition_uint_factorial_(u, /, *, to_expand=True):
    'uint -> (num_permutations/uint, uint_partition/([part] if to_expand else [(part, count)]))'
    it = uint2iter_uint_partitions_(u, to_expand=to_expand)
    s = 0
    j = 0
    for j, uint_partition in enumerate(it, 1):
        num_permutations = num_permutations5uint_partition_(uint_partition, zipped_vs_expanded=to_expand)
        yield (num_permutations, uint_partition)
        s += num_permutations
    assert s == (__:=factorial(u)), (u, s, __)
    assert j == (__:=uint2num_uint_partitions_(u, cache=None)), (u, j, __)
    return

def _find_zpows4us(us, /):
    for u in us:
        yield from _find_zpows(u)
def _find_zpows(u, /):
    M = 16
    if u > 12:raise Exception('too big')
    sz = uint2num_uint_partitions_(u, cache=None)
    if sz > M*2:raise Exception('too big')
    ns = []
    ts = []
    for num_permutations, uint_partition in partition_uint_factorial_(u, to_expand=False):
        ns.append(num_permutations)
        ts.append(uint_partition)
    L = len(ns)
    H = L//2
    lows = ns[:H]
    bigs = ns[H:]
    #permutation
    sum2lows = {sum(ns):ns for ns in _iter_all_subsets_of_seq_(lows)}
    sum2bigs = {sum(ns):ns for ns in _iter_all_subsets_of_seq_(bigs)}
    flb_fu = factorial(u).bit_length()-1
    for ez in reversed(range(flb_fu+1)):
        zpow = 1 << ez
        for s0 in sum2lows:
            s1 = zpow -s0
            if s1 in sum2bigs:
                ns0 = sum2lows[s0]
                ns1 = sum2bigs[s1]
                yield (u, ez, [*ns0, *ns1])

def _iter_all_subsets_of_seq_(ls, /):
    sz = len(ls)
    m = 1 << sz
    M = 1 << (1+sz)
    for i in range(m, M):
        bs = bin(i)[3:]
        assert len(bs) == sz
        yield tuple(compress(ls, map(int, bs)))

def _find_partial_zpows__16():
    u = 16
    sz = uint2num_uint_partitions_(u, cache=None)
    assert sz == 231
    ns = []
    ts = []
    for num_permutations, uint_partition in partition_uint_factorial_(u, to_expand=False):
        ns.append(num_permutations)
        ts.append(uint_partition)
    L = len(ns)
    sorted(set(ns))
    raise ...
__all__
from seed.math.uint_partition import *
