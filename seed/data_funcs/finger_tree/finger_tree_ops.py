#__all__:goto
r'''[[[
e ../../python3_src/seed/data_funcs/finger_tree/finger_tree_ops.py
e ../../python3_src/seed/data_funcs/finger_tree/finger_tree_ops__instances.py


seed.data_funcs.finger_tree.finger_tree_ops
py -m nn_ns.app.debug_cmd   seed.data_funcs.finger_tree.finger_tree_ops -x
py -m nn_ns.app.doctest_cmd seed.data_funcs.finger_tree.finger_tree_ops:__doc__
py -m nn_ns.app.doctest_cmd seed.data_funcs.finger_tree.finger_tree_ops:__doc__  -ff -v --ndiff
py_adhoc_call   seed.data_funcs.finger_tree.finger_tree_ops   @f
py_adhoc_call  seed.helper.print_methods  @wrapped_print_methods   %seed.data_funcs.finger_tree.finger_tree_ops:魖双侧展翅树囗相关操作囗囗面向树实例终端用户囗囗元素版@T    =T      ++exclude_prefixes:_       +exclude_attrs5listed_in_cls_doc

py_adhoc_call  seed.helper.print_methods  @wrapped_print_methods   %seed.data_funcs.finger_tree.finger_tree_ops:魖双侧展翅树囗相关操作囗囗面向树实例终端用户囗囗元素版囗囗囗囗固化方法囗囗长度相关@T    =T      ++exclude_prefixes:_       +exclude_attrs5listed_in_cls_doc


#]]]'''
__all__ = r'''
魖双侧展翅树囗相关操作囗囗面向树实例终端用户囗囗元素版
    魖双侧展翅树囗相关操作囗囗面向树实例终端用户囗囗元素版囗囗囗囗固化方法囗囗长度相关
    魖双侧展翅树囗相关操作囗囗面向树实例终端用户囗囗元素版囗囗囗囗固化方法囗囗散列值相关
    魖双侧展翅树囗相关操作囗囗面向树实例终端用户囗囗元素版囗囗囗囗部分方法缺省具现
    魖双侧展翅树囗相关操作
        乸双侧展翅树囗相关操作

'''.split()#'''
__all__
from seed.abc.abc__ver1 import abstractmethod, override, ABC, ABC__no_slots
from seed.tiny import null_tuple

import operator as opss
from seed.iters.cmp4iterable import cmp4iterable__lt, lt4iterable__lt


######################
__all__
#class 魖双侧展翅树囗数据类型配置囗囗显式参数列举式囗囗面向适配底层数据类型(ABC):
    #底层接口冖冖某某某
#class 魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程(ABC):
    #外参接口冖冖某某某(..., 参数配置=???)
#class 魖双侧展翅树囗数据类型配置囗囗隐式参数囗囗面向树子类设计者囗囗节点版(ABC):
    #内参接口冖冖某某某<参数配置>(...)
    #元素版内参接口冖冖某某某
#class 魖双侧展翅树囗相关操作囗囗面向树实例终端用户囗囗元素版(ABC):
    #某某某#元素版
#



class 魖双侧展翅树囗相关操作囗囗面向树实例终端用户囗囗元素版(ABC):
    r'''[[[
new_abstract_methods:
    `构造树囗
    `迭代元素囗
    `巜压入元素囗
    `巜弹出魊元素囗
    `合并两树囗
    `分裂成两树囗
    `查询整树属性囗
    `是空树囗
    `构造空树囗
    `取端点魊元素囗
    `定位焦点魊元素囗
    `取魊属性索引纟长度囗

    #]]]'''#'''
    __slots__ = ()

    @abstractmethod
    def 构造树囗(sf, 元素序列, /, *, 左起丷右起):
        '-> 双侧展翅树'
    @abstractmethod
    def 迭代元素囗(sf, 双侧展翅树, /, *, 左起丷右起):
        '-> Iter 元素'
    @abstractmethod
    def 巜压入元素囗(sf, 双侧展翅树, 元素, /, *, 左端丷右端):
        '-> (双侧展翅树, None)'
    @abstractmethod
    def 巜弹出魊元素囗(sf, 双侧展翅树, /, *, 左端丷右端):
        '-> (双侧展翅树, 魊元素)'

    @abstractmethod
    def 合并两树囗(sf, 左囗双侧展翅树, 右囗双侧展翅树, /):
        '-> 双侧展翅树'

    @abstractmethod
    def 分裂成两树囗(sf, 双侧展翅树, 属性索引, 满足条件囗丨最大许可值, /, *, 左起丷右起):
        '[属性索引 是公开属性] => 双侧展翅树 -> 属性索引 -> (满足条件囗/(属性<属性索引> -> 退丷进)|最大许可值<属性索引;起树>) -> (起囗双侧展翅树<左起丷右起>/焦点居前, 讫囗双侧展翅树<左起丷右起>/焦点诸后) # [最大化 起树:满足条件囗(起树.属性<属性索引>)]' ' #see:魖属性界面'


    @abstractmethod
    def 查询整树属性囗(sf, 双侧展翅树, 属性索引, /):
        '[属性索引 是公开属性] => 双侧展翅树 -> 属性索引 -> 属性<属性索引>' ' #see:魖属性界面'


    @abstractmethod
    def 是空树囗(sf, 双侧展翅树, /):
        '-> bool'
    @abstractmethod
    def 构造空树囗(sf, /):
        '-> 双侧展翅树'
    @abstractmethod
    def 取端点魊元素囗(sf, 双侧展翅树, /, *, 左端丷右端):
        '-> 魊元素'
    @abstractmethod
    def 定位焦点魊元素囗(sf, 双侧展翅树, 属性索引, 满足条件囗丨最大许可值, /, *, 左起丷右起):
        '[属性索引 是公开属性] => 双侧展翅树 -> 属性索引 -> (满足条件囗/(属性<属性索引> -> 退丷进)|最大许可值<属性索引;起树>) -> (焦点居前囗累计值, 魊元素) # [最大化 起树:满足条件囗(起树.属性<属性索引>)]' ' #see:魖属性界面'

    @abstractmethod
    def 取魊属性索引纟长度囗(sf, 双侧展翅树, /):
        '-> 魊属性索引纟长度/(魊 属性索引<长度>)'
    @abstractmethod
    def 取魊属性索引纟散列值囗(sf, 双侧展翅树, /):
        '-> 魊属性索引纟散列值/(魊 属性索引<散列值>)'
    ######################
    ######################
    #####以下:需要:[[双侧展翅树 内建支持 长度属性]or["len" 是公开属性]]
    ######################
    ######################
    # 固化方法
    #@abstractmethod
    #def 取长度囗(sf, 双侧展翅树, /):
    #    '[[双侧展翅树 内建支持 长度属性]or["len" 是公开属性]] => 双侧展翅树 -> 长度/元素数目'
    #    # 因为 长度 与元素无关，所以 长度 可以被 内建支持
    #@abstractmethod
    #def 取魊元素囗(sf, 双侧展翅树, 位置, /):
    #    '[[双侧展翅树 内建支持 长度属性]or["len" 是公开属性]] => 双侧展翅树 -> 位置/int -> 魊元素'
    #@abstractmethod
    #def 取子树囗(sf, 双侧展翅树, 起囗位置, 讫囗位置, /):
    #    '[[双侧展翅树 内建支持 长度属性]or["len" 是公开属性]] => 双侧展翅树 -> 起囗位置/int -> 讫囗位置/int -> 双侧展翅树'


    ######################
    ######################
    #####以下:需要:[[双侧展翅树 内建支持 散列值属性]or["len" 是公开属性]]
    ######################
    ######################
    # 固化方法
    #@abstractmethod
    #def 取散列值囗(sf, 双侧展翅树, /):
    #    '[[双侧展翅树 内建支持 散列值属性]or["hash" 是公开属性]] => 双侧展翅树 -> 散列值<整树;只考虑元素与次序，不考虑树结构>'
    #    # 因为 散列值 使用 hash(元素)，所以 元素 可散列 情形下，散列值 可以被 内建支持

#end-class 魖双侧展翅树囗相关操作囗囗面向树实例终端用户囗囗元素版

####class 魖双侧展翅树囗相关操作囗囗面向树实例终端用户囗囗元素版囗囗囗囗整树封包(魖双侧展翅树囗相关操作囗囗面向树实例终端用户囗囗元素版):
####    @abstractmethod
####    def 整树封包囗(sf, 双侧展翅树, /):
####        '-> 双侧展翅树 #例如:用于 内建支持 整树长度/元素数目'
####    @abstractmethod
####    def 整树拆包囗(sf, 双侧展翅树, /):
####        '-> 双侧展翅树'
class 魖双侧展翅树囗相关操作囗囗面向树实例终端用户囗囗元素版囗囗囗囗固化方法囗囗长度相关(魖双侧展翅树囗相关操作囗囗面向树实例终端用户囗囗元素版):
    r'''[[[
new_abstract_methods:
    `取属性索引纟长度囗
new_concrete_methods:
    取魊属性索引纟长度囗
    取长度囗
    取魊元素囗
    取子树囗

    #]]]'''#'''
    __slots__ = ()

    @abstractmethod
    def 取属性索引纟长度囗(sf, 双侧展翅树, /):
        '-> 属性索引纟长度/(属性索引<长度>)'
        属性索引纟长度 = 'len'
        return 属性索引纟长度
    @override
    def 取魊属性索引纟长度囗(sf, 双侧展翅树, /):
        '-> 魊属性索引纟长度/(魊 属性索引<长度>)'
        属性索引纟长度 = sf.取属性索引纟长度囗(双侧展翅树)
        return (属性索引纟长度,)
    ######################
    ######################
    #####以下:需要:[[双侧展翅树 内建支持 长度属性]or["len" 是公开属性]]
    ######################
    ######################
    # 固化方法:属性:长度
    #
    #@override
    def 取长度囗(sf, 双侧展翅树, /):
        '[[双侧展翅树 内建支持 长度属性]or["len" 是公开属性]] => 双侧展翅树 -> 长度/元素数目'
        # 因为 长度 与元素无关，所以 长度 可以被 内建支持
        属性索引纟长度 = sf.取属性索引纟长度囗(双侧展翅树)
        return sf.查询整树属性囗(双侧展翅树, 属性索引纟长度)
    #@override
    def 取魊元素囗(sf, 双侧展翅树, 位置, /):
        '[[双侧展翅树 内建支持 长度属性]or["len" 是公开属性]] => 双侧展翅树 -> 位置/int -> 魊元素'
        属性索引纟长度 = sf.取属性索引纟长度囗(双侧展翅树)
        左起丷右起 = 位置 < 0
        if 左起丷右起:
            位置 = -1-位置
        (焦点居前囗累计值, 魊元素) = sf.定位焦点魊元素囗(双侧展翅树, 属性索引纟长度, 位置, 左起丷右起=左起丷右起)
        return 魊元素
    #@override
    def 取子树囗(sf, 双侧展翅树, 起囗位置, 讫囗位置, /):
        '[[双侧展翅树 内建支持 长度属性]or["len" 是公开属性]] => 双侧展翅树 -> 起囗位置/int -> 讫囗位置/int -> 双侧展翅树'
        总长 = sf.取长度囗(双侧展翅树)
        if 起囗位置 is None:
            起囗位置 = 0
        if 讫囗位置 is None:
            讫囗位置 = 总长

        if 起囗位置 < 0:
            起囗位置 += 总长
        起囗位置 = max(起囗位置, 0)
        if 讫囗位置 < 0:
            讫囗位置 += 总长
        讫囗位置 = min(讫囗位置, 总长)
        if not 起囗位置 < 讫囗位置:
            return sf.构造空树囗()
        属性索引纟长度 = sf.取属性索引纟长度囗(双侧展翅树)
        if not 讫囗位置 == 总长:
            双侧展翅树, _ = sf.分裂成两树囗(双侧展翅树, 属性索引纟长度, 讫囗位置, 左起丷右起=False)
        if not 起囗位置 == 0:
            _, 双侧展翅树 = sf.分裂成两树囗(双侧展翅树, 属性索引纟长度, 起囗位置, 左起丷右起=False)
        return 双侧展翅树
#end-class 魖双侧展翅树囗相关操作囗囗面向树实例终端用户囗囗元素版囗囗囗囗固化方法囗囗长度相关


class 魖双侧展翅树囗相关操作囗囗面向树实例终端用户囗囗元素版囗囗囗囗固化方法囗囗散列值相关(魖双侧展翅树囗相关操作囗囗面向树实例终端用户囗囗元素版):
    '一般来说，散列值 都 依赖于 长度 与 次序，否则 是糟糕的散列算法'
    __slots__ = ()
    @abstractmethod
    def 取属性索引纟散列值囗(sf, 双侧展翅树, /):
        '-> 属性索引纟散列值/(属性索引<散列值>)'
        属性索引纟散列值 = 'hash'
        return 属性索引纟散列值
    @override
    def 取魊属性索引纟散列值囗(sf, 双侧展翅树, /):
        '-> 魊属性索引纟散列值/(魊 属性索引<散列值>)'
        属性索引纟散列值 = sf.取属性索引纟散列值囗(双侧展翅树)
        return (属性索引纟散列值,)
    ######################
    ######################
    #####以下:需要:[[双侧展翅树 内建支持 散列值属性]or["len" 是公开属性]]
    ######################
    ######################
    # 固化方法
    #
    #@override
    def 取散列值囗(sf, 双侧展翅树, /):
        '[[双侧展翅树 内建支持 散列值属性]or["hash" 是公开属性]] => 双侧展翅树 -> 散列值<整树;只考虑元素与次序，不考虑树结构>'
        属性索引纟散列值 = sf.取属性索引纟散列值囗(双侧展翅树)
        return sf.查询整树属性囗(双侧展翅树, 属性索引纟散列值)
#end-class 魖双侧展翅树囗相关操作囗囗面向树实例终端用户囗囗元素版囗囗囗囗固化方法囗囗散列值相关




class 魖双侧展翅树囗相关操作囗囗面向树实例终端用户囗囗元素版囗囗囗囗部分方法缺省具现(魖双侧展翅树囗相关操作囗囗面向树实例终端用户囗囗元素版):
    __slots__ = ()
    @override
    def 是空树囗(sf, 双侧展翅树, /):
        '-> bool'
        it = sf.迭代元素囗(双侧展翅树, 左起丷右起=False)
        for 元素 in it:
            return False
        return True
    @override
    def 构造空树囗(sf, /):
        '-> 双侧展翅树'
        return sf.构造树囗('', 左起丷右起=False)
    @override
    def 取端点魊元素囗(sf, 双侧展翅树, /, *, 左端丷右端):
        '-> 魊元素'
        it = sf.迭代元素囗(双侧展翅树, 左起丷右起=左端丷右端)
        for 元素 in it:
            return (元素,)
        return null_tuple
    @override
    def 定位焦点魊元素囗(sf, 双侧展翅树, 属性索引, 满足条件囗丨最大许可值, /, *, 左起丷右起):
        '[属性索引 是公开属性] => 双侧展翅树 -> 属性索引 -> (满足条件囗/(属性<属性索引> -> 退丷进)|最大许可值<属性索引;起树>) -> (焦点居前囗累计值, 魊元素) # [最大化 起树:满足条件囗(起树.属性<属性索引>)]' ' #see:魖属性界面'
        焦点居前囗起树, 焦点诸后囗讫树 = sf.分裂成两树囗(双侧展翅树, 属性索引, 满足条件囗丨最大许可值, 左起丷右起=左起丷右起)
        _, 魊元素囗囗焦点 = sf.巜弹出魊元素囗(焦点诸后囗讫树, 左端丷右端=左起丷右起)
        焦点居前囗累计值 = sf.查询整树属性囗(双侧展翅树, 属性索引)
        return (焦点居前囗累计值, 魊元素囗囗焦点)
#end-class 魖双侧展翅树囗相关操作囗囗面向树实例终端用户囗囗元素版囗囗囗囗部分方法缺省具现



def _取两参数囗(sf, /):
    return (sf.取囗参数配置囗(), sf.取囗外参操作界面囗())
def _get_epi_kw2(sf, /):
    参数配置, 外参操作界面 = _取两参数囗(sf)
    kw2 = dict(参数配置=参数配置, 深度=0)
    epi = 外参操作界面
    return epi, kw2


class 魖双侧展翅树囗相关操作(魖双侧展翅树囗相关操作囗囗面向树实例终端用户囗囗元素版):
    r'''[[[
参数配置 :: 乸双侧展翅树囗参数配置囗囗紧致假设
外参操作界面 :: (魖属性界面 && 魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程)


from seed.data_funcs.finger_tree.finger_tree_common import 乸双侧展翅树囗参数配置囗囗紧致假设
from seed.data_funcs.finger_tree.finger_tree__external_packed_config import 魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程
from seed.data_funcs.finger_tree.finger_tree__physical_layer import 魖属性界面

    #]]]'''#'''
    __slots__ = ()
    @abstractmethod
    def 取囗参数配置囗(sf, /):
        '-> 参数配置'
    @abstractmethod
    def 取囗外参操作界面囗(sf, /):
        '-> 外参操作界面'

    ######################
    @override
    def 构造树囗(sf, 元素序列, /, *, 左起丷右起):
        '-> 双侧展翅树'
        参数配置, 外参操作界面 = _取两参数囗(sf)
        kw2 = dict(参数配置=参数配置, 深度=0)
        f = 外参操作界面.外参接口冖冖构造囗元素封包节点囗
        节点序列 = (f(元素, **kw2) for 元素 in 元素序列)
        return 外参操作界面.外参接口冖冖构造囗双侧展翅树囗(节点序列, 左起丷右起=左起丷右起, **kw2)
    ######################
    @override
    def 是空树囗(sf, 双侧展翅树, /):
        '-> bool'
        epi, kw2 = _get_epi_kw2(sf)
        return epi.外参接口冖冖是空树囗囗双侧展翅树囗(双侧展翅树, **kw2)
    ######################
    @override
    def 迭代元素囗(sf, 双侧展翅树, /, *, 左起丷右起):
        '-> Iter 元素'
        epi, kw2 = _get_epi_kw2(sf)
        元素封包节点序列 = epi.外参接口冖冖迭代囗子节点囗囗双侧展翅树囗(双侧展翅树, 左起丷右起=左起丷右起, **kw2)
        f = epi.外参接口冖冖拆包囗元素封包节点囗
        return (f(元素封包节点, **kw2) for 元素封包节点 in 元素封包节点序列)
    ######################
    @override
    def 巜压入元素囗(sf, 双侧展翅树, 元素, /, *, 左端丷右端):
        '-> (双侧展翅树, None)'
        epi, kw2 = _get_epi_kw2(sf)
        节点 = epi.外参接口冖冖构造囗元素封包节点囗(元素, **kw2)
        return epi.外参接口冖冖巜压入节点囗囗双侧展翅树囗(双侧展翅树, 节点, 左端丷右端=左端丷右端, **kw2)
    ######################
    @override
    def 巜弹出魊元素囗(sf, 双侧展翅树, /, *, 左端丷右端):
        '-> (双侧展翅树, 魊元素)'
        epi, kw2 = _get_epi_kw2(sf)
        (双侧展翅树, 魊端点) = epi.外参接口冖冖巜弹出节点囗囗双侧展翅树囗(双侧展翅树, 空树报错丷魊=True, 左端丷右端=左端丷右端, **kw2)
        魊元素 = _魊拆包囗(epi, 魊端点, kw2)
        return (双侧展翅树, 魊元素)

    ######################
    @override
    def 合并两树囗(sf, 左囗双侧展翅树, 右囗双侧展翅树, /):
        '-> 双侧展翅树'
        epi, kw2 = _get_epi_kw2(sf)
        双侧展翅树, _ = epi.外参接口冖冖巜合并囗囗双侧展翅树囗(左囗双侧展翅树, 右囗双侧展翅树, 左起丷右起=False, **kw2)
        return 双侧展翅树

    ######################
    @override
    def 分裂成两树囗(sf, 双侧展翅树, 属性索引, 满足条件囗丨最大许可值, /, *, 左起丷右起):
        '[属性索引 是公开属性] => 双侧展翅树 -> 属性索引 -> (满足条件囗/(属性<属性索引> -> 退丷进)|最大许可值<属性索引;起树>) -> (起囗双侧展翅树<左起丷右起>/焦点居前, 讫囗双侧展翅树<左起丷右起>/焦点诸后) # [最大化 起树:满足条件囗(起树.属性<属性索引>)]' ' #see:魖属性界面'
        return _分裂仐定位囗(sf, 双侧展翅树, 属性索引, 满足条件囗丨最大许可值, 左起丷右起=左起丷右起, 分裂丷定位=False)
    ######################
    @override
    def 定位焦点魊元素囗(sf, 双侧展翅树, 属性索引, 满足条件囗丨最大许可值, /, *, 左起丷右起):
        '[属性索引 是公开属性] => 双侧展翅树 -> 属性索引 -> (满足条件囗/(属性<属性索引> -> 退丷进)|最大许可值<属性索引;起树>) -> (焦点居前囗累计值, 魊元素) # [最大化 起树:满足条件囗(起树.属性<属性索引>)]' ' #see:魖属性界面'
        return _分裂仐定位囗(sf, 双侧展翅树, 属性索引, 满足条件囗丨最大许可值, 左起丷右起=左起丷右起, 分裂丷定位=True)
    ######################
    @override
    def 查询整树属性囗(sf, 双侧展翅树, 属性索引, /):
        '[属性索引 是公开属性] => 双侧展翅树 -> 属性索引 -> 属性<属性索引>' ' #see:魖属性界面'
        epi, kw2 = _get_epi_kw2(sf)
        缓存度量囗囗整树 = epi.外参接口冖冖取囗缓存度量囗囗双侧展翅树囗(双侧展翅树, **kw2)
        属性值囗囗整树 = epi.底层接口冖冖取囗缓存度量囗公开属性囗(缓存度量囗囗整树, 属性索引)
        return 属性值囗囗整树

    @override
    def 构造空树囗(sf, /):
        '-> 双侧展翅树'
        epi, kw2 = _get_epi_kw2(sf)
        双侧展翅树 = epi.外参接口冖冖构造囗空树囗(**kw2)
        return 双侧展翅树
    @override
    def 取端点魊元素囗(sf, 双侧展翅树, /, *, 左端丷右端):
        '-> 魊元素'
        epi, kw2 = _get_epi_kw2(sf)
        魊端点 = epi.外参接口冖冖取囗端点囗囗双侧展翅树囗(双侧展翅树, 空树报错丷魊=True, 左起丷右起=左端丷右端, **kw2)
        魊元素 = _魊拆包囗(epi, 魊端点, kw2)
        return 魊元素
#end-class 魖双侧展翅树囗相关操作



def _分裂仐定位囗(sf, 双侧展翅树, 属性索引, 满足条件囗丨最大许可值, /, *, 左起丷右起, 分裂丷定位):
    '[属性索引 是公开属性] => 双侧展翅树 -> 属性索引 -> (满足条件囗/(属性<属性索引> -> 退丷进)|最大许可值<属性索引;起树>) -> ((起囗双侧展翅树<左起丷右起>/焦点居前, 讫囗双侧展翅树<左起丷右起>/焦点诸后) | (焦点居前囗累计值, 魊元素)) # [最大化 起树:满足条件囗(起树.属性<属性索引>)]' ' #see:魖属性界面'
    ######################
    #长度 ~ 位置 # 特殊处理
    if not callable(满足条件囗丨最大许可值):
        最大许可值 = 满足条件囗丨最大许可值
        if 属性索引 in sf.取魊属性索引纟长度囗(双侧展翅树):
            位置 = 最大许可值
            长度属性索引 = 属性索引
            整树长度 = sf.查询整树属性囗(双侧展翅树, 长度属性索引)
            if 位置 < 0:
                位置 += 整树长度
                位置 = max(0, 位置)
            else:
                位置 = min(位置, 整树长度)
            位置
            满足条件囗丨最大许可值 = 最大许可值 = 位置
    ######################

    epi, kw2 = _get_epi_kw2(sf)
    初始累计值 = epi.取囗缓存度量囗公开属性囗加法零元囗(属性索引)

    def 抽取差分囗(缓存度量, /):
        差分度量 = 属性值 = epi.底层接口冖冖取囗缓存度量囗公开属性囗(缓存度量, 属性索引)
        return 差分度量
    # (抽取差分囗, 累积囗:=(+), 退进决断囗:=(最大许可值>=), 已知初始累计值决断进) =
    退进决断囗 = 满足条件囗丨最大许可值
    t4 = (抽取差分囗, None, 退进决断囗, False)
    r = epi.外参接口冖冖分裂囗囗定位囗魊焦点囗囗全魊囗囗双侧展翅树囗(双侧展翅树, 初始累计值, t4, 已知焦点存在=False, 是否需囗焦点居前囗起半扇=not 分裂丷定位, 是否需囗焦点诸后囗讫半扇=not 分裂丷定位, 是否需囗焦点=分裂丷定位, 是否需囗焦点居后囗讫半扇=False, 左起丷右起=左起丷右起, **kw2)

    if not 分裂丷定位:
        ([焦点居前囗双侧展翅树], 焦点居前囗累计值, [焦点诸后囗双侧展翅树], [], []) = r
        return 焦点居前囗双侧展翅树, 焦点诸后囗双侧展翅树
    ([], 焦点居前囗累计值, [], [魊焦点], []) = r
    魊元素 = _魊拆包囗(epi, 魊焦点, kw2)
    return (焦点居前囗累计值, 魊元素)
######################
def _魊拆包囗(epi, 魊节点, kw2, /):
    if 魊节点:
        [节点] = 魊节点
        元素 = epi.外参接口冖冖拆包囗元素封包节点囗(节点, **kw2)
        魊元素 = (元素,)
    else:
        魊元素 = null_tuple
    return 魊元素

######################
######################
######################
######################
class _魖双侧展翅树囗相关操作囗囗无长度(魖双侧展翅树囗相关操作):
    ___no_slots_ok___ = True

    @override
    def 取囗参数配置囗(sf, /):
        '-> 参数配置'
        return sf._参数配置
    @override
    def 取囗外参操作界面囗(sf, /):
        '-> 外参操作界面'
        return sf._外参操作界面

    ######################
    def __init__(sf, 参数配置, 外参操作界面, /):
        sf._参数配置 = 参数配置
        sf._外参操作界面 = 外参操作界面

class 乸双侧展翅树囗相关操作囗囗无长度(_魖双侧展翅树囗相关操作囗囗无长度):
    @override
    def 取魊属性索引纟长度囗(sf, 双侧展翅树, /):
        '-> 魊属性索引纟长度/(魊 属性索引<长度>)'
        return null_tuple
    @override
    def 取魊属性索引纟散列值囗(sf, 双侧展翅树, /):
        '-> 魊属性索引纟散列值/(魊 属性索引<散列值>)'
        return null_tuple

class 乸双侧展翅树囗相关操作(魖双侧展翅树囗相关操作囗囗面向树实例终端用户囗囗元素版囗囗囗囗固化方法囗囗散列值相关, 魖双侧展翅树囗相关操作囗囗面向树实例终端用户囗囗元素版囗囗囗囗固化方法囗囗长度相关, _魖双侧展翅树囗相关操作囗囗无长度):
    @override
    def 取属性索引纟长度囗(sf, 双侧展翅树, /):
        '-> 属性索引纟长度/(属性索引<长度>)'
        return super().取属性索引纟长度囗(双侧展翅树)
    @override
    def 取属性索引纟散列值囗(sf, 双侧展翅树, /):
        '[[双侧展翅树 内建支持 散列值属性]or["hash" 是公开属性]] => 双侧展翅树 -> 散列值<整树;只考虑元素与次序，不考虑树结构>'
        return super().取属性索引纟散列值囗(双侧展翅树)


    def 小于冃列表囗(sf, 左囗双侧展翅树, 右囗双侧展翅树, /):
        '[左囗双侧展翅树 <[词典序小于]< 右囗双侧展翅树]'
        itL = sf.迭代元素囗(左囗双侧展翅树, 左起丷右起=False)
        itR = sf.迭代元素囗(右囗双侧展翅树, 左起丷右起=False)
        return lt4iterable__lt(itL, itR)
    def 等价冃列表囗(sf, 左囗双侧展翅树, 右囗双侧展翅树, /):
        '[左囗双侧展翅树 =[词典序等价]= 右囗双侧展翅树]'
        try:
            if not sf.取长度囗(左囗双侧展翅树) == sf.取长度囗(右囗双侧展翅树):
                return False
            if not sf.取散列值囗(左囗双侧展翅树) == sf.取散列值囗(右囗双侧展翅树):
                return False
        except LookupError:
            pass
        itL = sf.迭代元素囗(左囗双侧展翅树, 左起丷右起=False)
        itR = sf.迭代元素囗(右囗双侧展翅树, 左起丷右起=False)
        return all(map(opss.__eq__, itL, itR))

乸双侧展翅树囗相关操作囗囗无长度(..., ...)
乸双侧展翅树囗相关操作(..., ...)

__all__


from seed.data_funcs.finger_tree.finger_tree_ops import 魖双侧展翅树囗相关操作囗囗面向树实例终端用户囗囗元素版
from seed.data_funcs.finger_tree.finger_tree_ops import 魖双侧展翅树囗相关操作囗囗面向树实例终端用户囗囗元素版囗囗囗囗固化方法囗囗长度相关
from seed.data_funcs.finger_tree.finger_tree_ops import 魖双侧展翅树囗相关操作囗囗面向树实例终端用户囗囗元素版囗囗囗囗固化方法囗囗散列值相关

from seed.data_funcs.finger_tree.finger_tree_ops import 魖双侧展翅树囗相关操作囗囗面向树实例终端用户囗囗元素版囗囗囗囗部分方法缺省具现

from seed.data_funcs.finger_tree.finger_tree_ops import 魖双侧展翅树囗相关操作
from seed.data_funcs.finger_tree.finger_tree_ops import 乸双侧展翅树囗相关操作囗囗无长度
from seed.data_funcs.finger_tree.finger_tree_ops import 乸双侧展翅树囗相关操作

from seed.data_funcs.finger_tree.finger_tree_ops import *
