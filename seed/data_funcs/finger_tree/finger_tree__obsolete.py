##################
##################
def _巜压入节点囗囗某某某囗(某某某, 节点, 左端丷右端, 取囗长度囗囗某某某囗, kwds1, 某某某最大许可长度, 错误囗囗溢出囗囗某某某, 迭代囗子节点囗囗某某某囗, kwds2, 构造囗某某某囗, kwds3, /):
    '-> (某某某<深度>, None)'
    左起丷右起 = 左端丷右端
    长度 = 取囗长度囗囗某某某囗(某某某, **kwds1)
    if not 长度+1 <= 某某某最大许可长度: raise 错误囗囗溢出囗囗某某某
    节点序列 = 迭代囗子节点囗囗某某某囗(某某某, 左起丷右起=左起丷右起, **kwds2)
    节点序列 = chain([节点], 节点序列)
    某某某 = 构造囗某某某囗(节点序列, 左起丷右起=左起丷右起, **kwds3)
    return (某某某, None)

######################
def _巜弹出节点囗囗某某某囗(某某某, 左端丷右端, 取囗长度囗囗某某某囗, kwds1, 某某某最小许可长度, 错误囗囗缺员囗囗某某某, 迭代囗子节点囗囗某某某囗, kwds2, 构造囗某某某囗, kwds3, /):
    '-> (某某某<深度>, 节点<深度>)'
    左起丷右起 = 左端丷右端
    长度 = 取囗长度囗囗某某某囗(某某某, **kwds1)
    if not 长度-1 >= 某某某最小许可长度: raise 错误囗囗缺员囗囗某某某
    节点序列 = 迭代囗子节点囗囗某某某囗(某某某, 左起丷右起=左起丷右起, **kwds2)
    节点 = next(节点序列)
    某某某 = 构造囗某某某囗(节点序列, 左起丷右起=左起丷右起, **kwds3)
    return (某某某, 节点)
######################
def _巜同端先弹出再压入节点囗囗某某某囗(某某某, 左端丷右端, 错误囗囗缺员囗囗某某某, 迭代囗子节点囗囗某某某囗, kwds2, 构造囗某某某囗, kwds3, /):
    左起丷右起 = 左端丷右端
    节点序列 = 迭代囗子节点囗囗某某某囗(某某某, 左起丷右起=左起丷右起, **kwds2)
    Nothing = []
    for 节点囗囗出 in 节点序列:
        break
    else:
        raise 错误囗囗缺员囗囗某某某
            # 光杆树 允空
            # 翅膀 非空
    节点序列 = chain([节点], 节点序列)
    某某某 = 构造囗某某某囗(节点序列, 左起丷右起=左起丷右起, **kwds3)
    return (某某某, 节点囗囗出)

######################
def _分流囗囗树形态囗(sf, 针对囗光杆树囗, 针对囗根深树囗, 深度, 双侧展翅树, /, *args, **kwds):
    光杆树丷根深树 = sf.区分树形态囗(双侧展翅树, 深度=深度)
    if 光杆树丷根深树 is False:
        光杆树 = 双侧展翅树
        f = 针对囗光杆树囗
    elif 光杆树丷根深树 is True:
        根深树 = 双侧展翅树
        f = 针对囗根深树囗
    else:
        raise 000
    return f(双侧展翅树, *args, **kwds)
######################
#尝试平衡双翼:
def _尝试平衡双翼囗(sf, 长度, 节点序列, /, *, 左起丷右起, 参数配置, 深度):
    余长 = 长度
    if 余长 <= 参数配置.翅膀缺员时退化上限:
        #变态:退化
        光杆树 = sf.构造囗光杆树囗(节点序列, 左起丷右起=左起丷右起, 光杆树最大许可长度=参数配置.光杆树最大许可长度, 深度=深度)
        双侧展翅树 = 光杆树
        #已有:双侧展翅树
    else:
        根深树 = _分为两翅膀而成根深树囗(sf, 余长, 节点序列, 左起丷右起=左起丷右起, 参数配置=参数配置, 深度=深度)
        #已更新:根深树
        双侧展翅树 = 根深树
        #已有:双侧展翅树
    #已有:双侧展翅树
    return 双侧展翅树
######################
def _分为两翅膀而成根深树囗(sf, 长度, 节点序列, /, *, 左起丷右起, 参数配置, 深度):
    z0 = 长度//2
    #z1 = zz -z0
    it0 = islice(z0, 节点序列)
    起翼 = sf.构造囗翅膀囗囗相对定位囗(it0, 左起丷右起=左起丷右起, 起翼丷讫翼=False, 翅膀最大许可长度=参数配置.翅膀最大许可长度, 翅膀最小许可长度=参数配置.翅膀最小许可长度, 深度=深度)
    讫翼 = sf.构造囗翅膀囗囗相对定位囗(节点序列, 左起丷右起=左起丷右起, 起翼丷讫翼=True, 翅膀最大许可长度=参数配置.翅膀最大许可长度, 翅膀最小许可长度=参数配置.翅膀最小许可长度, 深度=深度)
    更深树 = 空树 = 光杆树 = sf.构造囗光杆树囗('', 左起丷右起=左起丷右起, 光杆树最大许可长度=参数配置.光杆树最大许可长度, 深度=深度+1)
    根深树 = sf.构造囗根深树囗囗相对定位囗(起翼, 更深树, 讫翼, 左起丷右起=左起丷右起, 深度=深度)
    return 根深树
######################


__all__
class 魖双侧展翅树囗数据类型配置囗囗紧致假设(魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程, 魊属性界面):
    r'''[[[
命名解释:goto
===
py_adhoc_call  seed.helper.print_methods  @wrapped_print_methods   %seed.data_funcs.finger_tree.finger_tree_common:魖双侧展翅树囗数据类型配置囗囗紧致假设@T    =T +exclude_attrs5listed_in_cls_doc
===
abstract_methods:
    `区分树形态囗
    `取囗缓存度量囗公开属性囗
    `取囗缓存度量囗公开属性囗加法零元囗
    `取囗缓存度量囗公开属性囗索引列表囗
    `取囗缓存度量囗囗元素封包节点囗
    `取囗缓存度量囗囗光杆树囗
    `取囗缓存度量囗囗更深节点囗
    `取囗缓存度量囗囗根深树囗
    `取囗缓存度量囗囗翅膀囗囗绝对定位囗
    `取囗长度囗囗光杆树囗
    `取囗长度囗囗更深节点囗
    `取囗长度囗囗翅膀囗囗绝对定位囗
    `拆包囗元素封包节点囗
    `拆包囗根深树囗囗绝对定位囗
    `是空树囗囗光杆树囗
    `构造囗元素封包节点囗
    `构造囗光杆树囗
    `构造囗更深节点囗
    `构造囗根深树囗囗绝对定位囗
    `构造囗翅膀囗囗绝对定位囗
    `迭代囗子节点囗囗光杆树囗
    `迭代囗子节点囗囗更深节点囗
    `迭代囗子节点囗囗翅膀囗囗绝对定位囗
===
all_methods:
    _囗分裂囗囗搜索定位囗囗精简版囗囗光杆树囗囗分流用囗
    _囗分裂囗囗搜索定位囗囗精简版囗囗根深树囗囗分流用囗
    _囗分裂囗囗搜索定位囗囗精简版囗囗节点序列囗囗琐碎囗
    _囗取囗魊端点囗囗根深树囗囗分流用囗
    _囗巜压入节点囗囗光杆树囗囗溢出变态囗囗分流用囗
    _囗巜压入节点囗囗根深树囗囗分流用囗
    _囗巜弹出节点囗囗光杆树囗囗分流用囗
    _囗巜弹出节点囗囗根深树囗囗缺员变态囗囗分流用囗
    _囗更深节点序列巛节点序列囗囗要求足够长囗囗紧致假设囗
    分裂囗囗搜索定位囗囗精简版囗囗双侧展翅树囗囗返回值为起讫次序囗
    分裂囗囗搜索定位囗囗复杂版囗囗返回值为起讫次序囗
    分裂囗囗搜索定位囗囗索引版囗囗返回值为起讫次序囗
    `区分树形态囗
    取囗端点囗囗光杆树囗囗空树报错囗
    取囗端点囗囗双侧展翅树囗囗空树报错囗
    取囗端点囗囗根深树囗
    `取囗缓存度量囗公开属性囗
    `取囗缓存度量囗公开属性囗加法零元囗
    `取囗缓存度量囗公开属性囗索引列表囗
    `取囗缓存度量囗囗元素封包节点囗
    `取囗缓存度量囗囗光杆树囗
    取囗缓存度量囗囗双侧展翅树囗
    `取囗缓存度量囗囗更深节点囗
    `取囗缓存度量囗囗根深树囗
    取囗缓存度量囗囗翅膀囗囗相对定位囗
    `取囗缓存度量囗囗翅膀囗囗绝对定位囗
    取囗缓存度量囗囗节点囗
    `取囗长度囗囗光杆树囗
    `取囗长度囗囗更深节点囗
    取囗长度囗囗翅膀囗囗相对定位囗
    `取囗长度囗囗翅膀囗囗绝对定位囗
    取囗魊端点囗囗光杆树囗
    取囗魊端点囗囗双侧展翅树囗
    取外端点囗囗翅膀囗囗绝对定位囗
    合并囗囗间夹囗节点序列囗
    巜压入节点囗囗光杆树囗囗溢出报错囗囗基础囗
    巜压入节点囗囗双侧展翅树囗
    巜外端压入节点囗囗翅膀囗囗相对定位囗
    巜外端压入节点囗囗翅膀囗囗绝对定位囗
    巜弹出节点囗囗光杆树囗囗基础囗
    巜弹出节点囗囗双侧展翅树囗
    巜外端弹出节点囗囗翅膀囗囗相对定位囗
    巜外端弹出节点囗囗翅膀囗囗绝对定位囗
    巜连续压入节点囗囗双侧展翅树囗囗注意反序囗
    巜连续弹出节点囗囗双侧展翅树囗囗注意反序囗
    `拆包囗元素封包节点囗
    拆包囗根深树囗囗相对定位囗
    `拆包囗根深树囗囗绝对定位囗
    是光杆树囗
    是根深树囗
    `是空树囗囗光杆树囗
    是空树囗囗双侧展翅树囗
    `构造囗元素封包节点囗
    `构造囗光杆树囗
    构造囗双侧展翅树囗
    构造囗双侧展翅树囗囗讫翼修复囗
    `构造囗更深节点囗
    构造囗根深树囗囗相对定位囗
    `构造囗根深树囗囗绝对定位囗
    构造囗空树囗
    构造囗翅膀囗囗相对定位囗
    `构造囗翅膀囗囗绝对定位囗
    迭代囗子更深节点囗囗更深树囗
    `迭代囗子节点囗囗光杆树囗
    迭代囗子节点囗囗双侧展翅树囗
    `迭代囗子节点囗囗更深节点囗
    迭代囗子节点囗囗根深树囗
    迭代囗子节点囗囗翅膀囗囗相对定位囗
    `迭代囗子节点囗囗翅膀囗囗绝对定位囗
    迭代囗孙节点囗囗更深树囗

===
    #]]]'''#'''
    __slots__ = ()
    @abstractmethod
    def 构造囗元素封包节点囗(sf, 元素, /):
        '-> 元素封包节点/节点<0>/封包<元素> #用于 缓存 度量，否则 无需 封包'
    @abstractmethod
    def 构造囗更深节点囗(sf, 节点序列, /, *, 左起丷右起, 更深节点最小许可长度, 更深节点最大许可长度, 深度):
        '-> 节点<深度+1>/更深节点<深度> #可能需要 缓存 度量'
    @abstractmethod
    def 构造囗光杆树囗(sf, 节点序列, /, *, 左起丷右起, 光杆树最大许可长度, 深度):
        '-> 光杆树<深度> #可能需要 缓存 度量'
        #光杆树:封顶双侧栈<光杆树最大许可长度>
    @abstractmethod
    def 构造囗翅膀囗囗绝对定位囗(sf, 节点序列, /, *, 左起丷右起, 左翼丷右翼, 翅膀最大许可长度, 翅膀最小许可长度, 深度):
        '[节点<左起丷右起,深度>] -> 翅膀<左翼丷右翼,深度> #区分左右:栈开口方向不同！#可能需要 缓存 度量'
        #翅膀:封顶单侧保底栈<左起丷右起,翅膀最大许可长度,翅膀最小许可长度>
    @abstractmethod
    def 构造囗根深树囗囗绝对定位囗(sf, 左翼, 更深树, 右翼, /, *, 深度):
        '-> 根深树<深度> #可能需要 缓存 度量'


    @abstractmethod
    def 拆包囗元素封包节点囗(sf, 元素封包节点, /):
        '-> 元素'
    @abstractmethod
    def 拆包囗根深树囗囗绝对定位囗(sf, 根深树, /, *, 深度):
        '-> (左翼, 更深树, 右翼)'

    @abstractmethod
    def 区分树形态囗(sf, 双侧展翅树, /, *, 深度):
        '-> 光杆树丷根深树/bool'
    @abstractmethod
    def 是空树囗囗光杆树囗(sf, 光杆树, /, *, 深度):
        '-> bool'

    @abstractmethod
    def 迭代囗子节点囗囗光杆树囗(sf, 光杆树, /, *, 左起丷右起, 深度):
        '-> Iter 节点<深度>'
    @abstractmethod
    def 迭代囗子节点囗囗翅膀囗囗绝对定位囗(sf, 左翼丨右翼, /, *, 左起丷右起, 左翼丷右翼, 深度):
        '-> Iter 节点<深度>'
    @abstractmethod
    def 迭代囗子节点囗囗更深节点囗(sf, 更深节点, /, *, 左起丷右起, 深度):
        '更深节点<深度> -> Iter 节点<深度>'


    @abstractmethod
    def 取囗长度囗囗光杆树囗(sf, 光杆树, /, *, 深度):
        '-> 长度'
    @abstractmethod
    def 取囗长度囗囗翅膀囗囗绝对定位囗(sf, 左翼丨右翼, /, *, 左翼丷右翼, 深度):
        '-> 长度'
    @abstractmethod
    def 取囗长度囗囗更深节点囗(sf, 更深节点, /, *, 深度):
        '-> 长度'

    ######################
    ######################
    #属性界面:
    #
    @abstractmethod
    def 取囗缓存度量囗公开属性囗索引列表囗(sf, /):
        '-> [索引] #用于 访问/解读 缓存度量 #see:分裂囗囗搜索定位囗'
    @abstractmethod
    def 取囗缓存度量囗公开属性囗(sf, 缓存度量, 索引, /):
        '缓存度量 -> 索引 -> 属性值<索引>'
    @abstractmethod
    def 取囗缓存度量囗公开属性囗加法零元囗(sf, 索引, /):
        '索引 -> 加法零元<索引>'
    ######################
    ######################
    @abstractmethod
    def 取囗缓存度量囗囗元素封包节点囗(sf, 元素封包节点, /):
        '-> 缓存度量'
    @abstractmethod
    def 取囗缓存度量囗囗更深节点囗(sf, 更深节点, /, *, 深度):
        '-> 缓存度量'
    @abstractmethod
    def 取囗缓存度量囗囗光杆树囗(sf, 光杆树, /, *, 深度):
        '-> 缓存度量'
    @abstractmethod
    def 取囗缓存度量囗囗翅膀囗囗绝对定位囗(sf, 左翼丨右翼, /, *, 左翼丷右翼, 深度):
        '-> 缓存度量'
    @abstractmethod
    def 取囗缓存度量囗囗根深树囗(sf, 根深树, /, *, 深度):
        '-> 缓存度量'

    ######################
    #构造
    构造囗元素封包节点囗
    构造囗更深节点囗
    构造囗光杆树囗
    构造囗翅膀囗囗绝对定位囗
        #构造囗翅膀囗囗相对定位囗
    构造囗根深树囗囗绝对定位囗
        #构造囗根深树囗囗相对定位囗
    ######################
    #元素封包节点,根深树:定长:拆包
    拆包囗元素封包节点囗
    拆包囗根深树囗囗绝对定位囗
        #拆包囗根深树囗囗相对定位囗
    #更深节点,光杆树,翅膀:变长:迭代:取囗长度
    迭代囗子节点囗囗更深节点囗
    迭代囗子节点囗囗光杆树囗
    迭代囗子节点囗囗翅膀囗囗绝对定位囗
        #迭代囗子节点囗囗翅膀囗囗相对定位囗
    #
    取囗长度囗囗更深节点囗
    取囗长度囗囗光杆树囗
    取囗长度囗囗翅膀囗囗绝对定位囗
        #取囗长度囗囗翅膀囗囗相对定位囗
    ######################


    ######################
    ######################
    # 可优化方法:栈操作:光杆树,翅膀
    #   #错误处理:未定义/报错/魊/追加修复
    #   取囗端点
    #   压入节点
    #   弹出节点
    #   同端先弹出再压入节点
    #   先讫端压入再起端弹出节点
    #   连续压入<正序/反序！>
    #   压入指定数目<恰好>
    #   弹出指定数目<恰好>
    #   合并/分裂
    #   #无错:
    #   构造囗空栈囗
    #   是空栈囗 #O(1)
    #   取囗长度 #可能O(n)#kw:bigO_1__vs__bigO_log_L__vs_bigO_L
    #   迭代子节点
    #
    #   #细节:
    #   取囗端点:缺员时未定义
    #   取囗端点:缺员时报错/魊
    #   压入节点:溢出时未定义
    #   压入节点:溢出时报错/魊
    #   压入节点:翅膀:溢出时异端弹出更深节点
    #   压入节点:光杆树:溢出时分裂成均衡双翼
    #   弹出节点:缺员时未定义
    #   弹出节点:光杆树:缺员时报错/魊
    #   xxx弹出节点:翅膀:缺员时索取异端更深节点
    #   先内端压入更深节点再外端弹出节点:翅膀#用于:临界缺员时:损耗精血
    #   先双翼合并再弹出节点而成光杆树:翅膀#用于:临界缺员时:变态:退化
    #   同端先弹出再压入节点:光杆树:缺员时报错/魊
    #   同端先弹出再压入节点:翅膀:缺员时未定义
    #   先讫端压入再起端弹出节点:光杆树:无错
    #
    #   连续压入
    #   压入指定数目<恰好>:翅膀/光杆树:溢出时未定义#用于 连续压入不溢出时#数目足够小
    #   弹出指定数目<恰好>:翅膀/光杆树:缺员时未定义#用于 连续弹出不缺员时#数目足够小
    #   ???合并???无用
    #   分裂起翼:起翼+更深节点-->光杆树+焦点+起翼+损耗精血与否
    #   分裂起翼空心:起翼+讫翼-->光杆树+焦点+(讫翼|光杆树)
    #   分裂讫翼空心:起翼+讫翼-->(起翼|光杆树)+焦点+光杆树
    #   分裂讫翼:更深节点+讫翼-->讫翼+光杆树+焦点+损耗精血与否
    ######################
    ######################
    :<< doing
    def 巜压入节点囗囗光杆树囗囗溢出报错囗囗基础囗(sf, 光杆树, 节点, /, *, 左端丷右端, 光杆树最大许可长度, 深度):
        '-> (光杆树<深度>, None) # [左起=>右入/在右端]'
        #vs:_囗巜压入节点囗囗光杆树囗囗溢出变态囗囗分流用囗(...参数配置...) -> 可能进化为 根深树
        #vs:巜压入节点囗囗光杆树囗囗溢出报错囗囗基础囗(...光杆树最大许可长度...) -> ^错误囗囗溢出囗囗光杆树
        #
        kwds1 = dict(深度=深度)
        kwds2 = kwds1 #dict(深度=深度)
        kwds3 = dict(光杆树最大许可长度=光杆树最大许可长度, 深度=深度)
        return _巜压入节点囗囗某某某囗(光杆树, 节点, 左端丷右端, sf.取囗长度囗囗光杆树囗, kwds1, 光杆树最大许可长度, 错误囗囗溢出囗囗光杆树, sf.迭代囗子节点囗囗光杆树囗, kwds2, sf.构造囗光杆树囗, kwds3)

    ######################
    def 巜弹出节点囗囗光杆树囗囗基础囗(sf, 光杆树, /, *, 左端丷右端, 光杆树最大许可长度, 深度):
        '-> (光杆树<深度>, 节点<深度>) # [左起=>右出/在右端]'
        #vs:_囗巜弹出节点囗囗光杆树囗囗分流用囗(...参数配置...)
        #vs:巜弹出节点囗囗光杆树囗囗基础囗(...光杆树最大许可长度...)
        #
        光杆树最小许可长度 = 0
        kwds1 = dict(深度=深度)
        kwds2 = kwds1 #dict(深度=深度)
        kwds3 = dict(光杆树最大许可长度=光杆树最大许可长度, 深度=深度)
        return _巜弹出节点囗囗某某某囗(光杆树, 左端丷右端, sf.取囗长度囗囗光杆树囗, kwds1, 光杆树最小许可长度, 错误囗囗缺员囗囗光杆树, sf.迭代囗子节点囗囗光杆树囗, kwds2, sf.构造囗光杆树囗, kwds3)
    ######################
    ######################
    ######################
    def 巜外端压入节点囗囗翅膀囗囗相对定位囗(sf, 翅膀, 节点, /, *, 左起丷右起, 起翼丷讫翼, 翅膀最大许可长度, 翅膀最小许可长度, 深度):
        '-> (翅膀<深度>, None) # [左端丷右端==(not 左起丷右起 is 起翼丷讫翼)]'
        左端丷右端 = 左翼丷右翼 = 翅膀囗绝对定位巛相对定位囗(左起丷右起=左起丷右起, 起翼丷讫翼=起翼丷讫翼)
        return sf.巜外端压入节点囗囗翅膀囗囗绝对定位囗(翅膀, 节点, 左翼丷右翼=左翼丷右翼, 翅膀最大许可长度=翅膀最大许可长度, 翅膀最小许可长度=翅膀最小许可长度, 深度=深度)
    #####
    def 巜外端压入节点囗囗翅膀囗囗绝对定位囗(sf, 翅膀, 节点, /, *, 左翼丷右翼, 翅膀最大许可长度, 翅膀最小许可长度, 深度):
        '-> (翅膀<深度>, None) # [左端丷右端==左翼丷右翼]'
        左端丷右端 = 左翼丷右翼
        kwds1 = dict(左翼丷右翼=左翼丷右翼, 深度=深度)
        kwds2 = kwds1
        kwds3 = dict(左翼丷右翼=左翼丷右翼, 翅膀最大许可长度=翅膀最大许可长度, 翅膀最小许可长度=翅膀最小许可长度, 深度=深度)
        return _巜压入节点囗囗某某某囗(翅膀, 节点, 左端丷右端, sf.取囗长度囗囗翅膀囗囗绝对定位囗, kwds1, 翅膀最大许可长度, 错误囗囗溢出囗囗翅膀, sf.迭代囗子节点囗囗翅膀囗囗绝对定位囗, kwds2, sf.构造囗翅膀囗囗绝对定位囗, kwds3)
    ######################
    def 巜外端弹出节点囗囗翅膀囗囗相对定位囗(sf, 翅膀, /, *, 左起丷右起, 起翼丷讫翼, 翅膀最大许可长度, 翅膀最小许可长度, 深度):
        '-> (翅膀<深度>, 节点) # [左端丷右端==(not 左起丷右起 is 起翼丷讫翼)]'
        左端丷右端 = 左翼丷右翼 = 翅膀囗绝对定位巛相对定位囗(左起丷右起=左起丷右起, 起翼丷讫翼=起翼丷讫翼)
        return sf.巜外端弹出节点囗囗翅膀囗囗绝对定位囗(翅膀, 左翼丷右翼=左翼丷右翼, 翅膀最大许可长度=翅膀最大许可长度, 翅膀最小许可长度=翅膀最小许可长度, 深度=深度)
    #####
    def 巜外端弹出节点囗囗翅膀囗囗绝对定位囗(sf, 翅膀, /, *, 左翼丷右翼, 翅膀最大许可长度, 翅膀最小许可长度, 深度):
        '-> (翅膀<深度>, 节点) # [左端丷右端==左翼丷右翼]'
        左端丷右端 = 左翼丷右翼
        kwds1 = dict(左翼丷右翼=左翼丷右翼, 深度=深度)
        kwds2 = kwds1
        kwds3 = dict(左翼丷右翼=左翼丷右翼, 翅膀最大许可长度=翅膀最大许可长度, 翅膀最小许可长度=翅膀最小许可长度, 深度=深度)
        return _巜弹出节点囗囗某某某囗(翅膀, 左端丷右端, sf.取囗长度囗囗翅膀囗囗绝对定位囗, kwds1, 翅膀最小许可长度, 错误囗囗缺员囗囗翅膀, sf.迭代囗子节点囗囗翅膀囗囗绝对定位囗, kwds2, sf.构造囗翅膀囗囗绝对定位囗, kwds3)
    ######################
    ######################
    ######################
    def 巜同端先弹出再压入节点囗囗光杆树囗(sf, 光杆树, 节点, /, *, 左端丷右端, 参数配置, 深度):
        '-> (光杆树<深度>, 节点)'
        kwds1 = dict(深度=深度)
        kwds2 = kwds1 #dict(深度=深度)
        kwds3 = dict(光杆树最大许可长度=参数配置.光杆树最大许可长度, 深度=深度)
        return _巜同端先弹出再压入节点囗囗某某某囗(光杆树, 左端丷右端, 错误囗囗缺员囗囗光杆树, 迭代囗子节点囗囗光杆树囗, kwds2, 构造囗光杆树囗, kwds3)
    ######################
    def 巜外端先弹出再压入节点囗囗翅膀囗囗相对定位囗(sf, 翅膀, 节点, /, *, 左起丷右起, 起翼丷讫翼, 参数配置, 深度):
        '-> (翅膀<深度>, 节点)'
        左端丷右端 = 左翼丷右翼 = 翅膀囗绝对定位巛相对定位囗(左起丷右起=左起丷右起, 起翼丷讫翼=起翼丷讫翼)
        return sf.巜外端先弹出再压入节点囗囗翅膀囗囗绝对定位囗(翅膀, 左翼丷右翼=左翼丷右翼, 参数配置=参数配置, 深度=深度)
    def 巜外端先弹出再压入节点囗囗翅膀囗囗绝对定位囗(sf, 翅膀, 节点, /, *, 左翼丷右翼, 参数配置, 深度):
        '-> (翅膀<深度>, 节点)'
        左端丷右端 = 左翼丷右翼
        kwds1 = dict(左翼丷右翼=左翼丷右翼, 深度=深度)
        kwds2 = kwds1
        kwds3 = dict(左翼丷右翼=左翼丷右翼, 翅膀最大许可长度=参数配置.翅膀最大许可长度, 翅膀最小许可长度=参数配置.翅膀最小许可长度, 深度=深度)
        return _巜同端先弹出再压入节点囗囗某某某囗(翅膀, 左端丷右端, 错误囗囗缺员囗囗翅膀, 迭代囗子节点囗囗翅膀囗, kwds2, 构造囗翅膀囗, kwds3)
    ######################
    ######################
    ######################
    #view/peek
    def 取囗魊端点囗囗光杆树囗(sf, 光杆树, /, *, 左端丷右端, 深度):
        '光杆树<深度> -> 魊节点<深度>'
        for 节点 in sf.迭代囗子节点囗囗光杆树囗(光杆树, 左起丷右起=左端丷右端, 深度=深度):
            魊节点 = (节点,)
            break
        else:
            魊节点 = null_tuple
        return 魊节点
    def 取囗端点囗囗光杆树囗囗空树报错囗(sf, 光杆树, /, *, 左端丷右端, 深度):
        '光杆树<深度> -> 节点<深度>'
        魊节点 = sf.取囗魊端点囗囗光杆树囗(光杆树, 左端丷右端=左端丷右端, 深度=深度)
        if not 魊节点:
            raise 错误囗囗空树囗囗光杆树
        [节点] = 魊节点
        return 节点
    def 取外端点囗囗翅膀囗囗绝对定位囗(sf, 翅膀, /, *, 左翼丷右翼, 深度):
        '翅膀<左翼丷右翼;深度> -> 节点<深度> # [左翼丷右翼===左端丷右端]'
        return next(sf.迭代囗子节点囗囗翅膀囗囗绝对定位囗(翅膀, 左起丷右起=左翼丷右翼, 左翼丷右翼=左翼丷右翼, 深度=深度))
    #
    def _囗取囗魊端点囗囗根深树囗囗分流用囗(sf, 根深树, /, *, 左端丷右端, 深度):
        '根深树<深度> -> 魊节点<深度>'
        节点 = sf.取囗端点囗囗根深树囗(根深树, 左端丷右端=左端丷右端, 深度=深度)
        魊节点 = (节点,)
        return 魊节点
    def 取囗端点囗囗根深树囗(sf, 根深树, /, *, 左端丷右端, 深度):
        '根深树<深度> -> 节点<深度>'
        左起丷右起 = 左端丷右端
        左翼丷右翼 = 左端丷右端
        (起翼, 更深树, 讫翼) = sf.拆包囗根深树囗囗相对定位囗(根深树, 左起丷右起=左起丷右起, 深度=深度)
        左翼丷右翼
        翅膀 = 左翼丨右翼 = 起翼
        return sf.取外端点囗囗翅膀囗囗绝对定位囗(翅膀, 左翼丷右翼=左翼丷右翼, 深度=深度)

    def 取囗端点囗囗双侧展翅树囗囗空树报错囗(sf, 双侧展翅树, /, *, 左端丷右端, 深度):
        '双侧展翅树<深度> -> 节点<深度>'
        return _分流囗囗树形态囗(sf, sf.取囗端点囗囗光杆树囗囗空树报错囗, sf.取囗端点囗囗根深树囗, 深度, 双侧展翅树, 左端丷右端=左端丷右端, 深度=深度)
    def 取囗魊端点囗囗双侧展翅树囗(sf, 双侧展翅树, /, *, 左端丷右端, 深度):
        '双侧展翅树<深度> -> 魊节点/魊<节点<深度> >'
        return _分流囗囗树形态囗(sf, sf.取囗魊端点囗囗光杆树囗, sf._囗取囗魊端点囗囗根深树囗囗分流用囗, 深度, 双侧展翅树, 左端丷右端=左端丷右端, 深度=深度)
    ######################
    ######################
    ######################
    def 构造囗空树囗(sf, /, *, 参数配置, 深度):
        '-> 空树/双侧展翅树<深度>'
        空树 = 双侧展翅树 = 光杆树 = sf.构造囗光杆树囗('', 左起丷右起=False, 光杆树最大许可长度=参数配置.光杆树最大许可长度, 深度=深度)
        return 空树
    def 构造囗双侧展翅树囗(sf, 节点序列, /, *, 左起丷右起, 参数配置, 深度):
        '-> 双侧展翅树<深度>'
        双侧展翅树 = 空树 = sf.构造囗空树囗(参数配置=参数配置, 深度=深度)
        双侧展翅树, _ = sf.巜连续压入节点囗囗双侧展翅树囗囗注意反序囗(双侧展翅树, 节点序列, 左端丷右端=not 左起丷右起, 参数配置=参数配置, 深度=深度)
        return 双侧展翅树
    def __():
        #see: def 构造囗双侧展翅树囗囗讫翼修复囗(sf, 起翼, 更深树, 讫翼囗节点序列, /, *, 左起丷右起, 参数配置, 深度):
    #####def 构造囗双侧展翅树囗囗折翅再生囗囗相对定位囗(sf, 更深树, 起翼丨讫翼, /, *, 左起丷右起, 起翼丷讫翼, 参数配置, 深度):
    ####def 构造囗双侧展翅树囗囗折翅再生囗囗相对定位囗(sf, 更深树, 起翼丨讫翼, /, *, 左起丷右起, 起翼丷讫翼, 参数配置, 深度):
    ####    '更深树<深度>/双侧展翅树<深度+1> -> 起翼丨讫翼/翅膀<左翼丷右翼(左起丷右起,起翼丷讫翼);深度> -> 双侧展翅树<深度>'
    ####    翅膀方位 = 左翼丷右翼 = 翅膀囗绝对定位巛相对定位囗(左起丷右起=左起丷右起, 起翼丷讫翼=起翼丷讫翼)
    ####    左翼丨右翼 = 起翼丨讫翼
    ####    return sf.构造囗双侧展翅树囗囗折翅再生囗囗绝对定位囗(更深树, 左翼丨右翼, 左翼丷右翼=左翼丷右翼, 参数配置=参数配置, 深度=深度)
    #####def 构造囗双侧展翅树囗囗折翅再生囗囗绝对定位囗(sf, 更深树, 左翼丨右翼, /, *, 左翼丷右翼, 参数配置, 深度):
    ####def 构造囗双侧展翅树囗囗折翅再生囗囗绝对定位囗(sf, 更深树, 左翼丨右翼, /, *, 左翼丷右翼, 参数配置, 深度):
    ####    '更深树<深度>/双侧展翅树<深度+1> -> 左翼丨右翼/翅膀<左翼丷右翼;深度> -> 双侧展翅树<深度>'
    ####    check_type_is(bool, 左翼丷右翼)
    ####    assert 参数配置.缩水分裂 #保证拥有 滴血重生 的境界
    ####    翅膀最大许可长度 = 参数配置.翅膀最大许可长度
    ####    翅膀最小许可长度 = 参数配置.翅膀最小许可长度
    ####    翅膀方位 = 左翼丷右翼
    ####    翅膀 = 左翼丨右翼
    ####    断翅方位 = 异翅方位 = not 翅膀方位
    ####    if not sf.是空树囗囗双侧展翅树囗(更深树, 深度=深度+1):
    ####        更深树, 更深节点 = sf.巜弹出节点囗囗双侧展翅树囗(更深树, 左端丷右端=断翅方位, 参数配置=参数配置, 深度=深度+1)
    ####        #已更新:更深树
    ####        深度囗囗更深节点 = 深度##
    ####        左起丷右起 = 断翅方位
    ####        it = sf.迭代囗子节点囗囗更深节点囗(更深节点, 左起丷右起=左起丷右起, 深度=深度囗囗更深节点)
    ####        更深节点最大许可长度 = 参数配置.更深节点最大许可长度
    ####        更深节点最小许可长度 = 参数配置.更深节点最小许可长度
    ####        assert 翅膀最小许可长度+1 <= 更深节点最小许可长度 <= 更深节点最大许可长度 <= 翅膀最大许可长度 # <<== [缩水分裂]
    ####        异翅 = sf.构造囗翅膀囗囗绝对定位囗(it, 左起丷右起=左起丷右起, 左翼丷右翼=异翅方位, 翅膀最大许可长度=翅膀最大许可长度, 翅膀最小许可长度=翅膀最小许可长度, 深度=深度)
    ####        左翼, 更深树, 右翼 = _调整次序囗(异翅, 更深树, 翅膀, 左起丷右起=异翅方位)
    ####        根深树 = sf.构造囗根深树囗囗绝对定位囗(左翼, 更深树, 右翼, 深度=深度)
    ####        双侧展翅树 = 根深树
    ####    else:
    ####        #只剩下:翅膀
    ####        #尝试平衡双翼:
    ####        长度 = sf.取囗长度囗囗翅膀囗囗绝对定位囗(翅膀, 左翼丷右翼=左翼丷右翼, 深度=深度)
    ####        余长 = 长度
    ####        左起丷右起 = 左翼丷右翼
    ####        节点序列 = sf.迭代囗子节点囗囗翅膀囗囗绝对定位囗(翅膀, 左起丷右起=左起丷右起, 左翼丷右翼=左翼丷右翼, 深度=深度)
    ####        双侧展翅树 = _尝试平衡双翼囗(sf, 余长, 节点序列, 左起丷右起=左起丷右起, 参数配置=参数配置, 深度=深度)
    ####    return 双侧展翅树
        pass
    #end-def __():
    def 构造囗双侧展翅树囗囗讫翼修复囗(sf, 起翼, 更深树, 讫翼囗节点序列, /, *, 左起丷右起, 参数配置, 深度):
        '起翼/翅膀<左翼丷右翼:=左起丷右起;深度> -> 更深树<深度>/双侧展翅树<深度+1> -> 讫翼囗节点序列<左起丷右起;深度>/(Iter 节点<深度>) -> 双侧展翅树<深度>'
        assert 参数配置.缩水分裂 #保证拥有 滴血重生 的境界
        assert 参数配置.紧致假设 # 简化下沉处理
        起翼方位 = 左翼丷右翼 = 翅膀囗绝对定位巛相对定位囗(左起丷右起=左起丷右起, 起翼丷讫翼=False)
        断翅方位 = 讫翼方位 = not 起翼方位
        #

        it = echo_or_mk_PeekableIterator(讫翼囗节点序列)
        it.fill_le(参数配置.翅膀最大许可长度+1)

        需抽取精血 = False
        刚好组成讫翼 = False
        需下沉处理 = False
        尝试平衡双翼 = False
        L = it.len_relax()
        if 参数配置.翅膀最小许可长度 <= L <= 参数配置.翅膀最大许可长度:
            刚好组成讫翼 = True
            ls = it.read_relax()
        elif L > 参数配置.翅膀最大许可长度:
            assert 参数配置.更深节点最小许可长度 <= 参数配置.翅膀最大许可长度
            # [紧致假设] ==>> 下沉 可完全拆分
            需下沉处理 = True
        elif L < 参数配置.翅膀最小许可长度:
            if not sf.是空树囗囗双侧展翅树囗(更深树, 深度=深度+1):
                需抽取精血 = True
            else:
                尝试平衡双翼 = True
        else:
            raise 000
        ######################
        if 尝试平衡双翼:
            长度 = sf.取囗长度囗囗翅膀囗囗绝对定位囗(起翼, 左翼丷右翼=起翼方位, 深度=深度)
            余长 = 长度+L
            #xxx 左起丷右起 = 左翼丷右翼
            节点序列 = sf.迭代囗子节点囗囗翅膀囗囗绝对定位囗(起翼, 左起丷右起=左起丷右起, 左翼丷右翼=左翼丷右翼, 深度=深度)
                #起翼
            xs = it.read_relax()
                #讫翼
            it = chain(节点序列, xs)
            双侧展翅树 = _尝试平衡双翼囗(sf, 余长, it, 左起丷右起=左起丷右起, 参数配置=参数配置, 深度=深度)
            return 双侧展翅树
        ######################
        if 需下沉处理:
            更深节点序列 = sf._囗更深节点序列巛节点序列囗囗要求足够长囗囗紧致假设囗(it, 左起丷右起=左起丷右起, 更深节点最小许可长度=参数配置.更深节点最小许可长度, 更深节点最大许可长度=参数配置.更深节点最大许可长度, 紧致假设=参数配置.紧致假设, 深度=深度)
            更深树, _ = sf.巜连续压入节点囗囗双侧展翅树囗囗注意反序囗(更深树, 更深节点序列, 左端丷右端=断翅方位, 参数配置=参数配置, 深度=深度+1)
            #已更新:更深树
            #已耗尽 it
            it.fill_le(1)
            L = it.len_relax()
            assert L == 0
            需抽取精血 = True
        ######################
        if 需抽取精血:
            # [缩水分裂] => 只需抽取一滴
            更深树, 更深节点 = sf.巜弹出节点囗囗双侧展翅树囗(更深树, 左端丷右端=断翅方位, 参数配置=参数配置, 深度=深度+1)
            #已更新:更深树
            深度囗囗更深节点 = 深度##
            #xxx 左起丷右起 = 断翅方位
            节点序列 = sf.迭代囗子节点囗囗更深节点囗(更深节点, 左起丷右起=左起丷右起, 深度=深度囗囗更深节点)
            xs = it.read_relax()
            ls = [*节点序列, *xs]
            L = len(ls)
            刚好组成讫翼 = True
        ######################
        assert 刚好组成讫翼
        if 刚好组成讫翼:
            ls
            assert len(ls) == L
            assert 参数配置.翅膀最小许可长度 <= L <= 参数配置.翅膀最大许可长度
            讫翼 = 异翅 = sf.构造囗翅膀囗囗绝对定位囗(ls, 左起丷右起=左起丷右起, 左翼丷右翼=断翅方位, 翅膀最大许可长度=参数配置.翅膀最大许可长度, 翅膀最小许可长度=参数配置.翅膀最小许可长度, 深度=深度)
            根深树 = sf.构造囗根深树囗囗相对定位囗(起翼, 更深树, 讫翼, 左起丷右起=左起丷右起, 深度=深度)
            双侧展翅树 = 根深树
            return 双侧展翅树

        raise 000



    ######################
    ######################
    ######################





    ######################
    ######################
    ##以下:具象方法
    ######################
    ######################
    def 是光杆树囗(sf, 双侧展翅树, /, *, 深度):
        光杆树丷根深树 = sf.区分树形态囗(双侧展翅树, 深度=深度)
        return not 光杆树丷根深树
    def 是根深树囗(sf, 双侧展翅树, /, *, 深度):
        光杆树丷根深树 = sf.区分树形态囗(双侧展翅树, 深度=深度)
        return 光杆树丷根深树
    def 是空树囗囗双侧展翅树囗(sf, 双侧展翅树, /, *, 深度):
        '-> bool'
        return _分流囗囗树形态囗(sf, sf.是空树囗囗光杆树囗, lambda _, /, *, 深度:False, 深度, 双侧展翅树, 深度=深度)

    #度量
    def 取囗缓存度量囗囗翅膀囗囗相对定位囗(sf, 起翼丨讫翼, /, *, 左起丷右起, 起翼丷讫翼, 深度):
        '-> 缓存度量'
        左翼丷右翼 = 翅膀囗绝对定位巛相对定位囗(左起丷右起=左起丷右起, 起翼丷讫翼=起翼丷讫翼)
        左翼丨右翼 = 翅膀 = 起翼丨讫翼
        return sf.取囗缓存度量囗囗翅膀囗囗绝对定位囗(左翼丨右翼, 左翼丷右翼=左翼丷右翼, 深度=深度)
    def 取囗缓存度量囗囗节点囗(sf, 节点, /, *, 深度):
        '-> 缓存度量'
        check_int_ge(0, 深度)
        if 深度 == 0:
            f = sf.取囗缓存度量囗囗元素封包节点囗
            return f(节点)
        else:
            f = sf.取囗缓存度量囗囗更深节点囗
            深度囗囗更深节点 = 深度-1
            return f(节点, 深度=深度囗囗更深节点)
    def 取囗缓存度量囗囗双侧展翅树囗(sf, 双侧展翅树, /, *, 深度):
        '-> 缓存度量'
        return _分流囗囗树形态囗(sf, sf.取囗缓存度量囗囗光杆树囗, sf.取囗缓存度量囗囗根深树囗, 深度, 双侧展翅树, 深度=深度)

    #相对
    def 拆包囗根深树囗囗相对定位囗(sf, 根深树, /, *, 左起丷右起, 深度):
        '-> (起翼, 更深树, 讫翼)'
        (左翼, 更深树, 右翼) = sf.拆包囗根深树囗囗绝对定位囗(根深树, 深度=深度)
        (起翼, 更深树, 讫翼) = _调整次序囗(左翼, 更深树, 右翼, 左起丷右起=左起丷右起)
        return (起翼, 更深树, 讫翼)
    def 构造囗根深树囗囗相对定位囗(sf, 起翼, 更深树, 讫翼, /, *, 左起丷右起, 深度):
        '-> 根深树<深度> #可能需要 缓存 度量'
        (左翼, 更深树, 右翼) = _调整次序囗(起翼, 更深树, 讫翼, 左起丷右起=左起丷右起)
        return sf.构造囗根深树囗囗绝对定位囗(左翼, 更深树, 右翼, 深度=深度)
    def 构造囗翅膀囗囗相对定位囗(sf, 节点序列, /, *, 左起丷右起, 起翼丷讫翼, 翅膀最大许可长度, 翅膀最小许可长度, 深度):
        '[节点<左起丷右起,深度>] -> 翅膀<左翼丷右翼=(not 起翼丷讫翼 is 左起丷右起),深度> #区分左右:栈开口方向不同！#可能需要 缓存 度量'
        #翅膀:封顶单侧保底栈<左起丷右起,翅膀最大许可长度,翅膀最小许可长度>
        左翼丷右翼 = 翅膀囗绝对定位巛相对定位囗(左起丷右起=左起丷右起, 起翼丷讫翼=起翼丷讫翼)
        return sf.构造囗翅膀囗囗绝对定位囗(节点序列, 左起丷右起=左起丷右起, 左翼丷右翼=左翼丷右翼, 翅膀最大许可长度=翅膀最大许可长度, 翅膀最小许可长度=翅膀最小许可长度, 深度=深度)
    def 取囗长度囗囗翅膀囗囗相对定位囗(sf, 起翼丨讫翼, /, *, 左起丷右起, 起翼丷讫翼, 深度):
        '-> 长度'
        左翼丷右翼 = 翅膀囗绝对定位巛相对定位囗(左起丷右起=左起丷右起, 起翼丷讫翼=起翼丷讫翼)
        左翼丨右翼 = 翅膀 = 起翼丨讫翼
        return sf.取囗长度囗囗翅膀囗囗绝对定位囗(左翼丨右翼, 左翼丷右翼=左翼丷右翼, 深度=深度)

    def 迭代囗子节点囗囗翅膀囗囗相对定位囗(sf, 起翼丨讫翼, /, *, 左起丷右起, 起翼丷讫翼, 深度):
        '-> Iter 节点<深度>'
        左翼丷右翼 = 翅膀囗绝对定位巛相对定位囗(左起丷右起=左起丷右起, 起翼丷讫翼=起翼丷讫翼)
        左翼丨右翼 = 翅膀 = 起翼丨讫翼
        return sf.迭代囗子节点囗囗翅膀囗囗绝对定位囗(左翼丨右翼, 左起丷右起=左起丷右起, 左翼丷右翼=左翼丷右翼, 深度=深度)

    ######################
    ######################
    ######################
    ######################
    def __():
      def 囗囗囗囗迭代囗子节点囗囗节点囗(sf, 节点, /, *, 左起丷右起, 深度):
        '节点<深度> -> Iter 节点<深度-1> #xxx:[节点<-1> == 元素]'
        if 深度==0:
            # [节点 :: 节点<0>]
            raise 错误囗囗零深度节点囗子节点
            元素封包节点 = 节点
            元素 = sf.拆包囗元素封包节点囗(元素封包节点)
            return iter((元素,))
        # [节点 :: 节点<深度> == 更深节点<深度-1>]
        更深节点 = 节点
        深度囗囗更深节点 = 深度-1
        return sf.迭代囗子节点囗囗更深节点囗(更深节点, 左起丷右起=左起丷右起, 深度=深度囗囗更深节点)
    ######################
    ######################
    ######################
    ######################
    def 迭代囗子节点囗囗根深树囗(sf, 根深树, /, *, 左起丷右起, 深度):
        '-> Iter 节点<深度>'
        (起翼, 更深树, 讫翼) = sf.拆包囗根深树囗囗相对定位囗(根深树, 左起丷右起=左起丷右起, 深度=深度)
        yield from sf.迭代囗子节点囗囗翅膀囗囗相对定位囗(起翼, 左起丷右起=左起丷右起, 起翼丷讫翼=False, 深度=深度)
        yield from sf.迭代囗孙节点囗囗更深树囗(更深树, 左起丷右起=左起丷右起, 深度=深度)
        yield from sf.迭代囗子节点囗囗翅膀囗囗相对定位囗(讫翼, 左起丷右起=左起丷右起, 起翼丷讫翼=True, 深度=深度)
        return

    ######################
    def 迭代囗子更深节点囗囗更深树囗(sf, 更深树, /, *, 左起丷右起, 深度):
        '更深树<深度> -> Iter 更深节点<深度>'
        深度囗囗更深节点 = 深度囗囗更深树 = 深度
        双侧展翅树 = 更深树
        深度囗囗树 = 深度囗囗更深树+1
        return sf.迭代囗子节点囗囗双侧展翅树囗(双侧展翅树, 左起丷右起=左起丷右起, 深度=深度囗囗树)
    ######################
    def 迭代囗孙节点囗囗更深树囗(sf, 更深树, /, *, 左起丷右起, 深度):
        '更深树<深度> -> Iter 节点<深度>'
        深度囗囗更深节点 = 深度囗囗更深树 = 深度
        双侧展翅树 = 更深树
        深度囗囗树 = 深度囗囗更深树+1
        for 更深节点 in sf.迭代囗子更深节点囗囗更深树囗(更深树, 左起丷右起=左起丷右起, 深度=深度囗囗更深树):
            yield from sf.迭代囗子节点囗囗更深节点囗(更深节点, 左起丷右起=左起丷右起, 深度=深度囗囗更深节点)

    ######################
    def 迭代囗子节点囗囗双侧展翅树囗(sf, 双侧展翅树, /, *, 左起丷右起, 深度):
        '-> Iter 节点<深度>'
        return _分流囗囗树形态囗(sf, sf.迭代囗子节点囗囗光杆树囗, sf.迭代囗子节点囗囗根深树囗, 深度, 双侧展翅树, 左起丷右起=左起丷右起, 深度=深度)
    ######################
    def 巜压入节点囗囗双侧展翅树囗(sf, 双侧展翅树, 节点, /, *, 左端丷右端, 参数配置, 深度):
        '-> (双侧展翅树<深度>, None)'
        assert 参数配置.增长
        return _分流囗囗树形态囗(sf, sf._囗巜压入节点囗囗光杆树囗囗溢出变态囗囗分流用囗, sf._囗巜压入节点囗囗根深树囗囗分流用囗, 深度, 双侧展翅树, 节点, 左端丷右端=左端丷右端, 参数配置=参数配置, 深度=深度)
    ######################
    def _囗巜压入节点囗囗光杆树囗囗溢出变态囗囗分流用囗(sf, 光杆树, 节点, /, *, 左端丷右端, 参数配置, 深度):
        '-> (双侧展翅树<深度>, None)'
        #vs:_囗巜压入节点囗囗光杆树囗囗溢出变态囗囗分流用囗(...参数配置...) -> 可能进化为 根深树
        #vs:巜压入节点囗囗光杆树囗囗溢出报错囗囗基础囗(...光杆树最大许可长度...) -> ^错误囗囗溢出囗囗光杆树
        #
        左起丷右起 = 左端丷右端
        左翼丷右翼 = 左端丷右端
        光杆树最大许可长度 = 参数配置.光杆树最大许可长度
        长度 = sf.取囗长度囗囗光杆树囗(光杆树, 深度=深度)
        if not 长度 == 光杆树最大许可长度:
            if not 长度 < 光杆树最大许可长度: raise 000
            return sf.巜压入节点囗囗光杆树囗囗溢出报错囗囗基础囗(光杆树, 节点, 左端丷右端=左端丷右端, 光杆树最大许可长度=光杆树最大许可长度, 深度=深度)

        assert 长度 == 光杆树最大许可长度
        zz = 参数配置.光杆树溢出时分裂出的双翼的长度
        if not zz == 长度+1:
            szs = 参数配置.光杆树溢出时分裂出的更深节点的各自长度
            for sz in szs:
                #sf构造囗更深节点囗(节点序列, 左起丷右起=左起丷右起, 更深节点最小许可长度, 更深节点最大许可长度, 深度=深度)
                raise NotImplementedError
            raise 000
        # 变态:进化:光杆树-->根深树
        节点序列 = sf.迭代囗子节点囗囗光杆树囗(光杆树, 左起丷右起=左起丷右起, 深度=深度)
        节点序列 = chain([节点], 节点序列)
                #压入:正向迭代==>>前缀
        根深树 = _分为两翅膀而成根深树囗(sf, zz, 节点序列, 左起丷右起=左起丷右起, 参数配置=参数配置, 深度=深度)
        return (根深树, None)
    ######################
    def _囗巜压入节点囗囗根深树囗囗分流用囗(sf, 根深树, 节点, /, *, 左端丷右端, 参数配置, 深度):
        '-> (根深树/双侧展翅树<深度>, None)'
        左起丷右起 = 左端丷右端
        左翼丷右翼 = 左端丷右端
        (起翼, 更深树, 讫翼) = sf.拆包囗根深树囗囗相对定位囗(根深树, 左起丷右起=左起丷右起, 深度=深度)
        左翼丷右翼
        翅膀 = 左翼丨右翼 = 起翼

        翅膀最大许可长度=参数配置.翅膀最大许可长度
        翅膀最小许可长度=参数配置.翅膀最小许可长度
        长度 = sf.取囗长度囗囗翅膀囗囗绝对定位囗(翅膀, 左翼丷右翼=左翼丷右翼, 深度=深度)
        if not 长度 == 翅膀最大许可长度:
            if not 长度 < 翅膀最大许可长度: raise 000
            翅膀, _ = sf.巜外端压入节点囗囗翅膀囗囗绝对定位囗(翅膀, 节点, 左翼丷右翼=左翼丷右翼, 翅膀最大许可长度=翅膀最大许可长度, 翅膀最小许可长度=翅膀最小许可长度, 深度=深度)
            起翼 = 翅膀
            #已更新: 起翼
        else:
            assert 长度 == 翅膀最大许可长度
            szs = 参数配置.翅膀溢出时分裂出的更深节点的各自长度
            更深节点最小许可长度 = 参数配置.更深节点最小许可长度
            更深节点最大许可长度 = 参数配置.更深节点最大许可长度
            节点序列 = sf.迭代囗子节点囗囗翅膀囗囗绝对定位囗(翅膀, 左起丷右起=not 左起丷右起, 左翼丷右翼=左翼丷右翼, 深度=深度)
                #溢出:向内部排泄:反转遍历方向
            for sz in szs:
                it = islice(节点序列, sz)
                更深节点 = sf.构造囗更深节点囗(it, 左起丷右起=not 左起丷右起, 更深节点最小许可长度=更深节点最小许可长度, 更深节点最大许可长度=更深节点最大许可长度, 深度=深度)
                更深树, _ = sf.巜压入节点囗囗双侧展翅树囗(更深树, 更深节点, 左端丷右端=左端丷右端, 参数配置=参数配置, 深度=深度+1)
            更深树
            #已更新:更深树

            it = chain(节点序列, [节点])
                #压入:反向迭代==>>后缀
            翅膀 = sf.构造囗翅膀囗囗绝对定位囗(it, 左起丷右起=not 左起丷右起, 左翼丷右翼=左翼丷右翼, 翅膀最大许可长度=翅膀最大许可长度, 翅膀最小许可长度=翅膀最小许可长度, 深度=深度)
            起翼 = 翅膀
            #已更新:更深树,起翼
        #已更新:更深树,起翼
        根深树 = sf.构造囗根深树囗囗相对定位囗(起翼, 更深树, 讫翼, 左起丷右起=左起丷右起, 深度=深度)
        return (根深树, None)

    ######################
    ######################
    ######################
    ######################
    def 巜弹出节点囗囗双侧展翅树囗(sf, 双侧展翅树, /, *, 左端丷右端, 参数配置, 深度):
        '-> (双侧展翅树<深度>, 节点)'
        assert 参数配置.缩水
        return _分流囗囗树形态囗(sf, sf._囗巜弹出节点囗囗光杆树囗囗分流用囗, sf._囗巜弹出节点囗囗根深树囗囗缺员变态囗囗分流用囗, 深度, 双侧展翅树, 左端丷右端=左端丷右端, 参数配置=参数配置, 深度=深度)
    ######################
    def _囗巜弹出节点囗囗根深树囗囗缺员变态囗囗分流用囗(sf, 根深树, /, *, 左端丷右端, 参数配置, 深度):
        '-> (双侧展翅树<深度>, 节点)'
        左起丷右起 = 左端丷右端
        左翼丷右翼 = 左端丷右端
        (起翼, 更深树, 讫翼) = sf.拆包囗根深树囗囗相对定位囗(根深树, 左起丷右起=左起丷右起, 深度=深度)
        左翼丷右翼
        翅膀 = 左翼丨右翼 = 起翼

        翅膀最大许可长度=参数配置.翅膀最大许可长度
        翅膀最小许可长度=参数配置.翅膀最小许可长度
        长度 = sf.取囗长度囗囗翅膀囗囗绝对定位囗(翅膀, 左翼丷右翼=左翼丷右翼, 深度=深度)
        已完成 = False
        if not 长度 == 翅膀最小许可长度:
            if not 长度 > 翅膀最小许可长度: raise 000
            翅膀, 节点 = sf.巜外端弹出节点囗囗翅膀囗囗绝对定位囗(翅膀, 左翼丷右翼=左翼丷右翼, 翅膀最大许可长度=翅膀最大许可长度, 翅膀最小许可长度=翅膀最小许可长度, 深度=深度)
            起翼 = 翅膀
            #已更新:起翼
            #已弹出:节点
            已完成 = True
        else:
            # [长度 == 翅膀最小许可长度]
            节点序列 = sf.迭代囗子节点囗囗翅膀囗囗绝对定位囗(翅膀, 左起丷右起=左起丷右起, 左翼丷右翼=左翼丷右翼, 深度=深度)
                #向外部弹出:正向遍历
            节点 = next(节点序列)
                #弹出
            #已弹出:节点
        #已弹出:节点
        ########
        if 已完成:
            #已更新:起翼
            pass
        elif not sf.是空树囗囗双侧展翅树囗(更深树, 深度=深度+1):
            更深树, 更深节点 = sf.巜弹出节点囗囗双侧展翅树囗(更深树, 左端丷右端=左端丷右端, 参数配置=参数配置, 深度=深度+1)
            #已更新:更深树
            深度囗囗更深节点 = 深度##
            it = sf.迭代囗子节点囗囗更深节点囗(更深节点, 左起丷右起=左起丷右起, 深度=深度囗囗更深节点)
            it = chain(节点序列, it)
            翅膀 = sf.构造囗翅膀囗囗绝对定位囗(it, 左起丷右起=左起丷右起, 左翼丷右翼=左翼丷右翼, 翅膀最大许可长度=翅膀最大许可长度, 翅膀最小许可长度=翅膀最小许可长度, 深度=深度)
            起翼 = 翅膀
            #已更新:更深树,起翼
            已完成 = True
        else:
            #尝试平衡双翼:
            异翅 = 讫翼
            异翅长度 = sf.取囗长度囗囗翅膀囗囗绝对定位囗(异翅, 左翼丷右翼=not 左翼丷右翼, 深度=深度)
            异翅节点序列 = sf.迭代囗子节点囗囗翅膀囗囗绝对定位囗(异翅, 左起丷右起=左起丷右起, 左翼丷右翼=not 左翼丷右翼, 深度=深度)

            余长 = 长度+异翅长度-1
            it = chain(节点序列, 异翅节点序列)
        if 已完成:
            #已更新:起翼
            #已更新:更深树,起翼
            根深树 = sf.构造囗根深树囗囗相对定位囗(起翼, 更深树, 讫翼, 左起丷右起=左起丷右起, 深度=深度)
            #已更新:根深树
            双侧展翅树 = 根深树
            #已有:双侧展翅树
        else:
            双侧展翅树 = _尝试平衡双翼囗(sf, 余长, it, 左起丷右起=左起丷右起, 参数配置=参数配置, 深度=深度)
                #可能:变态:退化
            #已有:双侧展翅树
        #已有:双侧展翅树
        #已弹出:节点
        return 双侧展翅树, 节点

    ######################
    def _囗巜弹出节点囗囗光杆树囗囗分流用囗(sf, 光杆树, /, *, 左端丷右端, 参数配置, 深度):
        '-> (光杆树/双侧展翅树<深度>, 节点)'
        #vs:_囗巜弹出节点囗囗光杆树囗囗分流用囗(...参数配置...)
        #vs:巜弹出节点囗囗光杆树囗囗基础囗(...光杆树最大许可长度...)
        #
        return sf.巜弹出节点囗囗光杆树囗囗基础囗(光杆树, 左端丷右端=左端丷右端, 光杆树最大许可长度=参数配置.光杆树最大许可长度, 深度=深度)
    ######################
    ######################
    ######################
    def 巜连续压入节点囗囗双侧展翅树囗囗注意反序囗(sf, 双侧展翅树, 节点序列, /, *, 左端丷右端, 参数配置, 深度):
        '-> (双侧展翅树<深度>, None) #NOTE:REVERSE insert'
        assert 参数配置.增长
        assert 参数配置.增长防板荡
        for 节点 in 节点序列:
            双侧展翅树, _ = sf.巜压入节点囗囗双侧展翅树囗(双侧展翅树, 节点, 左端丷右端=左端丷右端, 参数配置=参数配置, 深度=深度)
        return 双侧展翅树, None
    ######################
    def 巜连续弹出节点囗囗双侧展翅树囗囗注意反序囗(sf, 双侧展翅树, 最大弹出数目, /, *, 左端丷右端, 参数配置, 深度):
        '-> (双侧展翅树<深度>, [节点]) #NOTE:REVERSE pop'
        assert 参数配置.缩水
        assert 参数配置.缩水防板荡
        节点列表 = []
        while not (len(节点列表) == 最大弹出数目 or sf.是空树囗囗双侧展翅树囗(双侧展翅树)):
            双侧展翅树, 节点 = sf.巜弹出节点囗囗双侧展翅树囗(双侧展翅树, 左端丷右端=左端丷右端, 参数配置=参数配置, 深度=深度)
            节点列表.append(节点)
        return 双侧展翅树, 节点列表
    ######################
    ######################
    #???无用
    def 巜同端先压入再弹出节点囗囗双侧展翅树囗(sf, 双侧展翅树, 节点, /, *, 左端丷右端, 参数配置, 深度):
        '-> (双侧展翅树<深度>, 节点)'
        return (双侧展翅树, 节点)
    ######################
    def 巜同端先弹出再压入节点囗囗双侧展翅树囗(sf, 双侧展翅树, 节点, /, *, 左端丷右端, 参数配置, 深度):
        '-> (双侧展翅树<深度>, 节点)'
        return _分流囗囗树形态囗(sf, sf.巜同端先弹出再压入节点囗囗光杆树囗, sf._囗巜同端先弹出再压入节点囗囗根深树囗囗分流用囗, 深度, 双侧展翅树, 节点, 左端丷右端=左端丷右端, 参数配置=参数配置, 深度=深度)
    ###
    def _囗巜同端先弹出再压入节点囗囗根深树囗囗分流用囗(sf, 根深树, 节点, /, *, 左端丷右端, 参数配置, 深度):
        '-> (根深树<深度>, 节点)'
        (起翼, 更深树, 讫翼) = sf.拆包囗根深树囗囗相对定位囗(根深树, 左起丷右起=左端丷右端, 深度=深度)
        起翼, 节点 = sf.巜外端先弹出再压入节点囗囗翅膀囗囗绝对定位囗(起翼, 节点, 左翼丷右翼=左端丷右端, 参数配置=参数配置, 深度=深度)
        根深树 = sf.构造囗根深树囗囗相对定位囗(起翼, 更深树, 讫翼, 左起丷右起=左端丷右端, 深度=深度)
        return 根深树, 节点
    ######################
    def 巜先讫端压入再起端弹出节点囗囗双侧展翅树囗(sf, 双侧展翅树, 节点, /, *, 左起丷右起, 参数配置, 深度):
        '-> (双侧展翅树<深度>, 节点)'
        双侧展翅树, _ = sf.巜压入节点囗囗双侧展翅树囗(双侧展翅树, 节点, 左端丷右端=not 左起丷右起, 参数配置=参数配置, 深度=深度)
            #讫端
        双侧展翅树, 节点 = sf.巜弹出节点囗囗双侧展翅树囗(双侧展翅树, 左端丷右端=左起丷右起, 参数配置=参数配置, 深度=深度)
            #起端
        return (双侧展翅树, 节点)
    ######################
    #???无用
    def 巜先起端弹出再讫端压入节点囗囗双侧展翅树囗(sf, 双侧展翅树, 节点, /, *, 左起丷右起, 参数配置, 深度):
        '-> (双侧展翅树<深度>, 节点)'
        双侧展翅树, 节点 = sf.巜弹出节点囗囗双侧展翅树囗(双侧展翅树, 左端丷右端=左起丷右起, 参数配置=参数配置, 深度=深度)
            #起端
        双侧展翅树, _ = sf.巜压入节点囗囗双侧展翅树囗(双侧展翅树, 节点, 左端丷右端=not 左起丷右起, 参数配置=参数配置, 深度=深度)
            #讫端
        return (双侧展翅树, 节点)

    doing
    ######################
    ######################
    ######################
    def 合并囗囗间夹囗节点序列囗(sf, 左囗双侧展翅树, 节点序列, 右囗双侧展翅树, /, *, 参数配置, 深度):
        '双侧展翅树<深度> -> [节点<深度>] -> 双侧展翅树<深度> -> 双侧展翅树<深度>'
        assert 参数配置.增长合并
        assert 参数配置.紧致假设
        #节点列表 #reversed

        左光杆 = sf.是光杆树囗(左囗双侧展翅树, 深度=深度)
        右光杆 = sf.是光杆树囗(右囗双侧展翅树, 深度=深度)
        if 左光杆:
            左囗光杆树 = 左囗双侧展翅树
        else:
            左囗根深树 = 左囗双侧展翅树
        if 右光杆:
            右囗光杆树 = 右囗双侧展翅树
        else:
            右囗根深树 = 右囗双侧展翅树
        #左巜右 = None
            # =[def]= [左长度 < 右长度]
        if 左光杆:
            if 右光杆:
                左长度 = sf.取囗长度囗囗光杆树囗(左囗光杆树, 深度=深度)
                右长度 = sf.取囗长度囗囗光杆树囗(右囗光杆树, 深度=深度)
                左巜右 = 左长度 < 右长度
            else:
                左巜右 = True
        else:
            if 右光杆:
                左巜右 = False
            else:
                左巜右 = None
        ######################
        if not 左巜右 is None:
            #if 左巜右:
                # [左长度 < 右长度]
            ls = [左囗双侧展翅树, 右囗双侧展翅树]
            长囗双侧展翅树 = ls[左巜右]
            短囗双侧展翅树 = ls[not 左巜右]
            左端丷右端 = not 左巜右
                # 左端丷右端<长囗双侧展翅树>
            左起丷右起 = 左巜右
                # 左起丷右起<短囗双侧展翅树>
            短囗节点序列 = sf.迭代囗子节点囗囗双侧展翅树囗(短囗双侧展翅树, 左起丷右起=左起丷右起, 深度=深度)
            f = reversed if 左巜右 else iter
                # [左长度 < 右长度]
                # 注入 右囗双侧展翅树
            try:
                it = f(节点序列)
                    #reversible
            except TypeError:
                节点列表 = [*节点序列]
                    #此后并无递归调用，所以没毛病！
                it = f(节点列表)
            it
            it = chain(it, 短囗节点序列)
            长囗双侧展翅树, _ = sf.巜连续压入节点囗囗双侧展翅树囗囗注意反序囗(长囗双侧展翅树, it, 左端丷右端=左端丷右端, 参数配置=参数配置, 深度=深度)
            return 长囗双侧展翅树
        ######################
        左囗根深树
        节点序列
        右囗根深树
        ######################
        (左囗左翼, 左囗更深树, 左囗右翼) = sf.拆包囗根深树囗囗绝对定位囗(左囗根深树, 深度=深度)
        (右囗左翼, 右囗更深树, 右囗右翼) = sf.拆包囗根深树囗囗绝对定位囗(右囗根深树, 深度=深度)
        ######################
        左起丷右起 = False
        itL = sf.迭代囗子节点囗囗翅膀囗囗绝对定位囗(左囗右翼, 左起丷右起=左起丷右起, 左翼丷右翼=True, 深度=深度)
        itR = sf.迭代囗子节点囗囗翅膀囗囗绝对定位囗(右囗左翼, 左起丷右起=左起丷右起, 左翼丷右翼=False, 深度=深度)
        it = chain(itL, 节点序列, itR)
        #assert 参数配置.紧致假设
        更深节点序列 = sf._囗更深节点序列巛节点序列囗囗要求足够长囗囗紧致假设囗(it, 左起丷右起=左起丷右起, 更深节点最小许可长度=参数配置.更深节点最小许可长度, 更深节点最大许可长度=参数配置.更深节点最大许可长度, 紧致假设=参数配置.紧致假设, 深度=深度)
        ######################
        (左囗左翼, 左囗更深树, ...)
        更深节点序列
        (..., 右囗更深树, 右囗右翼)
        ######################
        #recur:
        更深树 = sf.合并囗囗间夹囗节点序列囗(左囗更深树, 更深节点序列, 右囗更深树, 参数配置=参数配置, 深度=深度+1)
        ######################
        return sf.构造囗根深树囗囗绝对定位囗(左囗左翼, 更深树, 右囗右翼, 深度=深度)
        ######################
    def _囗更深节点序列巛节点序列囗囗要求足够长囗囗紧致假设囗(sf, 节点序列, /, *, 左起丷右起, 更深节点最小许可长度, 更深节点最大许可长度, 紧致假设, 深度):
        '『紧致假设:』=> Iter 节点<深度> -> Iter 更深节点<深度>'
        #assert 参数配置.紧致假设
        assert 紧致假设
        it = echo_or_mk_PeekableIterator(节点序列)
        it
        sz = 更深节点最小许可长度 + 更深节点最大许可长度
        n = 更深节点最大许可长度
        it.fill_le(sz)
        if it.len_relax() < 更深节点最小许可长度: raise 000
        kwds = dict(左起丷右起=左起丷右起, 更深节点最小许可长度=更深节点最小许可长度, 更深节点最大许可长度=更深节点最大许可长度, 深度=深度)
        while 1:
            it.fill_le(sz)
            if it.len_relax() < sz:
                break
            xs = it.read_relax_le(n)
            assert len(xs) == n
            更深节点 = sf.构造囗更深节点囗(xs, **kwds)
            yield 更深节点
        m = it.len_relax()
        assert 更深节点最小许可长度 <= m < 更深节点最小许可长度 + 更深节点最大许可长度
        if m < 2*更深节点最小许可长度:
            assert m <= 2*更深节点最小许可长度-1 <= 更深节点最大许可长度
            pass
        else:
            #assert 2*更深节点最小许可长度 <= m <= 更深节点最小许可长度+更深节点最大许可长度
            assert 更深节点最小许可长度 <= m-更深节点最小许可长度 <= 更深节点最大许可长度
            xs = it.read_relax_le(更深节点最小许可长度)
            更深节点 = sf.构造囗更深节点囗(xs, **kwds)
            yield 更深节点
            pass
        ######################
        m = it.len_relax()
        assert 更深节点最小许可长度 <= m <= 更深节点最大许可长度
        更深节点 = sf.构造囗更深节点囗(it, **kwds)
        yield 更深节点
        return
    ######################
    #begin-分裂囗囗搜索定位囗
    #
    def 分裂囗囗搜索定位囗囗索引版囗囗返回值为起讫次序囗(sf, 双侧展翅树, 索引, 目标, /, *, 左起丷右起, 参数配置, 深度):
        '双侧展翅树 -> 索引 -> 目标/属性<索引> -> (起囗双侧展翅树<左起丷右起;深度>, 讫囗双侧展翅树<左起丷右起;深度>)' ' #see:取囗缓存度量囗公开属性囗'
        assert 参数配置.缩水分裂
        加法零元 = sf.取囗缓存度量囗公开属性囗加法零元囗(索引)
        def 提取囗差分度量囗(缓存度量, /):
            return sf.取囗缓存度量囗公开属性囗(缓存度量, 索引)
        加法囗目标度量囗 = None
        比较囗目标度量囗 = None
        return sf.分裂囗囗搜索定位囗囗复杂版囗囗返回值为起讫次序囗(双侧展翅树, 加法零元, 目标, 提取囗差分度量囗, 加法囗目标度量囗, 比较囗目标度量囗, 左起丷右起=左起丷右起, 参数配置=参数配置, 深度=深度)
    #
    def 分裂囗囗搜索定位囗囗复杂版囗囗返回值为起讫次序囗(sf, 双侧展翅树, 偏移量, 目标, 提取囗差分度量囗, 加法囗目标度量囗, 比较囗目标度量囗, /, *, 左起丷右起, 参数配置, 深度):
        '偏移量/目标度量 -> 目标/目标度量 -> 提取囗差分度量囗/(缓存度量->差分度量) -> 加法囗目标度量囗/(目标度量->差分度量->目标度量) -> 比较囗目标度量囗/(累计/目标度量->目标/目标度量->退丷进) -> (起囗双侧展翅树<左起丷右起;深度>, 讫囗双侧展翅树<左起丷右起;深度>)'
        assert 参数配置.缩水分裂
        提取囗差分度量囗 = ifNone(提取囗差分度量囗, echo)
        加法囗目标度量囗 = ifNone(加法囗目标度量囗, opss.__add__)
        比较囗目标度量囗 = ifNone(比较囗目标度量囗, opss.__le__)
        初始累计值 = 偏移量
        def 魊累积囗(累计值, 缓存度量, /):
            差分度量 = 提取囗差分度量囗(缓存度量)
            整体度量 = 加法囗目标度量囗(累计值, 差分度量)
            退丷进 = 比较囗目标度量囗(整体度量, 目标)
            check_type_is(bool, 退丷进)
            if 退丷进:
                #进
                魊累计值 = (整体度量,)
            else:
                #退
                魊累计值 = null_tuple
            return 魊累计值
        ######################
        (焦点居前囗双侧展翅树, 焦点居前囗累计值, 魊囗焦点, 焦点居后囗双侧展翅树) = sf.分裂囗囗搜索定位囗囗精简版囗囗双侧展翅树囗囗返回值为起讫次序囗(双侧展翅树, 初始累计值, 魊累积囗, 已知焦点存在=False, 左起丷右起=左起丷右起, 参数配置=参数配置, 深度=深度)
        ######################
        整树 = 双侧展翅树
        assert (not 魊囗焦点) is (焦点居前囗双侧展翅树 is 整树)
        if sf.是空树囗囗双侧展翅树囗(焦点居前囗双侧展翅树, 深度=深度):
            焦点诸后囗双侧展翅树 = 整树
        elif 魊囗焦点:
            [焦点] = 魊囗焦点
            焦点诸后囗双侧展翅树, _ = sf.巜压入节点囗囗双侧展翅树囗(焦点居后囗双侧展翅树, 焦点, 左端丷右端=左起丷右起, 参数配置=参数配置, 深度=深度)
        else:
            焦点诸后囗双侧展翅树 = 焦点居后囗双侧展翅树 #空树
            assert (焦点居前囗双侧展翅树 is 整树)

        (起囗双侧展翅树, 讫囗双侧展翅树) = (焦点居前囗双侧展翅树, 焦点诸后囗双侧展翅树)
        return (起囗双侧展翅树, 讫囗双侧展翅树)
        ######################

    def 分裂囗囗搜索定位囗囗精简版囗囗双侧展翅树囗囗返回值为起讫次序囗(sf, 双侧展翅树, 初始累计值, 魊累积囗, /, *, 已知焦点存在, 左起丷右起, 参数配置, 深度):
        '初始累计值/累计值 -> 魊累积囗/(累计值 -> 缓存度量 -> 魊<累计值>) -> (焦点居前囗双侧展翅树<左起丷右起;深度>, 焦点居前囗累计值/累计值, 魊囗焦点/魊节点<深度>, 焦点居后囗双侧展翅树<左起丷右起;深度>)'
        '-> (焦点居前囗双侧展翅树<左起丷右起;深度>, 焦点居前囗累计值/累计值, 魊囗焦点/魊节点<深度>, 焦点居后囗双侧展翅树<左起丷右起;深度>)'
        '-> (焦点居前囗双侧展翅树, 焦点居前囗累计值, 魊囗焦点, 焦点居后囗双侧展翅树)'
        assert 参数配置.缩水分裂
        if not 已知焦点存在:
            整树 = 双侧展翅树

            缓存度量囗囗整树 = sf.取囗缓存度量囗囗双侧展翅树囗(整树, 深度=深度)
            魊累计值囗囗整树 = 魊累积囗(初始累计值, 缓存度量囗囗整树)
            焦点存在 = not 魊累计值囗囗整树
            if 魊累计值囗囗整树:
                assert not 焦点存在
                [累计值囗囗整树] = 魊累计值囗囗整树
                焦点居前囗双侧展翅树 = 整树
                焦点居后囗双侧展翅树 = 空树 = sf.构造囗空树囗(参数配置=参数配置, 深度=深度)
                焦点居前囗累计值 = 累计值囗囗整树
                魊囗焦点 = null_tuple
                return (焦点居前囗双侧展翅树, 焦点居前囗累计值, 魊囗焦点, 焦点居后囗双侧展翅树)
            已知焦点存在 = 焦点存在
        assert 已知焦点存在

        return _分流囗囗树形态囗(sf, sf._囗分裂囗囗搜索定位囗囗精简版囗囗光杆树囗囗分流用囗, sf._囗分裂囗囗搜索定位囗囗精简版囗囗根深树囗囗分流用囗, 深度, 双侧展翅树, 初始累计值, 魊累积囗, 已知焦点存在=True, 左起丷右起=左起丷右起, 参数配置=参数配置, 深度=深度)

    def _囗分裂囗囗搜索定位囗囗精简版囗囗光杆树囗囗分流用囗(sf, 光杆树, 初始累计值, 魊累积囗, /, *, 已知焦点存在, 左起丷右起, 参数配置, 深度):
        '-> (起囗光杆树/焦点居前囗双侧展翅树<左起丷右起;深度>, 焦点居前囗累计值/累计值, 魊囗焦点/魊节点<深度>, 讫囗光杆树/焦点居后囗双侧展翅树<左起丷右起;深度>)'
        if not 已知焦点存在:
            raise 000
        整树囗节点序列 = sf.迭代囗子节点囗囗光杆树囗(光杆树, 左起丷右起=左起丷右起, 深度=深度)
        (焦点居前囗节点列表, 焦点居前囗累计值, 魊囗焦点, 焦点居后囗节点序列) = sf._囗分裂囗囗搜索定位囗囗精简版囗囗节点序列囗囗琐碎囗(整树囗节点序列, 初始累计值, 魊累积囗, 已知焦点存在=True, 左起丷右起=False, 参数配置=参数配置, 深度=深度)
        焦点居前囗双侧展翅树 = sf.构造囗双侧展翅树囗(焦点居前囗节点列表, 左起丷右起=左起丷右起, 参数配置=参数配置, 深度=深度)
        焦点居后囗双侧展翅树 = sf.构造囗双侧展翅树囗(焦点居后囗节点序列, 左起丷右起=左起丷右起, 参数配置=参数配置, 深度=深度)
        return (焦点居前囗双侧展翅树, 焦点居前囗累计值, 魊囗焦点, 焦点居后囗双侧展翅树)
                #相对次序
                #移除:_调整次序囗

    ######################
    ######################
    def _囗分裂囗囗搜索定位囗囗精简版囗囗根深树囗囗分流用囗(sf, 根深树, 初始累计值, 魊累积囗, /, *, 已知焦点存在, 左起丷右起, 参数配置, 深度):
        '-> (焦点居前囗双侧展翅树<左起丷右起;深度>, 焦点居前囗累计值/累计值, 魊囗焦点/魊节点<深度>, 焦点居后囗双侧展翅树<左起丷右起;深度>)'
        if not 已知焦点存在:
            raise 000
        (起翼, 更深树, 讫翼) = sf.拆包囗根深树囗囗相对定位囗(根深树, 左起丷右起=左起丷右起, 深度=深度)
        ######################
        (起翼, 更深树, 讫翼)
        ######################
        缓存度量囗囗起翼 = sf.取囗缓存度量囗囗翅膀囗囗相对定位囗(起翼, 左起丷右起=左起丷右起, 起翼丷讫翼=False, 深度=深度)
        魊累计值囗囗起翼之后 = 魊累积囗(初始累计值, 缓存度量囗囗起翼)
        if not 魊累计值囗囗起翼之后:
            起翼囗节点序列 = sf.迭代囗子节点囗囗翅膀囗囗相对定位囗(起翼, 左起丷右起=左起丷右起, 起翼丷讫翼=False, 深度=深度)
            (焦点居前囗节点列表, 焦点居前囗累计值, 魊囗焦点, 焦点居后囗节点序列) = sf._囗分裂囗囗搜索定位囗囗精简版囗囗节点序列囗囗琐碎囗(起翼囗节点序列, 初始累计值, 魊累积囗, 已知焦点存在=True, 左起丷右起=False, 参数配置=参数配置, 深度=深度)
            ######################
            ((焦点居前囗节点列表, 焦点居前囗累计值, 魊囗焦点, 焦点居后囗节点序列), 更深树, 讫翼)
            ######################
            (焦点居前囗节点列表, 焦点居前囗累计值, 魊囗焦点, (焦点居后囗节点序列, 更深树, 讫翼))
            ######################
            assert 魊囗焦点 # <<== [not 魊累计值囗囗起翼之后]
            ######################
            sz = len(焦点居前囗节点列表)
            焦点居前囗双侧展翅树 = sf.构造囗双侧展翅树囗(焦点居前囗节点列表, 左起丷右起=左起丷右起, 参数配置=参数配置, 深度=深度)
            焦点居后囗双侧展翅树, _ = sf.巜连续弹出节点囗囗双侧展翅树囗囗注意反序囗(根深树, sz, 左端丷右端=左起丷右起, 参数配置=参数配置, 深度=深度)
            return (焦点居前囗双侧展翅树, 焦点居前囗累计值, 魊囗焦点, 焦点居后囗双侧展翅树)
                #相对次序
            #return _调整次序囗(焦点居前囗双侧展翅树, 焦点居前囗累计值, 魊囗焦点, 焦点居后囗双侧展翅树, 左起丷右起=左起丷右起)
                #绝对次序
        ######################
        ######################
        ######################
        (起翼, 更深树, 讫翼)
        ######################
        [累计值囗囗起翼之后] = 魊累计值囗囗起翼之后
        缓存度量囗囗更深树 = sf.取囗缓存度量囗囗双侧展翅树囗(更深树, 深度=深度+1)
        魊累计值囗囗讫翼之前 = 魊累积囗(累计值囗囗起翼之后, 缓存度量囗囗更深树)
        if not 魊累计值囗囗讫翼之前:
            (起囗更深树, 更深焦点居前囗累计值, 魊更深焦点, 讫囗更深树) = sf.分裂囗囗搜索定位囗囗精简版囗囗双侧展翅树囗囗返回值为起讫次序囗(更深树, 累计值囗囗起翼之后, 魊累积囗, 已知焦点存在=True, 左起丷右起=左起丷右起, 参数配置=参数配置, 深度=深度+1)
            ######################
            (起翼, (起囗更深树, 更深焦点居前囗累计值, 魊更深焦点, 讫囗更深树), 讫翼)
            ######################
            assert 魊更深焦点 # <<== [not 魊累计值囗囗讫翼之前]
            ######################
        if not 魊累计值囗囗讫翼之前 and not 魊更深焦点:
            assert sf.是空树囗囗双侧展翅树囗(讫囗更深树, 深度=深度+1)
            raise 000 --'logic-err'
        if not 魊累计值囗囗讫翼之前 and 魊更深焦点:
            [更深焦点] = 魊更深焦点
            深度囗囗更深节点 = 深度##
            it = sf.迭代囗子节点囗囗更深节点囗(更深焦点, 左起丷右起=左起丷右起, 深度=深度囗囗更深节点)
            (焦点居前囗节点列表, 焦点居前囗累计值, 魊囗焦点, 焦点居后囗节点序列) = sf._囗分裂囗囗搜索定位囗囗精简版囗囗节点序列囗囗琐碎囗(it, 更深焦点居前囗累计值, 魊累积囗, 已知焦点存在=True, 左起丷右起=False, 参数配置=参数配置, 深度=深度)
            ######################
            (起翼, (起囗更深树, (焦点居前囗节点列表, 焦点居前囗累计值, 魊囗焦点, 焦点居后囗节点序列), 讫囗更深树), 讫翼)
            ######################
            ((起翼, 起囗更深树, 焦点居前囗节点列表), 焦点居前囗累计值, 魊囗焦点, (焦点居后囗节点序列, 讫囗更深树, 讫翼))
            ######################
            assert 魊囗焦点 # <<== [not 魊累计值囗囗讫翼之前]
            ######################
            焦点居前囗双侧展翅树 = sf.构造囗双侧展翅树囗囗讫翼修复囗(起翼, 起囗更深树, iter(焦点居前囗节点列表), 左起丷右起=左起丷右起, 参数配置=参数配置, 深度=深度)
            焦点居后囗双侧展翅树 = sf.构造囗双侧展翅树囗囗讫翼修复囗(讫翼, 讫囗更深树, reversed([*焦点居后囗节点列表]), 左起丷右起=左起丷右起, 参数配置=参数配置, 深度=深度)
            return (焦点居前囗双侧展翅树, 焦点居前囗累计值, 魊囗焦点, 焦点居后囗双侧展翅树)
        ######################
        ######################
        ######################
        ######################
        (起翼, 更深树, 讫翼)
        ######################
        ######################
        assert 魊累计值囗囗讫翼之前
        [累计值囗囗讫翼之前] = 魊累计值囗囗讫翼之前
        if 0:
            缓存度量囗囗讫翼 = sf.取囗缓存度量囗囗翅膀囗囗相对定位囗(讫翼, 左起丷右起=左起丷右起, 起翼丷讫翼=True, 深度=深度)
            魊累计值囗囗讫翼之后 = 魊累积囗(累计值囗囗讫翼之前, 缓存度量囗囗讫翼)
            assert not 魊累计值囗囗讫翼之后 # <<== [not 魊累计值囗囗整树]
        ######################
        讫翼囗节点序列 = sf.迭代囗子节点囗囗翅膀囗囗相对定位囗(讫翼, 左起丷右起=左起丷右起, 起翼丷讫翼=True, 深度=深度)
        (焦点居前囗节点列表, 焦点居前囗累计值, 魊囗焦点, 焦点居后囗节点序列) = sf._囗分裂囗囗搜索定位囗囗精简版囗囗节点序列囗囗琐碎囗(讫翼囗节点序列, 累计值囗囗讫翼之前, 魊累积囗, 已知焦点存在=True, 左起丷右起=False, 参数配置=参数配置, 深度=深度)
        ######################
        (起翼, 更深树, (焦点居前囗节点列表, 焦点居前囗累计值, 魊囗焦点, 焦点居后囗节点序列))
        ######################
        ((起翼, 更深树, 焦点居前囗节点列表), 焦点居前囗累计值, 魊囗焦点, 焦点居后囗节点序列)
        ######################
        if 已知焦点存在:
            assert 魊囗焦点 # <<== [not 魊累计值囗囗整树]
        ######################
        焦点居后囗节点列表 = [*焦点居后囗节点序列]
        sz = len(焦点居后囗节点列表)
        焦点居前囗双侧展翅树, _ = sf.巜连续弹出节点囗囗双侧展翅树囗囗注意反序囗(根深树, sz, 左端丷右端=not 左起丷右起, 参数配置=参数配置, 深度=深度)
        焦点居后囗双侧展翅树 = sf.构造囗双侧展翅树囗(焦点居后囗节点列表, 左起丷右起=左起丷右起, 参数配置=参数配置, 深度=深度)
            ####同向
        if not 魊囗焦点:
            assert len(焦点居后囗节点列表) == 0
            assert 焦点居前囗双侧展翅树 is 整树
            整树 = 根深树
            #焦点居前囗双侧展翅树 = 整树 = 根深树
        return (焦点居前囗双侧展翅树, 焦点居前囗累计值, 魊囗焦点, 焦点居后囗双侧展翅树)

    def _囗分裂囗囗搜索定位囗囗精简版囗囗节点序列囗囗琐碎囗(sf, 节点序列, 初始累计值, 魊累积囗, /, *, 已知焦点存在, 左起丷右起, 参数配置, 深度):
        '-> (焦点居前囗节点列表<左起丷右起;深度>/[节点<深度>], 焦点居前囗累计值/累计值, 魊囗焦点/魊节点<深度>, 焦点居后囗节点序列<左起丷右起;深度>)'
        if not 已知焦点存在:
            raise 000
        if 左起丷右起:
            raise 000
            #xxx:raise NotImplementedError
        焦点居前囗节点列表 = []
        累计值 = 初始累计值
        it = iter(节点序列)
        for 节点 in it:
            缓存度量 = sf.取囗缓存度量囗囗节点囗(节点, 深度=深度)
            魊累计值 = 魊累积囗(累计值, 缓存度量)
            if not 魊累计值:
                魊囗焦点 = (节点,)
                break
            [累计值] = 魊累计值
        else:
                魊囗焦点 = null_tuple
        焦点居后囗节点序列 = it
        焦点居前囗累计值 = 累计值
        #xxx:return _调整次序囗
        # 保持相对性
        return (焦点居前囗节点列表, 焦点居前囗累计值, 魊囗焦点, 焦点居后囗节点序列)
    #end-分裂囗囗搜索定位囗
    #doing

    ######################
    ######################
#end-class 魖双侧展翅树囗数据类型配置囗囗紧致假设(ABC):



######################

def _累计囗缓存度量囗(sf, 取囗缓存度量囗囗某某某囗, 左起丷右起, 某某某序列, /, **kwds):
    起囗缓存度量 = sf.取囗加法零元囗囗缓存度量囗()
    for 某某某 in 某某某序列:
        讫囗缓存度量 = 取囗缓存度量囗囗某某某囗(某某某, **kwds)
        起囗缓存度量 = sf.加囗缓存度量囗囗相对定位囗(起囗缓存度量, 讫囗缓存度量, 左起丷右起=左起丷右起)
    return 起囗缓存度量
__all__
class 魖双侧展翅树囗数据类型配置囗囗紧致假设囗囗缓存度量(魖双侧展翅树囗数据类型配置囗囗紧致假设):
    r'''[[[
===
`加囗缓存度量囗囗绝对定位囗
    #满足 结合律
    #不一定满足 交换律
`取囗加法零元囗囗缓存度量囗
`求囗缓存度量囗囗元素囗
===
===
py_adhoc_call  seed.helper.print_methods  @wrapped_print_methods   %seed.data_funcs.finger_tree.finger_tree_common:魖双侧展翅树囗数据类型配置囗囗紧致假设囗囗缓存度量@T    =T  +exclude_attrs5listed_in_cls_doc
===
new_abstract_methods:
    `加囗缓存度量囗囗绝对定位囗
    `取囗加法零元囗囗缓存度量囗
    `求囗缓存度量囗囗元素囗
    `构造囗元素封包节点囗囗已知缓存度量囗
    `构造囗更深节点囗囗已知缓存度量囗
    `构造囗光杆树囗囗已知缓存度量囗
    `构造囗翅膀囗囗绝对定位囗囗已知缓存度量囗
    `构造囗根深树囗囗绝对定位囗囗已知缓存度量囗
new_concrete_methods:
    加囗缓存度量囗囗相对定位囗
    构造囗元素封包节点囗
    构造囗更深节点囗
    构造囗光杆树囗
    构造囗翅膀囗囗绝对定位囗
    构造囗根深树囗囗绝对定位囗

    #]]]'''#'''
    __slots__ = ()


    @abstractmethod
    def 加囗缓存度量囗囗绝对定位囗(sf, 左囗缓存度量, 右囗缓存度量, /):
        '-> 缓存度量 #满足 结合律 #不一定满足 交换律'
    @abstractmethod
    def 取囗加法零元囗囗缓存度量囗(sf, /):
        '-> 缓存度量'
    @abstractmethod
    def 求囗缓存度量囗囗元素囗(sf, 元素, /):
        '-> 缓存度量'

    @abstractmethod
    def 构造囗元素封包节点囗囗已知缓存度量囗(sf, 元素, /, *, 缓存度量):
        '-> 元素封包节点/节点<0>/封包<元素> #用于 缓存 度量，否则 无需 封包'
    @abstractmethod
    def 构造囗更深节点囗囗已知缓存度量囗(sf, 节点序列, /, *, 左起丷右起, 更深节点最小许可长度, 更深节点最大许可长度, 深度, 缓存度量):
        '-> 节点<深度+1>/更深节点<深度> #可能需要 缓存 度量'
    @abstractmethod
    def 构造囗光杆树囗囗已知缓存度量囗(sf, 节点序列, /, *, 左起丷右起, 光杆树最大许可长度, 深度, 缓存度量):
        '-> 光杆树<深度> #可能需要 缓存 度量'
        #光杆树:封顶双侧栈<光杆树最大许可长度>
    @abstractmethod
    def 构造囗翅膀囗囗绝对定位囗囗已知缓存度量囗(sf, 节点序列, /, *, 左起丷右起, 左翼丷右翼, 翅膀最大许可长度, 翅膀最小许可长度, 深度, 缓存度量):
        '[节点<左起丷右起,深度>] -> 翅膀<左翼丷右翼,深度> #区分左右:栈开口方向不同！#可能需要 缓存 度量'
        #翅膀:封顶单侧保底栈<左起丷右起,翅膀最大许可长度,翅膀最小许可长度>
    @abstractmethod
    def 构造囗根深树囗囗绝对定位囗囗已知缓存度量囗(sf, 左翼, 更深树, 右翼, /, *, 深度, 缓存度量):
        '-> 根深树<深度> #可能需要 缓存 度量'

    ######################
    ######################
    ###以下 具象方法:
    ######################
    ######################



    def 加囗缓存度量囗囗相对定位囗(sf, 起囗缓存度量, 讫囗缓存度量, /, *, 左起丷右起):
        '-> 缓存度量 #满足 结合律 #不一定满足 交换律'
        (左囗缓存度量, 右囗缓存度量) = _调整次序囗(起囗缓存度量, 讫囗缓存度量, 左起丷右起=左起丷右起)
        return sf.加囗缓存度量囗囗绝对定位囗(左囗缓存度量, 右囗缓存度量)

    @override
    def 构造囗元素封包节点囗(sf, 元素, /):
        '-> 元素封包节点/节点<0>/封包<元素> #用于 缓存 度量，否则 无需 封包'
        缓存度量 = sf.求囗缓存度量囗囗元素囗(元素)
        return sf.构造囗元素封包节点囗囗已知缓存度量囗(元素, 缓存度量=缓存度量)

    @override
    def 构造囗更深节点囗(sf, 节点序列, /, *, 左起丷右起, 更深节点最小许可长度, 更深节点最大许可长度, 深度):
        '-> 节点<深度+1>/更深节点<深度> #可能需要 缓存 度量'
        ls = mk_reiterable(节点序列)
        if not 更深节点最小许可长度 <= len(ls) <= 更深节点最大许可长度: raise 错误囗囗长度囗囗更深节点
        缓存度量 = _累计囗缓存度量囗(sf, sf.取囗缓存度量囗囗节点囗, 左起丷右起, ls, 深度=深度)
        return sf.构造囗更深节点囗囗已知缓存度量囗(ls, 左起丷右起=左起丷右起, 更深节点最小许可长度=更深节点最小许可长度, 更深节点最大许可长度=更深节点最大许可长度, 深度=深度, 缓存度量=缓存度量)

    @override
    def 构造囗光杆树囗(sf, 节点序列, /, *, 左起丷右起, 光杆树最大许可长度, 深度):
        '-> 光杆树<深度> #可能需要 缓存 度量'
        #光杆树:封顶双侧栈<光杆树最大许可长度>
        ls = mk_reiterable(节点序列)
        if not len(ls) <= 光杆树最大许可长度: raise 错误囗囗长度囗囗光杆树
        缓存度量 = _累计囗缓存度量囗(sf, sf.取囗缓存度量囗囗节点囗, 左起丷右起, ls, 深度=深度)
        return sf.构造囗光杆树囗囗已知缓存度量囗(ls, 左起丷右起=左起丷右起, 光杆树最大许可长度=光杆树最大许可长度, 深度=深度, 缓存度量=缓存度量)

    @override
    def 构造囗翅膀囗囗绝对定位囗(sf, 节点序列, /, *, 左起丷右起, 左翼丷右翼, 翅膀最大许可长度, 翅膀最小许可长度, 深度):
        '[节点<左起丷右起,深度>] -> 翅膀<左翼丷右翼,深度> #区分左右:栈开口方向不同！#可能需要 缓存 度量'
        #翅膀:封顶单侧保底栈<左起丷右起,翅膀最大许可长度,翅膀最小许可长度>
        ls = mk_reiterable(节点序列)
        if not 翅膀最小许可长度 <= len(ls) <= 翅膀最大许可长度: raise 错误囗囗长度囗囗翅膀
        缓存度量 = _累计囗缓存度量囗(sf, sf.取囗缓存度量囗囗节点囗, 左起丷右起, ls, 深度=深度)
        return sf.构造囗翅膀囗囗已知缓存度量囗(ls, 左起丷右起=左起丷右起, 左翼丷右翼=左翼丷右翼, 翅膀最小许可长度=翅膀最小许可长度, 翅膀最大许可长度=翅膀最大许可长度, 深度=深度, 缓存度量=缓存度量)

    @override
    def 构造囗根深树囗囗绝对定位囗(sf, 左翼, 更深树, 右翼, /, *, 深度):
        '-> 根深树<深度> #可能需要 缓存 度量'
        左翼囗缓存度量 = sf.取囗缓存度量囗囗翅膀囗囗绝对定位囗(左翼, 左翼丷右翼=False, 深度=深度)
        右翼囗缓存度量 = sf.取囗缓存度量囗囗翅膀囗囗绝对定位囗(右翼, 左翼丷右翼=True, 深度=深度)
        更深树囗缓存度量 = sf.取囗缓存度量囗囗双侧展翅树囗(更深树, 深度=深度)
        左中 = sf.加囗缓存度量囗囗绝对定位囗(左翼囗缓存度量, 更深树囗缓存度量)
        左中右 = sf.加囗缓存度量囗囗绝对定位囗(左中, 右翼囗缓存度量)
        缓存度量囗囗整树 = 左中右
        return sf.构造囗根深树囗囗绝对定位囗囗已知缓存度量囗(左翼, 更深树, 右翼, 深度=深度, 缓存度量=缓存度量囗囗整树)


#end-class 魖双侧展翅树囗数据类型配置囗囗紧致假设囗囗缓存度量(魖双侧展翅树囗数据类型配置囗囗紧致假设):







######################
__all__
class 魖双侧展翅树囗数据类型配置囗囗紧致假设囗囗缓存度量囗囗囗标准元组(魖双侧展翅树囗数据类型配置囗囗紧致假设囗囗缓存度量):
    r'''[[[
    [元素封包节点 =[def]= (缓存度量, 元素)]
    [更深节点 =[def]= (缓存度量, 节点...)]
    [光杆树 =[def]= (False, 缓存度量, 节点...)]
    [翅膀 =[def]= (缓存度量, 节点...)]
    [根深树 =[def]= (True, 缓存度量, 左翼, 更深树, 右翼)]
        #开头的 真值 <<== 区分树形态囗()
        #空间开销不大，因为 每棵 双侧展翅树 包含的 光杆树 只有一棵，根深树 只出现在 中心，即只有 O(log(N))棵

===
===
py_adhoc_call  seed.helper.print_methods  @wrapped_print_methods   %seed.data_funcs.finger_tree.finger_tree_common:魖双侧展翅树囗数据类型配置囗囗紧致假设囗囗缓存度量囗囗囗标准元组@T    =T  +exclude_attrs5listed_in_cls_doc
===
abstract_methods:
    `加囗缓存度量囗囗绝对定位囗
    `取囗加法零元囗囗缓存度量囗
    `求囗缓存度量囗囗元素囗
    `取囗缓存度量囗公开属性囗
    `取囗缓存度量囗公开属性囗加法零元囗
    `取囗缓存度量囗公开属性囗索引列表囗
===

    #]]]'''#'''
    __slots__ = ()


    @override
    def 构造囗元素封包节点囗囗已知缓存度量囗(sf, 元素, /, *, 缓存度量):
        '-> 元素封包节点/节点<0>/封包<元素> #用于 缓存 度量，否则 无需 封包'
        return (缓存度量, 元素)
    @override
    def 构造囗更深节点囗囗已知缓存度量囗(sf, 节点序列, /, *, 左起丷右起, 更深节点最小许可长度, 更深节点最大许可长度, 深度, 缓存度量):
        '-> 节点<深度+1>/更深节点<深度> #可能需要 缓存 度量'
        return (缓存度量, *_调整次序囗(*节点序列, 左起丷右起))
    @override
    def 构造囗光杆树囗囗已知缓存度量囗(sf, 节点序列, /, *, 左起丷右起, 光杆树最大许可长度, 深度, 缓存度量):
        '-> 光杆树<深度> #可能需要 缓存 度量'
        #光杆树:封顶双侧栈<光杆树最大许可长度>
        return (False, 缓存度量, *_调整次序囗(*节点序列, 左起丷右起=左起丷右起))
    @override
    def 构造囗翅膀囗囗绝对定位囗囗已知缓存度量囗(sf, 节点序列, /, *, 左起丷右起, 左翼丷右翼, 翅膀最大许可长度, 翅膀最小许可长度, 深度, 缓存度量):
        '[节点<左起丷右起,深度>] -> 翅膀<左翼丷右翼,深度> #区分左右:栈开口方向不同！#可能需要 缓存 度量'
        #翅膀:封顶单侧保底栈<左起丷右起,翅膀最大许可长度,翅膀最小许可长度>
        return (缓存度量, *_调整次序囗(*节点序列, 左起丷右起))
    @override
    def 构造囗根深树囗囗绝对定位囗囗已知缓存度量囗(sf, 左翼, 更深树, 右翼, /, *, 深度, 缓存度量):
        '-> 根深树<深度> #可能需要 缓存 度量'
        return (True, 缓存度量, 左翼, 更深树, 右翼)


    @override
    def 拆包囗元素封包节点囗(sf, 元素封包节点, /):
        '-> 元素'
        return 元素封包节点[1]
        (缓存度量, 元素) = 元素封包节点
        return 元素
    @override
    def 拆包囗根深树囗囗绝对定位囗(sf, 根深树, /, *, 深度):
        '-> (左翼, 更深树, 右翼)'
        return 根深树[2:]

    @override
    def 区分树形态囗(sf, 双侧展翅树, /, *, 深度):
        '-> 光杆树丷根深树/bool'
        return 双侧展翅树[0]
    @override
    def 是空树囗囗光杆树囗(sf, 光杆树, /, *, 深度):
        '-> bool'
        return len(光杆树) == 2

    @override
    def 迭代囗子节点囗囗光杆树囗(sf, 光杆树, /, *, 左起丷右起, 深度):
        '-> Iter 节点<深度>'
        if 左起丷右起:
            return islice(reversed(光杆树), len(光杆树)-2)
        return islice(iter(光杆树), 2, None)
    @override
    def 迭代囗子节点囗囗翅膀囗囗绝对定位囗(sf, 左翼丨右翼, /, *, 左起丷右起, 左翼丷右翼, 深度):
        '-> Iter 节点<深度>'
        if 左起丷右起:
            return islice(reversed(左翼丨右翼), len(左翼丨右翼)-1)
        return islice(iter(左翼丨右翼), 1, None)
    @override
    def 迭代囗子节点囗囗更深节点囗(sf, 更深节点, /, *, 左起丷右起, 深度):
        '更深节点<深度> -> Iter 节点<深度>'
        if 左起丷右起:
            return islice(reversed(更深节点), len(更深节点)-1)
        return islice(iter(更深节点), 1, None)


    @override
    def 取囗长度囗囗光杆树囗(sf, 光杆树, /, *, 深度):
        '-> 长度'
        return len(光杆树) -2
    @override
    def 取囗长度囗囗翅膀囗囗绝对定位囗(sf, 左翼丨右翼, /, *, 左翼丷右翼, 深度):
        '-> 长度'
        return len(左翼丨右翼) -1
    @override
    def 取囗长度囗囗更深节点囗(sf, 更深节点, /, *, 深度):
        '-> 长度'
        return len(更深节点) -1

    ######################
    @override
    def 取囗缓存度量囗囗元素封包节点囗(sf, 元素封包节点, /):
        '-> 缓存度量'
        return 元素封包节点[0]
    @override
    def 取囗缓存度量囗囗更深节点囗(sf, 更深节点, /, *, 深度):
        '-> 缓存度量'
        return 更深节点[0]
    @override
    def 取囗缓存度量囗囗光杆树囗(sf, 光杆树, /, *, 深度):
        '-> 缓存度量'
        return 光杆树[1]
    @override
    def 取囗缓存度量囗囗翅膀囗囗绝对定位囗(sf, 左翼丨右翼, /, *, 左翼丷右翼, 深度):
        '-> 缓存度量'
        return 左翼丨右翼[0]
    @override
    def 取囗缓存度量囗囗根深树囗(sf, 根深树, /, *, 深度):
        '-> 缓存度量'
        return 根深树[1]


######################
__all__
class 魖双侧展翅树囗数据类型配置囗囗紧致假设囗囗缓存度量为长度(魖双侧展翅树囗数据类型配置囗囗紧致假设囗囗缓存度量):
    __slots__ = ()

    @override
    def 加囗缓存度量囗囗绝对定位囗(sf, 左囗缓存度量, 右囗缓存度量, /):
        '-> 缓存度量 #满足 结合律 #不一定满足 交换律'
        return 左囗缓存度量 + 右囗缓存度量
    @override
    def 取囗加法零元囗囗缓存度量囗(sf, /):
        '-> 缓存度量'
        return 0
    @override
    def 求囗缓存度量囗囗元素囗(sf, 元素, /):
        '-> 缓存度量'
        return 1


    ######################
    ######################
    #属性界面:
    #
    @override
    def 取囗缓存度量囗公开属性囗索引列表囗(sf, /):
        '-> [索引] #用于 访问/解读 缓存度量 #see:分裂囗囗搜索定位囗'
        return ('len',)
    @override
    def 取囗缓存度量囗公开属性囗(sf, 缓存度量, 索引, /):
        '缓存度量 -> 索引 -> 属性值<索引>'
        if 索引 == 'len':
            return 缓存度量
        raise LookupError(索引)
    @override
    def 取囗缓存度量囗公开属性囗加法零元囗(sf, 索引, /):
        '索引 -> 加法零元<索引>'
        if 索引 == 'len':
            return 0
        raise LookupError(索引)
    ######################
    ######################

######################
__all__
class 双侧展翅树囗数据类型配置囗囗紧致假设囗囗缓存度量囗囗囗标准元组囗囗缓存度量为长度(魖双侧展翅树囗数据类型配置囗囗紧致假设囗囗缓存度量为长度, 魖双侧展翅树囗数据类型配置囗囗紧致假设囗囗缓存度量囗囗囗标准元组):
    __slots__ = ()
双侧展翅树囗数据类型配置囗囗紧致假设囗囗缓存度量囗囗囗标准元组囗囗缓存度量为长度 = 双侧展翅树囗数据类型配置囗囗紧致假设囗囗缓存度量囗囗囗标准元组囗囗缓存度量为长度()



class 双侧展翅树囗数据类型配置囗囗紧致假设囗囗缓存度量囗囗囗标准元组(魖双侧展翅树囗数据类型配置囗囗紧致假设囗囗缓存度量囗囗囗标准元组
    , StaticImmutableNamespaceBase
    , ordered_user_attr_seq = r'''
    加囗缓存度量囗囗绝对定位囗
    求囗缓存度量囗囗元素囗
    取囗缓存度量囗公开属性囗
    加法零元囗囗缓存度量
    缓存度量囗公开属性囗加法零元巛索引
    缓存度量囗公开属性囗索引列表
    '''.split()):
    ___no_slots_ok___ = True


    @override
    def 加囗缓存度量囗囗绝对定位囗(sf, 左囗缓存度量, 右囗缓存度量, /):
        '-> 缓存度量 #满足 结合律 #不一定满足 交换律'
        return sf.加囗缓存度量囗囗绝对定位囗(左囗缓存度量, 右囗缓存度量)
    @override
    def 取囗加法零元囗囗缓存度量囗(sf, /):
        '-> 缓存度量'
        return sf.加法零元囗囗缓存度量
    @override
    def 求囗缓存度量囗囗元素囗(sf, 元素, /):
        '-> 缓存度量'
        return sf.求囗缓存度量囗囗元素囗(元素)


    ######################
    ######################
    #属性界面:
    #
    @override
    def 取囗缓存度量囗公开属性囗索引列表囗(sf, /):
        '-> [索引] #用于 访问/解读 缓存度量 #see:分裂囗囗搜索定位囗'
        return sf.缓存度量囗公开属性囗索引列表
    @override
    def 取囗缓存度量囗公开属性囗(sf, 缓存度量, 索引, /):
        '缓存度量 -> 索引 -> 属性值<索引>'
        return sf.取囗缓存度量囗公开属性囗(缓存度量, 索引)
    @override
    def 取囗缓存度量囗公开属性囗加法零元囗(sf, 索引, /):
        '索引 -> 加法零元<索引>'
        return sf.缓存度量囗公开属性囗加法零元巛索引[索引]
    ######################
    ######################
















######################
__all__
class 魖双侧展翅树囗相关操作(ABC):
    __slots__ = ()
    def 构造树囗(sf, 元素序列, /, *, 左起丷右起):
        '-> 双侧展翅树'
        节点序列 = map(sf.构造囗元素封包节点囗, 元素序列)
        return sf.构造树囗囗深树囗(节点序列, 左起丷右起=左起丷右起, 深度=0)
    def 是空树囗(sf, 双侧展翅树, /):
        '-> bool'
        return sf.是空树囗囗深树囗(双侧展翅树, 深度=0)
    def 迭代囗元素囗(sf, 双侧展翅树, /, *, 左起丷右起):
        '-> Iter 元素'
        return map(sf.拆包囗元素封包节点囗, sf.迭代囗子节点囗囗深树囗(双侧展翅树, 左起丷右起=左起丷右起, 深度=0))
    def 巜压入元素囗(sf, 双侧展翅树, 元素, /, *, 左端丷右端):
        '-> (双侧展翅树, None)'
        节点 = sf.构造囗元素封包节点囗(元素)
        return sf.巜压入节点囗囗深树囗(双侧展翅树, 节点, 左端丷右端=左端丷右端, 深度=0)
    def 巜弹出元素囗(sf, 双侧展翅树, /, *, 左端丷右端):
        '-> (双侧展翅树, 元素)'
        双侧展翅树, 节点 = sf.巜弹出节点囗囗深树囗(双侧展翅树, 左端丷右端=左端丷右端, 深度=0)
        元素封包节点 = 节点
        元素 = sf.拆包囗元素封包节点囗(元素封包节点)
        return (双侧展翅树, 元素)

    def 合并囗囗间夹囗元素序列囗(sf, 左囗双侧展翅树, 元素序列, 右囗双侧展翅树, /):
        '-> 双侧展翅树'
        节点序列 = map(sf.构造囗元素封包节点囗, 元素序列)
        return sf.合并囗囗间夹囗节点序列囗囗深树囗(左囗双侧展翅树, 节点序列, 右囗双侧展翅树, 深度=0)

    def 分裂囗囗搜索定位囗(sf, 双侧展翅树, 索引, 目标, /, *, 左起丷右起):
        '双侧展翅树 -> 索引 -> 目标/属性<索引> -> (起囗双侧展翅树<左起丷右起>, 讫囗双侧展翅树<左起丷右起>)' ' #see:取囗缓存度量囗公开属性囗'
        return sf.分裂囗囗搜索定位囗囗深树囗(双侧展翅树, 索引, 目标, 左起丷右起=左起丷右起, 深度=0)



    ######################
    @abstractmethod
    def 构造囗元素封包节点囗(sf, 元素, /):
        '-> 节点<0>/封包<元素> #用于 缓存 度量，否则 无需 封包'
    @abstractmethod
    def 拆包囗元素封包节点囗(sf, 元素封包节点, /):
        '-> 元素'
    ######################
    @abstractmethod
    def 构造树囗囗深树囗(sf, 节点序列, /, *, 左起丷右起, 深度):
        '-> 深囗双侧展翅树<深度>'
    @abstractmethod
    def 是空树囗囗深树囗(sf, 深囗双侧展翅树, /, *, 深度):
        '-> bool'
    @abstractmethod
    def 迭代囗子节点囗囗深树囗(sf, 深囗双侧展翅树, /, *, 左起丷右起, 深度):
        '-> Iter 节点'
    @abstractmethod
    def 巜压入节点囗囗深树囗(sf, 深囗双侧展翅树, 节点, /, *, 左端丷右端, 深度):
        '-> (深囗双侧展翅树<深度>, None)'
    @abstractmethod
    def 巜弹出节点囗囗深树囗(sf, 深囗双侧展翅树, /, *, 左端丷右端, 深度):
        '-> (深囗双侧展翅树<深度>, 节点)'
    @abstractmethod
    def 合并囗囗间夹囗节点序列囗囗深树囗(sf, 左囗深囗双侧展翅树, 节点序列, 右囗深囗双侧展翅树, /, *, 深度):
        '-> 深囗双侧展翅树<深度>'

    @abstractmethod
    def 分裂囗囗搜索定位囗囗深树囗(sf, 深囗双侧展翅树, 索引, 目标, /, *, 左起丷右起, 深度):
        '双侧展翅树<深度> -> 索引 -> 目标/属性<索引> -> (起囗双侧展翅树<左起丷右起;深度>, 讫囗双侧展翅树<左起丷右起;深度>)' ' #see:取囗缓存度量囗公开属性囗'
#end-class 魖双侧展翅树囗相关操作(ABC):


__all__
class 魖双侧展翅树囗相关操作囗囗囗配置(魖双侧展翅树囗相关操作):
    __slots__ = ()
    @abstractmethod
    def 取囗参数配置囗(sf, /):
        '-> 参数配置'
    @abstractmethod
    def 取囗数据类型配置囗(sf, /):
        '-> 数据类型配置'
    ######################
    @override
    def 构造囗元素封包节点囗(sf, 元素, /):
        '-> 节点<0>/封包<元素> #用于 缓存 度量，否则 无需 封包'
        数据类型配置 = sf.取囗数据类型配置囗()
        return 数据类型配置.构造囗元素封包节点囗(元素)
    @override
    def 拆包囗元素封包节点囗(sf, 元素封包节点, /):
        '-> 元素'
        数据类型配置 = sf.取囗数据类型配置囗()
        return 数据类型配置.拆包囗元素封包节点囗(元素封包节点)
    ######################
    @override
    def 构造树囗囗深树囗(sf, 节点序列, /, *, 左起丷右起, 深度):
        '-> 深囗双侧展翅树<深度>'
        参数配置 = sf.取囗参数配置囗()
        数据类型配置 = sf.取囗数据类型配置囗()
        深囗双侧展翅树 = 数据类型配置.构造囗双侧展翅树囗(节点序列, 左起丷右起=左起丷右起, 参数配置=参数配置, 深度=深度)
        return 深囗双侧展翅树

    @override
    def 是空树囗囗深树囗(sf, 深囗双侧展翅树, /, *, 深度):
        '-> bool'
        数据类型配置 = sf.取囗数据类型配置囗()
        return 数据类型配置.是空树囗囗双侧展翅树囗(深囗双侧展翅树, 深度=深度)

    @override
    def 迭代囗子节点囗囗深树囗(sf, 深囗双侧展翅树, /, *, 左起丷右起, 深度):
        '-> Iter 节点'
        数据类型配置 = sf.取囗数据类型配置囗()
        return 数据类型配置.迭代囗子节点囗囗双侧展翅树囗(深囗双侧展翅树, 左起丷右起=左起丷右起, 深度=深度)


    @override
    def 巜压入节点囗囗深树囗(sf, 深囗双侧展翅树, 节点, /, *, 左端丷右端, 深度):
        '-> (深囗双侧展翅树<深度>, None)'
        参数配置 = sf.取囗参数配置囗()
        数据类型配置 = sf.取囗数据类型配置囗()
        return 数据类型配置.巜压入节点囗囗双侧展翅树囗(深囗双侧展翅树, 节点, 左端丷右端=左端丷右端, 参数配置=参数配置, 深度=深度)
    @override
    def 巜弹出节点囗囗深树囗(sf, 深囗双侧展翅树, /, *, 左端丷右端, 深度):
        '-> (深囗双侧展翅树<深度>, 节点)'
        参数配置 = sf.取囗参数配置囗()
        数据类型配置 = sf.取囗数据类型配置囗()
        return 数据类型配置.巜弹出节点囗囗双侧展翅树囗(深囗双侧展翅树, 左端丷右端=左端丷右端, 参数配置=参数配置, 深度=深度)

    @override
    def 合并囗囗间夹囗节点序列囗囗深树囗(sf, 左囗深囗双侧展翅树, 节点序列, 右囗深囗双侧展翅树, /, *, 深度):
        '-> 深囗双侧展翅树<深度>'
        参数配置 = sf.取囗参数配置囗()
        数据类型配置 = sf.取囗数据类型配置囗()
        return 数据类型配置.合并囗囗间夹囗节点序列囗(左囗深囗双侧展翅树, 节点序列, 右囗深囗双侧展翅树, 参数配置=参数配置, 深度=深度)


    @override
    def 分裂囗囗搜索定位囗囗深树囗(sf, 深囗双侧展翅树, 索引, 目标, /, *, 左起丷右起, 深度):
        '双侧展翅树<深度> -> 索引 -> 目标/属性<索引> -> (起囗双侧展翅树<左起丷右起;深度>, 讫囗双侧展翅树<左起丷右起;深度>)' ' #see:取囗缓存度量囗公开属性囗'
        参数配置 = sf.取囗参数配置囗()
        数据类型配置 = sf.取囗数据类型配置囗()
        return 数据类型配置.分裂囗囗搜索定位囗囗索引版囗囗返回值为起讫次序囗(深囗双侧展翅树, 索引, 目标, 左起丷右起=左起丷右起, 参数配置=参数配置, 深度=深度)

#
__all__
class 双侧展翅树囗相关操作囗囗囗配置(
    魖双侧展翅树囗相关操作囗囗囗配置
    , StaticImmutableNamespaceBase
    , ordered_user_attr_seq = r'参数配置 数据类型配置'.split()
    ):
    ___no_slots_ok___ = True
    @override
    def 取囗参数配置囗(sf, /):
        '-> 参数配置'
        return sf.参数配置
    @override
    def 取囗数据类型配置囗(sf, /):
        '-> 数据类型配置'
        return sf.数据类型配置



数据类型配置囗囗囗元组囗长度 = (双侧展翅树囗数据类型配置囗囗紧致假设囗囗缓存度量囗囗囗标准元组
    (加囗缓存度量囗囗绝对定位囗=int.__add__
    ,求囗缓存度量囗囗元素囗=lambda _:1
    ,取囗缓存度量囗公开属性囗=lambda u, k:['len'].index(k) or u
    ,加法零元囗囗缓存度量=0
    ,缓存度量囗公开属性囗加法零元巛索引=dict(len=0)
    ,缓存度量囗公开属性囗索引列表=('len',)
    ))

双侧展翅树囗相关操作囗囗囗配置囗囗二囗元组囗长度囗囗甲 = 双侧展翅树囗相关操作囗囗囗配置(参数配置=双侧展翅树囗最小参数配置囗囗囗二囗无印, 数据类型配置=双侧展翅树囗数据类型配置囗囗紧致假设囗囗缓存度量囗囗囗标准元组囗囗缓存度量为长度)
双侧展翅树囗相关操作囗囗囗配置囗囗二囗元组囗长度囗囗乙 = 双侧展翅树囗相关操作囗囗囗配置(参数配置=双侧展翅树囗最小参数配置囗囗囗二囗无印, 数据类型配置=数据类型配置囗囗囗元组囗长度)

