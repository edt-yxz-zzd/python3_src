#__all__:goto
#doing
#
#无度量
#    最小值
#        类似heapq:压弹:起讫:单端/双端
#    长度
#    最小值+长度
#    任意...映射
r'''[[[
e ../../python3_src/seed/data_funcs/finger_tree/finger_tree_ops__instances.py


seed.data_funcs.finger_tree.finger_tree_ops__instances
py -m nn_ns.app.debug_cmd   seed.data_funcs.finger_tree.finger_tree_ops__instances -x
py -m nn_ns.app.doctest_cmd seed.data_funcs.finger_tree.finger_tree_ops__instances:__doc__ -ff
py -m nn_ns.app.doctest_cmd seed.data_funcs.finger_tree.finger_tree_ops__instances:__doc__  -ff -v --ndiff
py_adhoc_call   seed.data_funcs.finger_tree.finger_tree_ops__instances   @f



>>> from seed.data_funcs.finger_tree.finger_tree_ops__instances import *
>>> import seed.data_funcs.finger_tree.finger_tree_ops__instances as M


##############################
##############################
##############################
##############################
>>> M._正常丷调试 = True

    `构造树囗
    `迭代元素囗
>>> ops = 匴双侧展翅树囗相关操作囗囗无长度囗囗二三树
>>> 树 = ops.构造树囗('0123456789', 左起丷右起=False)
>>> [*ops.迭代元素囗(树, 左起丷右起=False)]
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
>>> [*ops.迭代元素囗(树, 左起丷右起=True)]
['9', '8', '7', '6', '5', '4', '3', '2', '1', '0']
>>> 树 = ops.构造树囗(iter('0123456789'), 左起丷右起=True)
>>> [*ops.迭代元素囗(树, 左起丷右起=False)]
['9', '8', '7', '6', '5', '4', '3', '2', '1', '0']
>>> [*ops.迭代元素囗(树, 左起丷右起=True)]
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']

#>>> 树 = ops.构造树囗(iter(range(999)), 左起丷右起=False)
#>>> [*ops.迭代元素囗(树, 左起丷右起=False)] == [*range(999)]
#True
#>>> [*ops.迭代元素囗(树, 左起丷右起=True)] == [*range(999)[::-1]]
#True
#>>> 树 = ops.构造树囗(iter(range(999)[::-1]), 左起丷右起=False)
#>>> [*ops.迭代元素囗(树, 左起丷右起=False)] == [*range(999)[::-1]]
#True
#>>> [*ops.迭代元素囗(树, 左起丷右起=True)] == [*range(999)]
#True


    `巜压入元素囗
    `巜弹出魊元素囗
>>> 树 = ops.构造树囗('0123456789', 左起丷右起=False)
>>> 树, m = ops.巜压入元素囗(树, '-', 左端丷右端=False)
>>> [*ops.迭代元素囗(树, 左起丷右起=False)]
['-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
>>> 树, m = ops.巜压入元素囗(树, '+', 左端丷右端=True)
>>> [*ops.迭代元素囗(树, 左起丷右起=False)]
['-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+']
>>> 树, [minus] = ops.巜弹出魊元素囗(树, 左端丷右端=False)
>>> minus
'-'
>>> [*ops.迭代元素囗(树, 左起丷右起=False)]
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+']
>>> 树, [plus] = ops.巜弹出魊元素囗(树, 左端丷右端=True)
>>> plus
'+'
>>> [*ops.迭代元素囗(树, 左起丷右起=False)]
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']

    `是空树囗
    `构造空树囗
    `取端点魊元素囗
>>> 树 = ops.构造空树囗()
>>> ops.是空树囗(树)
True
>>> [*ops.迭代元素囗(树, 左起丷右起=False)]
[]
>>> ops.取端点魊元素囗(树, 左端丷右端=False)
()
>>> 树 = ops.构造树囗('0123456789', 左起丷右起=False)
>>> ops.是空树囗(树)
False
>>> ops.取端点魊元素囗(树, 左端丷右端=False)
('0',)
>>> ops.取端点魊元素囗(树, 左端丷右端=True)
('9',)


    `合并两树囗
>>> 树 = ops.构造树囗('0123456789', 左起丷右起=False)
>>> 树树 = ops.合并两树囗(树, 树)
>>> 树     #doctest: +SKIP
(True, ('0',), (True, (('1', '2'),), (False,), (('3', '4'), ('5', '6'))), ('7', '8', '9'))
>>> 树树     #doctest: +SKIP
(True, ('0',), (True, (('1', '2'),), (True, ((('3', '4'), ('5', '6'), ('7', '8')),), (False,), ((('9', '0'), ('1', '2')),)), (('3', '4'), ('5', '6'))), ('7', '8', '9'))
>>> [*ops.迭代元素囗(树树, 左起丷右起=False)]
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9']

>>> 字母树 = ops.构造树囗('abcdefghijklmnopqrstuvwxyz', 左起丷右起=False)
>>> 树字母树 = ops.合并两树囗(树, 字母树)
>>> 树字母树     #doctest: +SKIP
>>> [*ops.迭代元素囗(树字母树, 左起丷右起=False)]
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']




    `分裂成两树囗
    `定位焦点魊元素囗

    `查询整树属性囗
    `取魊属性索引纟长度囗
>>> ops = 匴双侧展翅树囗相关操作囗囗仅长度囗囗二三树
>>> 树 = ops.构造树囗('0123456789', 左起丷右起=False)

>>> 字母树 = ops.构造树囗('abcdefghijklmnopqrstuvwxyz', 左起丷右起=False)
>>> 树字母树 = ops.合并两树囗(树, 字母树)
>>> [*ops.迭代元素囗(树字母树, 左起丷右起=False)]
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']
>>> 树刂, 字母树刂 = ops.分裂成两树囗(树字母树, 'len', 10, 左起丷右起=False)

>>> [*ops.迭代元素囗(树刂, 左起丷右起=False)]
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']

>>> [*ops.迭代元素囗(字母树刂, 左起丷右起=False)]
['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']













##############################
##############################
##############################
##############################
>>> M._正常丷调试 = False

    `构造树囗
    `迭代元素囗
>>> ops = 匴双侧展翅树囗相关操作囗囗无长度囗囗二三树
>>> 树 = ops.构造树囗('0123456789', 左起丷右起=False)
>>> [*ops.迭代元素囗(树, 左起丷右起=False)]
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
>>> [*ops.迭代元素囗(树, 左起丷右起=True)]
['9', '8', '7', '6', '5', '4', '3', '2', '1', '0']
>>> 树 = ops.构造树囗(iter('0123456789'), 左起丷右起=True)
>>> [*ops.迭代元素囗(树, 左起丷右起=False)]
['9', '8', '7', '6', '5', '4', '3', '2', '1', '0']
>>> [*ops.迭代元素囗(树, 左起丷右起=True)]
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']

#>>> 树 = ops.构造树囗(iter(range(999)), 左起丷右起=False)
#>>> [*ops.迭代元素囗(树, 左起丷右起=False)] == [*range(999)]
#True
#>>> [*ops.迭代元素囗(树, 左起丷右起=True)] == [*range(999)[::-1]]
#True
#>>> 树 = ops.构造树囗(iter(range(999)[::-1]), 左起丷右起=False)
#>>> [*ops.迭代元素囗(树, 左起丷右起=False)] == [*range(999)[::-1]]
#True
#>>> [*ops.迭代元素囗(树, 左起丷右起=True)] == [*range(999)]
#True


    `巜压入元素囗
    `巜弹出魊元素囗
>>> 树 = ops.构造树囗('0123456789', 左起丷右起=False)
>>> 树, m = ops.巜压入元素囗(树, '-', 左端丷右端=False)
>>> [*ops.迭代元素囗(树, 左起丷右起=False)]
['-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
>>> 树, m = ops.巜压入元素囗(树, '+', 左端丷右端=True)
>>> [*ops.迭代元素囗(树, 左起丷右起=False)]
['-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+']
>>> 树, [minus] = ops.巜弹出魊元素囗(树, 左端丷右端=False)
>>> minus
'-'
>>> [*ops.迭代元素囗(树, 左起丷右起=False)]
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+']
>>> 树, [plus] = ops.巜弹出魊元素囗(树, 左端丷右端=True)
>>> plus
'+'
>>> [*ops.迭代元素囗(树, 左起丷右起=False)]
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']

    `是空树囗
    `构造空树囗
    `取端点魊元素囗
>>> 树 = ops.构造空树囗()
>>> ops.是空树囗(树)
True
>>> [*ops.迭代元素囗(树, 左起丷右起=False)]
[]
>>> ops.取端点魊元素囗(树, 左端丷右端=False)
()
>>> 树 = ops.构造树囗('0123456789', 左起丷右起=False)
>>> ops.是空树囗(树)
False
>>> ops.取端点魊元素囗(树, 左端丷右端=False)
('0',)
>>> ops.取端点魊元素囗(树, 左端丷右端=True)
('9',)


    `合并两树囗
>>> 树 = ops.构造树囗('0123456789', 左起丷右起=False)
>>> 树树 = ops.合并两树囗(树, 树)
>>> 树
(True, ('0',), (True, (('1', '2'),), (False,), (('3', '4'), ('5', '6'))), ('7', '8', '9'))
>>> 树树
(True, ('0',), (True, (('1', '2'),), (True, ((('3', '4'), ('5', '6'), ('7', '8')),), (False,), ((('9', '0'), ('1', '2')),)), (('3', '4'), ('5', '6'))), ('7', '8', '9'))
>>> [*ops.迭代元素囗(树树, 左起丷右起=False)]
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9']

>>> 字母树 = ops.构造树囗('abcdefghijklmnopqrstuvwxyz', 左起丷右起=False)
>>> 树字母树 = ops.合并两树囗(树, 字母树)
>>> 树字母树
(True, ('0',), (True, (('1', '2'),), (True, ((('3', '4'), ('5', '6'), ('7', '8')),), (False, ((('9', 'a'), ('b', 'c')), (('d', 'e'), ('f', 'g')))), ((('h', 'i'), ('j', 'k')), (('l', 'm'), ('n', 'o')))), (('p', 'q'), ('r', 's'), ('t', 'u'), ('v', 'w'))), ('x', 'y', 'z'))
>>> [*ops.迭代元素囗(树字母树, 左起丷右起=False)]
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']



>>> ops.取魊属性索引纟长度囗(树)
()

    `分裂成两树囗
>>> ops = 匴双侧展翅树囗相关操作囗囗仅长度囗囗二三树
>>> 树 = ops.构造树囗('0123456789', 左起丷右起=False)

>>> 字母树 = ops.构造树囗('abcdefghijklmnopqrstuvwxyz', 左起丷右起=False)
>>> 树字母树 = ops.合并两树囗(树, 字母树)
>>> [*ops.迭代元素囗(树字母树, 左起丷右起=False)]
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']
>>> 树刂, 字母树刂 = ops.分裂成两树囗(树字母树, 'len', 10, 左起丷右起=False)
>>> [*ops.迭代元素囗(树刂, 左起丷右起=False)]
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
>>> [*ops.迭代元素囗(字母树刂, 左起丷右起=False)]
['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']



>>> 树刂, 字母树刂 = ops.分裂成两树囗(树字母树, 'len', -26, 左起丷右起=False)
>>> [*ops.迭代元素囗(树刂, 左起丷右起=False)]
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
>>> [*ops.迭代元素囗(字母树刂, 左起丷右起=False)]
['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']

>>> 字母树刂, 树刂 = ops.分裂成两树囗(树字母树, 'len', 26, 左起丷右起=True)
>>> [*ops.迭代元素囗(树刂, 左起丷右起=False)]
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
>>> [*ops.迭代元素囗(字母树刂, 左起丷右起=False)]
['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']

>>> 字母树刂, 树刂 = ops.分裂成两树囗(树字母树, 'len', -10, 左起丷右起=True)
>>> [*ops.迭代元素囗(树刂, 左起丷右起=False)]
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
>>> [*ops.迭代元素囗(字母树刂, 左起丷右起=False)]
['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']



    `定位焦点魊元素囗
>>> 累计值, 魊元素 = ops.定位焦点魊元素囗(树, 'len', 0, 左起丷右起=False)
>>> ops.定位焦点魊元素囗(树, 'len', 0, 左起丷右起=False)
(0, ('0',))
>>> ops.定位焦点魊元素囗(树, 'len', 5, 左起丷右起=False)
(5, ('5',))
>>> ops.定位焦点魊元素囗(树, 'len', 0, 左起丷右起=True)
(0, ('9',))
>>> ops.定位焦点魊元素囗(树, 'len', 5, 左起丷右起=True)
(5, ('4',))
>>> ops.定位焦点魊元素囗(树, 'len', -5, 左起丷右起=True)
(5, ('4',))



    `查询整树属性囗
    `取魊属性索引纟长度囗
>>> ops.查询整树属性囗(树, 'len')
10
>>> ops.取魊属性索引纟长度囗(树)
('len',)

##############################
    `取属性索引纟长度囗
    取魊属性索引纟长度囗
    取长度囗
    取魊元素囗
    取子树囗
>>> ops.取属性索引纟长度囗(树)
'len'
>>> ops.取魊属性索引纟长度囗(树)
('len',)
>>> ops.取长度囗(树)
10
>>> [ops.取魊元素囗(树, i) for i in range(0, 11)]
[('0',), ('1',), ('2',), ('3',), ('4',), ('5',), ('6',), ('7',), ('8',), ('9',), ()]
>>> [ops.取魊元素囗(树, i) for i in range(-11, 0)]
[(), ('0',), ('1',), ('2',), ('3',), ('4',), ('5',), ('6',), ('7',), ('8',), ('9',)]
>>> ops.取魊元素囗(树, 10)
()
>>> ops.取魊元素囗(树, -11)
()
>>> ops.取子树囗(树, None, None) is 树
True
>>> 子树 = ops.取子树囗(树, 10, None)
>>> ops.是空树囗(子树)
True
>>> [*ops.迭代元素囗(子树, 左起丷右起=False)]
[]
>>> 子树 = ops.取子树囗(树, 9, None)
>>> ops.是空树囗(子树)
False
>>> [*ops.迭代元素囗(子树, 左起丷右起=False)]
['9']
>>> [*ops.迭代元素囗(ops.取子树囗(树, 6, None), 左起丷右起=False)]
['6', '7', '8', '9']
>>> [*ops.迭代元素囗(ops.取子树囗(树, -4, None), 左起丷右起=False)]
['6', '7', '8', '9']
>>> [*ops.迭代元素囗(ops.取子树囗(树, None, 6), 左起丷右起=False)]
['0', '1', '2', '3', '4', '5']
>>> [*ops.迭代元素囗(ops.取子树囗(树, None, -4), 左起丷右起=False)]
['0', '1', '2', '3', '4', '5']
>>> [*ops.迭代元素囗(ops.取子树囗(树, -6, 6), 左起丷右起=False)]
['4', '5']
>>> [*ops.迭代元素囗(ops.取子树囗(树, 4, -4), 左起丷右起=False)]
['4', '5']
>>> [*ops.迭代元素囗(ops.取子树囗(树, 6, 4), 左起丷右起=False)]
[]
>>> [*ops.迭代元素囗(ops.取子树囗(树, -4, -6), 左起丷右起=False)]
[]




##############################
##############################
##############################
##############################
>>> M._正常丷调试 = False

    `构造树囗
    `迭代元素囗
>>> ops = 匴双侧展翅树囗相关操作囗囗丮长度丶散列值厈囗囗二三树
>>> 树 = ops.构造树囗('0123456789', 左起丷右起=False)
>>> [*ops.迭代元素囗(树, 左起丷右起=False)]
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
>>> [*ops.迭代元素囗(树, 左起丷右起=True)]
['9', '8', '7', '6', '5', '4', '3', '2', '1', '0']
>>> 树 = ops.构造树囗(iter('0123456789'), 左起丷右起=True)
>>> [*ops.迭代元素囗(树, 左起丷右起=False)]
['9', '8', '7', '6', '5', '4', '3', '2', '1', '0']
>>> [*ops.迭代元素囗(树, 左起丷右起=True)]
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']

>>> 树 = ops.构造树囗(iter(range(999)), 左起丷右起=False)
>>> [*ops.迭代元素囗(树, 左起丷右起=False)] == [*range(999)]
True
>>> [*ops.迭代元素囗(树, 左起丷右起=True)] == [*range(999)[::-1]]
True
>>> 树 = ops.构造树囗(iter(range(999)[::-1]), 左起丷右起=False)
>>> [*ops.迭代元素囗(树, 左起丷右起=False)] == [*range(999)[::-1]]
True
>>> [*ops.迭代元素囗(树, 左起丷右起=True)] == [*range(999)]
True


    `巜压入元素囗
    `巜弹出魊元素囗
>>> 树 = ops.构造树囗('0123456789', 左起丷右起=False)
>>> 树, m = ops.巜压入元素囗(树, '-', 左端丷右端=False)
>>> [*ops.迭代元素囗(树, 左起丷右起=False)]
['-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
>>> 树, m = ops.巜压入元素囗(树, '+', 左端丷右端=True)
>>> [*ops.迭代元素囗(树, 左起丷右起=False)]
['-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+']
>>> 树, [minus] = ops.巜弹出魊元素囗(树, 左端丷右端=False)
>>> minus
'-'
>>> [*ops.迭代元素囗(树, 左起丷右起=False)]
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+']
>>> 树, [plus] = ops.巜弹出魊元素囗(树, 左端丷右端=True)
>>> plus
'+'
>>> [*ops.迭代元素囗(树, 左起丷右起=False)]
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']

    `是空树囗
    `构造空树囗
    `取端点魊元素囗
>>> 树 = ops.构造空树囗()
>>> ops.是空树囗(树)
True
>>> [*ops.迭代元素囗(树, 左起丷右起=False)]
[]
>>> ops.取端点魊元素囗(树, 左端丷右端=False)
()
>>> 树 = ops.构造树囗('0123456789', 左起丷右起=False)
>>> ops.是空树囗(树)
False
>>> ops.取端点魊元素囗(树, 左端丷右端=False)
('0',)
>>> ops.取端点魊元素囗(树, 左端丷右端=True)
('9',)


    `合并两树囗
>>> 树 = ops.构造树囗('0123456789', 左起丷右起=False)
>>> 树树 = ops.合并两树囗(树, 树)
>>> 树     #doctest: +SKIP
>>> 树树     #doctest: +SKIP
>>> [*ops.迭代元素囗(树树, 左起丷右起=False)]
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9']

>>> 字母树 = ops.构造树囗('abcdefghijklmnopqrstuvwxyz', 左起丷右起=False)
>>> 树字母树 = ops.合并两树囗(树, 字母树)
>>> 树字母树     #doctest: +SKIP
>>> [*ops.迭代元素囗(树字母树, 左起丷右起=False)]
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']




    `分裂成两树囗
>>> 树 = ops.构造树囗('0123456789', 左起丷右起=False)

>>> 字母树 = ops.构造树囗('abcdefghijklmnopqrstuvwxyz', 左起丷右起=False)
>>> 树字母树 = ops.合并两树囗(树, 字母树)
>>> [*ops.迭代元素囗(树字母树, 左起丷右起=False)]
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']
>>> 树刂, 字母树刂 = ops.分裂成两树囗(树字母树, 'len', 10, 左起丷右起=False)
>>> [*ops.迭代元素囗(树刂, 左起丷右起=False)]
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
>>> [*ops.迭代元素囗(字母树刂, 左起丷右起=False)]
['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']



>>> 树刂, 字母树刂 = ops.分裂成两树囗(树字母树, 'len', -26, 左起丷右起=False)
>>> [*ops.迭代元素囗(树刂, 左起丷右起=False)]
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
>>> [*ops.迭代元素囗(字母树刂, 左起丷右起=False)]
['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']

>>> 字母树刂, 树刂 = ops.分裂成两树囗(树字母树, 'len', 26, 左起丷右起=True)
>>> [*ops.迭代元素囗(树刂, 左起丷右起=False)]
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
>>> [*ops.迭代元素囗(字母树刂, 左起丷右起=False)]
['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']

>>> 字母树刂, 树刂 = ops.分裂成两树囗(树字母树, 'len', -10, 左起丷右起=True)
>>> [*ops.迭代元素囗(树刂, 左起丷右起=False)]
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
>>> [*ops.迭代元素囗(字母树刂, 左起丷右起=False)]
['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']



    `定位焦点魊元素囗
>>> 累计值, 魊元素 = ops.定位焦点魊元素囗(树, 'len', 0, 左起丷右起=False)
>>> ops.定位焦点魊元素囗(树, 'len', 0, 左起丷右起=False)
(0, ('0',))
>>> ops.定位焦点魊元素囗(树, 'len', 5, 左起丷右起=False)
(5, ('5',))
>>> ops.定位焦点魊元素囗(树, 'len', 0, 左起丷右起=True)
(0, ('9',))
>>> ops.定位焦点魊元素囗(树, 'len', 5, 左起丷右起=True)
(5, ('4',))
>>> ops.定位焦点魊元素囗(树, 'len', -5, 左起丷右起=True)
(5, ('4',))



    `查询整树属性囗
    `取魊属性索引纟长度囗
>>> ops.查询整树属性囗(树, 'len')
10
>>> ops.取魊属性索引纟长度囗(树)
('len',)

##############################
    `取属性索引纟长度囗
    取魊属性索引纟长度囗
    取长度囗
    取魊元素囗
    取子树囗
>>> ops.取属性索引纟长度囗(树)
'len'
>>> ops.取魊属性索引纟长度囗(树)
('len',)
>>> ops.取长度囗(树)
10
>>> [ops.取魊元素囗(树, i) for i in range(0, 11)]
[('0',), ('1',), ('2',), ('3',), ('4',), ('5',), ('6',), ('7',), ('8',), ('9',), ()]
>>> [ops.取魊元素囗(树, i) for i in range(-11, 0)]
[(), ('0',), ('1',), ('2',), ('3',), ('4',), ('5',), ('6',), ('7',), ('8',), ('9',)]
>>> ops.取魊元素囗(树, 10)
()
>>> ops.取魊元素囗(树, -11)
()


>>> ops.取子树囗(树, None, None) is 树
True
>>> 子树 = ops.取子树囗(树, 10, None)
>>> ops.是空树囗(子树)
True
>>> [*ops.迭代元素囗(子树, 左起丷右起=False)]
[]
>>> 子树 = ops.取子树囗(树, 9, None)
>>> ops.是空树囗(子树)
False
>>> [*ops.迭代元素囗(子树, 左起丷右起=False)]
['9']
>>> [*ops.迭代元素囗(ops.取子树囗(树, 6, None), 左起丷右起=False)]
['6', '7', '8', '9']
>>> [*ops.迭代元素囗(ops.取子树囗(树, -4, None), 左起丷右起=False)]
['6', '7', '8', '9']
>>> [*ops.迭代元素囗(ops.取子树囗(树, None, 6), 左起丷右起=False)]
['0', '1', '2', '3', '4', '5']
>>> [*ops.迭代元素囗(ops.取子树囗(树, None, -4), 左起丷右起=False)]
['0', '1', '2', '3', '4', '5']
>>> [*ops.迭代元素囗(ops.取子树囗(树, -6, 6), 左起丷右起=False)]
['4', '5']
>>> [*ops.迭代元素囗(ops.取子树囗(树, 4, -4), 左起丷右起=False)]
['4', '5']
>>> [*ops.迭代元素囗(ops.取子树囗(树, 6, 4), 左起丷右起=False)]
[]
>>> [*ops.迭代元素囗(ops.取子树囗(树, -4, -6), 左起丷右起=False)]
[]

>>> 树 = ops.构造树囗(iter(range(999)), 左起丷右起=False)
>>> [ops.取魊元素囗(树, i) for i in range(9)]
[(0,), (1,), (2,), (3,), (4,), (5,), (6,), (7,), (8,)]
>>> [ops.取魊元素囗(树, i) for i in range(9)] == [(i,) for i in range(9)]
True
>>> [ops.取魊元素囗(树, i) for i in range(99)] == [(i,) for i in range(99)]
True
>>> [ops.取魊元素囗(树, i) for i in range(999)] == [(i,) for i in range(999)]
True


>>> ops.查询整树属性囗(树, 'len')
999
>>> ops.查询整树属性囗(树, 'hash')
886366917690088668
>>> ops.取长度囗(树)
999
>>> ops.取散列值囗(树)
886366917690088668

    等价冃列表囗
>>> ops.等价冃列表囗(树, 树)
True
>>> ops.等价冃列表囗(树, 字母树)
False
>>> 树刂 = ops.构造树囗(ops.迭代元素囗(树, 左起丷右起=True), 左起丷右起=True)
>>> ops.等价冃列表囗(树, 树刂)
True
>>> 反向树 = ops.构造树囗(ops.迭代元素囗(树, 左起丷右起=False), 左起丷右起=True)
>>> ops.等价冃列表囗(树, 反向树)
False

    小于冃列表囗
>>> ops.小于冃列表囗(树, 树)
False
>>> ops.小于冃列表囗(反向树, 树)
False
>>> ops.小于冃列表囗(树, 反向树)
True


todo:属性索引:正全序/无序/逆全序
    太麻烦了，还是算了


#]]]'''
__all__ = r'''
匴双侧展翅树囗相关操作囗囗无长度囗囗二三树
匴双侧展翅树囗相关操作囗囗仅长度囗囗二三树
匴双侧展翅树囗相关操作囗囗丮长度丶散列值厈囗囗二三树





乸双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组囗囗无缓存度量
    匴双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组冖冖实例冫无缓存度量

乸双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组囗囗缓存度量仅长度
    匴双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组冖冖实例冫长度

魖双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组囗囗缓存度量为词典映射
    乸双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组囗囗缓存度量为词典映射
        匴双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组冖冖实例冫长度丶散列值




'''.split()#'''
__all__


from seed.data_funcs.finger_tree.measurement import 乸词典映射冃缓存度量, 乸词典映射冃缓存度量囗囗长度丶散列值, 加法零元囗囗长度丶散列值
from seed.data_funcs.finger_tree.finger_tree_ops import 乸双侧展翅树囗相关操作囗囗无长度
from seed.data_funcs.finger_tree.finger_tree_ops import 乸双侧展翅树囗相关操作
from seed.data_funcs.finger_tree.finger_tree_common import 错误囗囗长度囗囗翅膀, 错误囗囗长度囗囗更深节点, 错误囗囗长度囗囗光杆树

from seed.data_funcs.finger_tree.finger_tree_common import 乸双侧展翅树囗参数配置囗囗紧致假设, 匞双侧展翅树囗最小参数配置囗囗囗二囗对半
from seed.data_funcs.finger_tree.finger_tree__external_packed_config import 魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程
from seed.data_funcs.finger_tree.finger_tree__physical_layer import 魖属性界面
from seed.data_funcs.finger_tree.finger_tree__physical_layer import 魖双侧展翅树囗数据类型配置囗囗显式参数列举式囗囗面向适配底层数据类型囗囗囗囗固化方法
from seed.data_funcs.finger_tree.finger_tree__EPC5PL import 魖双侧展翅树囗数据类型配置囗囗囗囗粘合囗囗物理适配层囗囗外参一致层


from seed.data_funcs.finger_tree.finger_tree__EPC__default import 魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程囗囗囗囗可优化方法缺省具象化

from functools import reduce
from itertools import islice

from seed.abc.abc__ver1 import abstractmethod, override, ABC, ABC__no_slots
from seed.tiny import mk_tuple, null_tuple

from seed.tiny import print_err# mk_fprint, mk_assert_eq_f, expectError



######################
######################
######################
_正常丷调试 = False
######################
######################
######################
__all__
class _魖双侧展翅树囗数据类型配置囗囗巨型参数无优化(魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程囗囗囗囗可优化方法缺省具象化, 魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程, 魖双侧展翅树囗数据类型配置囗囗囗囗粘合囗囗物理适配层囗囗外参一致层, 魖双侧展翅树囗数据类型配置囗囗显式参数列举式囗囗面向适配底层数据类型囗囗囗囗固化方法, 魖属性界面):
    r'''[[[
===
无优化:最好使用2_3_finger_tree配置，即 [更深节点许可长度集合=={2..=3}]

===
设计规范囗囗标准元组具现版:here
    _魖双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组:goto
===
specification
设计规范<标准元组具现版>
===
[无 缓存度量]:
    则 下面『缓存度量』项 可移除
[缓存度量 仅有 长度]:
    + 则:节点<(深度<=1)> 无需缓存度量
        * 节点<0>/元素封包节点
        * 节点<1>/更深节点<0>
    + 则:翅膀<0> 无需缓存度量


===
[元素封包节点 =[def]= (缓存度量, 元素)]
[更深节点 =[def]= (缓存度量, 节点...<左起丷右起:=False>)]
[光杆树 =[def]= (False, 缓存度量, 节点...<左起丷右起:=False>)]
[翅膀<左翼丷右翼> =[def]= (缓存度量, 节点...<左起丷右起:=not 左翼丷右翼>)]
[根深树 =[def]= (True, 缓存度量, 左翼, 更深树, 右翼)]
    #开头的 真值 <<== 区分树形态囗()具现需求
    #空间开销不大，因为 每棵 双侧展翅树 包含的 光杆树 只有一棵，根深树 只出现在 中心，即只有 O(log(N))棵
    #   其实 可以 ++外参:高度，这样就节省了一点空间，但是 返回值 也要 加上 新高度，有点麻烦




===
abstract_methods:
`取囗缓存度量囗公开属性囗加法零元囗
`取囗缓存度量囗公开属性囗索引列表囗
`底层接口冖冖区分树形态囗
`底层接口冖冖取囗缓存度量囗公开属性囗
`底层接口冖冖取囗缓存度量囗囗元素封包节点囗
`底层接口冖冖取囗缓存度量囗囗光杆树囗
`底层接口冖冖取囗缓存度量囗囗更深节点囗
`底层接口冖冖取囗缓存度量囗囗根深树囗
`底层接口冖冖取囗缓存度量囗囗翅膀囗囗绝对定位囗
`底层接口冖冖取囗长度囗囗光杆树囗
`底层接口冖冖取囗长度囗囗更深节点囗
`底层接口冖冖取囗长度囗囗翅膀囗囗绝对定位囗
`底层接口冖冖拆包囗元素封包节点囗
`底层接口冖冖拆包囗根深树囗囗绝对定位囗
`底层接口冖冖是空树囗囗光杆树囗
`底层接口冖冖构造囗元素封包节点囗
`底层接口冖冖构造囗光杆树囗
`底层接口冖冖构造囗更深节点囗
`底层接口冖冖构造囗根深树囗囗绝对定位囗
`底层接口冖冖构造囗翅膀囗囗绝对定位囗
`底层接口冖冖迭代囗子节点囗囗光杆树囗
`底层接口冖冖迭代囗子节点囗囗更深节点囗
`底层接口冖冖迭代囗子节点囗囗翅膀囗囗绝对定位囗

    #]]]'''#'''
    __slots__ = ()

    ######################
    #树基础数据类型界面囗囗缓存度量
    @abstractmethod
    def 加囗囗缓存度量囗囗绝对定位囗(sf, 左囗缓存度量, 右囗缓存度量, /):
        '-> 缓存度量 #满足 结合律 #不一定满足 交换律'
    @abstractmethod
    def 取囗加法零元囗囗缓存度量囗(sf, /):
        '-> 缓存度量'
    @abstractmethod
    def 底层接口冖冖求囗缓存度量囗囗元素囗(sf, 元素, /):
        '-> 缓存度量'
    ######################
    ######################
    @abstractmethod
    def 底层接口冖冖构造囗元素封包节点囗囗已知缓存度量囗(sf, 元素, /, *, 缓存度量):
        '-> 元素封包节点/节点<0>/封包<元素> #用于 缓存 度量，否则 无需 封包'
    @abstractmethod
    def 底层接口冖冖构造囗更深节点囗囗序列左起囗囗已知缓存度量囗(sf, 节点列表, /, *, 更深节点最小许可长度, 更深节点最大许可长度, 深度, 缓存度量):
        '-> 节点<深度+1>/更深节点<深度> #可能需要 缓存 度量'
    @abstractmethod
    def 底层接口冖冖构造囗光杆树囗囗序列左起囗囗已知缓存度量囗(sf, 节点列表, /, *, 光杆树最大许可长度, 深度, 缓存度量):
        '-> 光杆树<深度> #可能需要 缓存 度量'
    @abstractmethod
    def 底层接口冖冖构造囗翅膀囗囗绝对定位囗囗序列左起囗囗已知缓存度量囗(sf, 节点列表, /, *, 左翼丷右翼, 翅膀最大许可长度, 翅膀最小许可长度, 深度, 缓存度量):
        '节点列表<左起丷右起,深度> -> 翅膀<左翼丷右翼,深度> #区分左右:栈开口方向不同！#可能需要 缓存 度量'
    @abstractmethod
    def 底层接口冖冖构造囗根深树囗囗绝对定位囗囗序列左起囗囗已知缓存度量囗(sf, 左翼, 更深树, 右翼, /, *, 深度, 缓存度量):
        '-> 根深树<深度> #可能需要 缓存 度量'

    ######################
    #树基础数据类型界面
    @override
    def 底层接口冖冖构造囗元素封包节点囗(sf, 元素, /):
        '-> 元素封包节点/节点<0>/封包<元素> #用于 缓存 度量，否则 无需 封包'
        缓存度量 = sf.底层接口冖冖求囗缓存度量囗囗元素囗(元素)
        return sf.底层接口冖冖构造囗元素封包节点囗囗已知缓存度量囗(元素, 缓存度量=缓存度量)
    @override
    def 底层接口冖冖构造囗更深节点囗(sf, 节点序列, /, *, 左起丷右起, 更深节点最小许可长度, 更深节点最大许可长度, 深度):
        '-> 节点<深度+1>/更深节点<深度> #可能需要 缓存 度量'
        节点列表 = _构造囗元组囗(左起丷右起, 节点序列)
        if not 更深节点最小许可长度 <= len(节点列表) <= 更深节点最大许可长度:raise 错误囗囗长度囗囗更深节点
        缓存度量 = _累积囗缓存度量囗囗节点囗(sf, 节点列表, 深度=深度)
        return sf.底层接口冖冖构造囗更深节点囗囗序列左起囗囗已知缓存度量囗(节点列表, 深度=深度, 缓存度量=缓存度量, 更深节点最小许可长度=更深节点最小许可长度, 更深节点最大许可长度=更深节点最大许可长度)
    @override
    def 底层接口冖冖构造囗光杆树囗(sf, 节点序列, /, *, 左起丷右起, 光杆树最大许可长度, 深度):
        '-> 光杆树<深度> #可能需要 缓存 度量'
        节点列表 = _构造囗元组囗(左起丷右起, 节点序列)
        if not 0 <= len(节点列表) <= 光杆树最大许可长度:raise 错误囗囗长度囗囗光杆树
        缓存度量 = _累积囗缓存度量囗囗节点囗(sf, 节点列表, 深度=深度)
        return sf.底层接口冖冖构造囗光杆树囗囗序列左起囗囗已知缓存度量囗(节点列表, 光杆树最大许可长度=光杆树最大许可长度, 深度=深度, 缓存度量=缓存度量)
    @override
    def 底层接口冖冖构造囗翅膀囗囗绝对定位囗(sf, 节点序列, /, *, 左起丷右起, 左翼丷右翼, 翅膀最大许可长度, 翅膀最小许可长度, 深度):
        '节点序列<左起丷右起,深度> -> 翅膀<左翼丷右翼,深度> #区分左右:栈开口方向不同！#可能需要 缓存 度量'
        节点列表 = _构造囗元组囗(左起丷右起, 节点序列)
        if not 翅膀最小许可长度 <= len(节点列表) <= 翅膀最大许可长度:raise 错误囗囗长度囗囗翅膀
        缓存度量 = _累积囗缓存度量囗囗节点囗(sf, 节点列表, 深度=深度)
        return sf.底层接口冖冖构造囗翅膀囗囗绝对定位囗囗序列左起囗囗已知缓存度量囗(节点列表, 左翼丷右翼=左翼丷右翼, 深度=深度, 缓存度量=缓存度量, 翅膀最小许可长度=翅膀最小许可长度, 翅膀最大许可长度=翅膀最大许可长度)
    @override
    def 底层接口冖冖构造囗根深树囗囗绝对定位囗(sf, 左翼, 更深树, 右翼, /, *, 深度):
        '-> 根深树<深度> #可能需要 缓存 度量'
        缓存度量 = _累积囗缓存度量囗(sf,
            [sf.底层接口冖冖取囗缓存度量囗囗翅膀囗囗绝对定位囗(左翼, 左翼丷右翼=False, 深度=深度)
            ,sf.底层接口冖冖取囗缓存度量囗囗双侧展翅树囗(更深树, 深度=深度+1)
            ,sf.底层接口冖冖取囗缓存度量囗囗翅膀囗囗绝对定位囗(右翼, 左翼丷右翼=True, 深度=深度)
            ])
        return sf.底层接口冖冖构造囗根深树囗囗绝对定位囗囗序列左起囗囗已知缓存度量囗(左翼, 更深树, 右翼, 深度=深度, 缓存度量=缓存度量)
def _累积囗缓存度量囗囗节点囗(sf, 节点序列, /, *, 深度):
    取囗 = sf.底层接口冖冖取囗缓存度量囗囗节点囗
    右囗缓存度量序列 = (取囗(节点, 深度=深度) for 节点 in 节点序列)
    return _累积囗缓存度量囗(sf, 右囗缓存度量序列)
def _累积囗缓存度量囗(sf, 右囗缓存度量序列, /):
    加囗 = sf.加囗囗缓存度量囗囗绝对定位囗
    左囗缓存度量 = sf.取囗加法零元囗囗缓存度量囗()
    return _累积囗缓存度量囗囗基础囗(加囗, 左囗缓存度量, 右囗缓存度量序列)
def _累积囗缓存度量囗囗基础囗(加囗, 左囗缓存度量, 右囗缓存度量序列, /):
    #if 0b0001:print_err(加囗, 左囗缓存度量, 右囗缓存度量序列)
    return reduce(加囗, 右囗缓存度量序列, 左囗缓存度量)
def _构造囗元组囗(左起丷右起, 节点序列, /):
    if 左起丷右起:
        try:
            节点序列 = reversed(节点序列)
        except TypeError:
            节点列表 = [*节点序列]
            节点列表.reverse()
            节点序列 = 节点列表
            pass
        pass
    return tuple(节点序列)
#end-class _魖双侧展翅树囗数据类型配置囗囗巨型参数无优化




_正常丷调试
__all__
class _乸元素封包节点:
    # _乸元素封包节点(元素封包节点, 缓存度量)
    # 元素封包节点.确认囗元素封包节点囗()
    def __init__(sf, 元素封包节点, 缓存度量, /):
        sf.__dict__.update(locals())
        del sf.__dict__['sf']
    def 确认囗元素封包节点囗(sf, /):
        return sf.元素封包节点
    def 确认囗节点囗(sf, 深度, /):
        assert 深度 == 0
        return sf.元素封包节点
class _乸更深节点:
    # _乸更深节点(更深节点, 更深节点最小许可长度, 更深节点最大许可长度, 深度, 缓存度量)
    # 更深节点.确认囗更深节点囗(更深节点最小许可长度, 更深节点最大许可长度, 深度)
    def __init__(sf, 更深节点, 更深节点最小许可长度, 更深节点最大许可长度, 深度, 缓存度量, /):
        sf.__dict__.update(locals())
        del sf.__dict__['sf']
    def 确认囗更深节点囗(sf, 更深节点最小许可长度, 更深节点最大许可长度, 深度, /):
        d = dict(locals())
        del d['sf']
        q = dict(sf.__dict__)
        del q['更深节点']
        del q['缓存度量']
        assert q == d
        return sf.更深节点
    def 确认囗更深节点囗囗缺囗(sf, 深度, /):
        assert 深度 >= 0
        assert sf.深度 == 深度 >= 0
        return sf.更深节点
    def 确认囗节点囗(sf, 深度, /):
        assert 深度 > 0
        assert sf.深度+1 == 深度 > 0
        return sf.更深节点
class _乸光杆树:
    # _乸光杆树(光杆树, 光杆树最大许可长度, 深度, 缓存度量)
    # 光杆树.确认囗光杆树囗(光杆树最大许可长度, 深度)
    def __init__(sf, 光杆树, 光杆树最大许可长度, 深度, 缓存度量, /):
        sf.__dict__.update(locals())
        del sf.__dict__['sf']
    def 确认囗光杆树囗(sf, 光杆树最大许可长度, 深度, /):
        d = dict(locals())
        del d['sf']
        q = dict(sf.__dict__)
        del q['光杆树']
        del q['缓存度量']
        assert q == d
        return sf.光杆树
    def 确认囗光杆树囗囗缺囗(sf, 深度, /):
        assert sf.深度 == 深度
        return sf.光杆树
    def 确认囗双侧展翅树囗(sf, 深度, /):
        assert sf.深度 == 深度
        return sf.光杆树
class _乸翅膀:
    # _乸翅膀(翅膀, 左翼丷右翼, 翅膀最小许可长度, 翅膀最大许可长度, 深度, 缓存度量)
    # 翅膀.确认囗翅膀囗(左翼丷右翼, 翅膀最小许可长度, 翅膀最大许可长度, 深度)
    def __init__(sf, 翅膀, 左翼丷右翼, 翅膀最小许可长度, 翅膀最大许可长度, 深度, 缓存度量, /):
        sf.__dict__.update(locals())
        del sf.__dict__['sf']
    def 确认囗翅膀囗(sf, 左翼丷右翼, 翅膀最小许可长度, 翅膀最大许可长度, 深度, /):
        d = dict(locals())
        del d['sf']
        q = dict(sf.__dict__)
        del q['翅膀']
        del q['缓存度量']
        assert q == d
        return sf.翅膀
    def 确认囗翅膀囗囗缺囗(sf, 左翼丷右翼, 深度, /):
        assert sf.深度 == 深度
        assert sf.左翼丷右翼 is 左翼丷右翼
        return sf.翅膀
class _乸根深树:
    # _乸根深树(根深树, 左翼, 更深树, 右翼, 深度, 缓存度量)
    # 根深树.确认囗根深树囗(深度)
    def __init__(sf, 根深树, 左翼, 更深树, 右翼, 深度, 缓存度量, /):
        sf.__dict__.update(locals())
        del sf.__dict__['sf']
    def 确认囗根深树囗(sf, 深度, /):
        assert sf.深度 == 深度
        return sf.根深树
    def 确认囗双侧展翅树囗(sf, 深度, /):
        assert sf.深度 == 深度
        return sf.根深树



_正常丷调试
__all__
class _魖双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组(_魖双侧展翅树囗数据类型配置囗囗巨型参数无优化):
    '设计规范囗囗标准元组具现版:goto'
    __slots__ = ()
    ######################
    #树基础数据类型界面囗囗缓存度量囗囗标准元组
    @abstractmethod
    def 有无囗缓存度量囗囗元素封包节点囗(sf, /):
        '-> 无丷有/bool'
    @abstractmethod
    def 有无囗缓存度量囗囗更深节点囗(sf, /, *, 深度):
        '-> 无丷有/bool'
    @abstractmethod
    def 有无囗缓存度量囗囗翅膀囗囗绝对定位囗(sf, /, *, 左翼丷右翼, 深度):
        '-> 无丷有/bool'
    @abstractmethod
    def 有无囗缓存度量囗囗光杆树囗(sf, /, *, 深度):
        '-> 无丷有/bool'
    @abstractmethod
    def 有无囗缓存度量囗囗根深树囗(sf, /, *, 深度):
        '-> 无丷有/bool'

    ######################
    ######################
    #树基础数据类型界面囗囗缓存度量
    @override
    def 底层接口冖冖构造囗元素封包节点囗囗已知缓存度量囗(sf, 元素, /, *, 缓存度量):
        '-> 元素封包节点/节点<0>/封包<元素> #用于 缓存 度量，否则 无需 封包'
        if sf.有无囗缓存度量囗囗元素封包节点囗():
            元素封包节点 = 缓存度量, 元素
        else:
            元素封包节点 = 元素
        if _正常丷调试:
            元素封包节点 = _乸元素封包节点(元素封包节点, 缓存度量)
            元素封包节点.元素封包节点
            元素封包节点.确认囗元素封包节点囗()
        return 元素封包节点
    @override
    def 底层接口冖冖构造囗更深节点囗囗序列左起囗囗已知缓存度量囗(sf, 节点列表, /, *, 更深节点最小许可长度, 更深节点最大许可长度, 深度, 缓存度量):
        '-> 节点<深度+1>/更深节点<深度> #可能需要 缓存 度量'
        # 节点列表 = 节点列表[::-1]
        if sf.有无囗缓存度量囗囗更深节点囗(深度=深度):
            更深节点 = (缓存度量, *节点列表)
        else:
            更深节点 = mk_tuple(节点列表)
        if _正常丷调试:
            更深节点 = _乸更深节点(更深节点, 更深节点最小许可长度, 更深节点最大许可长度, 深度, 缓存度量)
            更深节点.更深节点
            更深节点.确认囗更深节点囗(更深节点最小许可长度, 更深节点最大许可长度, 深度)
        return 更深节点
    @override
    def 底层接口冖冖构造囗光杆树囗囗序列左起囗囗已知缓存度量囗(sf, 节点列表, /, *, 光杆树最大许可长度, 深度, 缓存度量):
        '-> 光杆树<深度> #可能需要 缓存 度量'
        # 节点列表 = 节点列表[::-1]
        if sf.有无囗缓存度量囗囗光杆树囗(深度=深度):
            光杆树 = (False, 缓存度量, *节点列表)
        else:
            光杆树 = (False, *节点列表)
        if _正常丷调试:
            光杆树 = _乸光杆树(光杆树, 光杆树最大许可长度, 深度, 缓存度量)
            光杆树.光杆树
            光杆树.确认囗光杆树囗(光杆树最大许可长度, 深度)
        return 光杆树
    @override
    def 底层接口冖冖构造囗翅膀囗囗绝对定位囗囗序列左起囗囗已知缓存度量囗(sf, 节点列表, /, *, 左翼丷右翼, 翅膀最大许可长度, 翅膀最小许可长度, 深度, 缓存度量):
        '节点列表<左起丷右起,深度> -> 翅膀<左翼丷右翼,深度> #区分左右:栈开口方向不同！#可能需要 缓存 度量'
        # [节点列表.左起丷右起 == False]
        if not 左翼丷右翼:
            节点列表 = 节点列表[::-1]
            # [节点列表.左起丷右起 == True]
            # [节点列表.左起丷右起 == not 左翼丷右翼]
        # [节点列表.左起丷右起 == not 左翼丷右翼]
        if sf.有无囗缓存度量囗囗翅膀囗囗绝对定位囗(左翼丷右翼=左翼丷右翼, 深度=深度):
            翅膀 = (缓存度量, *节点列表)
        else:
            翅膀 = mk_tuple(节点列表)
        if _正常丷调试:
            翅膀 = _乸翅膀(翅膀, 左翼丷右翼, 翅膀最小许可长度, 翅膀最大许可长度, 深度, 缓存度量)
            翅膀.翅膀
            翅膀.确认囗翅膀囗(左翼丷右翼, 翅膀最小许可长度, 翅膀最大许可长度, 深度)
        return 翅膀
    @override
    def 底层接口冖冖构造囗根深树囗囗绝对定位囗囗序列左起囗囗已知缓存度量囗(sf, 左翼, 更深树, 右翼, /, *, 深度, 缓存度量):
        '-> 根深树<深度> #可能需要 缓存 度量'
        if sf.有无囗缓存度量囗囗根深树囗(深度=深度):
            根深树 = (True, 缓存度量, 左翼, 更深树, 右翼)
        else:
            根深树 = (True, 左翼, 更深树, 右翼)
        if _正常丷调试:
            根深树 = _乸根深树(根深树, 左翼, 更深树, 右翼, 深度, 缓存度量)
            根深树.根深树
            根深树.确认囗根深树囗(深度)
        return 根深树



    ######################
    ######################
    @override
    def 底层接口冖冖拆包囗元素封包节点囗(sf, 元素封包节点, /):
        '-> 元素'
        if _正常丷调试:
            元素封包节点 = 元素封包节点.确认囗元素封包节点囗()

        if sf.有无囗缓存度量囗囗元素封包节点囗():
            缓存度量, 元素 = 元素封包节点
        else:
            元素 = 元素封包节点
        return 元素
    @override
    def 底层接口冖冖拆包囗根深树囗囗绝对定位囗(sf, 根深树, /, *, 深度):
        '-> (左翼, 更深树, 右翼)'
        if _正常丷调试:
            根深树 = 根深树.确认囗根深树囗(深度)
        assert len(根深树) >= 3
        return 根深树[-3:]

    ######################
    ######################
    @override
    def 底层接口冖冖区分树形态囗(sf, 双侧展翅树, /, *, 深度):
        '-> 光杆树丷根深树/bool'
        if _正常丷调试:
            双侧展翅树 = 双侧展翅树.确认囗双侧展翅树囗(深度)
        return 双侧展翅树[0]
    @override
    def 底层接口冖冖是空树囗囗光杆树囗(sf, 光杆树, /, *, 深度):
        '-> bool'
        if _正常丷调试:
            光杆树 = 光杆树.确认囗光杆树囗囗缺囗(深度)
        if sf.有无囗缓存度量囗囗光杆树囗(深度=深度):
            return len(光杆树) == 2
        return len(光杆树) == 1

    ######################
    ######################
    @override
    def 底层接口冖冖迭代囗子节点囗囗光杆树囗(sf, 光杆树, /, *, 左起丷右起, 深度):
        '-> Iter 节点<深度>'
        if _正常丷调试:
            光杆树 = 光杆树.确认囗光杆树囗囗缺囗(深度)

        b = bool(sf.有无囗缓存度量囗囗光杆树囗(深度=深度))
        sz4header = 1+b
        return _迭代囗囗元组囗(sz4header, 左起丷右起, 光杆树)
    @override
    def 底层接口冖冖迭代囗子节点囗囗翅膀囗囗绝对定位囗(sf, 左翼丨右翼, /, *, 左起丷右起, 左翼丷右翼, 深度):
        '-> Iter 节点<深度>'
        if _正常丷调试:
            左翼丨右翼 = 左翼丨右翼.确认囗翅膀囗囗缺囗(左翼丷右翼, 深度)

        b = bool(sf.有无囗缓存度量囗囗翅膀囗囗绝对定位囗(左翼丷右翼=左翼丷右翼, 深度=深度))
        sz4header = b
        return _迭代囗囗元组囗(sz4header, (not 左起丷右起) ^ 左翼丷右翼, 左翼丨右翼)
    @override
    def 底层接口冖冖迭代囗子节点囗囗更深节点囗(sf, 更深节点, /, *, 左起丷右起, 深度):
        '更深节点<深度> -> Iter 节点<深度>'
        if _正常丷调试:
            更深节点 = 更深节点.确认囗更深节点囗囗缺囗(深度)

        b = bool(sf.有无囗缓存度量囗囗更深节点囗(深度=深度))
        sz4header = b
        return _迭代囗囗元组囗(sz4header, 左起丷右起, 更深节点)


    ######################
    ######################
    @override
    def 底层接口冖冖取囗长度囗囗光杆树囗(sf, 光杆树, /, *, 深度):
        '-> 长度'
        if _正常丷调试:
            光杆树 = 光杆树.确认囗光杆树囗囗缺囗(深度)

        b = bool(sf.有无囗缓存度量囗囗光杆树囗(深度=深度))
        sz4header = 1+b
        return len(光杆树)-sz4header
    @override
    def 底层接口冖冖取囗长度囗囗翅膀囗囗绝对定位囗(sf, 左翼丨右翼, /, *, 左翼丷右翼, 深度):
        '-> 长度'
        if _正常丷调试:
            左翼丨右翼 = 左翼丨右翼.确认囗翅膀囗囗缺囗(左翼丷右翼, 深度)

        b = bool(sf.有无囗缓存度量囗囗翅膀囗囗绝对定位囗(左翼丷右翼=左翼丷右翼, 深度=深度))
        sz4header = b
        return len(左翼丨右翼) -b
    @override
    def 底层接口冖冖取囗长度囗囗更深节点囗(sf, 更深节点, /, *, 深度):
        '-> 长度'
        if _正常丷调试:
            更深节点 = 更深节点.确认囗更深节点囗囗缺囗(深度)

        b = bool(sf.有无囗缓存度量囗囗更深节点囗(深度=深度))
        sz4header = b
        return len(更深节点) -b

    ######################
    ######################
    @override
    def 底层接口冖冖取囗缓存度量囗囗元素封包节点囗(sf, 元素封包节点, /):
        '-> 缓存度量'
        if _正常丷调试:
            元素封包节点 = 元素封包节点.确认囗元素封包节点囗()

        if sf.有无囗缓存度量囗囗元素封包节点囗():
            return 元素封包节点[0]
        return None
    @override
    def 底层接口冖冖取囗缓存度量囗囗更深节点囗(sf, 更深节点, /, *, 深度):
        '-> 缓存度量'
        if _正常丷调试:
            更深节点 = 更深节点.确认囗更深节点囗囗缺囗(深度)

        if sf.有无囗缓存度量囗囗更深节点囗(深度=深度):
            return 更深节点[0]
        return None
    @override
    def 底层接口冖冖取囗缓存度量囗囗光杆树囗(sf, 光杆树, /, *, 深度):
        '-> 缓存度量'
        if _正常丷调试:
            光杆树 = 光杆树.确认囗光杆树囗囗缺囗(深度)

        if sf.有无囗缓存度量囗囗光杆树囗(深度=深度):
            return 光杆树[1]
        return None
    @override
    def 底层接口冖冖取囗缓存度量囗囗翅膀囗囗绝对定位囗(sf, 左翼丨右翼, /, *, 左翼丷右翼, 深度):
        '-> 缓存度量'
        if _正常丷调试:
            左翼丨右翼 = 左翼丨右翼.确认囗翅膀囗囗缺囗(左翼丷右翼, 深度)

        if sf.有无囗缓存度量囗囗翅膀囗囗绝对定位囗(左翼丷右翼=左翼丷右翼, 深度=深度):
            return 左翼丨右翼[0]
        return None
    @override
    def 底层接口冖冖取囗缓存度量囗囗根深树囗(sf, 根深树, /, *, 深度):
        '-> 缓存度量'
        if _正常丷调试:
            根深树 = 根深树.确认囗根深树囗(深度)

        if sf.有无囗缓存度量囗囗根深树囗(深度=深度):
            return 根深树[1]
        return None
def _迭代囗囗元组囗(sz4header, 左起丷右起, 元组, /):
    f = reversed if 左起丷右起 else iter
    it = f(元组)
    if 左起丷右起:
        return islice(it, len(元组)-sz4header)
    if sz4header:
        return islice(it, sz4header, None)
    return it
#end-class _魖双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组



__all__
def __():
  class __(_魖双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组):
    __slots__ = ()
    ######################
    #属性界面
    @override
    def 取囗缓存度量囗公开属性囗索引列表囗(sf, /):
        '-> [索引] #用于 访问/解读 缓存度量 #see:分裂囗囗搜索定位囗'
    @override
    def 底层接口冖冖取囗缓存度量囗公开属性囗(sf, 缓存度量, 索引, /):
        '缓存度量 -> 索引 -> 属性值<索引>'
    @override
    def 取囗缓存度量囗公开属性囗加法零元囗(sf, 索引, /):
        '索引 -> 加法零元<索引>'
    ######################
    ######################

    ######################
    #树基础数据类型界面囗囗缓存度量囗囗标准元组
    @override
    def 有无囗缓存度量囗囗元素封包节点囗(sf, /):
        '-> 无丷有/bool'
    @override
    def 有无囗缓存度量囗囗更深节点囗(sf, /, *, 深度):
        '-> 无丷有/bool'
    @override
    def 有无囗缓存度量囗囗翅膀囗囗绝对定位囗(sf, /, *, 左翼丷右翼, 深度):
        '-> 无丷有/bool'
    @override
    def 有无囗缓存度量囗囗光杆树囗(sf, /, *, 深度):
        '-> 无丷有/bool'
    @override
    def 有无囗缓存度量囗囗根深树囗(sf, /, *, 深度):
        '-> 无丷有/bool'

    ######################
    ######################
    #树基础数据类型界面囗囗缓存度量
    @override
    def 加囗囗缓存度量囗囗绝对定位囗(sf, 左囗缓存度量, 右囗缓存度量, /):
        '-> 缓存度量 #满足 结合律 #不一定满足 交换律'
    @override
    def 取囗加法零元囗囗缓存度量囗(sf, /):
        '-> 缓存度量'
    @override
    def 底层接口冖冖求囗缓存度量囗囗元素囗(sf, 元素, /):
        '-> 缓存度量'
    ######################
    ######################
#end-class __(_魖双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组):


__all__
class 乸双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组囗囗无缓存度量(_魖双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组):
    __slots__ = ()
    ######################
    #属性界面
    @override
    def 取囗缓存度量囗公开属性囗索引列表囗(sf, /):
        '-> [索引] #用于 访问/解读 缓存度量 #see:分裂囗囗搜索定位囗'
        return null_tuple
    @override
    def 底层接口冖冖取囗缓存度量囗公开属性囗(sf, 缓存度量, 索引, /):
        '缓存度量 -> 索引 -> 属性值<索引>'
        raise LookupError(索引)
    @override
    def 取囗缓存度量囗公开属性囗加法零元囗(sf, 索引, /):
        '索引 -> 加法零元<索引>'
        raise LookupError(索引)
    ######################
    ######################


    ######################
    #树基础数据类型界面囗囗缓存度量囗囗标准元组
    @override
    def 有无囗缓存度量囗囗元素封包节点囗(sf, /):
        '-> 无丷有/bool'
        return False
    @override
    def 有无囗缓存度量囗囗更深节点囗(sf, /, *, 深度):
        '-> 无丷有/bool'
        return False
    @override
    def 有无囗缓存度量囗囗翅膀囗囗绝对定位囗(sf, /, *, 左翼丷右翼, 深度):
        '-> 无丷有/bool'
        return False
    @override
    def 有无囗缓存度量囗囗光杆树囗(sf, /, *, 深度):
        '-> 无丷有/bool'
        return False
    @override
    def 有无囗缓存度量囗囗根深树囗(sf, /, *, 深度):
        '-> 无丷有/bool'
        return False

    ######################
    ######################
    #树基础数据类型界面囗囗缓存度量
    @override
    def 加囗囗缓存度量囗囗绝对定位囗(sf, 左囗缓存度量, 右囗缓存度量, /):
        '-> 缓存度量 #满足 结合律 #不一定满足 交换律'
        return None
    @override
    def 取囗加法零元囗囗缓存度量囗(sf, /):
        '-> 缓存度量'
        return None
    @override
    def 底层接口冖冖求囗缓存度量囗囗元素囗(sf, 元素, /):
        '-> 缓存度量'
        return None
    ######################
    ######################
#end-class 乸双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组囗囗无缓存度量
匴双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组冖冖实例冫无缓存度量 = 乸双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组囗囗无缓存度量()






__all__
class 乸双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组囗囗缓存度量仅长度(_魖双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组):
    __slots__ = ()
    缓存度量囗公开属性囗索引列表 = ('len',)
    ######################
    #属性界面
    @override
    def 取囗缓存度量囗公开属性囗索引列表囗(sf, /):
        '-> [索引] #用于 访问/解读 缓存度量 #see:分裂囗囗搜索定位囗'
        return sf.缓存度量囗公开属性囗索引列表
    @override
    def 底层接口冖冖取囗缓存度量囗公开属性囗(sf, 缓存度量, 索引, /):
        '缓存度量 -> 索引 -> 属性值<索引>'
        if 索引 == 'len':
            长度 = 缓存度量
            return 长度
        raise LookupError(索引)
    @override
    def 取囗缓存度量囗公开属性囗加法零元囗(sf, 索引, /):
        '索引 -> 加法零元<索引>'
        return 0
    ######################
    ######################



    ######################
    #树基础数据类型界面囗囗缓存度量囗囗标准元组
    @override
    def 有无囗缓存度量囗囗元素封包节点囗(sf, /):
        '-> 无丷有/bool'
        return False
    @override
    def 有无囗缓存度量囗囗更深节点囗(sf, /, *, 深度):
        '-> 无丷有/bool'
        return 深度 > 0
    @override
    def 有无囗缓存度量囗囗翅膀囗囗绝对定位囗(sf, /, *, 左翼丷右翼, 深度):
        '-> 无丷有/bool'
        return 深度 > 0
    @override
    def 有无囗缓存度量囗囗光杆树囗(sf, /, *, 深度):
        '-> 无丷有/bool'
        return True
    @override
    def 有无囗缓存度量囗囗根深树囗(sf, /, *, 深度):
        '-> 无丷有/bool'
        return True

    ######################
    ######################
    #树基础数据类型界面囗囗缓存度量
    @override
    def 加囗囗缓存度量囗囗绝对定位囗(sf, 左囗缓存度量, 右囗缓存度量, /):
        '-> 缓存度量 #满足 结合律 #不一定满足 交换律'
        return int.__add__(左囗缓存度量, 右囗缓存度量)
    @override
    def 取囗加法零元囗囗缓存度量囗(sf, /):
        '-> 缓存度量'
        return 0
    @override
    def 底层接口冖冖求囗缓存度量囗囗元素囗(sf, 元素, /):
        '-> 缓存度量'
        return 1
    ######################

    ######################
    ######################
    ##!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ##!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ##!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ##!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ##!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ##!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ##!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    @override
    def 底层接口冖冖取囗缓存度量囗囗元素封包节点囗(sf, 元素封包节点, /):
        '-> 缓存度量'
        if _正常丷调试:
            元素封包节点 = 元素封包节点.确认囗元素封包节点囗()

        return 1
        if sf.有无囗缓存度量囗囗元素封包节点囗():
            return 元素封包节点[0]
        return None
    @override
    def 底层接口冖冖取囗缓存度量囗囗更深节点囗(sf, 更深节点, /, *, 深度):
        '-> 缓存度量'
        if _正常丷调试:
            更深节点 = 更深节点.确认囗更深节点囗囗缺囗(深度)

        if sf.有无囗缓存度量囗囗更深节点囗(深度=深度):
            return 更深节点[0]
        return len(更深节点)
        return None
    @override
    def 底层接口冖冖取囗缓存度量囗囗光杆树囗(sf, 光杆树, /, *, 深度):
        '-> 缓存度量'
        if _正常丷调试:
            光杆树 = 光杆树.确认囗光杆树囗囗缺囗(深度)

        return 光杆树[1]
        if sf.有无囗缓存度量囗囗光杆树囗(深度=深度):
            return 光杆树[1]
        return None
    @override
    def 底层接口冖冖取囗缓存度量囗囗翅膀囗囗绝对定位囗(sf, 左翼丨右翼, /, *, 左翼丷右翼, 深度):
        '-> 缓存度量'
        if _正常丷调试:
            左翼丨右翼 = 左翼丨右翼.确认囗翅膀囗囗缺囗(左翼丷右翼, 深度)

        if sf.有无囗缓存度量囗囗翅膀囗囗绝对定位囗(左翼丷右翼=左翼丷右翼, 深度=深度):
            return 左翼丨右翼[0]
        return len(左翼丨右翼)
        return None
    @override
    def 底层接口冖冖取囗缓存度量囗囗根深树囗(sf, 根深树, /, *, 深度):
        '-> 缓存度量'
        if _正常丷调试:
            根深树 = 根深树.确认囗根深树囗(深度)

        return 根深树[1]
        if sf.有无囗缓存度量囗囗根深树囗(深度=深度):
            return 根深树[1]
        return None
#end-class 乸双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组囗囗缓存度量仅长度
匴双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组冖冖实例冫长度 = 乸双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组囗囗缓存度量仅长度()


__all__
def __():
  class 乸双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组囗囗缓存度量仅散列值(_魖双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组):
    '感觉不太行:xor不考虑次序，是糟糕的散列算法:需要:长度 用于 偏移 多项式'
    __slots__ = ()
    缓存度量囗公开属性囗索引列表 = ('hash',)
    ######################
    #属性界面
    @override
    def 取囗缓存度量囗公开属性囗索引列表囗(sf, /):
        '-> [索引] #用于 访问/解读 缓存度量 #see:分裂囗囗搜索定位囗'
        return sf.缓存度量囗公开属性囗索引列表
    @override
    def 底层接口冖冖取囗缓存度量囗公开属性囗(sf, 缓存度量, 索引, /):
        '缓存度量 -> 索引 -> 属性值<索引>'
        if 索引 == 'hash':
            长度 = 缓存度量
            return 长度
        raise LookupError(索引)
    @override
    def 取囗缓存度量囗公开属性囗加法零元囗(sf, 索引, /):
        '索引 -> 加法零元<索引>'
        return 0
    ######################
    ######################



    ######################
    #树基础数据类型界面囗囗缓存度量囗囗标准元组
    @override
    def 有无囗缓存度量囗囗元素封包节点囗(sf, /):
        '-> 无丷有/bool'
        return True
    @override
    def 有无囗缓存度量囗囗更深节点囗(sf, /, *, 深度):
        '-> 无丷有/bool'
        return True
    @override
    def 有无囗缓存度量囗囗翅膀囗囗绝对定位囗(sf, /, *, 左翼丷右翼, 深度):
        '-> 无丷有/bool'
        return True
    @override
    def 有无囗缓存度量囗囗光杆树囗(sf, /, *, 深度):
        '-> 无丷有/bool'
        return True
    @override
    def 有无囗缓存度量囗囗根深树囗(sf, /, *, 深度):
        '-> 无丷有/bool'
        return True

    ######################
    ######################
    #树基础数据类型界面囗囗缓存度量
    @override
    def 加囗囗缓存度量囗囗绝对定位囗(sf, 左囗缓存度量, 右囗缓存度量, /):
        '-> 缓存度量 #满足 结合律 #不一定满足 交换律'
        return int.__xor__(左囗缓存度量, 右囗缓存度量)
    @override
    def 取囗加法零元囗囗缓存度量囗(sf, /):
        '-> 缓存度量'
        return 0
    @override
    def 底层接口冖冖求囗缓存度量囗囗元素囗(sf, 元素, /):
        '-> 缓存度量'
        return hash(元素)
    ######################
  乸双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组囗囗缓存度量仅散列值()


__all__
class 魖双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组囗囗缓存度量为词典映射(_魖双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组):
    r'''[[[
两种 数据类型 配置:
    * 双侧展翅树: 标准元组
        设计规范囗囗标准元组具现版:goto
    * 缓存度量: 词典映射/Mapping
        [缓存度量 :: Map 索引 属性<索引>]
        使用:缓存度量.__all__

    #]]]'''#'''
    __slots__ = ()
    ######################
    #属性界面
    @override
    def 取囗缓存度量囗公开属性囗索引列表囗(sf, /):
        '-> [索引] #用于 访问/解读 缓存度量 #see:分裂囗囗搜索定位囗'
        缓存度量囗囗加法零元 = sf.取囗加法零元囗囗缓存度量囗()
        return tuple(缓存度量囗囗加法零元.keys())
    @override
    def 底层接口冖冖取囗缓存度量囗公开属性囗(sf, 缓存度量, 索引, /):
        '缓存度量 -> 索引 -> 属性值<索引>'
        return 缓存度量[索引]
    @override
    def 取囗缓存度量囗公开属性囗加法零元囗(sf, 索引, /):
        '索引 -> 加法零元<索引>'
        缓存度量囗囗加法零元 = sf.取囗加法零元囗囗缓存度量囗()
        return 缓存度量囗囗加法零元[索引]
    ######################
    ######################

    ######################
    #树基础数据类型界面囗囗缓存度量囗囗标准元组
    @override
    def 有无囗缓存度量囗囗元素封包节点囗(sf, /):
        '-> 无丷有/bool'
        return True
    @override
    def 有无囗缓存度量囗囗更深节点囗(sf, /, *, 深度):
        '-> 无丷有/bool'
        return True
    @override
    def 有无囗缓存度量囗囗翅膀囗囗绝对定位囗(sf, /, *, 左翼丷右翼, 深度):
        '-> 无丷有/bool'
        return True
    @override
    def 有无囗缓存度量囗囗光杆树囗(sf, /, *, 深度):
        '-> 无丷有/bool'
        return True
    @override
    def 有无囗缓存度量囗囗根深树囗(sf, /, *, 深度):
        '-> 无丷有/bool'
        return True

    ######################
    ######################
    #树基础数据类型界面囗囗缓存度量
    @override
    def 加囗囗缓存度量囗囗绝对定位囗(sf, 左囗缓存度量, 右囗缓存度量, /):
        '-> 缓存度量 #满足 结合律 #不一定满足 交换律'
        return 左囗缓存度量 + 右囗缓存度量
    #@override
    #def 取囗加法零元囗囗缓存度量囗(sf, /):
    #    '-> 缓存度量'
    #@override
    #def 底层接口冖冖求囗缓存度量囗囗元素囗(sf, 元素, /):
    #    '-> 缓存度量'
    ######################
#end-class 魖双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组囗囗缓存度量为词典映射





__all__
class 乸双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组囗囗缓存度量为词典映射(魖双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组囗囗缓存度量为词典映射):
    ___no_slots_ok___ = True

    def __init__(sf, 缓存度量囗囗加法零元:'乸词典映射冃缓存度量', 元素讠缓存度量囗:'元素->缓存度量', /):
        sf._缓存度量囗囗加法零元 = 缓存度量囗囗加法零元
        sf._元素讠缓存度量囗 = 元素讠缓存度量囗
    @override
    def 取囗加法零元囗囗缓存度量囗(sf, /):
        '-> 缓存度量'
        return sf._缓存度量囗囗加法零元
    @override
    def 底层接口冖冖求囗缓存度量囗囗元素囗(sf, 元素, /):
        '-> 缓存度量'
        return sf._元素讠缓存度量囗(元素)
#end-class 乸双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组囗囗缓存度量为词典映射
匴双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组冖冖实例冫长度丶散列值 = 乸双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组囗囗缓存度量为词典映射(加法零元囗囗长度丶散列值, lambda 元素:乸词典映射冃缓存度量囗囗长度丶散列值(dict(len=1,hash=hash(元素),shift_radix4hash=乸词典映射冃缓存度量囗囗长度丶散列值._基数_)))






######################
######################
######################
######################
######################
匴双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组冖冖实例冫无缓存度量
匴双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组冖冖实例冫长度
匴双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组冖冖实例冫长度丶散列值
##########
匞双侧展翅树囗最小参数配置囗囗囗二囗对半
##########
乸双侧展翅树囗相关操作囗囗无长度
乸双侧展翅树囗相关操作
######################
######################

匴双侧展翅树囗相关操作囗囗无长度囗囗二三树 = 乸双侧展翅树囗相关操作囗囗无长度(匞双侧展翅树囗最小参数配置囗囗囗二囗对半, 匴双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组冖冖实例冫无缓存度量)

匴双侧展翅树囗相关操作囗囗仅长度囗囗二三树 = 乸双侧展翅树囗相关操作(匞双侧展翅树囗最小参数配置囗囗囗二囗对半, 匴双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组冖冖实例冫长度)

匴双侧展翅树囗相关操作囗囗丮长度丶散列值厈囗囗二三树 = 乸双侧展翅树囗相关操作(匞双侧展翅树囗最小参数配置囗囗囗二囗对半, 匴双侧展翅树囗数据类型配置囗囗巨型参数无优化囗囗标准元组冖冖实例冫长度丶散列值)













__all__
def __():
    from seed.tiny import ifNonef, ifNone, echo
    from seed.tiny_.check import check_uint_lt, check_int_ge_lt, check_int_ge, check_int_ge_le
    from seed.tiny import print_err, mk_fprint, mk_assert_eq_f, expectError
    from seed.func_tools.fmapT.fmapT__tiny import dot, fmapT__dict, fmapT__list, fmapT__iter
    from seed.helper.repr_input import repr_helper

def __():
    from seed.helper.repr_input import repr_helper
    class _(ABC):
        __slots__ = ()
        raise NotImplementedError
        ___no_slots_ok___ = True
        def __repr__(sf, /):
            #return repr_helper(sf, *args, **kwargs)
            #return repr_helper_ex(sf, args, ordered_attrs, kwargs, ordered_attrs_only=False)
            ...
if __name__ == "__main__":
    pass
__all__


from seed.data_funcs.finger_tree.finger_tree_ops__instances import (
匴双侧展翅树囗相关操作囗囗无长度囗囗二三树
,匴双侧展翅树囗相关操作囗囗仅长度囗囗二三树
,匴双侧展翅树囗相关操作囗囗丮长度丶散列值厈囗囗二三树
)

from seed.data_funcs.finger_tree.finger_tree_ops__instances import *
