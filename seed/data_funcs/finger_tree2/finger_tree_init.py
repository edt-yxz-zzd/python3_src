#__all__:goto
#py_cmd:goto
r'''[[[
e ../../python3_src/seed/data_funcs/finger_tree2/finger_tree_init.py
需求源自:
    e ../../python3_src/seed/recognize/toy/poor_efficiency_toy_recognizer.py

e ../../python3_src/seed/data_funcs/finger_tree2/scene_role.py
    匞场景包++圁角色名++注册处
e ../../python3_src/seed/data_funcs/finger_tree2/finger_tree_basic_types.py


seed.data_funcs.finger_tree2.finger_tree_init
from seed.data_funcs.finger_tree2.scene_role import 魖场景包暨角色名注册处, 乸场景包暨角色名注册处







[[[
因为有许多更改，所以另起炉灶
vs:
    view ../../python3_src/seed/data_funcs/finger_tree/finger_tree_common.py
===
[数据实体 不能 直接保存场景配置，否则过于浪费空间]
[类型 不能 直接保存场景配置，因为 可能在同一场景中 扮演多个角色 或者 同一角色的不同特化参数版本]
===
tree: 类型包 作为 参数 传入
角色:不同环境 扮演 不同角色
    比如说，光杆树 可以很长
        当 翅膀缺员时，直接退化，而不是平衡
            #单侧缺员，异侧满员:2-3配置:(一侧0,一侧4,光杆树最大许可值1)
        这时，光杆树 本身 就可以是 异配置 双侧展翅树
    翅膀、光杆树 都可以是 异配置 双侧展翅树！
        异配置<<==通过 取消某些操作 而退化
        合并操作 要求 更深节点 长度覆盖
        合并操作 要求 翅膀 足够长

type(obj).角色讠算子包
不同角色算子包 其输入参数『类型包』是不同的
class XXX:
    #XXX 扮演不同角色:
    #   同一剧本场景 但不同 时空环境实例
    #角色一:
    class 匴翅膀
    #角色二#分流到:角色三?
    class 匴双侧展翅树
    #角色三
    class 匴光杆树
class YYY:
    #角色一
    class 匴节点#分流到:角色二?
    #角色二
    class 匴更深节点
class 类型包:
    参数配置 = ...
    #设置不同角色
    #   类型包 本身不参演
    #角色一
    乸元素封包节点 = ...
    #角色二
    乸更深节点 = ...
内建:长度
内建:反转#要求:所有属性 计算 左右双向:散列值
    但是:长度/最小值:次序无关
    属性界面 分离独立
    属性 全序声明: 正序/逆序/无序
    属性 次序依赖性声明/满足交换律与否: 依赖元素左右次序(反转支持:两倍计算)/不依赖元素左右次序
    属性 可减性声明:用于 整树统计/压入弹出返回值
    属性 依赖声明: 其余属性
        散列值~基数**长度~基数塔
压入/合并/弹出?/分裂?:返回:增减节点数/可减性 属性
        ++参数:属性差量累积器
压入/合并/弹出/分裂:返回:高度
分流:高度+深度+左翼丷右翼
    节点<深度==0> --> 元素封包节点
    双侧展翅树<高度==0> --> 光杆树
    翅膀<左翼丷右翼>
匞使用场景相关参数类型包
匞场景包#囶场景包#圙
匞场景包,角色名,类参数<高度/深度/左翼丷右翼>,对象?
    高度+深度===整树总高度===整树总深度
    匞场景包[角色名:对象?,参数?]
    圁角色名(匞场景包, **参数包).算子名(...)
        演/戭/訁/厃/閆/圁
        弡/亅/角
        扮
        假/叚/迦
        冒/冃/戼
    对象可能不存在，需要构造器
    匞场景包.构造囗算子包扌(角色名,算子包模板参数...).对象构造器(...)
    构造囗算子包扌 :: 匞场景包->圁角色名->(*算子包模板参数...) -> 匴算子包<算子包模板参数...>
    此前需要 绑定/注册:
    指派囗角色扌/绑定囗算子包囗构造器扌:: 匞场景包->圁角色名-> 乸算子包 -> None
,圙
:圁yín
:圕tuān
/“图书馆”三字的缩写。

,role
:角色
,scene
:场景
,operator
:操作符


===
]]]
[[[
命名规范:
===
魖抽象类
乸具象类
    例外:乸构造器
    例外:错误/异常
    例外:冭乸基础空类
匴算子包
    接口具现
匞配置包/匞类型包/匞场景包
    配置具现
圁角色名
欤真值变量名
函数名扌 f_
槑某某某 lazy_x
魊某某某 tmay x
鬽某某某 may x
===
]]]
[[[
紧致假设==True
===
求:更深节点最大的不可表达节点数
求囗更深节点最大的不可表达节点数乊紧致假设冖冖暴力版扌:goto
求囗更深节点最大的不可表达节点数乊紧致假设冖冖理论版扌:goto
===
[1 <= a < b]:
    [a..=b] 生成的 范围为:
        [a..=b]
        [2*a..=2*b]
        [3*a..=3*b]
        ...
        [k*a..=k*b]
        [(k+1)*a..=(k+1)*b]
        ...
    要求 找到 最小 k>=1 :=> [k*b+1 >= (k+1)*a]
    [k*b+1 >= (k+1)*a]
        <==> [k*(b-a)+1 >= a]
        <==> [k >= (a-1)/(b-a)]
        <==> [k >= ceil((a-1)/(b-a))]
        <==> [k >= floor((a-1+b-a-1)/(b-a))]
        <==> [k >= ((b-2)//(b-a))]
    [min_k == max(1, (b-2)//(b-a))]
    [更深节点最大的不可表达节点数 == (min_k*a-1)]
===
===
]]]

[[[
参数配置:删去:
    ,更深节点许可长度集合
        = range(更深节点最小许可长度,更深节点最大许可长度+1)
    ,更深节点最大的不可表达节点数
        #see:求囗更深节点最大的不可表达节点数乊紧致假设冖冖理论版扌
    ,翅膀溢出时分裂出的更深节点的各自长度
        = (更深节点最优许可长度,)*翅膀溢出时分裂出的更深节点的数目
    ,翅膀溢出时分裂出的节点的数目
        = sum(翅膀溢出时分裂出的更深节点的各自长度)
    #??,翅膀溢出时分裂出的更深节点的数目=1
    ,光杆树最小许可长度
        =0
    ,光杆树溢出时分裂出的双翼的长度
        =(光杆树最大许可长度//2,(光杆树最大许可长度+1)//2)
    ,光杆树溢出时分裂出的更深节点的各自长度
        =()
    ,光杆树溢出时分裂出的中间节点的数目
        =0
    ,光杆树溢出时分裂出的更深节点的数目
        =0
    #??,翅膀缺员时退化上限=光杆树最大许可长度
    ,紧致假设=True
===

view ../../python3_src/seed/data_funcs/finger_tree/finger_tree_common.py
def 检查约束囗双侧展翅树囗配置囗(*
    ,更深节点最小许可长度
    ,更深节点最大许可长度
    ,更深节点最优许可长度
    ,更深节点许可长度集合
    ,更深节点最大的不可表达节点数
    ,翅膀最小许可长度
    ,翅膀最大许可长度
    ,翅膀溢出时分裂出的更深节点的各自长度
    ,翅膀溢出时分裂出的节点的数目
    ,翅膀溢出时分裂出的更深节点的数目
    ,光杆树最小许可长度
    ,光杆树溢出时分裂出的双翼的长度
    ,光杆树溢出时分裂出的更深节点的各自长度
    ,光杆树溢出时分裂出的中间节点的数目
    ,光杆树溢出时分裂出的更深节点的数目
    ,光杆树最大许可长度
    ,翅膀缺员时退化上限
    ######################
    ,优先支持对半搜索
    ,紧致假设
    ,增长
    ,缩水
    ,增长防板荡
    ,可疑
    ,缩水防板荡
    ,消息盈虚防板荡
    ,增长合并
    ,缩水分裂
    ):
]]]
[[[
双侧展翅树
    欤支持长度
    欤支持反序
===
双侧展翅树
    双侧光杆树
    双侧根深树
    双侧更深树
        #其存在意义何在？
        #   使 接口 保持 所有输入参数 的 类型特化参数 一致
        #       除非 同时 输入多个同名 类型特化参数，但这时 这些同名 必须明确标识出 所属
翅膀
    异翅
    左翼
    右翼
    起翼
    讫翼
双侧节点
    元素封包节点
    双侧更深节点
===
######################
！！高度 作为 模板参数 不合理！！
    构造之后 才能 确定！！
也不对，匴算子包 确实依 高度 而特化
    构造之前 便确定 高度 ==>> 局部单层构造器
    类似 树巛节点序列 无法 实现
    只能: 光杆树巛节点序列
    或:   根深树巛左翼丶更深树丶右翼
######################
区分: 注水版 vs 脱水版
区分: 内部临时用-注水版 vs 内部保存用-脱水版
脱水版 只用于 内部保存
拆包 输出的 都是 注水版
这么看，注水版 也可 封装 算子包，成为 对象...
？？？
注水版=(模板参数,脱水版)
含高树<深度> = (高度,树<高度,深度>)
===
含高双侧展翅树<深度> = (高度,双侧展翅树<高度,深度>)
含高双侧根深树<深度> = (高度,双侧根深树<高度,深度>)
含高双侧更深树<深度> = (高度,双侧更深树<高度,深度>)
无:含高双侧光杆树:
    !! 双侧根深树<高度,深度> 之高度 是 绑定于 根深树 的『-1』版，并非 双侧展翅树<高度,深度> 之高度
===
双侧展翅树<高度,深度>
双侧展翅树 = 双侧光杆树 | 双侧根深树
双侧根深树 = (左翼, 双侧更深树, 右翼)

双侧展翅树<高度=0,深度> = 双侧光杆树<深度>
双侧展翅树<高度+1,深度> = 双侧根深树<高度,深度>
    #若是 考虑到『双侧更深树』的命名，也许这里该分别改名为『双侧无高树』『双侧更高树』
===
双侧根深树<高度,深度> = (左翼<深度>, 双侧更深树<高度,深度>, 右翼<深度>)
    #双侧更深树 存在的意义 在于 保持 特化参数不变
双侧更深树<高度,深度> = 双侧展翅树<高度,深度+1>
    # 『高度-1』发生在 双侧展翅树-->双侧根深树
    # 『深度+1』发生在 双侧展翅树<--双侧更深树
    #   所以 主干上的所有 双侧展翅树 的 (高度+深度) 不变 #不变量
===
双侧光杆树<深度> = 双侧栈<双侧节点<深度> >
===
翅膀<左翼丷右翼,深度>
异翅<左翼丷右翼,深度> = 翅膀<not 左翼丷右翼,深度>
起翼<起翼丷讫翼,左起丷右起,深度> = 翅膀<起翼丷讫翼^左起丷右起,深度>
讫翼<起翼丷讫翼,左起丷右起,深度> = 翅膀<not(起翼丷讫翼^左起丷右起),深度>
翅膀<False,深度> = 左翼<深度>
翅膀<True,深度> = 右翼<深度>
左翼<深度> = 单侧栈<双侧节点<深度> >
右翼<深度> = 单侧栈<双侧节点<深度> >
===
双侧节点<0> = 元素封包节点
双侧节点<深度+1> = 双侧更深节点<深度>
双侧更深节点<深度> = 数组<双侧节点<深度> >
===
===
===
双侧栈/单侧栈
数组版具现vs退化双侧展翅树版具现
复用:退化双侧展翅树/退化单侧展翅树
    #单侧展翅树:见下面
退化:即:配置退化,针对超小数据规模特化:旨在略微提高性能(相较于 数组版具现)
双侧栈 = (高度,退化双侧展翅树<高度,0>)
单侧栈 = (高度,退化单侧展翅树<高度,0>)
===

===
]]]
[[[
单侧展翅树
===
单侧展翅树
    单侧光杆树
    单侧根深树
起翼
单侧节点
    元素封包节点
    单侧更深节点
===
单侧展翅树 = 单侧光杆树 | 单侧根深树
单侧根深树 = (起翼, 单侧更深树)

单侧展翅树<高度=0,深度> = 单侧光杆树<深度>
单侧展翅树<高度+1,深度> = 单侧根深树<高度,深度>
===
单侧根深树<高度,深度> = (起翼<深度>, 单侧更深树<高度,深度>)
单侧更深树<高度,深度> = 单侧展翅树<高度-1,深度+1>
===
单侧光杆树<深度> = 单侧栈<单侧节点<深度> >
===
起翼<深度> = 单侧栈<单侧节点<深度> >
===
单侧节点<0> = 元素封包节点
单侧节点<深度+1> = 单侧更深节点<深度>
单侧更深节点<深度> = 数组<单侧节点<深度> >
#[单侧节点=?=双侧节点]
#毕竟:使用 数组...
#更何况 若用作 双侧展翅树.翅膀，依然 需要 双向遍历
===
===
下文 假设:
    双侧节点==节点
    单侧节点==节点
===
]]]
[[[
约束:双侧展翅树
    #仅限于 满足 检查约束囗双侧展翅树囗精简版配置冖冖紧致假设扌
    计算展翅树参数配置所满足的条件扌:goto
===
* 必须:
    [0 <= 更深节点最小许可长度 <= 更深节点最优许可长度 <= 更深节点最大许可长度]
    [0 <= 翅膀最小许可长度 <= 翅膀最大许可长度]
    [0 <= 光杆树最大许可长度]
    [0 <= 翅膀缺员时退化上限]
* 增长
    『增长:增一溢出冫翅膀』[翅膀最小许可长度 <= 翅膀最大许可长度+1-更深节点最优许可长度  <= 翅膀最大许可长度]
    不同下:『增长:增一溢出冫光杆树乊变态进化为空心双翼:双侧版』[2*翅膀最小许可长度 <= 光杆树最大许可长度+1 <= 2*翅膀最大许可长度]
* 缩水
    『缩水:减一缺员冫翅膀乊空心双翼乊变态退化』[翅膀缺员时退化上限 <= 光杆树最大许可长度]
    不同下:『缩水:减一缺员冫翅膀乊空心双翼乊均衡双翼:双侧版』[翅膀最小许可长度 <= 翅膀缺员时退化上限+1-翅膀最小许可长度 <= 翅膀最大许可长度]
    『缩水:减一缺员冫翅膀乊厚势』[翅膀最小许可长度 <= 翅膀最小许可长度-1+更深节点最小许可长度 <= 翅膀最小许可长度-1+更深节点最大许可长度 <= 翅膀最大许可长度]
* 增长防板荡
    『增长防板荡:增一溢出冫翅膀』[翅膀最小许可长度 <= 翅膀最大许可长度+1-更深节点最优许可长度 <= 翅膀最大许可长度-1]
    不同下:『可疑』『增长防板荡:增一溢出冫光杆树乊变态进化为空心双翼:双侧版』[2*翅膀最小许可长度 <= 光杆树最大许可长度+1 <= 2*(翅膀最大许可长度-1)]
* 可疑
* 缩水防板荡
    不同下:『缩水防板荡:减一缺员冫翅膀乊空心双翼乊均衡双翼:双侧版』[翅膀最小许可长度+1 <= 翅膀缺员时退化上限+1-(翅膀最小许可长度+1) <= 翅膀最大许可长度]
    『缩水防板荡:减一缺员冫翅膀乊厚势』[翅膀最小许可长度+1 <= 翅膀最小许可长度-1+更深节点最小许可长度 <= 翅膀最小许可长度-1+更深节点最大许可长度 <= 翅膀最大许可长度]
* 消息盈虚防板荡
    『消息盈虚防板荡:增一溢出冫翅膀』[翅膀最小许可长度+1 <= 翅膀最大许可长度+1-更深节点最优许可长度  <= 翅膀最大许可长度-1]
    不同下:『消息盈虚防板荡:增一溢出冫光杆树乊变态进化为空心双翼:双侧版』[2*(翅膀最小许可长度+1) <= 光杆树最大许可长度+1 <= 2*(翅膀最大许可长度-1)]
    『可疑』『消息盈虚防板荡:减一缺员冫翅膀乊空心双翼乊变态退化』[翅膀缺员时退化上限 <= 光杆树最大许可长度-1]
    不同下:『消息盈虚防板荡:减一缺员冫翅膀乊空心双翼乊均衡双翼:双侧版』[翅膀最小许可长度+1 <= 翅膀缺员时退化上限+1-(翅膀最小许可长度+1) <= 翅膀最大许可长度-1]
    『消息盈虚防板荡:减一缺员冫翅膀乊厚势』[翅膀最小许可长度+1 <= 翅膀最小许可长度-1+更深节点最小许可长度 <= 翅膀最小许可长度-1+更深节点最大许可长度 <= 翅膀最大许可长度-1]
* 增长合并
    不同下:『增长合并:可表达性臫下沉:双侧版』[2*翅膀最小许可长度>=1+更深节点最大的不可表达节点数]
    不同下:『增长合并:节点数目上限存在性臫无限下沉:双侧版』[@[x>=2*翅膀最小许可长度] -> [(2*翅膀最小许可长度+x)//更深节点最小许可长度 <= x]]
        # 『最小』不是『最优』<<==拆分 不确定性
    『增长合并:合并光杆树冫连续压入』[要求:增长防板荡]
        #vs『可疑』『增长合并:合并光杆树冫单侧下沉丶断肢再造』[要求:???]
* 缩水分裂
    『缩水分裂:滴血重生断肢再造』[翅膀最小许可长度+1 <= 0+更深节点最小许可长度 <= 翅膀最小许可长度-1+更深节点最大许可长度 <= 翅膀最大许可长度]
        # 最左『+1』是 不断上浮 连续 再造断翅 所需
    『缩水分裂:抽取精血』[要求:缩水]
===
===
]]]
[[[
约束:单侧展翅树
    #类比于: 双侧展翅树 仅限于 满足 检查约束囗双侧展翅树囗精简版配置冖冖紧致假设扌
    计算展翅树参数配置所满足的条件扌:goto
===
* 必须:
    同上:[0 <= 更深节点最小许可长度 <= 更深节点最优许可长度 <= 更深节点最大许可长度]
    同上:[0 <= 翅膀最小许可长度 <= 翅膀最大许可长度]
    同上:[0 <= 光杆树最大许可长度]
    同上:[0 <= 翅膀缺员时退化上限]
* 增长
    同上:『增长:增一溢出冫翅膀』[翅膀最小许可长度 <= 翅膀最大许可长度+1-更深节点最优许可长度  <= 翅膀最大许可长度]
    不同上:『增长:增一溢出冫光杆树乊变态进化为空心双翼:单侧版』[翅膀最小许可长度 <= 光杆树最大许可长度+1 <= 翅膀最大许可长度]
* 缩水
    同上:『缩水:减一缺员冫翅膀乊空心双翼乊变态退化』[翅膀缺员时退化上限 <= 光杆树最大许可长度]
    不同上:『缩水:减一缺员冫翅膀乊空心双翼乊均衡双翼:单侧版不存在』None
    同上:『缩水:减一缺员冫翅膀乊厚势』[翅膀最小许可长度 <= 翅膀最小许可长度-1+更深节点最小许可长度 <= 翅膀最小许可长度-1+更深节点最大许可长度 <= 翅膀最大许可长度]
* 增长防板荡
    同上:『增长防板荡:增一溢出冫翅膀』[翅膀最小许可长度 <= 翅膀最大许可长度+1-更深节点最优许可长度 <= 翅膀最大许可长度-1]
    不同上:『可疑』『增长防板荡:增一溢出冫光杆树乊变态进化为空心双翼:单侧版』[翅膀最小许可长度 <= 光杆树最大许可长度+1 <= 翅膀最大许可长度-1]
* 可疑
* 缩水防板荡
    不同上:『缩水防板荡:减一缺员冫翅膀乊空心双翼乊均衡双翼:单侧版不存在』None
    同上:『缩水防板荡:减一缺员冫翅膀乊厚势』[翅膀最小许可长度+1 <= 翅膀最小许可长度-1+更深节点最小许可长度 <= 翅膀最小许可长度-1+更深节点最大许可长度 <= 翅膀最大许可长度]
* 消息盈虚防板荡
    同上:『消息盈虚防板荡:增一溢出冫翅膀』[翅膀最小许可长度+1 <= 翅膀最大许可长度+1-更深节点最优许可长度  <= 翅膀最大许可长度-1]
    不同上:『消息盈虚防板荡:增一溢出冫光杆树乊变态进化为空心双翼:单侧版』[(翅膀最小许可长度+1) <= 光杆树最大许可长度+1 <= (翅膀最大许可长度-1)]
    同上:『可疑』『消息盈虚防板荡:减一缺员冫翅膀乊空心双翼乊变态退化』[翅膀缺员时退化上限 <= 光杆树最大许可长度-1]
    不同上:『消息盈虚防板荡:减一缺员冫翅膀乊空心双翼乊均衡双翼:单侧版不存在』None
    同上:『消息盈虚防板荡:减一缺员冫翅膀乊厚势』[翅膀最小许可长度+1 <= 翅膀最小许可长度-1+更深节点最小许可长度 <= 翅膀最小许可长度-1+更深节点最大许可长度 <= 翅膀最大许可长度-1]
* 增长合并
    不同上:『增长合并:可表达性臫下沉:单侧版』[翅膀最小许可长度>=1+更深节点最大的不可表达节点数]
    不同上:『增长合并:节点数目上限存在性臫无限下沉:单侧版』[@[x>=翅膀最小许可长度] -> [(翅膀最小许可长度+x)//更深节点最小许可长度 <= x]]
        # 『最小』不是『最优』<<==拆分 不确定性
    同上:『增长合并:合并光杆树冫连续压入』[要求:增长防板荡]
* 缩水分裂
    同上:『缩水分裂:滴血重生断肢再造』[翅膀最小许可长度+1 <= 0+更深节点最小许可长度 <= 翅膀最小许可长度-1+更深节点最大许可长度 <= 翅膀最大许可长度]
        # 最左『+1』是 不断上浮 连续 再造断翅 所需
    同上:『缩水分裂:抽取精血』[要求:缩水]
===
===
]]]





#py_cmd:here
seed.data_funcs.finger_tree2.finger_tree_init
py -m nn_ns.app.debug_cmd   seed.data_funcs.finger_tree2.finger_tree_init -x
py -m nn_ns.app.doctest_cmd seed.data_funcs.finger_tree2.finger_tree_init:__doc__
py -m nn_ns.app.doctest_cmd seed.data_funcs.finger_tree2.finger_tree_init:__doc__  -ff -v --ndiff
py_adhoc_call  seed.helper.print_methods  @wrapped_print_methods   %seed.data_funcs.finger_tree2.finger_tree_init:XXX@T    =T      ++exclude_prefixes:_       +exclude_attrs5listed_in_cls_doc





py_adhoc_call   seed.data_funcs.finger_tree2.finger_tree_init   @求囗更深节点最大的不可表达节点数乊紧致假设冖冖暴力版扌    =1 =2
0
py_adhoc_call   seed.data_funcs.finger_tree2.finger_tree_init   @求囗更深节点最大的不可表达节点数乊紧致假设冖冖暴力版扌    =2 =3
1
py_adhoc_call   seed.data_funcs.finger_tree2.finger_tree_init   @求囗更深节点最大的不可表达节点数乊紧致假设冖冖暴力版扌    =6 =7
29

py_adhoc_call   seed.data_funcs.finger_tree2.finger_tree_init   @确认囗理论版囗暴力版囗结果一致冖冖求囗更深节点最大的不可表达节点数乊紧致假设扌  '=range(1,30)' '=range(1,30)'
    ok



######################
######################
######################
###### 暴力版 ########
######################
######################
######################
>>> 求囗更深节点最大的不可表达节点数乊紧致假设冖冖暴力版扌(1,2)
0
>>> 求囗更深节点最大的不可表达节点数乊紧致假设冖冖暴力版扌(2,3)
1
>>> 求囗更深节点最大的不可表达节点数乊紧致假设冖冖暴力版扌(6,7)
29
>>> 求囗更深节点最大的不可表达节点数乊紧致假设冖冖暴力版扌(6,8)
17
>>> 求囗更深节点最大的不可表达节点数乊紧致假设冖冖暴力版扌(6,9)
11
>>> 求囗更深节点最大的不可表达节点数乊紧致假设冖冖暴力版扌(6,10)
11
>>> 求囗更深节点最大的不可表达节点数乊紧致假设冖冖暴力版扌(6,11)
5
>>> 求囗更深节点最大的不可表达节点数乊紧致假设冖冖暴力版扌(6,12)
5

>>> 求囗更深节点最大的不可表达节点数乊紧致假设冖冖暴力版扌(6,7,输出覆盖=True)
(29, [(6, 8), (12, 15), (18, 22), (24, 29), (30, 36)])
>>> 求囗更深节点最大的不可表达节点数乊紧致假设冖冖暴力版扌(6,8,输出覆盖=True)
(17, [(6, 9), (12, 17), (18, 25)])

>>> 求囗更深节点最大的不可表达节点数乊紧致假设冖冖暴力版扌(7,8,输出覆盖=True)
(41, [(7, 9), (14, 17), (21, 25), (28, 33), (35, 41), (42, 49)])
>>> 求囗更深节点最大的不可表达节点数乊紧致假设冖冖暴力版扌(7,9,输出覆盖=True)
(20, [(7, 10), (14, 19), (21, 28)])
>>> 求囗更深节点最大的不可表达节点数乊紧致假设冖冖暴力版扌(7,10,输出覆盖=True)
(13, [(7, 11), (14, 21)])





######################
######################
######################
###### 理论版 ########
######################
######################
######################
>>> 求囗更深节点最大的不可表达节点数乊紧致假设冖冖理论版扌(1,2)
0
>>> 求囗更深节点最大的不可表达节点数乊紧致假设冖冖理论版扌(2,3)
1
>>> 求囗更深节点最大的不可表达节点数乊紧致假设冖冖理论版扌(6,7)
29
>>> 求囗更深节点最大的不可表达节点数乊紧致假设冖冖理论版扌(6,8)
17
>>> 求囗更深节点最大的不可表达节点数乊紧致假设冖冖理论版扌(6,9)
11
>>> 求囗更深节点最大的不可表达节点数乊紧致假设冖冖理论版扌(6,10)
11
>>> 求囗更深节点最大的不可表达节点数乊紧致假设冖冖理论版扌(6,11)
5
>>> 求囗更深节点最大的不可表达节点数乊紧致假设冖冖理论版扌(6,12)
5

>>> 求囗更深节点最大的不可表达节点数乊紧致假设冖冖理论版扌(6,7,输出覆盖=True)
(29, [(6, 8), (12, 15), (18, 22), (24, 29), (30, 36)])
>>> 求囗更深节点最大的不可表达节点数乊紧致假设冖冖理论版扌(6,8,输出覆盖=True)
(17, [(6, 9), (12, 17), (18, 25)])

>>> 求囗更深节点最大的不可表达节点数乊紧致假设冖冖理论版扌(7,8,输出覆盖=True)
(41, [(7, 9), (14, 17), (21, 25), (28, 33), (35, 41), (42, 49)])
>>> 求囗更深节点最大的不可表达节点数乊紧致假设冖冖理论版扌(7,9,输出覆盖=True)
(20, [(7, 10), (14, 19), (21, 28)])
>>> 求囗更深节点最大的不可表达节点数乊紧致假设冖冖理论版扌(7,10,输出覆盖=True)
(13, [(7, 11), (14, 21)])




######################
######################
######################
######################
计算展翅树参数配置所满足的条件扌(*
    ,单侧版丷双侧版
    ,可疑
    #total 7
    ,更深节点最小许可长度
    ,更深节点最大许可长度
    ,更深节点最优许可长度
    ,翅膀最小许可长度
    ,翅膀最大许可长度
    ,光杆树最大许可长度
    ,翅膀缺员时退化上限
    )
>>> (inputs, details, outputs) = 计算展翅树参数配置所满足的条件扌(
... 单侧版丷双侧版=True
... ,可疑=False
... ,更深节点最小许可长度=2
... ,更深节点最大许可长度=3
... ,更深节点最优许可长度=2
... ,翅膀最小许可长度=1
... ,翅膀最大许可长度=4
... ,光杆树最大许可长度=1#-->3
... ,翅膀缺员时退化上限=1#-->3
... )
>>> inputs == {'单侧版丷双侧版': True, '更深节点最小许可长度': 2, '更深节点最大许可长度': 3, '更深节点最优许可长度': 2, '翅膀最小许可长度': 1, '翅膀最大许可长度': 4, '光杆树最大许可长度': 1, '翅膀缺员时退化上限': 1, '可疑': False}
True
>>> details == {'『增长:增一溢出冫翅膀』': True, '『增长:增一溢出冫光杆树乊变态进化为空心双翼:双侧版』': True, '『缩水:减一缺员冫翅膀乊空心双翼乊变态退化』': True, '『缩水:减一缺员冫翅膀乊空心双翼乊均衡双翼:双侧版』': True, '『缩水:减一缺员冫翅膀乊厚势』': True, '『增长防板荡:增一溢出冫翅膀』': True, '『可疑』『增长防板荡:增一溢出冫光杆树乊变态进化为空心双翼:双侧版』': True, '『缩水防板荡:减一缺员冫翅膀乊空心双翼乊均衡双翼:双侧版』': False, '『缩水防板荡:减一缺员冫翅膀乊厚势』': True, '『消息盈虚防板荡:增一溢出冫翅膀』': True, '『消息盈虚防板荡:增一溢出冫光杆树乊变态进化为空心双翼:双侧版』': False, '『可疑』『消息盈虚防板荡:减一缺员冫翅膀乊空心双翼乊变态退化』': False, '『消息盈虚防板荡:减一缺员冫翅膀乊空心双翼乊均衡双翼:双侧版』': False, '『消息盈虚防板荡:减一缺员冫翅膀乊厚势』': True, '『增长合并:可表达性臫下沉:双侧版』': True, '『增长合并:节点数目上限存在性臫无限下沉:双侧版』': True, '『增长合并:合并光杆树冫连续压入』': True, '『缩水分裂:滴血重生断肢再造』': True, '『缩水分裂:抽取精血』': True}
True
>>> outputs == {'增长': True, '缩水': True, '增长防板荡': True, '缩水防板荡': False, '消息盈虚防板荡': False, '增长合并': True, '缩水分裂': True}
True

>>> (_inputs, _details, _outputs) = 计算展翅树参数配置所满足的条件扌(**dict(inputs, 光杆树最大许可长度=3, 翅膀缺员时退化上限=3))
>>> _outputs == {'增长': True, '缩水': True, '增长防板荡': True, '缩水防板荡': True, '消息盈虚防板荡': True, '增长合并': True, '缩水分裂': True}
True









>>> fails5_ = lambda outputs: sorted(k for k,b in outputs.items() if not b)


单侧版
>>> (_inputs, _details, _outputs) = 计算展翅树参数配置所满足的条件扌(**dict(inputs, 单侧版丷双侧版=False))
>>> _outputs == {'增长': True, '缩水': True, '增长防板荡': True, '缩水防板荡': True, '消息盈虚防板荡': True, '增长合并': False, '缩水分裂': True}
True
>>> fails5_(_outputs)
['增长合并']
>>> (_inputs, _details, _outputs) = 计算展翅树参数配置所满足的条件扌(**dict(inputs, 单侧版丷双侧版=False, 更深节点最大许可长度=2))
>>> fails5_(_outputs)
['增长合并']
>>> (_inputs, _details, _outputs) = 计算展翅树参数配置所满足的条件扌(**dict(inputs, 单侧版丷双侧版=False, 更深节点最大许可长度=2, 翅膀最大许可长度=3))
>>> fails5_(_outputs)
['增长合并']
>>> (_inputs, _details, _outputs) = 计算展翅树参数配置所满足的条件扌(**dict(inputs, 单侧版丷双侧版=False, 更深节点最大许可长度=2, 翅膀最大许可长度=2))
>>> fails5_(_outputs)
['增长合并', '消息盈虚防板荡']
>>> (_inputs, _details, _outputs) = 计算展翅树参数配置所满足的条件扌(**dict(inputs, 单侧版丷双侧版=False, 更深节点最大许可长度=2, 翅膀最大许可长度=1))
>>> fails5_(_outputs)
['增长', '增长合并', '增长防板荡', '消息盈虚防板荡', '缩水', '缩水分裂', '缩水防板荡']



>>> 

######################
######################
######################

from seed.data_funcs.finger_tree2.finger_tree_init import *
#]]]'''
__all__ = r'''
确认囗理论版囗暴力版囗结果一致冖冖求囗更深节点最大的不可表达节点数乊紧致假设扌
    求囗更深节点最大的不可表达节点数乊紧致假设冖冖理论版扌
    求囗更深节点最大的不可表达节点数乊紧致假设冖冖暴力版扌


计算展翅树参数配置所满足的条件扌
    检查约束囗双侧展翅树囗精简版配置冖冖紧致假设扌
    乸双侧展翅树囗参数配置囗囗紧致假设囗囗精简版
'''.split()#'''
__all__

from seed.data_funcs.finger_tree.finger_tree_common import 检查约束囗双侧展翅树囗配置囗 as _检查
from seed.types.NamespaceABC import StaticImmutableNamespaceBase

from seed.tiny_.check import check_uint_lt, check_int_ge_lt, check_int_ge, check_int_ge_le
from seed.tiny import check_type_is















__all__
def 确认囗理论版囗暴力版囗结果一致冖冖求囗更深节点最大的不可表达节点数乊紧致假设扌(更深节点最小许可长度囗范围, 更深节点最大许可长度囗对最小的差值范围, /):
    for 更深节点最小许可长度 in 更深节点最小许可长度囗范围:
        for 差值 in 更深节点最大许可长度囗对最小的差值范围:
            更深节点最大许可长度 = 更深节点最小许可长度 +差值
            print(更深节点最小许可长度, 更深节点最大许可长度)
            r0 = 求囗更深节点最大的不可表达节点数乊紧致假设冖冖理论版扌(更深节点最小许可长度, 更深节点最大许可长度, 输出覆盖=True)
            r1 = 求囗更深节点最大的不可表达节点数乊紧致假设冖冖暴力版扌(更深节点最小许可长度, 更深节点最大许可长度, 输出覆盖=True)
            assert r0 == r1, (更深节点最小许可长度, 更深节点最大许可长度, r0, r1)

__all__
def 求囗更深节点最大的不可表达节点数乊紧致假设冖冖理论版扌(更深节点最小许可长度, 更深节点最大许可长度, /, *, 输出覆盖=False):
    '[紧致假设==True]'
    check_int_ge(1, 更深节点最小许可长度)
    check_int_ge(更深节点最小许可长度+1, 更深节点最大许可长度)
    a, b = (更深节点最小许可长度, 更深节点最大许可长度)
    min_k = max(1, (b-2)//(b-a))
    更深节点最大的不可表达节点数 = (min_k*a-1)
    if not 输出覆盖:
        return 更深节点最大的不可表达节点数
    #if a == 1:
    if b+1-a >= a:
        rngs = [(a, b+1)]
    else:
        if 0:
            rngs = [(k*a, k*b+1) for k in range(1, min_k)]
            rngs += [(min_k*a, (min_k+1)*b+1)]
        else:
            rngs = [(k*a, k*b+1) for k in range(1, min_k+1)]
    return (更深节点最大的不可表达节点数, rngs)

__all__
def 求囗更深节点最大的不可表达节点数乊紧致假设冖冖暴力版扌(更深节点最小许可长度, 更深节点最大许可长度, /, *, 输出覆盖=False):
    '[紧致假设==True]'
    from heapq import heappop, heappush
    #check_int_ge(2, 更深节点最小许可长度)
    check_int_ge(1, 更深节点最小许可长度)
    check_int_ge(更深节点最小许可长度+1, 更深节点最大许可长度)
        # [gcd(min, min+1)==1] ==>> [存在 更深节点最大的不可表达节点数]
    def len_rng(rng, /):
        a, b = rng
        return b-a
    def add(rngL, rngR, /):
        return (rngL[0]+rngR[0]), (rngL[1]+rngR[1]-1)
    def put(rngs, rng, /):
        assert len_rng(rng) >= 1
        if rngs:
            rng_ = rngs[-1]
            assert rng_ <= rng
            if rng_[1] >= rng[0]:
                rngs.pop()
                rng = (rng_[0], max(rng_[1], rng[1]))
        rngs.append(rng)

    rngs = []
        #已排序
        #无重叠
        #无接触
        #未出现 len_rng(rng)>=更深节点最小许可长度
    rng = (更深节点最小许可长度, 更深节点最大许可长度+1)
    all_rngs_set = set()
    heap = [rng]
    while heap:
        rng = heappop(heap)
        put(rngs, rng)
        if len_rng(rngs[-1]) >= 更深节点最小许可长度:
            break
        for rng_ in rngs:
            _rng = add(rng_, rng)
            if _rng in all_rngs_set:
                continue
            all_rngs_set.add(_rng)
            #if 0b0001:print(len(all_rngs_set), _rng)
            #
            heappush(heap, _rng)
    ######################
    更深节点最大的不可表达节点数 = rngs[-1][0] -1
    if not 输出覆盖:
        return 更深节点最大的不可表达节点数
    return (更深节点最大的不可表达节点数, rngs)
















__all__
def 计算展翅树参数配置所满足的条件扌(*
    ,单侧版丷双侧版
    ,可疑
    #total 7
    ,更深节点最小许可长度
    ,更深节点最大许可长度
    ,更深节点最优许可长度
    ,翅膀最小许可长度
    ,翅膀最大许可长度
    ,光杆树最大许可长度
    ,翅膀缺员时退化上限
    ):
    #inputs = {**locals()}
    inputs = dict(locals())
    ######################
    check_type_is(bool, 单侧版丷双侧版)
    check_type_is(bool, 可疑)
    check_type_is(int, 更深节点最小许可长度)
    check_type_is(int, 更深节点最大许可长度)
    check_type_is(int, 更深节点最优许可长度)
    check_type_is(int, 翅膀最小许可长度)
    check_type_is(int, 翅膀最大许可长度)
    check_type_is(int, 光杆树最大许可长度)
    check_type_is(int, 翅膀缺员时退化上限)
    ######################
    ######################

    #* 必须:
    if not 0 <= 更深节点最小许可长度 <= 更深节点最优许可长度 <= 更深节点最大许可长度: raise TypeError
    if not 0 <= 翅膀最小许可长度 <= 翅膀最大许可长度: raise TypeError
    if not 0 <= 光杆树最大许可长度: raise TypeError
    if not 0 <= 翅膀缺员时退化上限: raise TypeError
    #必须 = True
    ######################
    d = {}
    details = d
    def all_(d, nm, /):
        d, 可疑
        prefixes = [f'『{nm}:']
        if 可疑:
            prefixes += [f'『可疑』『{nm}:']
        return all(b for k,b in d.items() if any(map(k.startswith, prefixes)))
    ######################
    #更深节点最大的不可表达节点数
    if 更深节点最小许可长度 < 更深节点最大许可长度:
        更深节点最大的不可表达节点数 = 求囗更深节点最大的不可表达节点数乊紧致假设冖冖理论版扌(更深节点最小许可长度, 更深节点最大许可长度)
    else:
        更深节点最大的不可表达节点数 = None#inf
    更深节点最大的不可表达节点数
    ######################
    nm4exclude = ...
    nm4exclude = set(locals())
    #if 0b0001:print(nm4exclude)
    ######################
    # %s/d『\(.*\)』\[\(.*\)\]/d['『\1』'] = (\2)
    ######################
    #* 增长
    d['『增长:增一溢出冫翅膀』'] = (翅膀最小许可长度 <= 翅膀最大许可长度+1-更深节点最优许可长度  <= 翅膀最大许可长度)
    if 单侧版丷双侧版:
        d['『增长:增一溢出冫光杆树乊变态进化为空心双翼:双侧版』'] = (2*翅膀最小许可长度 <= 光杆树最大许可长度+1 <= 2*翅膀最大许可长度)
    else:
        d['『增长:增一溢出冫光杆树乊变态进化为空心双翼:单侧版』'] = (翅膀最小许可长度 <= 光杆树最大许可长度+1 <= 翅膀最大许可长度)
    增长 = all_(d, '增长')
    ######################
    #* 缩水
    d['『缩水:减一缺员冫翅膀乊空心双翼乊变态退化』'] = (翅膀缺员时退化上限 <= 光杆树最大许可长度)
    if 单侧版丷双侧版:
        d['『缩水:减一缺员冫翅膀乊空心双翼乊均衡双翼:双侧版』'] = (翅膀最小许可长度 <= 翅膀缺员时退化上限+1-翅膀最小许可长度 <= 翅膀最大许可长度)
    else:
        #『缩水:减一缺员冫翅膀乊空心双翼乊均衡双翼:单侧版不存在』None
        pass
    d['『缩水:减一缺员冫翅膀乊厚势』'] = (翅膀最小许可长度 <= 翅膀最小许可长度-1+更深节点最小许可长度 <= 翅膀最小许可长度-1+更深节点最大许可长度 <= 翅膀最大许可长度)
    缩水 = all_(d, '缩水')
    ######################
    #* 增长防板荡
    d['『增长防板荡:增一溢出冫翅膀』'] = (翅膀最小许可长度 <= 翅膀最大许可长度+1-更深节点最优许可长度 <= 翅膀最大许可长度-1)
    if 单侧版丷双侧版:
        d['『可疑』『增长防板荡:增一溢出冫光杆树乊变态进化为空心双翼:双侧版』'] = (2*翅膀最小许可长度 <= 光杆树最大许可长度+1 <= 2*(翅膀最大许可长度-1))
    else:
        d['『可疑』『增长防板荡:增一溢出冫光杆树乊变态进化为空心双翼:单侧版』'] = (翅膀最小许可长度 <= 光杆树最大许可长度+1 <= 翅膀最大许可长度-1)
    增长防板荡 = all_(d, '增长防板荡')
    ######################
    #* 可疑
    ######################
    #* 缩水防板荡
    if 单侧版丷双侧版:
        d['『缩水防板荡:减一缺员冫翅膀乊空心双翼乊均衡双翼:双侧版』'] = (翅膀最小许可长度+1 <= 翅膀缺员时退化上限+1-(翅膀最小许可长度+1) <= 翅膀最大许可长度)
    else:
        #『缩水防板荡:减一缺员冫翅膀乊空心双翼乊均衡双翼:单侧版不存在』None
        pass
    d['『缩水防板荡:减一缺员冫翅膀乊厚势』'] = (翅膀最小许可长度+1 <= 翅膀最小许可长度-1+更深节点最小许可长度 <= 翅膀最小许可长度-1+更深节点最大许可长度 <= 翅膀最大许可长度)
    缩水防板荡 = all_(d, '缩水防板荡')
    ######################
    #* 消息盈虚防板荡
    d['『消息盈虚防板荡:增一溢出冫翅膀』'] = (翅膀最小许可长度+1 <= 翅膀最大许可长度+1-更深节点最优许可长度  <= 翅膀最大许可长度-1)
    if 单侧版丷双侧版:
        d['『消息盈虚防板荡:增一溢出冫光杆树乊变态进化为空心双翼:双侧版』'] = (2*(翅膀最小许可长度+1) <= 光杆树最大许可长度+1 <= 2*(翅膀最大许可长度-1))
    else:
        d['『消息盈虚防板荡:增一溢出冫光杆树乊变态进化为空心双翼:单侧版』'] = ((翅膀最小许可长度+1) <= 光杆树最大许可长度+1 <= (翅膀最大许可长度-1))
    d['『可疑』『消息盈虚防板荡:减一缺员冫翅膀乊空心双翼乊变态退化』'] = (翅膀缺员时退化上限 <= 光杆树最大许可长度-1)
    if 单侧版丷双侧版:
        d['『消息盈虚防板荡:减一缺员冫翅膀乊空心双翼乊均衡双翼:双侧版』'] = (翅膀最小许可长度+1 <= 翅膀缺员时退化上限+1-(翅膀最小许可长度+1) <= 翅膀最大许可长度-1)
    else:
        #『消息盈虚防板荡:减一缺员冫翅膀乊空心双翼乊均衡双翼:单侧版不存在』None
        pass
    d['『消息盈虚防板荡:减一缺员冫翅膀乊厚势』'] = (翅膀最小许可长度+1 <= 翅膀最小许可长度-1+更深节点最小许可长度 <= 翅膀最小许可长度-1+更深节点最大许可长度 <= 翅膀最大许可长度-1)
    消息盈虚防板荡 = all_(d, '消息盈虚防板荡')
    ######################
    #* 增长合并
    if 单侧版丷双侧版:
        d['『增长合并:可表达性臫下沉:双侧版』'] = (not 更深节点最大的不可表达节点数 is None) and (2*翅膀最小许可长度>=1+更深节点最大的不可表达节点数)
    else:
        d['『增长合并:可表达性臫下沉:单侧版』'] = (not 更深节点最大的不可表达节点数 is None) and (翅膀最小许可长度>=1+更深节点最大的不可表达节点数)
    if 单侧版丷双侧版:
        d['『增长合并:节点数目上限存在性臫无限下沉:双侧版』'] = (更深节点最小许可长度 >= 2)
        # [@[x>=2*翅膀最小许可长度] -> [(2*翅膀最小许可长度+x)//更深节点最小许可长度 <= x]]
    else:
        d['『增长合并:节点数目上限存在性臫无限下沉:单侧版』'] = (更深节点最小许可长度 >= 2)
        # [@[x>=翅膀最小许可长度] -> [(翅膀最小许可长度+x)//更深节点最小许可长度 <= x]]
        # 『最小』不是『最优』<<==拆分 不确定性
    d['『增长合并:合并光杆树冫连续压入』'] = 增长防板荡 #(要求:)
        #vs『可疑』『增长合并:合并光杆树冫单侧下沉丶断肢再造』[要求:???]
    增长合并 = all_(d, '增长合并')
    ######################
    #* 缩水分裂
    d['『缩水分裂:滴血重生断肢再造』'] = (翅膀最小许可长度+1 <= 0+更深节点最小许可长度 <= 翅膀最小许可长度-1+更深节点最大许可长度 <= 翅膀最大许可长度)
        # 最左『+1』是 不断上浮 连续 再造断翅 所需
    d['『缩水分裂:抽取精血』'] = 缩水 #(要求:)
    缩水分裂 = all_(d, '缩水分裂')
    ######################
    inputs
    details
    nm4exclude
    #outputs = {**locals()}
    outputs = dict(locals())
    for nm in nm4exclude:
        del outputs[nm]
    ######################
    #if 0b0001:print(nm4exclude)
    return (inputs, details, outputs)
#end-def 计算展翅树参数配置所满足的条件扌



__all__
def 检查约束囗双侧展翅树囗精简版配置冖冖紧致假设扌(*
    ,更深节点最小许可长度
    ,更深节点最大许可长度
    ,更深节点最优许可长度
    #,更深节点许可长度集合
    #,更深节点最大的不可表达节点数
    ,翅膀最小许可长度
    ,翅膀最大许可长度
    #,翅膀溢出时分裂出的更深节点的各自长度
    #,翅膀溢出时分裂出的节点的数目
    #??,翅膀溢出时分裂出的更深节点的数目
    #,光杆树最小许可长度
    #,光杆树溢出时分裂出的双翼的长度
    #,光杆树溢出时分裂出的更深节点的各自长度
    #,光杆树溢出时分裂出的中间节点的数目
    #,光杆树溢出时分裂出的更深节点的数目
    ,光杆树最大许可长度
    ,翅膀缺员时退化上限
        #翅膀缺员时退化上限 = 光杆树最大许可长度 -bool(消息盈虚防板荡 and 可疑)
    ######################
    ,优先支持对半搜索
    #,紧致假设
    ,增长
    ,缩水
    ,增长防板荡
    ,可疑
    ,缩水防板荡
    ,消息盈虚防板荡
    ,增长合并
    ,缩水分裂
    ):
    '-> None'
    # '-> 翅膀缺员时退化上限'
    ######################
    更深节点许可长度集合 = range(更深节点最小许可长度, 更深节点最大许可长度+1)
    if 更深节点最小许可长度 < 更深节点最大许可长度:
        更深节点最大的不可表达节点数 = 求囗更深节点最大的不可表达节点数乊紧致假设冖冖理论版扌(更深节点最小许可长度, 更深节点最大许可长度)
    else:
        更深节点最大的不可表达节点数 = None#inf
    更深节点最大的不可表达节点数

    if not 增长合并:
        # MAY_BE: [更深节点最小许可长度==更深节点最大许可长度]
        pass

    ######################
    翅膀溢出时分裂出的更深节点的数目 = 1
        # ???
    翅膀溢出时分裂出的更深节点的各自长度 = (更深节点最优许可长度,)*翅膀溢出时分裂出的更深节点的数目
    翅膀溢出时分裂出的节点的数目= sum(翅膀溢出时分裂出的更深节点的各自长度)

    ######################
    光杆树最小许可长度 = 0
    光杆树溢出时分裂出的双翼的长度 = (光杆树最大许可长度//2, (光杆树最大许可长度+1)//2)
    光杆树溢出时分裂出的更深节点的各自长度 = ()
    光杆树溢出时分裂出的中间节点的数目 = 0
    光杆树溢出时分裂出的更深节点的数目 = 0
    ######################
    #翅膀缺员时退化上限 = 光杆树最大许可长度
        # ???
    #翅膀缺员时退化上限 = 光杆树最大许可长度 -bool(消息盈虚防板荡 and 可疑)
    紧致假设 = True
    kw = {**locals()}
    ######################
    _检查(**kw)
    if 消息盈虚防板荡 and 可疑:
        assert 翅膀缺员时退化上限 == 光杆树最大许可长度 - 1
    else:
        assert 翅膀缺员时退化上限 == 光杆树最大许可长度
    ######################

    return None
    return 翅膀缺员时退化上限
    return kw

__all__
class 乸双侧展翅树囗参数配置囗囗紧致假设囗囗精简版(StaticImmutableNamespaceBase
    #total 16==7+9
    , ordered_user_attr_seq = r'''
    更深节点最小许可长度
    更深节点最大许可长度
    更深节点最优许可长度
    翅膀最小许可长度
    翅膀最大许可长度
    光杆树最大许可长度
    翅膀缺员时退化上限
    优先支持对半搜索
    增长
    缩水
    增长防板荡
    可疑
    缩水防板荡
    消息盈虚防板荡
    增长合并
    缩水分裂
    '''.split()#'''
    ):
    r'''
    紧致假设:goto
    『紧致假设:』[更深节点许可长度集合 == {更深节点最小许可长度..=更深节点最大许可长度}]

    '''#'''
    __slots__ = ()
    def __init__(sf, /, **kwds):
        检查约束囗双侧展翅树囗精简版配置冖冖紧致假设扌(**kwds)

#end-class 乸双侧展翅树囗参数配置囗囗紧致假设囗囗精简版


__all__
def __():
    from seed.tiny import ifNonef, ifNone, echo
    from seed.tiny import check_type_is, fst, snd, at
    from seed.tiny_.check import check_uint_lt, check_int_ge_lt, check_int_ge, check_int_ge_le
    from seed.tiny import print_err, mk_fprint, mk_assert_eq_f, expectError
    from seed.func_tools.fmapT.fmapT__tiny import dot, fmapT__dict, fmapT__list, fmapT__iter
    from seed.helper.repr_input import repr_helper

def __():
    from seed.abc.abc__ver1 import abstractmethod, override, ABC, ABC__no_slots
    from seed.helper.repr_input import repr_helper
    class _(ABC):
        __slots__ = ()
        raise NotImplementedError
        ___no_slots_ok___ = True
        def __repr__(sf, /):
            #return repr_helper(sf, *args, **kwargs)
            #return repr_helper_ex(sf, args, ordered_attrs, kwargs, ordered_attrs_only=False)
            ...
if __name__ == "__main__":
    pass
__all__


from seed.data_funcs.finger_tree2.finger_tree_init import *
