#__all__:goto
# TODO:魖匞度量值.减左/减右
# TODO:构造器 ++度量值
# TODO:罓欤切换回默认算法
r'''[[[
e ../../python3_src/seed/data_funcs/finger_tree__ABC.py
view ../../python3_src/seed/data_funcs/finger_trees.py
    # [:综述冫各版本具象类纟展翅树]:goto

[[
命名规范:
标识名后缀约束声明:
    * 分号之前:虚拟成员:
        展翅树{深度;}
        节点序列{深度,左起丷右起;}
    * 分号之后:真实成员:
        翅膀{深度;左翼丷右翼}

]]


py -m seed.data_funcs.finger_tree__ABC
py -m nn_ns.app.debug_cmd   seed.data_funcs.finger_tree__ABC -x
py -m nn_ns.app.doctest_cmd seed.data_funcs.finger_tree__ABC:__doc__ -ht
py -m nn_ns.app.doctest_cmd seed.data_funcs.finger_tree__ABC:__doc__ -ht  > /sdcard/0my_files/tmp/out4py/seed.data_funcs.finger_tree__ABC..doctest.out.txt
view /sdcard/0my_files/tmp/out4py/seed.data_funcs.finger_tree__ABC..doctest.out.txt





#>>> for nm, nms in _列出冫重要属性纟所有类型扌():
...     print(nm)
...     print(nms)
魖元素节点
['元素', '度量值', '拆包冫元素节点扌']
魖光杆树
['分裂乊节点扌', '分裂乊节点间隙扌', '匞展翅树', '压入扌', '取冫节点巛路径扌', '合并牜间夹序列扌', '度量值', '弹出扌', '搜索定位冫节点扌', '枚举冫节点扌', '欤光杆', '欤空树', '测距冫节点乊起端扌', '节点数']
魖匞展翅树
['匞度量值', '毶展翅树', '构造冫元素节点扌', '构造冫光杆树扌', '构造冫右翼扌', '构造冫展翅树扌', '构造冫左翼扌', '构造冫更深节点扌', '构造冫根深树乊左右扌', '构造冫根深树乊起讫扌', '构造冫空树扌', '构造冫翅膀扌']
魖匞度量值
['结合冫度量值扌', '零度量值']
魖右翼
['匞展翅树', '取冫节点巛路径扌', '外端压入扌', '外端弹出乊濒危扌', '外端弹出乊足员扌', '左翼丷右翼', '度量值', '搜索定位冫节点扌', '枚举冫节点扌', '欤满员', '欤濒危', '测距冫节点乊起端扌', '节点数']
魖含冫度量值
['度量值']
魖展翅树
['分裂乊节点扌', '分裂乊节点间隙扌', '匞展翅树', '压入扌', '取冫节点巛路径扌', '合并牜间夹序列扌', '度量值', '弹出扌', '搜索定位冫节点扌', '枚举冫节点扌', '欤光杆', '欤空树']
魖左翼
['匞展翅树', '取冫节点巛路径扌', '外端压入扌', '外端弹出乊濒危扌', '外端弹出乊足员扌', '左翼丷右翼', '度量值', '搜索定位冫节点扌', '枚举冫节点扌', '欤满员', '欤濒危', '测距冫节点乊起端扌', '节点数']
魖更深节点
['匞展翅树', '取冫节点巛路径扌', '度量值', '搜索定位冫节点扌', '枚举冫节点扌', '测距冫节点乊起端扌', '节点数']
魖根深树
['分裂乊节点扌', '分裂乊节点间隙扌', '匞展翅树', '压入扌', '取冫节点巛路径扌', '合并牜间夹序列扌', '度量值', '弹出扌', '拆包冫根深树乊左右扌', '拆包冫根深树乊起讫扌', '搜索定位冫节点扌', '枚举冫节点扌', '枚举冫部件扌', '欤光杆', '欤空树', '部件数']
魖翅膀
['匞展翅树', '取冫节点巛路径扌', '外端压入扌', '外端弹出乊濒危扌', '外端弹出乊足员扌', '左翼丷右翼', '度量值', '搜索定位冫节点扌', '枚举冫节点扌', '欤满员', '欤濒危', '测距冫节点乊起端扌', '节点数']
魖节点
['度量值']





#>>> sorted(魖匞展翅树牜通用具现.__abstractmethods__)
#>>> sorted(魖左翼牜通用具现.__abstractmethods__)
#>>> sorted(魖光杆树牜通用具现.__abstractmethods__)
#>>> sorted(魖根深树牜通用具现.__abstractmethods__)

>>> sorted(魖匞展翅树牜通用具现.__abstractmethods__)
['匞度量值', '构造冫元素节点扌', '构造冫光杆树扌', '构造冫右翼扌', '构造冫左翼扌', '构造冫更深节点扌', '构造冫根深树乊左右扌', '毶展翅树']

>>> sorted(魖左翼牜通用具现.__abstractmethods__)
['匞展翅树', '取冫节点丶度量值巛路径扌', '取冫节点巛路径扌', '度量值', '搜索定位冫节点扌', '枚举冫节点扌', '枚举冫路径丶节点丶度量值扌', '测距冫节点乊起端扌', '节点数']

>>> sorted(魖光杆树牜通用具现.__abstractmethods__)
['匞展翅树', '取冫节点丶度量值巛路径扌', '取冫节点巛路径扌', '度量值', '搜索定位冫节点扌', '枚举冫节点扌', '枚举冫路径丶节点丶度量值扌', '测距冫节点乊起端扌', '节点数']

>>> sorted(魖根深树牜通用具现.__abstractmethods__)
['分裂乊节点扌', '匞展翅树', '取冫部件丶度量值巛扁索引扌', '取冫部件巛扁索引扌', '度量值', '枚举冫扁索引丶部件丶度量值扌', '枚举冫部件扌', '测距冫部件乊起端扌', '解读冫部件类别牜搜索定位扌', '部件数']




#>>> sorted(魖翅膀牜特化具现爫部件即节点.__abstractmethods__)
#>>> sorted(魖左翼牜特化具现爫部件即节点.__abstractmethods__)
#>>> sorted(魖更深节点牜特化具现爫部件即节点.__abstractmethods__)
#>>> sorted(魖光杆树牜特化具现爫部件即节点.__abstractmethods__)
#>>> sorted(魖根深树牜特化具现爫魖路径纟节点牜部件容器暨节点容器.__abstractmethods__)



>>> sorted(魖翅膀牜特化具现爫部件即节点.__abstractmethods__)
['匞展翅树', '取冫部件丶度量值巛扁索引扌', '取冫部件巛扁索引扌', '左翼丷右翼', '度量值', '枚举冫扁索引丶部件丶度量值扌', '枚举冫部件扌', '测距冫部件乊起端扌', '部件数']

>>> sorted(魖左翼牜特化具现爫部件即节点.__abstractmethods__)
['匞展翅树', '取冫部件丶度量值巛扁索引扌', '取冫部件巛扁索引扌', '度量值', '枚举冫扁索引丶部件丶度量值扌', '枚举冫部件扌', '测距冫部件乊起端扌', '部件数']

>>> sorted(魖更深节点牜特化具现爫部件即节点.__abstractmethods__)
['匞展翅树', '取冫部件丶度量值巛扁索引扌', '取冫部件巛扁索引扌', '度量值', '枚举冫扁索引丶部件丶度量值扌', '枚举冫部件扌', '测距冫部件乊起端扌', '部件数']

>>> sorted(魖光杆树牜特化具现爫部件即节点.__abstractmethods__)
['匞展翅树', '取冫部件丶度量值巛扁索引扌', '取冫部件巛扁索引扌', '度量值', '枚举冫扁索引丶部件丶度量值扌', '枚举冫部件扌', '测距冫部件乊起端扌', '部件数']

>>> sorted(魖根深树牜特化具现爫魖路径纟节点牜部件容器暨节点容器.__abstractmethods__)
['匞展翅树', '取冫部件丶度量值巛扁索引扌', '取冫部件巛扁索引扌', '度量值', '枚举冫扁索引丶部件丶度量值扌', '枚举冫部件扌', '测距冫部件乊起端扌', '解读冫部件类别牜搜索定位扌', '部件数']










#>>> sorted(魖根深树牜元组具现爫魖路径纟节点牜部件容器暨节点容器.__abstractmethods__)
#>>> sorted(魖光杆树牜元组具现爫部件即节点.__abstractmethods__)
#>>> sorted(魖翅膀牜元组具现爫部件即节点.__abstractmethods__)
#>>> sorted(魖左翼牜元组具现爫部件即节点.__abstractmethods__)
#>>> sorted(魖右翼牜元组具现爫部件即节点.__abstractmethods__)
#>>> sorted(魖更深节点牜元组具现爫部件即节点.__abstractmethods__)
#>>> sorted(魖元素节点牜元组具现.__abstractmethods__)

>>> sorted(魖根深树牜元组具现爫魖路径纟节点牜部件容器暨节点容器.__abstractmethods__)
['罒类忄取冫匞展翅树扌']

>>> sorted(魖光杆树牜元组具现爫部件即节点.__abstractmethods__)
['罒类忄取冫匞展翅树扌']

>>> sorted(魖翅膀牜元组具现爫部件即节点.__abstractmethods__)
['左翼丷右翼', '罒类忄取冫匞展翅树扌']

>>> sorted(魖左翼牜元组具现爫部件即节点.__abstractmethods__)
['罒类忄取冫匞展翅树扌']

>>> sorted(魖右翼牜元组具现爫部件即节点.__abstractmethods__)
['罒类忄取冫匞展翅树扌']

>>> sorted(魖更深节点牜元组具现爫部件即节点.__abstractmethods__)
['罒类忄取冫匞展翅树扌']

>>> sorted(魖元素节点牜元组具现.__abstractmethods__)
['罒类忄取冫匞展翅树扌']











#>>> sorted(魖节点容器牜搜索定位.__abstractmethods__)
#>>> sorted(魖元素容器爫展翅树.__abstractmethods__)
#>>> sorted(魖元素容器爫展翅树牜通用具现.__abstractmethods__)


>>> sorted(魖节点容器牜搜索定位.__abstractmethods__)
['取冫节点丶度量值巛路径扌', '取冫节点巛路径扌', '度量值', '搜索定位冫节点扌', '枚举冫节点扌', '枚举冫路径丶节点丶度量值扌']
>>> sorted(魖元素容器爫展翅树牜通用具现.__abstractmethods__)
['展翅树乊底层', '罒类忄包装冫展翅树乊底层扌', '罒类忄取冫匞展翅树扌', '罒类忄度量值巛元素扌']


# [:纯虚函数冫魖元素容器爫展翅树]:here
>>> sorted(魖元素容器爫展翅树.__abstractmethods__)
['__bool__', '__iter__', '__reversed__', '分裂乊元素扌', '分裂乊元素间隙扌', '压入冫元素序列扌', '压入冫元素序列牜计长度扌', '压入冫元素扌', '取冫元素丶度量值巛路径扌', '取冫元素巛路径扌', '取冫端点元素扌', '右端元素', '合并扌', '合并灬扌', '同端弹压冫元素扌', '展翅树乊底层', '左端元素', '度量值', '异端压弹冫元素序列扌', '异端压弹冫元素扌', '弹出冫元素列表扌', '弹出冫元素扌', '搜索定位冫元素扌', '枚举冫元素丶度量值扌', '枚举冫元素扌', '枚举冫路径丶元素丶度量值扌', '类忄合并牜序列扌', '类忄构造冫展翅树丶总长扌', '类忄构造冫空树扌', '罒类忄包装冫展翅树乊底层扌', '罒类忄取冫匞展翅树扌', '罒类忄度量值巛元素扌']




>>> 树 = 乸元素容器爫展翅树牜度量值为长度()
>>> 树
乸元素容器爫展翅树牜度量值为长度()
>>> from itertools import accumulate
>>> f = lambda 树, xs, b: list(accumulate(xs, lambda sf, x:sf.压入冫元素扌(x, 左端丷右端=b), initial=树))
>>> ls = f(树, range(20), False)
>>> rs = f(树, range(-20,0), True)
>>> bool(ls[0])
False
>>> len(ls[0])
0
>>> bool(ls[-1])
True
>>> len(ls[-1])
20
>>> [*iter(ls[-1])]
[19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
>>> [*reversed(ls[-1])]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
>>> ls[-1]
乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])
>>> ls[-1].左端元素
19
>>> ls[-1].右端元素
0
>>> ls[-1].取冫端点元素扌(左端丷右端=False)
19
>>> ls[-1].取冫端点元素扌(左端丷右端=True)
0
>>> print(ls[7])
乸元素容器爫展翅树牜度量值为长度(None, 乸根深树(乸左翼(乸元素节点(1, 6), 乸元素节点(1, 5), 乸元素节点(1, 4), 乸元素节点(1, 3)), 乸光杆树(), 乸右翼(乸元素节点(1, 2), 乸元素节点(1, 1), 乸元素节点(1, 0))))
>>> rs[-1]
乸元素容器爫展翅树牜度量值为长度([-20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1])
>>> def g(sf, b, /):
...     while sf:
...         sf, x = sf.弹出冫元素扌(左端丷右端=b)
...         yield x
>>> [*g(ls[-1], False)]
[19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
>>> [*g(ls[-1], True)]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]

#>>> ls[9].同端弹压冫元素扌(999, 左端丷右端=False)
#>>> ls[9].同端弹压冫元素扌(999, 左端丷右端=True)
#>>> ls[9].异端压弹冫元素扌(999, 左出丷右出=False)
#>>> ls[9].异端压弹冫元素扌(999, 左出丷右出=True)
#>>> ls[9].异端压弹冫元素序列扌([777,999], 左出丷右出=False)
#>>> ls[9].异端压弹冫元素序列扌([777,999], 左出丷右出=True)

#>>> ls[9].压入冫元素序列扌([777,999], 左端丷右端=False, 左起丷右起=False)
#>>> ls[9].压入冫元素序列扌([777,999], 左端丷右端=False, 左起丷右起=True)
#>>> ls[9].压入冫元素序列扌([777,999], 左端丷右端=True, 左起丷右起=False)
#>>> ls[9].压入冫元素序列扌([777,999], 左端丷右端=True, 左起丷右起=True)
#>>> ls[6].弹出冫元素列表扌(2, 左端丷右端=False, 左起丷右起=False)
#>>> ls[6].弹出冫元素列表扌(2, 左端丷右端=False, 左起丷右起=True)
#>>> ls[6].弹出冫元素列表扌(2, 左端丷右端=True, 左起丷右起=False)
#>>> ls[6].弹出冫元素列表扌(2, 左端丷右端=True, 左起丷右起=True)
#
#>>> ls[6].弹出冫元素列表扌(9, 左端丷右端=False, 左起丷右起=False)
#>>> ls[6].弹出冫元素列表扌(9, 左端丷右端=False, 左起丷右起=True)
#>>> ls[6].弹出冫元素列表扌(9, 左端丷右端=True, 左起丷右起=False)
#>>> ls[6].弹出冫元素列表扌(9, 左端丷右端=True, 左起丷右起=True)
#
#>>> ls[6].弹出冫元素列表扌(None, 左端丷右端=False, 左起丷右起=False)
#>>> ls[6].弹出冫元素列表扌(None, 左端丷右端=False, 左起丷右起=True)
#>>> ls[6].弹出冫元素列表扌(None, 左端丷右端=True, 左起丷右起=False)
#>>> ls[6].弹出冫元素列表扌(None, 左端丷右端=True, 左起丷右起=True)

>>> ls[9].同端弹压冫元素扌(999, 左端丷右端=False)
(乸元素容器爫展翅树牜度量值为长度([999, 7, 6, 5, 4, 3, 2, 1, 0]), 8)
>>> ls[9].同端弹压冫元素扌(999, 左端丷右端=True)
(乸元素容器爫展翅树牜度量值为长度([8, 7, 6, 5, 4, 3, 2, 1, 999]), 0)
>>> ls[9].异端压弹冫元素扌(999, 左出丷右出=False)
(乸元素容器爫展翅树牜度量值为长度([7, 6, 5, 4, 3, 2, 1, 0, 999]), 8)
>>> ls[9].异端压弹冫元素扌(999, 左出丷右出=True)
(乸元素容器爫展翅树牜度量值为长度([999, 8, 7, 6, 5, 4, 3, 2, 1]), 0)
>>> ls[9].异端压弹冫元素序列扌([777,999], 左出丷右出=False)
(乸元素容器爫展翅树牜度量值为长度([6, 5, 4, 3, 2, 1, 0, 777, 999]), [8, 7])
>>> ls[9].异端压弹冫元素序列扌([777,999], 左出丷右出=True)
(乸元素容器爫展翅树牜度量值为长度([999, 777, 8, 7, 6, 5, 4, 3, 2]), [0, 1])

>>> ls[9].压入冫元素序列扌([777,999], 左端丷右端=False, 左起丷右起=False)
乸元素容器爫展翅树牜度量值为长度([777, 999, 8, 7, 6, 5, 4, 3, 2, 1, 0])
>>> ls[9].压入冫元素序列扌([777,999], 左端丷右端=False, 左起丷右起=True)
乸元素容器爫展翅树牜度量值为长度([999, 777, 8, 7, 6, 5, 4, 3, 2, 1, 0])
>>> ls[9].压入冫元素序列扌([777,999], 左端丷右端=True, 左起丷右起=False)
乸元素容器爫展翅树牜度量值为长度([8, 7, 6, 5, 4, 3, 2, 1, 0, 777, 999])
>>> ls[9].压入冫元素序列扌([777,999], 左端丷右端=True, 左起丷右起=True)
乸元素容器爫展翅树牜度量值为长度([8, 7, 6, 5, 4, 3, 2, 1, 0, 999, 777])


>>> ls[6].弹出冫元素列表扌(2, 左端丷右端=False, 左起丷右起=False)
(乸元素容器爫展翅树牜度量值为长度([3, 2, 1, 0]), [5, 4])
>>> ls[6].弹出冫元素列表扌(2, 左端丷右端=False, 左起丷右起=True)
(乸元素容器爫展翅树牜度量值为长度([3, 2, 1, 0]), [4, 5])
>>> ls[6].弹出冫元素列表扌(2, 左端丷右端=True, 左起丷右起=False)
(乸元素容器爫展翅树牜度量值为长度([5, 4, 3, 2]), [1, 0])
>>> ls[6].弹出冫元素列表扌(2, 左端丷右端=True, 左起丷右起=True)
(乸元素容器爫展翅树牜度量值为长度([5, 4, 3, 2]), [0, 1])

>>> ls[6].弹出冫元素列表扌(9, 左端丷右端=False, 左起丷右起=False)
(乸元素容器爫展翅树牜度量值为长度(), [5, 4, 3, 2, 1, 0])
>>> ls[6].弹出冫元素列表扌(9, 左端丷右端=False, 左起丷右起=True)
(乸元素容器爫展翅树牜度量值为长度(), [0, 1, 2, 3, 4, 5])
>>> ls[6].弹出冫元素列表扌(9, 左端丷右端=True, 左起丷右起=False)
(乸元素容器爫展翅树牜度量值为长度(), [5, 4, 3, 2, 1, 0])
>>> ls[6].弹出冫元素列表扌(9, 左端丷右端=True, 左起丷右起=True)
(乸元素容器爫展翅树牜度量值为长度(), [0, 1, 2, 3, 4, 5])

>>> ls[6].弹出冫元素列表扌(None, 左端丷右端=False, 左起丷右起=False)
(乸元素容器爫展翅树牜度量值为长度(), [5, 4, 3, 2, 1, 0])
>>> ls[6].弹出冫元素列表扌(None, 左端丷右端=False, 左起丷右起=True)
(乸元素容器爫展翅树牜度量值为长度(), [0, 1, 2, 3, 4, 5])
>>> ls[6].弹出冫元素列表扌(None, 左端丷右端=True, 左起丷右起=False)
(乸元素容器爫展翅树牜度量值为长度(), [5, 4, 3, 2, 1, 0])
>>> ls[6].弹出冫元素列表扌(None, 左端丷右端=True, 左起丷右起=True)
(乸元素容器爫展翅树牜度量值为长度(), [0, 1, 2, 3, 4, 5])

>>> ls[-1].合并扌(rs[-1])
乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, -20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1])
>>> rs[-1].合并扌(ls[-1])
乸元素容器爫展翅树牜度量值为长度([-20, -19, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])

    def 搜索定位冫元素扌(sf, 初始累计值, 累积扌, 进退判定扌, /, *, 左起丷右起, 欤已知非超后退, 欤已知非超前进):
>>> r = ls[-1].搜索定位冫元素扌(0, int.__add__, 6 .__ge__, 左起丷右起=False, 欤已知非超后退=False, 欤已知非超前进=False)
>>> r
(<筐搜索定位况型.匡路径全纟元素: 5>, (6, 乸路径全纟元素(False, 乸路径纟节点乊匡部件即更深节点容器(1, 乸路径纟节点乊匡部件即节点容器(0, 1), 1)), 13, 1, 7))

(匡路径全纟元素, (累计值牜前进, 路径全纟元素{;左起丷右起},焦点元素,度量值纟元素, 累计值牜后退))
>>> 路径全纟元素 = r[1][1]
>>> ls[-1].分裂乊元素扌(路径全纟元素)
(乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14]), 13, 乸元素容器爫展翅树牜度量值为长度([12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]))

>>> r = ls[-1].搜索定位冫元素扌(0, int.__add__, 6 .__ge__, 左起丷右起=True, 欤已知非超后退=False, 欤已知非超前进=False)
>>> r
(<筐搜索定位况型.匡路径全纟元素: 5>, (6, 乸路径全纟元素(True, 乸路径纟节点乊匡部件即更深节点容器(1, 乸路径纟节点乊匡部件即节点容器(0, 1), 1)), 6, 1, 7))

>>> 路径全纟元素 = r[1][1]
>>> ls[-1].分裂乊元素扌(路径全纟元素)
(乸元素容器爫展翅树牜度量值为长度([5, 4, 3, 2, 1, 0]), 6, 乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7]))



>>> [*ls[-1].枚举冫元素扌(左起丷右起=False)]
[19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
>>> [*ls[-1].枚举冫元素扌(左起丷右起=True)]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
>>> [*ls[-1].枚举冫元素丶度量值扌(左起丷右起=False)]
[(19, 1), (18, 1), (17, 1), (16, 1), (15, 1), (14, 1), (13, 1), (12, 1), (11, 1), (10, 1), (9, 1), (8, 1), (7, 1), (6, 1), (5, 1), (4, 1), (3, 1), (2, 1), (1, 1), (0, 1)]
>>> [*ls[-1].枚举冫元素丶度量值扌(左起丷右起=True)]
[(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 1), (9, 1), (10, 1), (11, 1), (12, 1), (13, 1), (14, 1), (15, 1), (16, 1), (17, 1), (18, 1), (19, 1)]

>>> def h(sf, LR, /):
...     it = sf.枚举冫路径丶元素丶度量值扌(左起丷右起=LR)
...     for 路径全纟元素, 元素, 度量值 in it:
...         print(路径全纟元素)
...         print((元素, 度量值))
...         a, x, b = sf.分裂乊元素扌(路径全纟元素)
...         print((a, x, b))
...         assert sf.取冫元素巛路径扌(路径全纟元素) == x == 元素
...         assert sf.取冫元素丶度量值巛路径扌(路径全纟元素) == (元素,度量值)
...         a, b = sf.分裂乊元素间隙扌(路径全纟元素)
...         print((a, b))
...         print([a.合并扌(b)])
...         print([b.合并扌(a)])
...         print('='*9)

#>>> h(ls[-1], False)
#>>> h(ls[-1], True)
>>> h(ls[-1], False)
乸路径全纟元素(False, 乸路径纟节点乊匡部件即节点容器(0, 0))
(19, 1)
(乸元素容器爫展翅树牜度量值为长度(), 19, 乸元素容器爫展翅树牜度量值为长度([18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]))
(乸元素容器爫展翅树牜度量值为长度(), 乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]))
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
=========
乸路径全纟元素(False, 乸路径纟节点乊匡部件即节点容器(0, 1))
(18, 1)
(乸元素容器爫展翅树牜度量值为长度([19]), 18, 乸元素容器爫展翅树牜度量值为长度([17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]))
(乸元素容器爫展翅树牜度量值为长度([19]), 乸元素容器爫展翅树牜度量值为长度([18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]))
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
[乸元素容器爫展翅树牜度量值为长度([18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 19])]
=========
乸路径全纟元素(False, 乸路径纟节点乊匡部件即节点容器(0, 2))
(17, 1)
(乸元素容器爫展翅树牜度量值为长度([19, 18]), 17, 乸元素容器爫展翅树牜度量值为长度([16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]))
(乸元素容器爫展翅树牜度量值为长度([19, 18]), 乸元素容器爫展翅树牜度量值为长度([17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]))
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
[乸元素容器爫展翅树牜度量值为长度([17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 19, 18])]
=========
乸路径全纟元素(False, 乸路径纟节点乊匡部件即更深节点容器(1, 乸路径纟节点乊匡部件即节点容器(0, 0), 0))
(16, 1)
(乸元素容器爫展翅树牜度量值为长度([19, 18, 17]), 16, 乸元素容器爫展翅树牜度量值为长度([15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]))
(乸元素容器爫展翅树牜度量值为长度([19, 18, 17]), 乸元素容器爫展翅树牜度量值为长度([16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]))
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
[乸元素容器爫展翅树牜度量值为长度([16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 19, 18, 17])]
=========
乸路径全纟元素(False, 乸路径纟节点乊匡部件即更深节点容器(1, 乸路径纟节点乊匡部件即节点容器(0, 0), 1))
(15, 1)
(乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16]), 15, 乸元素容器爫展翅树牜度量值为长度([14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]))
(乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16]), 乸元素容器爫展翅树牜度量值为长度([15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]))
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
[乸元素容器爫展翅树牜度量值为长度([15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 19, 18, 17, 16])]
=========
乸路径全纟元素(False, 乸路径纟节点乊匡部件即更深节点容器(1, 乸路径纟节点乊匡部件即节点容器(0, 1), 0))
(14, 1)
(乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15]), 14, 乸元素容器爫展翅树牜度量值为长度([13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]))
(乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15]), 乸元素容器爫展翅树牜度量值为长度([14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]))
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
[乸元素容器爫展翅树牜度量值为长度([14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 19, 18, 17, 16, 15])]
=========
乸路径全纟元素(False, 乸路径纟节点乊匡部件即更深节点容器(1, 乸路径纟节点乊匡部件即节点容器(0, 1), 1))
(13, 1)
(乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14]), 13, 乸元素容器爫展翅树牜度量值为长度([12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]))
(乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14]), 乸元素容器爫展翅树牜度量值为长度([13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]))
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
[乸元素容器爫展翅树牜度量值为长度([13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 19, 18, 17, 16, 15, 14])]
=========
乸路径全纟元素(False, 乸路径纟节点乊匡部件即更深节点容器(1, 乸路径纟节点乊匡部件即节点容器(0, 2), 0))
(12, 1)
(乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13]), 12, 乸元素容器爫展翅树牜度量值为长度([11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]))
(乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13]), 乸元素容器爫展翅树牜度量值为长度([12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]))
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
[乸元素容器爫展翅树牜度量值为长度([12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 19, 18, 17, 16, 15, 14, 13])]
=========
乸路径全纟元素(False, 乸路径纟节点乊匡部件即更深节点容器(1, 乸路径纟节点乊匡部件即节点容器(0, 2), 1))
(11, 1)
(乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12]), 11, 乸元素容器爫展翅树牜度量值为长度([10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]))
(乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12]), 乸元素容器爫展翅树牜度量值为长度([11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]))
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
[乸元素容器爫展翅树牜度量值为长度([11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 19, 18, 17, 16, 15, 14, 13, 12])]
=========
乸路径全纟元素(False, 乸路径纟节点乊匡部件即更深节点容器(1, 乸路径纟节点乊匡部件即节点容器(0, 3), 0))
(10, 1)
(乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11]), 10, 乸元素容器爫展翅树牜度量值为长度([9, 8, 7, 6, 5, 4, 3, 2, 1, 0]))
(乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11]), 乸元素容器爫展翅树牜度量值为长度([10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]))
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
[乸元素容器爫展翅树牜度量值为长度([10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 19, 18, 17, 16, 15, 14, 13, 12, 11])]
=========
乸路径全纟元素(False, 乸路径纟节点乊匡部件即更深节点容器(1, 乸路径纟节点乊匡部件即节点容器(0, 3), 1))
(9, 1)
(乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10]), 9, 乸元素容器爫展翅树牜度量值为长度([8, 7, 6, 5, 4, 3, 2, 1, 0]))
(乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10]), 乸元素容器爫展翅树牜度量值为长度([9, 8, 7, 6, 5, 4, 3, 2, 1, 0]))
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
[乸元素容器爫展翅树牜度量值为长度([9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10])]
=========
乸路径全纟元素(False, 乸路径纟节点乊匡部件即更深节点容器(1, 乸路径纟节点乊匡部件即节点容器(2, 0), 0))
(8, 1)
(乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9]), 8, 乸元素容器爫展翅树牜度量值为长度([7, 6, 5, 4, 3, 2, 1, 0]))
(乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9]), 乸元素容器爫展翅树牜度量值为长度([8, 7, 6, 5, 4, 3, 2, 1, 0]))
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
[乸元素容器爫展翅树牜度量值为长度([8, 7, 6, 5, 4, 3, 2, 1, 0, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9])]
=========
乸路径全纟元素(False, 乸路径纟节点乊匡部件即更深节点容器(1, 乸路径纟节点乊匡部件即节点容器(2, 0), 1))
(7, 1)
(乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8]), 7, 乸元素容器爫展翅树牜度量值为长度([6, 5, 4, 3, 2, 1, 0]))
(乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8]), 乸元素容器爫展翅树牜度量值为长度([7, 6, 5, 4, 3, 2, 1, 0]))
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
[乸元素容器爫展翅树牜度量值为长度([7, 6, 5, 4, 3, 2, 1, 0, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8])]
=========
乸路径全纟元素(False, 乸路径纟节点乊匡部件即更深节点容器(1, 乸路径纟节点乊匡部件即节点容器(2, 1), 0))
(6, 1)
(乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7]), 6, 乸元素容器爫展翅树牜度量值为长度([5, 4, 3, 2, 1, 0]))
(乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7]), 乸元素容器爫展翅树牜度量值为长度([6, 5, 4, 3, 2, 1, 0]))
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
[乸元素容器爫展翅树牜度量值为长度([6, 5, 4, 3, 2, 1, 0, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7])]
=========
乸路径全纟元素(False, 乸路径纟节点乊匡部件即更深节点容器(1, 乸路径纟节点乊匡部件即节点容器(2, 1), 1))
(5, 1)
(乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6]), 5, 乸元素容器爫展翅树牜度量值为长度([4, 3, 2, 1, 0]))
(乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6]), 乸元素容器爫展翅树牜度量值为长度([5, 4, 3, 2, 1, 0]))
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
[乸元素容器爫展翅树牜度量值为长度([5, 4, 3, 2, 1, 0, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6])]
=========
乸路径全纟元素(False, 乸路径纟节点乊匡部件即更深节点容器(1, 乸路径纟节点乊匡部件即节点容器(2, 2), 0))
(4, 1)
(乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5]), 4, 乸元素容器爫展翅树牜度量值为长度([3, 2, 1, 0]))
(乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5]), 乸元素容器爫展翅树牜度量值为长度([4, 3, 2, 1, 0]))
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
[乸元素容器爫展翅树牜度量值为长度([4, 3, 2, 1, 0, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5])]
=========
乸路径全纟元素(False, 乸路径纟节点乊匡部件即更深节点容器(1, 乸路径纟节点乊匡部件即节点容器(2, 2), 1))
(3, 1)
(乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4]), 3, 乸元素容器爫展翅树牜度量值为长度([2, 1, 0]))
(乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4]), 乸元素容器爫展翅树牜度量值为长度([3, 2, 1, 0]))
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
[乸元素容器爫展翅树牜度量值为长度([3, 2, 1, 0, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4])]
=========
乸路径全纟元素(False, 乸路径纟节点乊匡部件即节点容器(2, 0))
(2, 1)
(乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3]), 2, 乸元素容器爫展翅树牜度量值为长度([1, 0]))
(乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3]), 乸元素容器爫展翅树牜度量值为长度([2, 1, 0]))
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
[乸元素容器爫展翅树牜度量值为长度([2, 1, 0, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3])]
=========
乸路径全纟元素(False, 乸路径纟节点乊匡部件即节点容器(2, 1))
(1, 1)
(乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]), 1, 乸元素容器爫展翅树牜度量值为长度([0]))
(乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]), 乸元素容器爫展翅树牜度量值为长度([1, 0]))
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
[乸元素容器爫展翅树牜度量值为长度([1, 0, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2])]
=========
乸路径全纟元素(False, 乸路径纟节点乊匡部件即节点容器(2, 2))
(0, 1)
(乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]), 0, 乸元素容器爫展翅树牜度量值为长度())
(乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]), 乸元素容器爫展翅树牜度量值为长度([0]))
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
[乸元素容器爫展翅树牜度量值为长度([0, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1])]
=========

>>> h(ls[-1], True)
乸路径全纟元素(True, 乸路径纟节点乊匡部件即节点容器(0, 0))
(0, 1)
(乸元素容器爫展翅树牜度量值为长度(), 0, 乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]))
(乸元素容器爫展翅树牜度量值为长度(), 乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]))
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
=========
乸路径全纟元素(True, 乸路径纟节点乊匡部件即节点容器(0, 1))
(1, 1)
(乸元素容器爫展翅树牜度量值为长度([0]), 1, 乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]))
(乸元素容器爫展翅树牜度量值为长度([0]), 乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]))
[乸元素容器爫展翅树牜度量值为长度([0, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1])]
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
=========
乸路径全纟元素(True, 乸路径纟节点乊匡部件即节点容器(0, 2))
(2, 1)
(乸元素容器爫展翅树牜度量值为长度([1, 0]), 2, 乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3]))
(乸元素容器爫展翅树牜度量值为长度([1, 0]), 乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]))
[乸元素容器爫展翅树牜度量值为长度([1, 0, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2])]
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
=========
乸路径全纟元素(True, 乸路径纟节点乊匡部件即更深节点容器(1, 乸路径纟节点乊匡部件即节点容器(0, 0), 0))
(3, 1)
(乸元素容器爫展翅树牜度量值为长度([2, 1, 0]), 3, 乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4]))
(乸元素容器爫展翅树牜度量值为长度([2, 1, 0]), 乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3]))
[乸元素容器爫展翅树牜度量值为长度([2, 1, 0, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3])]
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
=========
乸路径全纟元素(True, 乸路径纟节点乊匡部件即更深节点容器(1, 乸路径纟节点乊匡部件即节点容器(0, 0), 1))
(4, 1)
(乸元素容器爫展翅树牜度量值为长度([3, 2, 1, 0]), 4, 乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5]))
(乸元素容器爫展翅树牜度量值为长度([3, 2, 1, 0]), 乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4]))
[乸元素容器爫展翅树牜度量值为长度([3, 2, 1, 0, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4])]
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
=========
乸路径全纟元素(True, 乸路径纟节点乊匡部件即更深节点容器(1, 乸路径纟节点乊匡部件即节点容器(0, 1), 0))
(5, 1)
(乸元素容器爫展翅树牜度量值为长度([4, 3, 2, 1, 0]), 5, 乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6]))
(乸元素容器爫展翅树牜度量值为长度([4, 3, 2, 1, 0]), 乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5]))
[乸元素容器爫展翅树牜度量值为长度([4, 3, 2, 1, 0, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5])]
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
=========
乸路径全纟元素(True, 乸路径纟节点乊匡部件即更深节点容器(1, 乸路径纟节点乊匡部件即节点容器(0, 1), 1))
(6, 1)
(乸元素容器爫展翅树牜度量值为长度([5, 4, 3, 2, 1, 0]), 6, 乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7]))
(乸元素容器爫展翅树牜度量值为长度([5, 4, 3, 2, 1, 0]), 乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6]))
[乸元素容器爫展翅树牜度量值为长度([5, 4, 3, 2, 1, 0, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6])]
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
=========
乸路径全纟元素(True, 乸路径纟节点乊匡部件即更深节点容器(1, 乸路径纟节点乊匡部件即节点容器(0, 2), 0))
(7, 1)
(乸元素容器爫展翅树牜度量值为长度([6, 5, 4, 3, 2, 1, 0]), 7, 乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8]))
(乸元素容器爫展翅树牜度量值为长度([6, 5, 4, 3, 2, 1, 0]), 乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7]))
[乸元素容器爫展翅树牜度量值为长度([6, 5, 4, 3, 2, 1, 0, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7])]
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
=========
乸路径全纟元素(True, 乸路径纟节点乊匡部件即更深节点容器(1, 乸路径纟节点乊匡部件即节点容器(0, 2), 1))
(8, 1)
(乸元素容器爫展翅树牜度量值为长度([7, 6, 5, 4, 3, 2, 1, 0]), 8, 乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9]))
(乸元素容器爫展翅树牜度量值为长度([7, 6, 5, 4, 3, 2, 1, 0]), 乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8]))
[乸元素容器爫展翅树牜度量值为长度([7, 6, 5, 4, 3, 2, 1, 0, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8])]
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
=========
乸路径全纟元素(True, 乸路径纟节点乊匡部件即更深节点容器(1, 乸路径纟节点乊匡部件即节点容器(2, 0), 0))
(9, 1)
(乸元素容器爫展翅树牜度量值为长度([8, 7, 6, 5, 4, 3, 2, 1, 0]), 9, 乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10]))
(乸元素容器爫展翅树牜度量值为长度([8, 7, 6, 5, 4, 3, 2, 1, 0]), 乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9]))
[乸元素容器爫展翅树牜度量值为长度([8, 7, 6, 5, 4, 3, 2, 1, 0, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9])]
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
=========
乸路径全纟元素(True, 乸路径纟节点乊匡部件即更深节点容器(1, 乸路径纟节点乊匡部件即节点容器(2, 0), 1))
(10, 1)
(乸元素容器爫展翅树牜度量值为长度([9, 8, 7, 6, 5, 4, 3, 2, 1, 0]), 10, 乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11]))
(乸元素容器爫展翅树牜度量值为长度([9, 8, 7, 6, 5, 4, 3, 2, 1, 0]), 乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10]))
[乸元素容器爫展翅树牜度量值为长度([9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10])]
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
=========
乸路径全纟元素(True, 乸路径纟节点乊匡部件即更深节点容器(1, 乸路径纟节点乊匡部件即节点容器(2, 1), 0))
(11, 1)
(乸元素容器爫展翅树牜度量值为长度([10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]), 11, 乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12]))
(乸元素容器爫展翅树牜度量值为长度([10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]), 乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11]))
[乸元素容器爫展翅树牜度量值为长度([10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 19, 18, 17, 16, 15, 14, 13, 12, 11])]
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
=========
乸路径全纟元素(True, 乸路径纟节点乊匡部件即更深节点容器(1, 乸路径纟节点乊匡部件即节点容器(2, 1), 1))
(12, 1)
(乸元素容器爫展翅树牜度量值为长度([11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]), 12, 乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13]))
(乸元素容器爫展翅树牜度量值为长度([11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]), 乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12]))
[乸元素容器爫展翅树牜度量值为长度([11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 19, 18, 17, 16, 15, 14, 13, 12])]
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
=========
乸路径全纟元素(True, 乸路径纟节点乊匡部件即更深节点容器(1, 乸路径纟节点乊匡部件即节点容器(2, 2), 0))
(13, 1)
(乸元素容器爫展翅树牜度量值为长度([12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]), 13, 乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14]))
(乸元素容器爫展翅树牜度量值为长度([12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]), 乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13]))
[乸元素容器爫展翅树牜度量值为长度([12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 19, 18, 17, 16, 15, 14, 13])]
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
=========
乸路径全纟元素(True, 乸路径纟节点乊匡部件即更深节点容器(1, 乸路径纟节点乊匡部件即节点容器(2, 2), 1))
(14, 1)
(乸元素容器爫展翅树牜度量值为长度([13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]), 14, 乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15]))
(乸元素容器爫展翅树牜度量值为长度([13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]), 乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14]))
[乸元素容器爫展翅树牜度量值为长度([13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 19, 18, 17, 16, 15, 14])]
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
=========
乸路径全纟元素(True, 乸路径纟节点乊匡部件即更深节点容器(1, 乸路径纟节点乊匡部件即节点容器(2, 3), 0))
(15, 1)
(乸元素容器爫展翅树牜度量值为长度([14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]), 15, 乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16]))
(乸元素容器爫展翅树牜度量值为长度([14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]), 乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15]))
[乸元素容器爫展翅树牜度量值为长度([14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 19, 18, 17, 16, 15])]
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
=========
乸路径全纟元素(True, 乸路径纟节点乊匡部件即更深节点容器(1, 乸路径纟节点乊匡部件即节点容器(2, 3), 1))
(16, 1)
(乸元素容器爫展翅树牜度量值为长度([15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]), 16, 乸元素容器爫展翅树牜度量值为长度([19, 18, 17]))
(乸元素容器爫展翅树牜度量值为长度([15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]), 乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16]))
[乸元素容器爫展翅树牜度量值为长度([15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 19, 18, 17, 16])]
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
=========
乸路径全纟元素(True, 乸路径纟节点乊匡部件即节点容器(2, 0))
(17, 1)
(乸元素容器爫展翅树牜度量值为长度([16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]), 17, 乸元素容器爫展翅树牜度量值为长度([19, 18]))
(乸元素容器爫展翅树牜度量值为长度([16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]), 乸元素容器爫展翅树牜度量值为长度([19, 18, 17]))
[乸元素容器爫展翅树牜度量值为长度([16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 19, 18, 17])]
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
=========
乸路径全纟元素(True, 乸路径纟节点乊匡部件即节点容器(2, 1))
(18, 1)
(乸元素容器爫展翅树牜度量值为长度([17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]), 18, 乸元素容器爫展翅树牜度量值为长度([19]))
(乸元素容器爫展翅树牜度量值为长度([17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]), 乸元素容器爫展翅树牜度量值为长度([19, 18]))
[乸元素容器爫展翅树牜度量值为长度([17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 19, 18])]
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
=========
乸路径全纟元素(True, 乸路径纟节点乊匡部件即节点容器(2, 2))
(19, 1)
(乸元素容器爫展翅树牜度量值为长度([18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]), 19, 乸元素容器爫展翅树牜度量值为长度())
(乸元素容器爫展翅树牜度量值为长度([18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]), 乸元素容器爫展翅树牜度量值为长度([19]))
[乸元素容器爫展翅树牜度量值为长度([18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 19])]
[乸元素容器爫展翅树牜度量值为长度([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])]
=========
















######################
######################
######################
######################

[:list_attrs__IFingerTree]:goto
[:list_attrs__IFingerTree__wrapper]:goto
    underlying_tree
    __str__
    __repr__
    __hash__
    __eq__
    __new__
[:list_attrs__FingerTree__measurement_is_len]:goto
    slice_between
    split_at4value
    split_at4gap
    __getitem__


FingerTree__measurement_is_len
>>> t0 = FingerTree__measurement_is_len()
>>> print(t0)
FingerTree__measurement_is_len()
>>> t0
FingerTree__measurement_is_len()
>>> t0 is FingerTree__measurement_is_len()
True
>>> t0.measurement
0
>>> len(t0)
0
>>> bool(t0)
False
>>> [*iter(t0)]
[]
>>> [*reversed(t0)]
[]
>>> [*t0.iter_(reverse=False)]
[]
>>> [*t0.iter_(reverse=True)]
[]
>>> [*t0.iter_value_measurement_pairs_(reverse=False)]
[]
>>> [*t0.iter_value_measurement_pairs_(reverse=True)]
[]
>>> [*t0.iter_path_value_measurement_triples_(reverse=False)]
[]
>>> [*t0.iter_path_value_measurement_triples_(reverse=True)]
[]
>>> t0.ipush_(999, left_vs_right=False)
FingerTree__measurement_is_len([999])
>>> t0.ipush_(999, left_vs_right=True)
FingerTree__measurement_is_len([999])
>>> t0.ipop_(left_vs_right=False)
Traceback (most recent call last):
    ...
seed.data_funcs.finger_tree__errors.Error__empty_tree
>>> t0.ipop_(left_vs_right=True)
Traceback (most recent call last):
    ...
seed.data_funcs.finger_tree__errors.Error__empty_tree
>>> t0.get_endpoint_(left_vs_right=False)
Traceback (most recent call last):
    ...
seed.data_funcs.finger_tree__errors.Error__empty_tree
>>> t0.get_endpoint_(left_vs_right=True)
Traceback (most recent call last):
    ...
seed.data_funcs.finger_tree__errors.Error__empty_tree
>>> t0.first
Traceback (most recent call last):
    ...
seed.data_funcs.finger_tree__errors.Error__empty_tree
>>> t0.last
Traceback (most recent call last):
    ...
seed.data_funcs.finger_tree__errors.Error__empty_tree
>>> (t0 + t0) is t0
True
>>> FingerTree__measurement_is_len.mk_empty_tree() is t0
True
>>> _t0 = t0
>>> _t0 += t0
>>> _t0 is t0
True

>>> t0.join() is t0
True
>>> t0.join(t0, t0, t0) is t0
True

>>> FingerTree__measurement_is_len.joins([]) is t0
True
>>> FingerTree__measurement_is_len.joins([t0, t0, t0]) is t0
True

>>> t0.ipushs__([], left_vs_right=False, reverse=False) is t0
True
>>> t0.ipushs__([], left_vs_right=False, reverse=True) is t0
True
>>> t0.ipushs__([], left_vs_right=True, reverse=False) is t0
True
>>> t0.ipushs__([], left_vs_right=True, reverse=True) is t0
True

>>> t0.ipops_le__(0, left_vs_right=False, reverse=False)
(FingerTree__measurement_is_len(), [])
>>> t0.ipops_le__(0, left_vs_right=False, reverse=True)
(FingerTree__measurement_is_len(), [])
>>> t0.ipops_le__(0, left_vs_right=True, reverse=False)
(FingerTree__measurement_is_len(), [])
>>> t0.ipops_le__(0, left_vs_right=True, reverse=True)
(FingerTree__measurement_is_len(), [])

>>> t0.ipops_le__(1, left_vs_right=False, reverse=False)
(FingerTree__measurement_is_len(), [])
>>> t0.ipops_le__(1, left_vs_right=False, reverse=True)
(FingerTree__measurement_is_len(), [])
>>> t0.ipops_le__(1, left_vs_right=True, reverse=False)
(FingerTree__measurement_is_len(), [])
>>> t0.ipops_le__(1, left_vs_right=True, reverse=True)
(FingerTree__measurement_is_len(), [])


>>> t0.ipop_then_ipush_on_same_endpoint_(999, left_vs_right=False)
Traceback (most recent call last):
    ...
seed.data_funcs.finger_tree__errors.Error__empty_tree
>>> t0.ipop_then_ipush_on_same_endpoint_(999, left_vs_right=True)
Traceback (most recent call last):
    ...
seed.data_funcs.finger_tree__errors.Error__empty_tree

>>> t0.ipush_then_ipop_on_diff_endpoints_(999, leftward_vs_rightward=False)
(FingerTree__measurement_is_len(), 999)
>>> t0.ipush_then_ipop_on_diff_endpoints_(999, leftward_vs_rightward=True)
(FingerTree__measurement_is_len(), 999)

>>> t0.ipushs_then_ipops_on_diff_endpoints_([777, 999], leftward_vs_rightward=False)
(FingerTree__measurement_is_len(), [777, 999])
>>> t0.ipushs_then_ipops_on_diff_endpoints_([777, 999], leftward_vs_rightward=True)
(FingerTree__measurement_is_len(), [777, 999])


>>> t0.search_via_measurement___(0, int.__add__, (0).__ge__, reverse=False, known_non_underflow=False, known_non_overflow=False)
(True, 0)
>>> t0.search_via_measurement___(0, int.__add__, (0).__ge__, reverse=True, known_non_underflow=False, known_non_overflow=False)
(True, 0)

>>> t0.search_via_measurement___(0, int.__add__, (-1).__ge__, reverse=False, known_non_underflow=False, known_non_overflow=False)
(False, 0)
>>> t0.search_via_measurement___(0, int.__add__, (-1).__ge__, reverse=True, known_non_underflow=False, known_non_overflow=False)
(False, 0)
>>> t0.split4gap(False) == (t0, t0)
True
>>> t0.split4gap(True) == (t0, t0)
True



######################
######################
######################
>>> t6 = FingerTree__measurement_is_len(range(6))
>>> t3 = FingerTree__measurement_is_len([777,888,999])
>>> t2 = FingerTree__measurement_is_len([11,22])
>>> t0 = FingerTree__measurement_is_len()
>>> print(t6)
FingerTree__measurement_is_len(6, 乸元素容器爫展翅树牜度量值为长度([0, 1, 2, 3, 4, 5]))
>>> t6
FingerTree__measurement_is_len([0, 1, 2, 3, 4, 5])
>>> t3
FingerTree__measurement_is_len([777, 888, 999])
>>> t2
FingerTree__measurement_is_len([11, 22])
>>> t6.measurement
6
>>> len(t6)
6
>>> bool(t6)
True
>>> [*iter(t6)]
[0, 1, 2, 3, 4, 5]
>>> [*reversed(t6)]
[5, 4, 3, 2, 1, 0]
>>> [*t6.iter_(reverse=False)]
[0, 1, 2, 3, 4, 5]
>>> [*t6.iter_(reverse=True)]
[5, 4, 3, 2, 1, 0]
>>> [*t6.iter_value_measurement_pairs_(reverse=False)]
[(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]
>>> [*t6.iter_value_measurement_pairs_(reverse=True)]
[(5, 1), (4, 1), (3, 1), (2, 1), (1, 1), (0, 1)]
>>> [*t6.iter_path_value_measurement_triples_(reverse=False)]
[(乸路径全纟元素(False, 乸路径纟节点乊匡部件即节点容器(0, 0)), 0, 1), (乸路径全纟元素(False, 乸路径纟节点乊匡部件即节点容器(0, 1)), 1, 1), (乸路径全纟元素(False, 乸路径纟节点乊匡部件即节点容器(0, 2)), 2, 1), (乸路径全纟元素(False, 乸路径纟节点乊匡部件即节点容器(2, 0)), 3, 1), (乸路径全纟元素(False, 乸路径纟节点乊匡部件即节点容器(2, 1)), 4, 1), (乸路径全纟元素(False, 乸路径纟节点乊匡部件即节点容器(2, 2)), 5, 1)]
>>> [*t6.iter_path_value_measurement_triples_(reverse=True)]
[(乸路径全纟元素(True, 乸路径纟节点乊匡部件即节点容器(0, 0)), 5, 1), (乸路径全纟元素(True, 乸路径纟节点乊匡部件即节点容器(0, 1)), 4, 1), (乸路径全纟元素(True, 乸路径纟节点乊匡部件即节点容器(0, 2)), 3, 1), (乸路径全纟元素(True, 乸路径纟节点乊匡部件即节点容器(2, 0)), 2, 1), (乸路径全纟元素(True, 乸路径纟节点乊匡部件即节点容器(2, 1)), 1, 1), (乸路径全纟元素(True, 乸路径纟节点乊匡部件即节点容器(2, 2)), 0, 1)]

>>> t6.ipush_(999, left_vs_right=False)
FingerTree__measurement_is_len([999, 0, 1, 2, 3, 4, 5])
>>> t6.ipush_(999, left_vs_right=True)
FingerTree__measurement_is_len([0, 1, 2, 3, 4, 5, 999])
>>> t6.ipop_(left_vs_right=False)
(FingerTree__measurement_is_len([1, 2, 3, 4, 5]), 0)
>>> t6.ipop_(left_vs_right=True)
(FingerTree__measurement_is_len([0, 1, 2, 3, 4]), 5)

>>> t6.get_endpoint_(left_vs_right=False)
0
>>> t6.get_endpoint_(left_vs_right=True)
5
>>> t6.first
0
>>> t6.last
5
>>> (t6 + t0) is t6
True
>>> (t0 + t6) is t6
True
>>> (t6 + t3)
FingerTree__measurement_is_len([0, 1, 2, 3, 4, 5, 777, 888, 999])
>>> _t6 = t6
>>> _t6 += t3
>>> _t6 == (t6 + t3)
True

>>> t6.join() is t6
True
>>> t6.join(t0, t0, t0) is t6
True
>>> t0.join(t0, t6, t0) is t6
True
>>> t6.join(t3, t2)
FingerTree__measurement_is_len([0, 1, 2, 3, 4, 5, 777, 888, 999, 11, 22])

>>> FingerTree__measurement_is_len.joins([t6]) is t6
True
>>> FingerTree__measurement_is_len.joins([t0, t6, t0]) is t6
True
>>> FingerTree__measurement_is_len.joins([t2, t6, t3])
FingerTree__measurement_is_len([11, 22, 0, 1, 2, 3, 4, 5, 777, 888, 999])

>>> t6.ipushs__([], left_vs_right=False, reverse=False) is t6
True
>>> t6.ipushs__([], left_vs_right=False, reverse=True) is t6
True
>>> t6.ipushs__([], left_vs_right=True, reverse=False) is t6
True
>>> t6.ipushs__([], left_vs_right=True, reverse=True) is t6
True

>>> t6.ipushs__([33, 44, 55], left_vs_right=False, reverse=False)
FingerTree__measurement_is_len([33, 44, 55, 0, 1, 2, 3, 4, 5])
>>> t6.ipushs__([33, 44, 55], left_vs_right=False, reverse=True)
FingerTree__measurement_is_len([55, 44, 33, 0, 1, 2, 3, 4, 5])
>>> t6.ipushs__([33, 44, 55], left_vs_right=True, reverse=False)
FingerTree__measurement_is_len([0, 1, 2, 3, 4, 5, 33, 44, 55])
>>> t6.ipushs__([33, 44, 55], left_vs_right=True, reverse=True)
FingerTree__measurement_is_len([0, 1, 2, 3, 4, 5, 55, 44, 33])


>>> t6.ipops_le__(0, left_vs_right=False, reverse=False) == (t6, [])
True
>>> t6.ipops_le__(0, left_vs_right=False, reverse=True) == (t6, [])
True
>>> t6.ipops_le__(0, left_vs_right=True, reverse=False) == (t6, [])
True
>>> t6.ipops_le__(0, left_vs_right=True, reverse=True) == (t6, [])
True
>>> t6.ipops_le__(0, left_vs_right=True, reverse=True)[0] is t6
True

>>> t6.ipops_le__(3, left_vs_right=False, reverse=False)
(FingerTree__measurement_is_len([3, 4, 5]), [0, 1, 2])
>>> t6.ipops_le__(3, left_vs_right=False, reverse=True)
(FingerTree__measurement_is_len([3, 4, 5]), [2, 1, 0])
>>> t6.ipops_le__(3, left_vs_right=True, reverse=False)
(FingerTree__measurement_is_len([0, 1, 2]), [3, 4, 5])
>>> t6.ipops_le__(3, left_vs_right=True, reverse=True)
(FingerTree__measurement_is_len([0, 1, 2]), [5, 4, 3])


>>> t6.ipop_then_ipush_on_same_endpoint_(999, left_vs_right=False)
(FingerTree__measurement_is_len([999, 1, 2, 3, 4, 5]), 0)
>>> t6.ipop_then_ipush_on_same_endpoint_(999, left_vs_right=True)
(FingerTree__measurement_is_len([0, 1, 2, 3, 4, 999]), 5)

>>> t6.ipush_then_ipop_on_diff_endpoints_(999, leftward_vs_rightward=False)
(FingerTree__measurement_is_len([1, 2, 3, 4, 5, 999]), 0)
>>> t6.ipush_then_ipop_on_diff_endpoints_(999, leftward_vs_rightward=True)
(FingerTree__measurement_is_len([999, 0, 1, 2, 3, 4]), 5)

>>> t6.ipushs_then_ipops_on_diff_endpoints_([777, 999], leftward_vs_rightward=False)
(FingerTree__measurement_is_len([2, 3, 4, 5, 777, 999]), [0, 1])
>>> t6.ipushs_then_ipops_on_diff_endpoints_([777, 999], leftward_vs_rightward=True)
(FingerTree__measurement_is_len([999, 777, 0, 1, 2, 3]), [5, 4])


>>> t6.search_via_measurement___(0, int.__add__, (0).__ge__, reverse=False, known_non_underflow=False, known_non_overflow=False)
(Ellipsis, (0, 乸路径全纟元素(False, 乸路径纟节点乊匡部件即节点容器(0, 0)), 0, 1, 1))
>>> t6.search_via_measurement___(0, int.__add__, (0).__ge__, reverse=True, known_non_underflow=False, known_non_overflow=False)
(Ellipsis, (0, 乸路径全纟元素(True, 乸路径纟节点乊匡部件即节点容器(0, 0)), 5, 1, 1))


>>> t6.search_via_measurement___(0, int.__add__, (-1).__ge__, reverse=False, known_non_underflow=False, known_non_overflow=False)
(False, 0)
>>> t6.search_via_measurement___(0, int.__add__, (-1).__ge__, reverse=True, known_non_underflow=False, known_non_overflow=False)
(False, 0)
>>> t6.split4gap(False) == (t6, t0)
True
>>> t6.split4gap(True) == (t6, t0)
True
>>> t6.split4gap(False)[0] is t6
True
>>> t6.split4gap(True)[0] is t6
True




    `path2reverse
    `path2value_measurement_pair
    `path2value
    `split4value
    `split4gap
    `search_via_measurement___
>>> ttt = FingerTree__measurement_is_len(range(11, 17))
>>> r = ttt.search_via_measurement___(0, int.__add__, (3).__ge__, reverse=False, known_non_underflow=False, known_non_overflow=False)
>>> r
(Ellipsis, (3, 乸路径全纟元素(False, 乸路径纟节点乊匡部件即节点容器(2, 0)), 14, 1, 4))
>>> path = r[1][1]
>>> path
乸路径全纟元素(False, 乸路径纟节点乊匡部件即节点容器(2, 0))
>>> FingerTree__measurement_is_len.path2reverse(path)
False
>>> ttt.path2value(path)
14
>>> ttt.path2value_measurement_pair(path)
(14, 1)
>>> ttt.split4value(path)
(FingerTree__measurement_is_len([11, 12, 13]), 14, FingerTree__measurement_is_len([15, 16]))
>>> ttt.split4gap(path)
(FingerTree__measurement_is_len([11, 12, 13]), FingerTree__measurement_is_len([14, 15, 16]))

>>> r = ttt.search_via_measurement___(0, int.__add__, (3).__ge__, reverse=True, known_non_underflow=False, known_non_overflow=False)
>>> r
(Ellipsis, (3, 乸路径全纟元素(True, 乸路径纟节点乊匡部件即节点容器(2, 0)), 13, 1, 4))
>>> path = r[1][1]
>>> path
乸路径全纟元素(True, 乸路径纟节点乊匡部件即节点容器(2, 0))
>>> FingerTree__measurement_is_len.path2reverse(path)
True
>>> ttt.path2value(path)
13
>>> ttt.path2value_measurement_pair(path)
(13, 1)
>>> ttt.split4value(path)
(FingerTree__measurement_is_len([14, 15, 16]), 13, FingerTree__measurement_is_len([11, 12]))
>>> ttt.split4gap(path)
(FingerTree__measurement_is_len([14, 15, 16]), FingerTree__measurement_is_len([11, 12, 13]))




    underlying_tree
    __str__
    __repr__
    __hash__
    __eq__
    __new__
>>> t6.underlying_tree
乸元素容器爫展翅树牜度量值为长度([0, 1, 2, 3, 4, 5])
>>> print(t6)
FingerTree__measurement_is_len(6, 乸元素容器爫展翅树牜度量值为长度([0, 1, 2, 3, 4, 5]))
>>> repr(t6)
'FingerTree__measurement_is_len([0, 1, 2, 3, 4, 5])'
>>> t6._mh is None
True
>>> h = hash(t6)
>>> t6._mh is None
False
>>> h == hash(t6)
True
>>> hash(t6) == hash(t6) != hash(t2)
True
>>> t6 == t6
True
>>> t6 != t6
False
>>> t6 == FingerTree__measurement_is_len(range(6)[::-1], reverse=True)
True
>>> t6 != FingerTree__measurement_is_len(range(6)[::-1], reverse=True)
False
>>> t6 == t2
False
>>> t6 != t2
True
>>> t6 == FingerTree__measurement_is_len(range(6), reverse=True)
False
>>> t6 != FingerTree__measurement_is_len(range(6), reverse=True)
True



    slice_between
    split_at4value
    split_at4gap
    __getitem__
#>>> t6.slice_between(-1, 3)
#>>> t6.slice_between(-1, None)
#>>> t6.slice_between(None, -6)
#>>> t6.slice_between(None, -5)
#>>> t6.slice_between(-4, -4)
#>>> t6.slice_between(-3, -4)
#>>> t6.slice_between(-2, -4)
#>>> t6.slice_between(2, 4)
#>>> t6.slice_between(2, 3)
#>>> t6.slice_between(2, 2)
#>>> t6.slice_between(2, 1)
#
#>>> t6.split_at4value(-8)
#>>> t6.split_at4value(-7)
#>>> t6.split_at4value(-6)
#>>> t6.split_at4value(-5)
#>>> t6.split_at4value(-2)
#>>> t6.split_at4value(-1)
#>>> t6.split_at4value(0)
#>>> t6.split_at4value(1)
#>>> t6.split_at4value(3)
#>>> t6.split_at4value(5)
#>>> t6.split_at4value(6)
#>>> t6.split_at4value(7)
#
#>>> t6.split_at4gap(-8)
#>>> t6.split_at4gap(-7)
#>>> t6.split_at4gap(-6)
#>>> t6.split_at4gap(-5)
#>>> t6.split_at4gap(-2)
#>>> t6.split_at4gap(-1)
#>>> t6.split_at4gap(0)
#>>> t6.split_at4gap(1)
#>>> t6.split_at4gap(3)
#>>> t6.split_at4gap(5)
#>>> t6.split_at4gap(6)
#>>> t6.split_at4gap(7)
#
#>>> t6[-8]
#>>> t6[-7]
#>>> t6[-6]
#>>> t6[-5]
#>>> t6[-2]
#>>> t6[-1]
#>>> t6[0]
#>>> t6[1]
#>>> t6[3]
#>>> t6[5]
#>>> t6[6]
#>>> t6[7]
#
#>>> t6[-1:3]
#>>> t6[-1:]
#>>> t6[:-6]
#>>> t6[:-5]
#>>> t6[-4:-4]
#>>> t6[-3:-4]
#>>> t6[-2:-4]
#>>> t6[2:4]
#>>> t6[2:3]
#>>> t6[2:2]
#>>> t6[2:1]

#>>> t6[-5:-4]
#>>> t6[-5:-3]

#>>> t6.split_between(-1, 3)
#>>> t6.split_between(-1, None)
#>>> t6.split_between(None, -6)
#>>> t6.split_between(None, -5)
#>>> t6.split_between(-4, -4)
#>>> t6.split_between(-3, -4)
#>>> t6.split_between(-2, -4)
#>>> t6.split_between(2, 4)
#>>> t6.split_between(2, 3)
#>>> t6.split_between(2, 2)
#>>> t6.split_between(2, 1)
#
#>>> t6.split_between(-5, -4)
#>>> t6.split_between(-5, -3)


>>> t6.slice_between(None, -6)
FingerTree__measurement_is_len()
>>> t6.slice_between(None, -5)
FingerTree__measurement_is_len([0])
>>> t6.slice_between(-4, -4)
FingerTree__measurement_is_len()
>>> t6.slice_between(-3, -4)
FingerTree__measurement_is_len()
>>> t6.slice_between(-2, -4)
FingerTree__measurement_is_len()
>>> t6.slice_between(2, 4)
FingerTree__measurement_is_len([2, 3])
>>> t6.slice_between(2, 3)
FingerTree__measurement_is_len([2])
>>> t6.slice_between(2, 2)
FingerTree__measurement_is_len()
>>> t6.slice_between(2, 1)
FingerTree__measurement_is_len()
>>> t6.split_at4value(-8)
Traceback (most recent call last):
    ...
IndexError: range object index out of range
>>> t6.split_at4value(-7)
Traceback (most recent call last):
    ...
IndexError: range object index out of range
>>> t6.split_at4value(-6)
(FingerTree__measurement_is_len(), 0, FingerTree__measurement_is_len([1, 2, 3, 4, 5]))
>>> t6.split_at4value(-5)
(FingerTree__measurement_is_len([0]), 1, FingerTree__measurement_is_len([2, 3, 4, 5]))
>>> t6.split_at4value(-2)
(FingerTree__measurement_is_len([0, 1, 2, 3]), 4, FingerTree__measurement_is_len([5]))
>>> t6.split_at4value(-1)
(FingerTree__measurement_is_len([0, 1, 2, 3, 4]), 5, FingerTree__measurement_is_len())
>>> t6.split_at4value(0)
(FingerTree__measurement_is_len(), 0, FingerTree__measurement_is_len([1, 2, 3, 4, 5]))
>>> t6.split_at4value(1)
(FingerTree__measurement_is_len([0]), 1, FingerTree__measurement_is_len([2, 3, 4, 5]))
>>> t6.split_at4value(3)
(FingerTree__measurement_is_len([0, 1, 2]), 3, FingerTree__measurement_is_len([4, 5]))
>>> t6.split_at4value(5)
(FingerTree__measurement_is_len([0, 1, 2, 3, 4]), 5, FingerTree__measurement_is_len())
>>> t6.split_at4value(6)
Traceback (most recent call last):
    ...
IndexError: range object index out of range
>>> t6.split_at4value(7)
Traceback (most recent call last):
    ...
IndexError: range object index out of range
>>> t6.split_at4gap(-8)
(FingerTree__measurement_is_len(), FingerTree__measurement_is_len([0, 1, 2, 3, 4, 5]))
>>> t6.split_at4gap(-7)
(FingerTree__measurement_is_len(), FingerTree__measurement_is_len([0, 1, 2, 3, 4, 5]))
>>> t6.split_at4gap(-6)
(FingerTree__measurement_is_len(), FingerTree__measurement_is_len([0, 1, 2, 3, 4, 5]))
>>> t6.split_at4gap(-5)
(FingerTree__measurement_is_len([0]), FingerTree__measurement_is_len([1, 2, 3, 4, 5]))
>>> t6.split_at4gap(-2)
(FingerTree__measurement_is_len([0, 1, 2, 3]), FingerTree__measurement_is_len([4, 5]))
>>> t6.split_at4gap(-1)
(FingerTree__measurement_is_len([0, 1, 2, 3, 4]), FingerTree__measurement_is_len([5]))
>>> t6.split_at4gap(0)
(FingerTree__measurement_is_len(), FingerTree__measurement_is_len([0, 1, 2, 3, 4, 5]))
>>> t6.split_at4gap(1)
(FingerTree__measurement_is_len([0]), FingerTree__measurement_is_len([1, 2, 3, 4, 5]))
>>> t6.split_at4gap(3)
(FingerTree__measurement_is_len([0, 1, 2]), FingerTree__measurement_is_len([3, 4, 5]))
>>> t6.split_at4gap(5)
(FingerTree__measurement_is_len([0, 1, 2, 3, 4]), FingerTree__measurement_is_len([5]))
>>> t6.split_at4gap(6)
(FingerTree__measurement_is_len([0, 1, 2, 3, 4, 5]), FingerTree__measurement_is_len())
>>> t6.split_at4gap(7)
(FingerTree__measurement_is_len([0, 1, 2, 3, 4, 5]), FingerTree__measurement_is_len())
>>> t6[-8]
Traceback (most recent call last):
    ...
IndexError: range object index out of range
>>> t6[-7]
Traceback (most recent call last):
    ...
IndexError: range object index out of range
>>> t6[-6]
0
>>> t6[-5]
1
>>> t6[-2]
4
>>> t6[-1]
5
>>> t6[0]
0
>>> t6[1]
1
>>> t6[3]
3
>>> t6[5]
5
>>> t6[6]
Traceback (most recent call last):
    ...
IndexError: range object index out of range
>>> t6[7]
Traceback (most recent call last):
    ...
IndexError: range object index out of range
>>> t6[-1:3]
FingerTree__measurement_is_len()
>>> t6[-1:]
FingerTree__measurement_is_len([5])
>>> t6[:-6]
FingerTree__measurement_is_len()
>>> t6[:-5]
FingerTree__measurement_is_len([0])
>>> t6[-4:-4]
FingerTree__measurement_is_len()
>>> t6[-3:-4]
FingerTree__measurement_is_len()
>>> t6[-2:-4]
FingerTree__measurement_is_len()
>>> t6[2:4]
FingerTree__measurement_is_len([2, 3])
>>> t6[2:3]
FingerTree__measurement_is_len([2])
>>> t6[2:2]
FingerTree__measurement_is_len()
>>> t6[2:1]
FingerTree__measurement_is_len()


>>> t6[-5:-4]
FingerTree__measurement_is_len([1])
>>> t6[-5:-3]
FingerTree__measurement_is_len([1, 2])



news:
    split_between
>>> t6
FingerTree__measurement_is_len([0, 1, 2, 3, 4, 5])
>>> t6.split_between(-1, 3)
(FingerTree__measurement_is_len([0, 1, 2, 3, 4]), FingerTree__measurement_is_len(), FingerTree__measurement_is_len([5]))
>>> t6.split_between(-1, None)
(FingerTree__measurement_is_len([0, 1, 2, 3, 4]), FingerTree__measurement_is_len([5]), FingerTree__measurement_is_len())
>>> t6.split_between(None, -6)
(FingerTree__measurement_is_len(), FingerTree__measurement_is_len(), FingerTree__measurement_is_len([0, 1, 2, 3, 4, 5]))
>>> t6.split_between(None, -5)
(FingerTree__measurement_is_len(), FingerTree__measurement_is_len([0]), FingerTree__measurement_is_len([1, 2, 3, 4, 5]))
>>> t6.split_between(-4, -4)
(FingerTree__measurement_is_len([0, 1]), FingerTree__measurement_is_len(), FingerTree__measurement_is_len([2, 3, 4, 5]))
>>> t6.split_between(-3, -4)
(FingerTree__measurement_is_len([0, 1, 2]), FingerTree__measurement_is_len(), FingerTree__measurement_is_len([3, 4, 5]))
>>> t6.split_between(-2, -4)
(FingerTree__measurement_is_len([0, 1, 2, 3]), FingerTree__measurement_is_len(), FingerTree__measurement_is_len([4, 5]))
>>> t6.split_between(2, 4)
(FingerTree__measurement_is_len([0, 1]), FingerTree__measurement_is_len([2, 3]), FingerTree__measurement_is_len([4, 5]))
>>> t6.split_between(2, 3)
(FingerTree__measurement_is_len([0, 1]), FingerTree__measurement_is_len([2]), FingerTree__measurement_is_len([3, 4, 5]))
>>> t6.split_between(2, 2)
(FingerTree__measurement_is_len([0, 1]), FingerTree__measurement_is_len(), FingerTree__measurement_is_len([2, 3, 4, 5]))
>>> t6.split_between(2, 1)
(FingerTree__measurement_is_len([0, 1]), FingerTree__measurement_is_len(), FingerTree__measurement_is_len([2, 3, 4, 5]))
>>> t6.split_between(-5, -4)
(FingerTree__measurement_is_len([0]), FingerTree__measurement_is_len([1]), FingerTree__measurement_is_len([2, 3, 4, 5]))
>>> t6.split_between(-5, -3)
(FingerTree__measurement_is_len([0]), FingerTree__measurement_is_len([1, 2]), FingerTree__measurement_is_len([3, 4, 5]))


extras-Sequence:
    __contains__
    count
    index
    rindex
    index_

extras-tuple:
    __mul__
    __rmul__
>>> 6 in t6
False
>>> 5 in t6
True
>>> t6.count(6)
0
>>> t6.count(5)
1
>>> txx = FingerTree__measurement_is_len([1,2,5,5,5,4,4])
>>> txx.count(5)
3
>>> txx.count(4)
2
>>> txx.count(6)
0


>>> txx.index(5)
2
>>> txx.rindex(5)
4
>>> txx.index(5, 3)
3
>>> txx.rindex(5, 3)
4
>>> txx.index(5, 3, 4)
3
>>> txx.rindex(5, 3, 4)
3
>>> txx.index(5, 1, 4)
2
>>> txx.rindex(5, 1, 4)
3
>>> txx.index(999)
Traceback (most recent call last):
    ...
IndexError: 999
>>> txx.rindex(999)
Traceback (most recent call last):
    ...
IndexError: 999
>>> txx.index(5, 0, 2)
Traceback (most recent call last):
    ...
IndexError: 5
>>> txx.rindex(5, 0, 2)
Traceback (most recent call last):
    ...
IndexError: 5

>>> txx*-2 is t0
True
>>> txx*-1 is t0
True
>>> txx*0 is t0
True
>>> txx*1 is txx
True
>>> t0*(2**62) is t0
True
>>> t0*(2**9999) is t0
True

#fixed:>>> t0*(2**9999) is t0
Traceback (most recent call last):
    ...
OverflowError: cannot fit 'int' into an index-sized integer
>>> txx*2
FingerTree__measurement_is_len([1, 2, 5, 5, 5, 4, 4, 1, 2, 5, 5, 5, 4, 4])
>>> txx*3
FingerTree__measurement_is_len([1, 2, 5, 5, 5, 4, 4, 1, 2, 5, 5, 5, 4, 4, 1, 2, 5, 5, 5, 4, 4])


>>> 3*txx
FingerTree__measurement_is_len([1, 2, 5, 5, 5, 4, 4, 1, 2, 5, 5, 5, 4, 4, 1, 2, 5, 5, 5, 4, 4])
>>> txx*''
Traceback (most recent call last):
    ...
TypeError: can't multiply sequence by non-int of type 'str'


#]]]'''
__all__ = r'''
乸元素容器爫展翅树牜度量值为长度
FingerTree__measurement_is_len



错误牜展翅树相关
    错误牜欤已知非超前进
    错误牜空树



魖匞度量值
魖匞展翅树
魖含冫度量值
    魖元素容器爫展翅树
    魖展翅树
        魖光杆树
        魖根深树
    魖翅膀
        魖左翼
        魖右翼
    魖节点
        魖更深节点
        魖元素节点


魖元素容器爫展翅树牜通用具现

魖展翅树牜通用具现
魖根深树牜通用具现冫琐碎
魖光杆树牜通用具现冫分裂
魖根深树牜特化具现冫分裂爫魖路径纟节点牜部件容器暨节点容器
    补全冫起翼扌
    分裂乊节点乊翅膀扌
    分裂乊节点爫测距扌

魖光杆树牜通用具现冫合并
魖根深树牜通用具现冫合并
    下沉浓缩冫节点序列扌
    下沉浓缩冫异树双翼间夹节点序列扌

魖光杆树牜通用具现冫压入弹出
魖根深树牜通用具现冫压入弹出









魖元素容器爫展翅树牜通用具现

魖匞展翅树牜通用具现

魖展翅树牜通用具现
    魖光杆树牜通用具现
        魖光杆树牜特化具现爫部件即节点
            魖光杆树牜元组具现爫部件即节点
    魖根深树牜通用具现
        魖根深树牜特化具现爫魖路径纟节点牜部件容器暨节点容器
            魖根深树牜元组具现爫魖路径纟节点牜部件容器暨节点容器

魖翅膀牜通用具现
        魖翅膀牜特化具现爫部件即节点
            魖翅膀牜元组具现爫部件即节点
    魖左翼牜通用具现
        魖左翼牜特化具现爫部件即节点
            魖左翼牜元组具现爫部件即节点
    魖右翼牜通用具现
        魖右翼牜特化具现爫部件即节点
            魖右翼牜元组具现爫部件即节点

魖节点
    魖更深节点
        魖更深节点牜特化具现爫部件即节点
            魖更深节点牜元组具现爫部件即节点
    魖元素节点
        魖元素节点牜元组具现













魖元素容器爫展翅树牜通用具现

魖匞展翅树牜通用具现

魖展翅树牜通用具现
魖光杆树牜通用具现
魖根深树牜通用具现
魖翅膀牜通用具现
魖左翼牜通用具现
魖右翼牜通用具现










魖根深树牜特化具现爫魖路径纟节点牜部件容器暨节点容器

魖光杆树牜特化具现爫部件即节点
魖翅膀牜特化具现爫部件即节点
魖左翼牜特化具现爫部件即节点
魖右翼牜特化具现爫部件即节点
魖更深节点牜特化具现爫部件即节点









魖根深树牜元组具现爫魖路径纟节点牜部件容器暨节点容器

魖光杆树牜元组具现爫部件即节点
魖翅膀牜元组具现爫部件即节点
魖左翼牜元组具现爫部件即节点
魖右翼牜元组具现爫部件即节点
魖更深节点牜元组具现爫部件即节点

魖元素节点牜元组具现






















构造冫匞展翅树爫元组具现扌
    魖匞度量值
        乸匞度量值爫自然数加法半群
            匞度量值爫自然数加法半群
        乸匞度量值爫无度量值
            匞度量值爫无度量值
    魖匞展翅树
        匞展翅树牜一二三四四爫自然数加法半群
        匞展翅树牜一二三四四爫无度量值





魖元素容器爫展翅树
    魖元素容器爫展翅树牜带总长
        魖元素容器爫展翅树牜度量值含长度
            乸元素容器爫展翅树牜度量值为长度
    魖元素容器爫展翅树牜通用具现
        魖元素容器爫展翅树牜元组具现
            乸元素容器爫展翅树牜度量值为长度











Error4FingerTree
    Error__empty_tree
    Error__known_non_overflow
IWithMeasurement
    IFingerTree
        IFingerTree__wrapper__not_yet_support_split_ops
            IFingerTree__wrapper
                IFingerTree__wrapper__measurement_contains_len
                    FingerTree__measurement_is_len



IFingerTree__wrapper__not_yet_support_split_ops
    魖元素容器爫展翅树
IFingerTree__wrapper
    魖元素容器爫展翅树牜带总长
IFingerTree__wrapper__measurement_contains_len
    魖元素容器爫展翅树牜度量值含长度
FingerTree__measurement_is_len
    乸元素容器爫展翅树牜度量值为长度



'''.split()#'''
#_移至子类冫重要属性纟所有类型扌
__all__

___begin_mark_of_excluded_global_names__0___ = ...
from itertools import islice, chain, repeat
from collections.abc import Sequence

from seed.data_funcs.finger_tree__config import 魖毶展翅树
#from seed.data_funcs.finger_tree__config import 毶展翅树牜一二二三三牜无分裂无合并,毶展翅树牜二四七九十牜有分裂有合并牜分裂不濒危,毶展翅树牜一三五六六牜有分裂无合并牜分裂不濒危,毶展翅树牜一二三四四牜有分裂有合并牜分裂濒危
from seed.data_funcs.finger_tree__config import 毶展翅树牜一二三四四牜有分裂有合并牜分裂濒危

from seed.data_funcs.finger_tree__search import 筐部件类别牜搜索定位,匡部件即节点,匡部件即节点容器,匡部件即更深节点容器

from seed.data_funcs.finger_tree__search import 魖部件容器,魖部件容器牜搜索定位
from seed.data_funcs.finger_tree__search import 魖节点容器,魖节点容器牜节点数,魖节点容器牜搜索定位,魖部件容器暨节点容器,魖部件容器暨节点容器牜搜索定位,魖部件容器牜搜索定位爫部件即节点

from seed.data_funcs.finger_tree__search import 魖路径纟节点牜部件容器暨节点容器

from seed.data_funcs.finger_tree__search import 魖路径纟节点,魖路径全纟节点间隙,魖路径全纟元素间隙, 魖路径全纟元素

from seed.data_funcs.finger_tree__search import 乸路径全纟节点间隙,乸路径全纟元素间隙, 乸路径全纟元素

from seed.data_funcs.finger_tree__search import 魖含冫度量值

from seed.data_funcs.finger_tree__search import 匡路径纟节点, 匡路径全纟元素, 匡超后退, 匡超前进
from seed.data_funcs.finger_tree__search import 魖路径纟节点
from seed.types.FrozenDict import FrozenDict, mk_FrozenDict, empty_FrozenDict

from seed.abc.abc__ver1 import abstractmethod, override, ABC, ABC__no_slots
from seed.helper.repr_input import repr_helper
from seed.tiny_.check import check_type_is, check_int_ge
from seed.tiny import echo

___end_mark_of_excluded_global_names__0___ = ...


__all__
罓欤切换回默认算法 = True

from seed.data_funcs.finger_tree__errors import 错误牜展翅树相关,错误牜欤已知非超前进,错误牜空树

class 魖匞度量值(ABC):
    '匞度量值:半群:满足结合律，不一定满足交换律'
    __slots__ = ()
    @property
    @abstractmethod
    def 零度量值(sf, /):
        '-> 度量值'
    @abstractmethod
    def 结合冫度量值扌(sf, 度量值纟左, 度量值纟右, /):
        '-> 度量值'

    罓欤切换回默认算法
    @property
    @abstractmethod
    def 欤可减(sf, /):
        '-> bool #减左,减右'
    @property
    @abstractmethod
    def 鬽减左冫度量值扌(sf, /):
        'None | (度量值 -> 度量值 -> 度量值) # [a == b+减左(a,b)]'
    @property
    @abstractmethod
    def 鬽减右冫度量值扌(sf, /):
        '-> 度量值'
        'None | (度量值 -> 度量值 -> 度量值) # [a == 减右(a,b)+b]'





class 魖匞展翅树(ABC):
    __slots__ = ()
    @property
    @abstractmethod
    def 毶展翅树(sf, /):
        '-> 魖毶展翅树'
    @property
    @abstractmethod
    def 匞度量值(sf, /):
        '-> 魖匞度量值'
    if 0:
        #取消原因:属于应用层函数:
        #   相应地:增加『度量值』于:构造冫元素节点扌
        @abstractmethod
        def 度量值巛元素扌(sf, 元素, /):
            '元素 -> 度量值'

    ######################
    ######################
    if not 罓欤切换回默认算法:
        @abstractmethod
        def 痸构造冫更深节点扌(sf, 度量值, 节点序列, /, *, 左起丷右起):
            '节点序列{深度,左起丷右起;}/Iter 节点{深度;} -> 节点{深度+1;}/更深节点{深度;}/魖更深节点'
        @abstractmethod
        def 痸构造冫左翼扌(sf, 度量值, 节点序列, /, *, 左起丷右起):
            '节点序列{深度,左起丷右起;}/Iter 节点{深度;} -> 左翼{深度;}/魖左翼'
        @abstractmethod
        def 痸构造冫右翼扌(sf, 度量值, 节点序列, /, *, 左起丷右起):
            '节点序列{深度,左起丷右起;}/Iter 节点{深度;} -> 右翼{深度;}/魖右翼'
        @abstractmethod
        def 痸构造冫光杆树扌(sf, 度量值, 节点序列, /, *, 左起丷右起):
            '节点序列{深度,左起丷右起;}/Iter 节点{深度;} -> 光杆树{深度;}/魖光杆树'
        @abstractmethod
        def 痸构造冫根深树乊左右扌(sf, 度量值, 左翼, 更深树, 右翼, /):
            '左翼{深度;} -> 更深树{深度;}/展翅树{深度+1;} -> 右翼{深度;} -> 根深树{深度;}/魖根深树'
    ######################
    ######################



    @abstractmethod
    def 构造冫元素节点扌(sf, 度量值, 元素, /):
        '度量值 -> 元素 -> 节点{深度:=0;}/元素节点/魖元素节点'
    @abstractmethod
    def 构造冫更深节点扌(sf, 节点序列, /, *, 左起丷右起):
        '节点序列{深度,左起丷右起;}/Iter 节点{深度;} -> 节点{深度+1;}/更深节点{深度;}/魖更深节点'
    @abstractmethod
    def 构造冫左翼扌(sf, 节点序列, /, *, 左起丷右起):
        '节点序列{深度,左起丷右起;}/Iter 节点{深度;} -> 左翼{深度;}/魖左翼'
    @abstractmethod
    def 构造冫右翼扌(sf, 节点序列, /, *, 左起丷右起):
        '节点序列{深度,左起丷右起;}/Iter 节点{深度;} -> 右翼{深度;}/魖右翼'
    @abstractmethod
    def 构造冫光杆树扌(sf, 节点序列, /, *, 左起丷右起):
        '节点序列{深度,左起丷右起;}/Iter 节点{深度;} -> 光杆树{深度;}/魖光杆树'
    @abstractmethod
    def 构造冫根深树乊左右扌(sf, 左翼, 更深树, 右翼, /):
        '左翼{深度;} -> 更深树{深度;}/展翅树{深度+1;} -> 右翼{深度;} -> 根深树{深度;}/魖根深树'


    ######################
    ##非必要:
    ######################
    @abstractmethod
    def 构造冫根深树乊起讫扌(sf, 起翼, 更深树, 讫翼, /, *, 左起丷右起):
        '起翼{深度,左起丷右起;} -> 更深树{深度;}/展翅树{深度+1;} -> 讫翼{深度,左起丷右起;} -> 根深树{深度;}/魖根深树'
    @abstractmethod
    def 构造冫翅膀扌(sf, 节点序列, /, *, 左翼丷右翼, 左起丷右起):
        '节点序列{深度,左起丷右起;}/Iter 节点{深度;} -> 翅膀{深度;左翼丷右翼}/魖翅膀'
    @abstractmethod
    def 构造冫空树扌(sf, /):
        '-> 展翅树{深度;}/魖展翅树'
    @abstractmethod
    def 构造冫展翅树扌(sf, 节点序列, /, *, 左起丷右起):
        '节点序列{深度,左起丷右起;}/Iter 节点{深度;} -> 展翅树{深度;}/魖展翅树'
    @abstractmethod
    def 构造冫展翅树丶总长扌(sf, 节点序列, /, *, 左起丷右起):
        '节点序列{深度,左起丷右起;}/Iter 节点{深度;} -> (展翅树{深度;}, 总长/uint)'

魖含冫度量值
class _21(魖含冫度量值):
    __slots__ = ()
    @property
    @abstractmethod
    def 匞展翅树(sf, /):
        '-> 魖匞展翅树'
class _321(魖节点容器牜搜索定位,_21):
    #class _321(魖节点容器牜搜索定位,魖部件容器暨节点容器,魖含冫度量值):
    #取消:魖部件容器暨节点容器
    #   即:取消:魖部件容器
    __slots__ = ()
    魖节点容器.枚举冫节点扌
    魖节点容器牜搜索定位.搜索定位冫节点扌
    魖节点容器牜搜索定位.取冫节点巛路径扌

#class _4321(魖节点容器牜节点数,_321):
class _4321(_321,魖节点容器牜搜索定位,魖节点容器牜节点数,魖含冫度量值):
    __slots__ = ()
    魖节点容器牜节点数.节点数
    魖节点容器牜节点数.测距冫节点乊起端扌

if 0:
  class 魖元素容器爫展翅树(_321):
    '[节点===元素]'
    __slots__ = ()
  class 魖元素容器爫展翅树(_21):
    __slots__ = ()
魖路径全纟元素间隙, 魖路径全纟元素
乸路径全纟元素间隙, 乸路径全纟元素

class 魖元素容器爫展翅树(魖含冫度量值):
    '见:魖路径全纟元素间隙,魖路径全纟元素'
    __slots__ = ()

    #取消:@classmethod
    #   !! _移至子类冫重要属性纟所有类型扌 要求 不含 classmethod
    @abstractmethod
    def 罒类忄包装冫展翅树乊底层扌(cls, 展翅树乊底层, /):
        '展翅树乊底层/魖展翅树 -> 树/元素容器/魖元素容器爫展翅树'
    @abstractmethod
    def 罒类忄度量值巛元素扌(cls, 元素, /):
        '元素 -> 度量值'
    @abstractmethod
    def 罒类忄取冫匞展翅树扌(cls, /):
        '-> 匞展翅树'

    @property
    @abstractmethod
    def 展翅树乊底层(sf, /):
        '-> 魖展翅树'

    ######################
    ##非必要:
    ######################
    @abstractmethod
    def 类忄构造冫空树扌(cls, /):
        '-> 空树/树'
    @abstractmethod
    def 类忄构造冫展翅树丶总长扌(cls, 元素序列, /, *, 左起丷右起):
        '-> 元素序列{左起丷右起;}/Iter 元素 -> 树'
    @abstractmethod
    def __bool__(sf, /):
        '-> bool'
    @abstractmethod
    def __iter__(sf, /):
        '-> 元素序列{左起丷右起=False;}/Iter 元素'
    @abstractmethod
    def __reversed__(sf, /):
        '-> 元素序列{左起丷右起=True;}/Iter 元素'

    @abstractmethod
    def 压入冫元素扌(sf, 元素, /, *, 左端丷右端):
        '树 -> 元素 -> 树'
    @abstractmethod
    def 弹出冫元素扌(sf, /, *, 左端丷右端):
        '树 -> (树, 元素) | ^错误牜空树'

    @abstractmethod
    def 合并扌(sf, 树, /):
        '树 -> 树 -> 树'
    @abstractmethod
    def 合并灬扌(sf, /, *树列表):
        '树 -> *树列表-> 树'
    @abstractmethod
    def 类忄合并牜序列扌(cls, 树序列, /):
        '树序列/Iter 树 -> 树'


    @abstractmethod
    def 分裂乊元素扌(sf, 路径全纟元素, /):
        '树 -> 路径全纟元素{;左起丷右起} -> (起树纟焦点居前{左起丷右起;}/树, 元素, 讫树纟焦点居后{左起丷右起;}/树)'
    @abstractmethod
    def 分裂乊元素间隙扌(sf, 路径全纟元素间隙, /):
        '树 -> 路径全纟元素间隙{;左起丷右起} -> (起树纟魊焦点居前/起树{左起丷右起;}/树, 讫树纟魊焦点诸后/讫树{左起丷右起;}/树)'

    @property
    @abstractmethod
    def 左端元素(sf, /):
        '-> 元素 | ^错误牜空树'
    @property
    @abstractmethod
    def 右端元素(sf, /):
        '-> 元素 | ^错误牜空树'
    @abstractmethod
    def 取冫端点元素扌(sf, /, *, 左端丷右端):
        '-> 端点{左端丷右端;}/元素 | ^错误牜空树'

    @abstractmethod
    def 同端弹压冫元素扌(sf, 元素, /, *, 左端丷右端):
        '树 -> 元素 -> (树, 元素) | ^错误牜弹出乊空树'
    @abstractmethod
    def 异端压弹冫元素扌(sf, 元素, /, *, 左出丷右出):
        '树 -> 元素 -> (树, 元素)'
    @abstractmethod
    def 异端压弹冫元素序列扌(sf, 元素序列, /, *, 左出丷右出):
        '树 -> 元素序列{左起丷右起=左出丷右出;} -> (树, 元素列表{左起丷右起=左出丷右出;}/[元素])'
    @abstractmethod
    def 压入冫元素序列扌(sf, 元素序列, /, *, 左端丷右端, 左起丷右起):
        '树 -> 元素序列{左起丷右起;} -> 树'
    @abstractmethod
    def 压入冫元素序列牜计长度扌(sf, 元素序列, /, *, 左端丷右端, 左起丷右起):
        '树 -> 元素序列{左起丷右起;} -> (树,新增长度/uint)'
    @abstractmethod
    def 弹出冫元素列表扌(sf, 鬽最大弹出数, /, *, 左端丷右端, 左起丷右起):
        '树 -> 鬽 最大弹出数/uint -> (树, 元素列表{左起丷右起;}{len<=最大弹出数}/[元素])'



    ['取冫节点丶度量值巛路径扌', '取冫节点巛路径扌', '度量值', '搜索定位冫节点扌', '枚举冫节点扌', '枚举冫路径丶节点丶度量值扌']


    @abstractmethod
    def 枚举冫元素扌(sf, /, *, 左起丷右起):
        '元素容器 -> 元素序列{左起丷右起;}/Iter 元素'
    @abstractmethod
    def 枚举冫元素丶度量值扌(sf, /, *, 左起丷右起):
        '元素容器 -> 元素辻度量值序列{左起丷右起;}/Iter (元素, 度量值纟元素)'
    @abstractmethod
    def 取冫元素巛路径扌(sf, 路径全纟元素, /):
        '路径全纟元素{;左起丷右起} -> 元素'
    @abstractmethod
    def 取冫元素丶度量值巛路径扌(sf, 路径全纟元素, /):
        '路径全纟元素{;左起丷右起} -> (元素, 度量值纟元素)#注意:[不一定:[元素::魖含冫度量值]]'

    魖含冫度量值.度量值
        #用于:[not:欤已知非超前进]
        #注意:[不一定:[元素::魖含冫度量值]]
    @abstractmethod
    def 枚举冫路径丶元素丶度量值扌(sf, /, *, 左起丷右起):
        '-> Iter (路径全纟元素{;左起丷右起},元素,度量值纟元素)#注意:[不一定:[元素::魖含冫度量值]]'
    @abstractmethod
    def 搜索定位冫元素扌(sf, 初始累计值, 累积扌, 进退判定扌, /, *, 左起丷右起, 欤已知非超后退, 欤已知非超前进):
        r'''[[[
        -> (筐搜索定位况型, x)
        | -> (匡超后退,初始累计值)
        | -> (匡超前进,终末累计值)
        | -> (匡路径全纟元素, (累计值牜前进, 路径全纟元素{;左起丷右起},焦点元素,度量值纟元素, 累计值牜后退))
        | ^错误牜欤已知非超前进
        ######################
        初始累计值 :: 累计值
        累积扌 :: 累计值 -> 度量值纟部件 -> 累计值
        进退判定扌 :: 累计值 -> 后退丷前进
        ######################
        # [不一定:[元素::魖含冫度量值]]
        ######################
        #]]]'''#'''

#end-class 魖元素容器爫展翅树(魖含冫度量值):
class 魖元素容器爫展翅树牜带总长(魖元素容器爫展翅树):
    __slots__ = ()
    @property
    @abstractmethod
    def 总长(sf, /):
        '-> 总节点数纟整树/uint'
    def __len__(sf, /):
        return sf.总长
class 魖元素容器爫展翅树牜度量值含长度(魖元素容器爫展翅树牜带总长):
    # [[度量值含长度] ==>> [自带总长]]
    __slots__ = ()
    @classmethod
    @abstractmethod
    def 度量值讠长度(cls, 度量值, /):
        '-> 度量值 -> 长度/uint'
        #measurement2len
    @property
    @override
    def 总长(sf, /):
        '-> 总节点数纟整树/uint'
        return type(sf).度量值讠长度(sf.展翅树乊底层.度量值)

class 魖展翅树(_321):
    __slots__ = ()
    #拆包冫展翅树扌===枚举冫节点扌
    @property
    @abstractmethod
    def 欤光杆(sf, /):
        '-> bool'
    @property
    @abstractmethod
    def 欤空树(sf, /):
        '-> bool'

    @abstractmethod
    def 压入扌(sf, 节点, /, *, 左端丷右端):
        '展翅树{深度;} -> 节点{深度;} -> 展翅树{深度;}'
    @abstractmethod
    def 弹出扌(sf, /, *, 左端丷右端):
        '展翅树{深度;} -> (展翅树{深度;}, 节点{深度;}) | ^错误牜空树'

    @abstractmethod
    def 合并牜间夹序列扌(sf, 节点数纟序列, 节点序列, 展翅树, /, *, 左端丷右端, 左起丷右起):
        '展翅树{深度;} -> 节点数纟序列/uint -> 节点序列{深度,左起丷右起;}{len=节点数纟序列}/Iter 节点 -> 展翅树{深度;} -> 展翅树{深度;} #[左起丷右起:只对 节点序列 起作用][左端丷右端:在这里扮演 大颗粒版 左起丷右起]'
        assert sf.匞展翅树.毶展翅树.欤需要冫合并操作

    魖节点容器牜搜索定位.搜索定位冫节点扌
    魖节点容器牜搜索定位.取冫节点巛路径扌
    @abstractmethod
    def 分裂乊节点扌(sf, 路径纟节点, /, *, 左起丷右起):
        '展翅树{深度;} -> 路径纟节点{左起丷右起;} -> (起树纟焦点居前{左起丷右起;}/展翅树{深度;}, 节点{深度;}, 讫树纟焦点居后{左起丷右起;}/展翅树{深度;})'
        assert sf.匞展翅树.毶展翅树.欤需要冫分裂操作
    @abstractmethod
    def 分裂乊节点间隙扌(sf, 鬽路径纟节点, /, *, 左起丷右起):
        '展翅树{深度;} -> 鬽 路径纟节点{左起丷右起;} -> (起树纟魊焦点居前/展翅树{深度;}, 讫树纟魊焦点诸后/展翅树{深度;}) #鬽路径纟节点:功用类似:魖路径全纟节点间隙'

    @property
    @abstractmethod
    def 左端点(sf, /):
        '-> 节点{深度;} | ^错误牜空树'
    @property
    @abstractmethod
    def 右端点(sf, /):
        '-> 节点{深度;} | ^错误牜空树'
    @abstractmethod
    def 取冫端点扌(sf, /, *, 左端丷右端):
        '-> 端点{深度,左端丷右端;}/节点{深度;} | ^错误牜空树'

    @abstractmethod
    def 同端弹压扌(sf, 节点, /, *, 左端丷右端):
        '展翅树{深度;} -> 节点{深度;} -> (展翅树{深度;}/魖展翅树, 节点{深度;}) | ^错误牜弹出乊空树'
    @abstractmethod
    def 异端压弹扌(sf, 节点, /, *, 左出丷右出):
        '展翅树{深度;} -> 节点{深度;} -> (展翅树{深度;}/魖展翅树, 节点{深度;})'
    @abstractmethod
    def 异端压弹牜序列扌(sf, 节点序列, /, *, 左出丷右出):
        '展翅树{深度;} -> 节点序列{深度,左起丷右起=左出丷右出;} -> (展翅树{深度;}/魖展翅树, 节点列表{深度,左起丷右起=左出丷右出;}/[节点])'
    @abstractmethod
    def 压入牜序列扌(sf, 节点序列, /, *, 左端丷右端, 左起丷右起):
        '展翅树{深度;} -> 节点序列{深度,左起丷右起;} -> 展翅树{深度;}'
    @abstractmethod
    def 压入牜序列牜计长度扌(sf, 节点序列, /, *, 左端丷右端, 左起丷右起):
        '展翅树{深度;} -> 节点序列{深度,左起丷右起;} -> (展翅树{深度;}, 新增长度/uint)'
    @abstractmethod
    def 弹出牜列表扌(sf, 鬽最大弹出数, /, *, 左端丷右端, 左起丷右起):
        '展翅树{深度;} -> 鬽 最大弹出数/uint -> (展翅树{深度;}, 节点列表{深度,左起丷右起;}{len<=最大弹出数}/[节点])'

class 魖翅膀(_4321):
    __slots__ = ()
    #拆包冫翅膀扌===枚举冫节点扌
    @property
    @abstractmethod
    def 左翼丷右翼(sf, /):
        '-> bool'
    @property
    @abstractmethod
    def 欤濒危(sf, /):
        '-> bool/欤临界缺员'
    @property
    @abstractmethod
    def 欤满员(sf, /):
        '-> bool'
    @abstractmethod
    def 外端压入扌(sf, 节点, /):
        '翅膀{深度;左翼丷右翼} -> 节点{深度;} -> (翅膀{深度;左翼丷右翼}, 鬽 更深节点{深度;})'
    @abstractmethod
    def 外端弹出乊足员扌(sf, /):
        '翅膀{深度;左翼丷右翼} -> (翅膀{深度;左翼丷右翼}, 节点{深度;})'
    @abstractmethod
    def 外端弹出乊濒危扌(sf, 更深节点, /):
        '翅膀{深度;左翼丷右翼} -> 更深节点{深度;} -> (翅膀{深度;左翼丷右翼}, 节点{深度;})'


class 魖节点(_21):
    __slots__ = ()
    _21.匞展翅树




























class 魖光杆树(魖展翅树,_4321):
    '[路径纟节点<光杆树> === 扁索引纟节点]'
    __slots__ = ()
    欤光杆 = True
    @property
    @override
    def 欤空树(sf, /):
        '-> bool'
        return sf.节点数 == 0

    @property
    @abstractmethod
    def 欤满员(sf, /):
        '-> bool'

class 魖根深树(魖展翅树,魖部件容器暨节点容器牜搜索定位):
    #,魖部件容器牜搜索定位,魖部件容器暨节点容器
    '见:魖根深树牜特化具现冫分裂爫魖路径纟节点牜部件容器暨节点容器'
    __slots__ = ()
    欤光杆 = False
    欤空树 = False
    @abstractmethod
    def 拆包冫根深树乊左右扌(sf, /):
        '根深树{深度;} -> (左翼{深度;}, 更深树{深度;}/展翅树{深度+1;}, 右翼{深度;})'
    @abstractmethod
    def 拆包冫根深树乊起讫扌(sf, /, *, 左起丷右起):
        '根深树{深度;} -> (起翼{深度,左起丷右起;}, 更深树{深度;}/展翅树{深度+1;}, 讫翼{深度,左起丷右起;})'
    @abstractmethod
    def 取冫翅膀扌(sf, /, *, 左翼丷右翼):
        '-> 翅膀{深度,左翼丷右翼;}'
    @property
    @abstractmethod
    def 左翼(sf, /):
        '-> 左翼{深度;}/翅膀{深度,左翼丷右翼=False;}'
    @property
    @abstractmethod
    def 右翼(sf, /):
        '-> 右翼{深度;}/翅膀{深度,左翼丷右翼=True;}'
    @property
    @abstractmethod
    def 更深树(sf, /):
        '-> 更深树{深度;}/展翅树{深度+1;}'


class 魖左翼(魖翅膀):
    __slots__ = ()
    左翼丷右翼 = False
class 魖右翼(魖翅膀):
    __slots__ = ()
    左翼丷右翼 = True
class 魖更深节点(魖节点,_4321):
    __slots__ = ()
    #拆包冫更深节点扌===枚举冫节点扌
class 魖元素节点(魖节点):
    '元素封包节点 改名为 元素节点'
    __slots__ = ()
    @property
    @abstractmethod
    def 元素(sf, /):
        '-> 元素'
    @abstractmethod
    def 拆包冫元素节点扌(sf, /):
        '元素节点/节点{深度:=0;} -> (度量值, 元素)'
    魖节点.匞展翅树




















#默认具现
#通用具现
class 魖元素容器爫展翅树牜通用具现(魖元素容器爫展翅树):
    __slots__ = ()

    @property
    def 匞展翅树(sf, /):
        '-> 魖匞展翅树'
        cls = type(sf)
        匞展翅树 = cls.罒类忄取冫匞展翅树扌(cls)
        return 匞展翅树
    def 度量值巛元素扌(sf, 元素, /):
        '元素 -> 度量值'
        cls = type(sf)
        度量值 = cls.罒类忄度量值巛元素扌(cls, 元素)
        return 度量值
    def 包装冫展翅树乊底层扌(sf, 展翅树乊底层, /):
        '展翅树乊底层/魖展翅树 -> 树/元素容器/魖元素容器爫展翅树'
        cls = type(sf)
        ot = cls.罒类忄包装冫展翅树乊底层扌(cls, 展翅树乊底层)
        return ot
    def 包装冫元素扌(sf, 元素, /):
        '元素 -> 元素节点乊底层'
        度量值 = sf.度量值巛元素扌(元素)
        return sf.匞展翅树.构造冫元素节点扌(度量值, 元素)

    ######################
    ######################
    @property
    @override
    def 度量值(sf, /):
        '-> 度量值'
        return sf.展翅树乊底层.度量值
    ######################
    @override
    def 类忄构造冫空树扌(cls, /):
        '-> 空树/树'
        匞展翅树 = cls.罒类忄取冫匞展翅树扌(cls)
        底树 = 匞展翅树.构造冫空树扌()
        树 = cls.罒类忄包装冫展翅树乊底层扌(cls, 底树)
        return 树
    @override
    def 类忄构造冫展翅树丶总长扌(cls, 元素序列, /, *, 左起丷右起):
        '-> 元素序列{左起丷右起;}/Iter 元素 -> (树, 总长/uint)'
        return cls.类忄构造冫空树扌(cls).压入冫元素序列牜计长度扌(元素序列, 左端丷右端=not 左起丷右起, 左起丷右起=左起丷右起)
    @override
    def __bool__(sf, /):
        '-> bool'
        return not sf.展翅树乊底层.欤空树
    @override
    def __iter__(sf, /):
        '元素容器 -> 元素序列{左起丷右起=False;}/Iter 元素'
        return sf.枚举冫元素扌(左起丷右起=False)
    @override
    def __reversed__(sf, /):
        '元素容器 -> 元素序列{左起丷右起=True;}/Iter 元素'
        return sf.枚举冫元素扌(左起丷右起=True)
    ######################
    @override
    def 压入冫元素扌(sf, 元素, /, *, 左端丷右端):
        '树 -> 元素 -> 树'
        节点 = sf.包装冫元素扌(元素)
        底树 = sf.展翅树乊底层.压入扌(节点, 左端丷右端=左端丷右端)
        树 = sf.包装冫展翅树乊底层扌(底树)
        return 树
    @override
    def 弹出冫元素扌(sf, /, *, 左端丷右端):
        '树 -> (树, 元素) | ^错误牜空树'
        (底树, 节点) = sf.展翅树乊底层.弹出扌(左端丷右端=左端丷右端)
        树 = sf.包装冫展翅树乊底层扌(底树)
        return (树, 节点.元素)

    @override
    def 合并扌(sf, 树, /):
        '树 -> 树 -> 树'
        return sf.合并灬扌(树)
        ######################
        ######################
        check_type_is(type(sf), 树)
        底树 = sf.展翅树乊底层.合并牜间夹序列扌(0, '', 树.展翅树乊底层, 左端丷右端=True, 左起丷右起=False)
        树 = sf.包装冫展翅树乊底层扌(底树)
        return 树
    @override
    def 合并灬扌(sf, /, *树列表):
        '树 -> *树列表-> 树'
        cls = type(sf)
        return cls.类忄合并牜序列扌(cls, chain([sf], 树列表))
    @override
    def 类忄合并牜序列扌(cls, 树序列, /):
        '树序列/Iter 树 -> 树'
        it = iter(树序列)
        for sf in it:
            check_type_is(cls, sf)
            if sf:
                break
        else:
            return cls.类忄构造冫空树扌(cls)
        底树 = sf.展翅树乊底层
        new = False
        for ot in it:
            check_type_is(cls, sf)
            if not ot:
                continue
            new = True
            底树 = 底树.合并牜间夹序列扌(0, '', ot.展翅树乊底层, 左端丷右端=True, 左起丷右起=False)
        if new:
            sf = cls.罒类忄包装冫展翅树乊底层扌(cls, 底树)
        return sf

    @override
    def 分裂乊元素扌(sf, 路径全纟元素, /):
        '树 -> 路径全纟元素{;左起丷右起} -> (起树纟焦点居前{左起丷右起;}/树, 元素, 讫树纟焦点居后{左起丷右起;}/树)'
        (起底树, 焦点, 讫底树) = sf.展翅树乊底层.分裂乊节点扌(路径全纟元素.路径纟节点, 左起丷右起=路径全纟元素.左起丷右起)
        起树 = sf.包装冫展翅树乊底层扌(起底树)
        讫树 = sf.包装冫展翅树乊底层扌(讫底树)
        元素 = 焦点.元素
        return (起树, 元素, 讫树)
    @override
    def 分裂乊元素间隙扌(sf, 路径全纟元素间隙, /):
        '树 -> 路径全纟元素间隙{;左起丷右起} -> (起树纟魊焦点居前/起树{左起丷右起;}/树, 讫树纟魊焦点诸后/讫树{左起丷右起;}/树)'
        (起底树, 讫底树) = sf.展翅树乊底层.分裂乊节点间隙扌(路径全纟元素间隙.鬽路径纟节点, 左起丷右起=路径全纟元素间隙.左起丷右起)
        起树 = sf.包装冫展翅树乊底层扌(起底树)
        讫树 = sf.包装冫展翅树乊底层扌(讫底树)
        return (起树, 讫树)

    @property
    @override
    def 左端元素(sf, /):
        '-> 元素 | ^错误牜空树'
        节点 = sf.展翅树乊底层.左端点
        return 节点.元素
    @property
    @override
    def 右端元素(sf, /):
        '-> 元素 | ^错误牜空树'
        节点 = sf.展翅树乊底层.右端点
        return 节点.元素
    @override
    def 取冫端点元素扌(sf, /, *, 左端丷右端):
        '-> 端点{左端丷右端;}/元素 | ^错误牜空树'
        节点 = sf.展翅树乊底层.取冫端点扌(左端丷右端=左端丷右端)
        return 节点.元素

    @override
    def 同端弹压冫元素扌(sf, 元素, /, *, 左端丷右端):
        '树 -> 元素 -> (树, 元素) | ^错误牜弹出乊空树'
        节点 = sf.包装冫元素扌(元素)
        (底树, 节点) = sf.展翅树乊底层.同端弹压扌(节点, 左端丷右端=左端丷右端)
        树 = sf.包装冫展翅树乊底层扌(底树)
        return (树, 节点.元素)
        ######################
        ######################
        (树, 元素纟出) = sf.弹出冫元素扌(左端丷右端=左端丷右端)
            # ^错误牜弹出乊空树
        树 = 树.压入冫元素扌(元素, 左端丷右端=左端丷右端)
        return (树, 元素纟出)
    @override
    def 异端压弹冫元素扌(sf, 元素, /, *, 左出丷右出):
        '树 -> 元素 -> (树, 元素)'
        节点 = sf.包装冫元素扌(元素)
        (底树, 节点) = sf.展翅树乊底层.异端压弹扌(节点, 左出丷右出=左出丷右出)
        树 = sf.包装冫展翅树乊底层扌(底树)
        return (树, 节点.元素)
        ######################
        ######################
        return sf.压入冫元素扌(元素, 左端丷右端=not 左出丷右出).弹出冫元素扌(左端丷右端=左出丷右出)
    @override
    def 异端压弹冫元素序列扌(sf, 元素序列, /, *, 左出丷右出):
        '树 -> 元素序列{左起丷右起=左出丷右出;} -> (树, 元素列表{左起丷右起=左出丷右出;}/[元素])'
        节点序列 = map(sf.包装冫元素扌, 元素序列)
        (底树, 节点列表) = sf.展翅树乊底层.异端压弹牜序列扌(节点序列, 左出丷右出=左出丷右出)
        树 = sf.包装冫展翅树乊底层扌(底树)
        元素列表 = [节点.元素 for 节点 in 节点列表]
        return (树, 元素列表)
        ######################
        ######################
        #保长流动:
        #异端压弹牜序列扌
        #ipushs_then_ipops_on_diff_endpoints_
        ls = []
        for 元素 in 元素序列:
            (sf, 元素) = sf.异端压弹冫元素扌(元素, 左出丷右出=左出丷右出)
            ls.append(元素)
        return (sf, ls)
    @override
    def 压入冫元素序列扌(sf, 元素序列, /, *, 左端丷右端, 左起丷右起):
        '树 -> 元素序列{左起丷右起;} -> 树'
        节点序列 = map(sf.包装冫元素扌, 元素序列)
        底树 = sf.展翅树乊底层.压入牜序列扌(节点序列, 左端丷右端=左端丷右端, 左起丷右起=左起丷右起)
        树 = sf.包装冫展翅树乊底层扌(底树)
        return 树
    @override
    def 压入冫元素序列牜计长度扌(sf, 元素序列, /, *, 左端丷右端, 左起丷右起):
        '树 -> 元素序列{左起丷右起;} -> (树,新增长度/uint)'
        节点序列 = map(sf.包装冫元素扌, 元素序列)
        (底树,新增长度) = sf.展翅树乊底层.压入牜序列牜计长度扌(节点序列, 左端丷右端=左端丷右端, 左起丷右起=左起丷右起)
        树 = sf.包装冫展翅树乊底层扌(底树)
        return (树,新增长度)
        ######################
    @override
    def 弹出冫元素列表扌(sf, 鬽最大弹出数, /, *, 左端丷右端, 左起丷右起):
        '树 -> 鬽 最大弹出数/uint -> (树, 元素列表{左起丷右起;}{len<=最大弹出数}/[元素])'
        (底树, 节点列表) = sf.展翅树乊底层.弹出牜列表扌(鬽最大弹出数, 左端丷右端=左端丷右端, 左起丷右起=左起丷右起)
        树 = sf.包装冫展翅树乊底层扌(底树)
        元素列表 = [节点.元素 for 节点 in 节点列表]
        return (树, 元素列表)





    ['取冫节点丶度量值巛路径扌', '取冫节点巛路径扌', '度量值', '搜索定位冫节点扌', '枚举冫节点扌', '枚举冫路径丶节点丶度量值扌']

    @override
    def 枚举冫元素扌(sf, /, *, 左起丷右起):
        '元素容器 -> 元素序列{左起丷右起;}/Iter 元素'
        r'''[[[
        from seed.tiny import print_err
        if 0b0001:print_err(type(sf.展翅树乊底层))
        if 0b0001:print_err((sf.展翅树乊底层.枚举冫节点扌))
        #]]]'''#'''
        for 节点 in sf.展翅树乊底层.枚举冫节点扌(左起丷右起=左起丷右起):
            yield 节点.元素
    @override
    def 枚举冫元素丶度量值扌(sf, /, *, 左起丷右起):
        '元素容器 -> 元素辻度量值序列{左起丷右起;}/Iter (元素, 度量值纟元素)'
        for 节点 in sf.展翅树乊底层.枚举冫节点扌(左起丷右起=左起丷右起):
            yield 节点.拆包冫元素节点扌()[::-1]
    @override
    def 取冫元素巛路径扌(sf, 路径全纟元素, /):
        '路径全纟元素{;左起丷右起} -> 元素'
        节点 = sf.展翅树乊底层.取冫节点巛路径扌(路径全纟元素.路径纟节点, 左起丷右起=路径全纟元素.左起丷右起)
        return 节点.元素
    @override
    def 取冫元素丶度量值巛路径扌(sf, 路径全纟元素, /):
        '路径全纟元素{;左起丷右起} -> (元素, 度量值纟元素)#注意:[不一定:[元素::魖含冫度量值]]'
        节点 = sf.展翅树乊底层.取冫节点巛路径扌(路径全纟元素.路径纟节点, 左起丷右起=路径全纟元素.左起丷右起)
        return 节点.拆包冫元素节点扌()[::-1]

    @override
    def 枚举冫路径丶元素丶度量值扌(sf, /, *, 左起丷右起):
        '-> Iter (路径全纟元素{;左起丷右起},元素,度量值纟元素)#注意:[不一定:[元素::魖含冫度量值]]'
        for (路径纟节点, 节点, 度量值) in sf.展翅树乊底层.枚举冫路径丶节点丶度量值扌(左起丷右起=左起丷右起):
            路径全纟元素 = 乸路径全纟元素(左起丷右起, 路径纟节点)
            yield (路径全纟元素, 节点.元素, 度量值)

    @override
    def 搜索定位冫元素扌(sf, 初始累计值, 累积扌, 进退判定扌, /, *, 左起丷右起, 欤已知非超后退, 欤已知非超前进):
        xx = (况态, x) = sf.展翅树乊底层.搜索定位冫节点扌(初始累计值, 累积扌, 进退判定扌, 左起丷右起=左起丷右起, 欤已知非超后退=欤已知非超后退, 欤已知非超前进=欤已知非超前进)
            # ^错误牜欤已知非超前进
        if not 况态 is 匡路径纟节点:
            return xx
        (累计值牜前进, 路径纟节点,焦点节点,度量值纟节点, 累计值牜后退) = x
        路径全纟元素 = 乸路径全纟元素(左起丷右起, 路径纟节点)
        return (匡路径全纟元素, (累计值牜前进, 路径全纟元素,焦点节点.元素,度量值纟节点, 累计值牜后退))

#end-class 魖元素容器爫展翅树牜通用具现(魖元素容器爫展翅树):





class 魖展翅树牜通用具现(魖展翅树):
    #class 魖展翅树牜通用具现冫分裂(魖展翅树):
    __slots__ = ()
    @override
    def 分裂乊节点间隙扌(sf, 鬽路径纟节点, /, *, 左起丷右起):
        '展翅树{深度;} -> 鬽 路径纟节点{左起丷右起;} -> (起树纟魊焦点居前/展翅树{深度;}, 讫树纟魊焦点诸后/展翅树{深度;}) #鬽路径纟节点:功用类似:魖路径全纟节点间隙'
        if 鬽路径纟节点 is None:
            #讫地址
            空树 = sf.匞展翅树.构造冫空树扌()
            (起树, 讫树) = sf, 空树
            return (起树, 讫树)
        路径纟节点 = 鬽路径纟节点
        (起树, 焦点, 讫树纟居后) = sf.分裂乊节点扌(路径纟节点, 左起丷右起=左起丷右起)
        讫树纟诸后 = 讫树纟居后.压入扌(焦点, 左端丷右端=左起丷右起)
        return (起树, 讫树纟诸后)

    @property
    @override
    def 左端点(sf, /):
        '-> 节点{深度;} | ^错误牜空树'
        return sf.取冫端点扌(左端丷右端=False)
    @property
    @override
    def 右端点(sf, /):
        '-> 节点{深度;} | ^错误牜空树'
        return sf.取冫端点扌(左端丷右端=True)

    @override
    def 取冫端点扌(sf, /, *, 左端丷右端):
        '-> 端点{深度,左端丷右端;}/节点{深度;} | ^错误牜空树'
        it = sf.枚举冫节点扌(左起丷右起=左端丷右端)
        for 端点 in it:
            assert not sf.欤空树
            return 端点
        assert sf.欤空树
        raise 错误牜空树
    @override
    def 同端弹压扌(sf, 节点, /, *, 左端丷右端):
        '展翅树{深度;} -> 节点{深度;} -> (展翅树{深度;}/魖展翅树, 节点{深度;}) | ^错误牜弹出乊空树'
        (树, 节点纟出) = sf.弹出扌(左端丷右端=左端丷右端)
            # ^错误牜弹出乊空树
        树 = 树.压入扌(节点, 左端丷右端=左端丷右端)
        return (树, 节点纟出)
    @override
    def 异端压弹扌(sf, 节点, /, *, 左出丷右出):
        '展翅树{深度;} -> 节点{深度;} -> (展翅树{深度;}/魖展翅树, 节点{深度;})'
        return sf.压入扌(节点, 左端丷右端=not 左出丷右出).弹出扌(左端丷右端=左出丷右出)
    @override
    def 异端压弹牜序列扌(sf, 节点序列, /, *, 左出丷右出):
        '展翅树{深度;} -> 节点序列{深度,左起丷右起=左出丷右出;} -> (展翅树{深度;}/魖展翅树, 节点列表{深度,左起丷右起=左出丷右出;}/[节点])'
        #保长流动:
        #异端压弹牜序列扌
        #ipushs_then_ipops_on_diff_endpoints_
        ls = []
        for 节点 in 节点序列:
            (sf, 节点) = sf.异端压弹扌(节点, 左出丷右出=左出丷右出)
            ls.append(节点)
        return (sf, ls)


    @override
    def 压入牜序列扌(sf, 节点序列, /, *, 左端丷右端, 左起丷右起):
        '展翅树{深度;} -> 节点序列{深度,左起丷右起;} -> 展翅树{深度;}'
        (树, 新增长度) = sf.压入牜序列牜计长度扌(节点序列, 左端丷右端=左端丷右端, 左起丷右起=左起丷右起)
        return 树
    @override
    def 压入牜序列牜计长度扌(sf, 节点序列, /, *, 左端丷右端, 左起丷右起):
        '展翅树{深度;} -> 节点序列{深度,左起丷右起;} -> (展翅树{深度;}, 新增长度/uint)'
        check_type_is(bool, 左起丷右起)
        check_type_is(bool, 左端丷右端)
        if 左起丷右起 is 左端丷右端:
            节点序列 = _蛮力反向枚举扌(节点序列)
            左起丷右起 = not 左起丷右起
        assert 左起丷右起 ^ 左端丷右端
        sz = 0
        for sz,节点 in enumerate(节点序列, 1):
            sf = sf.压入扌(节点, 左端丷右端=左端丷右端)
        return (sf, sz)
        #=>构造冫展翅树扌
    @override
    def 弹出牜列表扌(sf, 鬽最大弹出数, /, *, 左端丷右端, 左起丷右起):
        '展翅树{深度;} -> 鬽 最大弹出数/uint -> (展翅树{深度;}, 节点列表{深度,左起丷右起;}{len<=最大弹出数}/[节点])'
        check_type_is(bool, 左起丷右起)
        check_type_is(bool, 左端丷右端)
        if not 鬽最大弹出数 is None:
            最大弹出数 = 鬽最大弹出数
            check_int_ge(0, 最大弹出数)
            it = repeat(1, 最大弹出数)
        else:
            it = repeat(1)
        it
        ls = []
        for _ in it:
            #bug:if not sf:break
            if sf.欤空树:break
            (sf, 节点) = sf.弹出扌(左端丷右端=左端丷右端)
            ls.append(节点)
        if 鬽最大弹出数 is None:
            #bug:assert not sf
            assert sf.欤空树
        else:
            assert len(ls) <= 最大弹出数
            #bug:assert not sf or len(ls) == 最大弹出数
            assert sf.欤空树 or len(ls) == 最大弹出数
        if 左起丷右起 ^ 左端丷右端:
            ls.reverse()
        return (sf, ls)
#end-class 魖展翅树牜通用具现(魖展翅树):

class 魖根深树牜通用具现冫琐碎(魖根深树):
    __slots__ = ()

    @override
    def 拆包冫根深树乊左右扌(sf, /):
        '根深树{深度;} -> (左翼{深度;}, 更深树{深度;}/展翅树{深度+1;}, 右翼{深度;})'
        return sf.拆包冫根深树乊起讫扌(左起丷右起=False)
    @override
    def 拆包冫根深树乊起讫扌(sf, /, *, 左起丷右起):
        '根深树{深度;} -> (起翼{深度,左起丷右起;}, 更深树{深度;}/展翅树{深度+1;}, 讫翼{深度,左起丷右起;})'
        return tuple(sf.枚举冫部件扌(左起丷右起=左起丷右起))
    @override
    def 取冫翅膀扌(sf, /, *, 左翼丷右翼):
        '-> 翅膀{深度,左翼丷右翼;}'
        #(左翼, 更深树, 右翼) = sf.拆包冫根深树乊左右扌()
        (起翼, 更深树, 讫翼) = sf.拆包冫根深树乊起讫扌(左起丷右起=左翼丷右翼)
        return 起翼
    @property
    @override
    def 左翼(sf, /):
        '-> 左翼{深度;}/翅膀{深度,左翼丷右翼=False;}'
        return sf.取冫翅膀扌(左翼丷右翼=False)
    @property
    @override
    def 右翼(sf, /):
        '-> 右翼{深度;}/翅膀{深度,左翼丷右翼=True;}'
        return sf.取冫翅膀扌(左翼丷右翼=True)
    @property
    @override
    def 更深树(sf, /):
        '-> 更深树{深度;}/展翅树{深度+1;}'
        (左翼, 更深树, 右翼) = sf.拆包冫根深树乊左右扌()
        return 更深树

    @override
    def 枚举冫节点扌(sf, /, *, 左起丷右起):
        '-> 节点序列{深度;左起丷右起}/Iter 节点'
        for i, 部件 in enumerate(sf.枚举冫部件扌(左起丷右起=左起丷右起)):
            it = 部件.枚举冫节点扌(左起丷右起=左起丷右起)
            if i == 1:
                更深节点序列 = it
                节点序列 = (节点 for 更深节点 in 更深节点序列 for 节点 in 更深节点.枚举冫节点扌(左起丷右起=左起丷右起))
            else:
                节点序列 = it
            yield from 节点序列
        return

#end-class 魖根深树牜通用具现冫琐碎(魖根深树):







class 魖光杆树牜通用具现冫分裂(魖光杆树):
    __slots__ = ()
    @override
    def 分裂乊节点扌(sf, 路径纟节点, /, *, 左起丷右起):
        '展翅树{深度;} -> 路径纟节点{左起丷右起;} -> (起树纟焦点居前{左起丷右起;}/展翅树{深度;}, 节点{深度;}, 讫树纟焦点居后{左起丷右起;}/展翅树{深度;})'
        (起列表, 焦点, 讫列表) = 分裂乊节点爫测距扌(光杆树:=sf, 路径纟节点, 左起丷右起=左起丷右起)
        匞展翅树 = sf.匞展翅树
        起树 = 匞展翅树.构造冫光杆树扌(起列表, 左起丷右起=左起丷右起)
        讫树 = 匞展翅树.构造冫光杆树扌(讫列表, 左起丷右起=左起丷右起)
        return (起树, 焦点, 讫树)
#end-class 魖光杆树牜通用具现冫分裂(魖光杆树):


def 补全冫起翼扌(起列表冃残缺起翼, 更深树, 讫翼, /, *, 左起丷右起):
    '起列表冃残缺起翼{深度,左起丷右起;}/[节点{深度;}]{len<=最大节点数纟翅膀} -> 更深树{深度;}/展翅树{深度+1;} -> 讫翼{深度,左起丷右起;} -> 展翅树{深度;}'
    匞展翅树 = 更深树.匞展翅树
    最小节点数纟翅膀 = 匞展翅树.毶展翅树.最小节点数纟翅膀
    ls = 起列表冃残缺起翼
    if len(ls) < 最小节点数纟翅膀:
        if 更深树.欤空树:
            it = 讫翼.枚举冫节点扌(左起丷右起=左起丷右起)
            it = chain(ls, it)
            光杆树 = 匞展翅树.构造冫光杆树扌(it, 左起丷右起=左起丷右起)
                # !! 简化退化=>[1+最大节点数纟光杆树 >= 最大节点数纟翅膀+最小节点数纟翅膀]
            return 光杆树
        (更深树, 更深节点) = 更深树.弹出扌(左端丷右端=左起丷右起)
        it = 更深节点.枚举冫节点扌(左起丷右起=左起丷右起)
        ls.extend(it)
    assert len(ls) >= 最小节点数纟翅膀
    起翼 = 匞展翅树.构造冫翅膀扌(ls, 左翼丷右翼=左起丷右起, 左起丷右起=左起丷右起)
    根深树 = 匞展翅树.构造冫根深树乊起讫扌(起翼, 更深树, 讫翼, 左起丷右起=左起丷右起)
    return 根深树


def 分裂乊节点乊翅膀扌(根深树, 起端距离, /, *, 左翼丷右翼, 左起丷右起):
    '根深树{深度;} -> 起端距离{左翼丷右翼,左起丷右起;} -> (起树纟焦点居前{左起丷右起;}/展翅树{深度;}, 节点{深度;}, 讫树纟焦点居后{左起丷右起;}/展翅树{深度;})'
    check_type_is(bool, 左起丷右起)
    check_type_is(bool, 左翼丷右翼)
    翅膀 = 根深树.取冫翅膀扌(左翼丷右翼=左翼丷右翼)
    外端距离 = 起端距离 if 左起丷右起 is 左翼丷右翼 else 翅膀.节点数 -起端距离 -1
    it = 根深树.枚举冫节点扌(左起丷右起=左翼丷右翼)
        # !! 外端
    光杆树 = 根深树.匞展翅树.构造冫光杆树扌(islice(it,外端距离), 左起丷右起=左翼丷右翼)
        # !! 简化退化=>[最大节点数纟光杆树 >= 最大节点数纟翅膀 > 外端距离]
    焦点 = next(it)
    树 = 根深树
    for _ in range(1+外端距离):
        (树,_) = 树.弹出扌(左端丷右端=左翼丷右翼)
    (起树, 讫树) = (光杆树, 树) if 左起丷右起 is 左翼丷右翼 else (树, 光杆树)
    return (起树, 焦点, 讫树)
def 分裂乊节点爫测距扌(节点容器牜节点数, 路径纟节点, /, *, 左起丷右起):
    '魖节点容器牜节点数{深度;} -> 路径纟节点{左起丷右起;} -> (起列表纟焦点居前{左起丷右起;}/[节点{深度;}], 节点{深度;}, 讫列表纟焦点居后{左起丷右起;}/[节点{深度;}])'
    i = 节点容器牜节点数.测距冫节点乊起端扌(路径纟节点, 左起丷右起=左起丷右起)
    it = 节点容器牜节点数.枚举冫节点扌(左起丷右起=左起丷右起)
    起列表 = [*islice(it, i)]
    焦点 = next(it)
    讫列表 = [*it]
    return (起列表, 焦点, 讫列表)
class 魖根深树牜特化具现冫分裂爫魖路径纟节点牜部件容器暨节点容器(魖根深树):

    #see:魖根深树牜通用具现冫琐碎
    '[路径纟节点<根深树> === 魖路径纟节点牜部件容器暨节点容器]'
    #需要:魖部件容器牜搜索定位
    __slots__ = ()
    @override
    def 分裂乊节点扌(sf, 路径纟节点, /, *, 左起丷右起):
        '展翅树{深度;} -> 路径纟节点{左起丷右起;} -> (起树纟焦点居前{左起丷右起;}/展翅树{深度;}, 节点{深度;}, 讫树纟焦点居后{左起丷右起;}/展翅树{深度;})'
        assert sf.匞展翅树.毶展翅树.欤需要冫分裂操作
        类别 = 路径纟节点.部件类别牜搜索定位
        if 类别 is 匡部件即更深节点容器:
            #更深树
            (起翼, 更深树, 讫翼) = sf.拆包冫根深树乊起讫扌(左起丷右起=左起丷右起)
            更深树
            (起树纟更深, 焦点纟更深, 讫树纟更深) = 更深树.分裂乊节点扌(路径纟节点.路径纟更深节点匕部件, 左起丷右起=左起丷右起)
            (起列表, 焦点, 讫列表) = 分裂乊节点爫测距扌(焦点纟更深, 路径纟节点.路径纟节点匕更深节点, 左起丷右起=左起丷右起)
            讫树 = 补全冫起翼扌(讫列表, 讫树纟更深, 讫翼, 左起丷右起=左起丷右起)
            起树 = 补全冫起翼扌(起列表, 起树纟更深, 起翼, 左起丷右起=not 左起丷右起)
            return (起树, 焦点, 讫树)
        if 类别 is 匡部件即节点容器:
            #翅膀
            #注意:浅包装 导致 id()不一致
            部件 = sf.取冫部件巛扁索引扌(路径纟节点.扁索引纟部件, 左起丷右起=左起丷右起)
            左翼丷右翼 = 部件.左翼丷右翼
            翅膀 = sf.取冫翅膀扌(左翼丷右翼=左翼丷右翼)
            部件 = 翅膀
            起端距离 = 翅膀.测距冫节点乊起端扌(路径纟节点.路径纟节点匕部件, 左起丷右起=左起丷右起)
            return 分裂乊节点乊翅膀扌(展翅树:=sf, 起端距离, 左翼丷右翼=左翼丷右翼, 左起丷右起=左起丷右起)
        raise TypeError(类别)
#end-class 魖根深树牜特化具现冫分裂爫魖路径纟节点牜部件容器暨节点容器(魖根深树):

def _连续压入扌(展翅树, 节点数纟序列, 节点序列, /, *, 左端丷右端, 左起丷右起):
    if not 左端丷右端 ^ 左起丷右起:raise 000
    总数 = 0
    for 总数, 节点 in enumerate(节点序列, 1):
        展翅树 = 展翅树.压入扌(节点, 左端丷右端=左端丷右端)
    if not 总数 == 节点数纟序列:raise 000
    return 展翅树
class 魖光杆树牜通用具现冫合并(魖光杆树):
    __slots__ = ()
    @override
    def 合并牜间夹序列扌(sf, 节点数纟序列, 节点序列, 展翅树, /, *, 左端丷右端, 左起丷右起):
        '展翅树{深度;} -> 节点数纟序列/uint -> 节点序列{深度,左起丷右起;}{len=节点数纟序列}/Iter 节点 -> 展翅树{深度;} -> 展翅树{深度;} #[左起丷右起:只对 节点序列 起作用][左端丷右端:在这里扮演 大颗粒版 左起丷右起]'
        匞展翅树 = sf.匞展翅树
        assert 匞展翅树.毶展翅树.欤需要冫合并操作
        check_type_is(bool, 左起丷右起)
        check_type_is(bool, 左端丷右端)
        if 节点数纟序列:
            if 左端丷右端 is 左起丷右起:
                展翅树 = _连续压入扌(展翅树, 节点数纟序列, 节点序列, 左端丷右端=not 左端丷右端, 左起丷右起=左起丷右起)
            else:
                sf = _连续压入扌(sf, 节点数纟序列, 节点序列, 左端丷右端=左端丷右端, 左起丷右起=左起丷右起)
            return sf.合并牜间夹序列扌(0, '', 展翅树, 左端丷右端=左端丷右端, 左起丷右起=左起丷右起)

        assert 节点数纟序列 == 0
        [] = 节点序列

        if 展翅树.欤光杆 and 展翅树.节点数 < sf.节点数:
            return 展翅树.合并牜间夹序列扌(节点数纟序列, 节点序列, sf, 左端丷右端=not 左端丷右端, 左起丷右起=左起丷右起)

        大树 = 展翅树
        小树 = sf
        左端丷右端纟小树 = 左端丷右端
        左端丷右端纟大树 = not 左端丷右端
        it = 小树.枚举冫节点扌(左起丷右起=左端丷右端纟小树)
        展翅树 = _连续压入扌(展翅树, 节点数纟序列:=小树.节点数, 节点序列:=it, 左端丷右端=左端丷右端纟大树, 左起丷右起=左端丷右端纟小树)
        return 展翅树
#end-class 魖光杆树牜通用具现冫合并(魖光杆树):

class 魖根深树牜通用具现冫合并(魖根深树):
    __slots__ = ()
    @override
    def 合并牜间夹序列扌(sf, 节点数纟序列, 节点序列, 展翅树, /, *, 左端丷右端, 左起丷右起):
        '展翅树{深度;} -> 节点数纟序列/uint -> 节点序列{深度,左起丷右起;}{len=节点数纟序列}/Iter 节点 -> 展翅树{深度;} -> 展翅树{深度;} #[左起丷右起:只对 节点序列 起作用][左端丷右端:在这里扮演 大颗粒版 左起丷右起]'
        匞展翅树 = sf.匞展翅树
        assert 匞展翅树.毶展翅树.欤需要冫合并操作
        check_type_is(bool, 左起丷右起)
        check_type_is(bool, 左端丷右端)
        if 展翅树.欤光杆 or 左端丷右端 is 左起丷右起:
            return 展翅树.合并牜间夹序列扌(节点数纟序列, 节点序列, sf, 左端丷右端=not 左端丷右端, 左起丷右起=左起丷右起)
        assert 左端丷右端 ^ 左起丷右起
        起树 = sf
        讫树 = 展翅树
        (起树起翼, 起树灬更深树, 起树讫翼) = 起树.拆包冫根深树乊起讫扌(左起丷右起=左起丷右起)
        (讫树起翼, 讫树灬更深树, 讫树讫翼) = 讫树.拆包冫根深树乊起讫扌(左起丷右起=左起丷右起)

        (更深节点数纟序列, 更深节点序列) = 下沉浓缩冫异树双翼间夹节点序列扌(匞展翅树, 起树讫翼, 节点数纟序列, 节点序列, 讫树起翼, 左起丷右起=左起丷右起)
        更深树 = 起树灬更深树.合并牜间夹序列扌(更深节点数纟序列, 更深节点序列, 讫树灬更深树, 左端丷右端=左端丷右端, 左起丷右起=左起丷右起)
        #####
        根深树 = 匞展翅树.构造冫根深树乊起讫扌(起树起翼, 更深树, 讫树讫翼, 左起丷右起=左起丷右起)
        return 根深树
#end-class 魖根深树牜通用具现冫合并(魖根深树):

def 下沉浓缩冫节点序列扌(匞展翅树, 节点数纟序列, 节点序列, /, *, 左起丷右起):
    '节点数纟序列/uint -> 节点序列{深度,左起丷右起;}{len=节点数纟序列}/Iter 节点{深度;} -> (更深节点数纟序列/uint, 更深节点序列{深度,左起丷右起;}/Iter 节点{深度+1;})'
    参 = 匞展翅树.毶展翅树
    assert 参.欤需要冫合并操作
    a = 参.最小节点数纟更深节点
    b = 参.最优节点数纟更深节点
    c = 参.最大节点数纟更深节点
    if not 2 <= a <= b <= c:raise TypeError
    if not 2*a <= 1+c:raise TypeError
    if not 参.最小节点数纟更深节点 <= 节点数纟序列:raise ValueError
    n = 节点数纟序列
    q, r = divmod(n-a, b)
    rs = [r+a] if r < a else [r, a]
    assert all(a <= r <= c for r in rs)
    assert n == q*b+sum(rs)
    更深节点数纟序列 = q + len(rs)
    us = chain(repeat(b, q), rs)
    it = iter(节点序列)
    mk = 匞展翅树.构造冫更深节点扌
    def __(mk, us, it, 左起丷右起, /):
        for u in us:
            更深节点 = mk(islice(it, u), 左起丷右起=左起丷右起)
            #bug:if not len(更深节点) == u:raise 000
            if not 更深节点.节点数 == u:raise 000
            yield 更深节点
        for _ in it:
            raise 000
    return 更深节点数纟序列, __(mk, us, it, 左起丷右起)

def 下沉浓缩冫异树双翼间夹节点序列扌(匞展翅树, 起树讫翼, 节点数纟序列, 节点序列, 讫树起翼, /, *, 左起丷右起):
    '起树讫翼{深度,左起丷右起;} -> 节点数纟序列/uint -> 节点序列{深度,左起丷右起;}{len=节点数纟序列}/Iter 节点{深度;} -> 讫树起翼{深度,左起丷右起;} -> (更深节点数纟序列/uint, 更深节点序列{深度,左起丷右起;}/Iter 节点{深度+1;})'
    it0 = 起树讫翼.枚举冫节点扌(左起丷右起=左起丷右起)
    it1 = 节点序列
    it2 = 讫树起翼.枚举冫节点扌(左起丷右起=左起丷右起)
    sz0 = 起树讫翼.节点数
    sz1 = 节点数纟序列
    sz2 = 讫树起翼.节点数
    sz = sz0 + sz1 + sz2
    it = chain(it0, it1, it2)
    return 下沉浓缩冫节点序列扌(匞展翅树, 节点数纟序列:=sz, 节点序列:=it, 左起丷右起=左起丷右起)




class 魖光杆树牜通用具现冫压入弹出(魖光杆树):
    __slots__ = ()
    @override
    def 压入扌(sf, 节点, /, *, 左端丷右端):
        '展翅树{深度;} -> 节点{深度;} -> 展翅树{深度;}'
        #if 0b001:print(魖光杆树牜通用具现冫压入弹出, sf.压入扌)
        it = chain([节点], sf.枚举冫节点扌(左起丷右起=左端丷右端))
        匞展翅树 = sf.匞展翅树
        if not sf.欤满员:
            #if 0b001:print('not 欤满员')
            return 匞展翅树.构造冫光杆树扌(it, 左起丷右起=左端丷右端)
        #if 0b001:print('欤满员')
        sz = (sf.节点数+1)
        sz0 = sz//2
        sz1 = sz -sz0
        匞展翅树 = sf.匞展翅树
        起翼 = 匞展翅树.构造冫翅膀扌(islice(it, sz0), 左翼丷右翼=左端丷右端, 左起丷右起=左端丷右端)
        讫翼 = 匞展翅树.构造冫翅膀扌(islice(it, sz1), 左翼丷右翼=not 左端丷右端, 左起丷右起=左端丷右端)
        空更深树 = 匞展翅树.构造冫空树扌()
        空心树 = 匞展翅树.构造冫根深树乊起讫扌(起翼, 空更深树, 讫翼, 左起丷右起=左端丷右端)
        return 空心树

    @override
    def 弹出扌(sf, /, *, 左端丷右端):
        '展翅树{深度;} -> (展翅树{深度;}, 节点{深度;}) | ^错误牜空树'
        it = sf.枚举冫节点扌(左起丷右起=左端丷右端)
        for 节点 in it:
            break
        else:
            assert sf.欤空树
            raise 错误牜空树
        光杆树 = sf.匞展翅树.构造冫光杆树扌(it, 左起丷右起=左端丷右端)
        return (光杆树, 节点)

#end-class 魖光杆树牜通用具现冫压入弹出(魖光杆树):


class 魖根深树牜通用具现冫压入弹出(魖根深树):
    __slots__ = ()

    @override
    def 压入扌(sf, 节点, /, *, 左端丷右端):
        '展翅树{深度;} -> 节点{深度;} -> 展翅树{深度;}'
        (起翼, 更深树, 讫翼) = sf.拆包冫根深树乊起讫扌(左起丷右起=左端丷右端)
        (起翼, 鬽更深节点) = 起翼.外端压入扌(节点)
        if not 鬽更深节点 is None:
            更深节点 = 鬽更深节点
            更深树 = 更深树.压入扌(更深节点, 左端丷右端=左端丷右端)
                #recur...
        return sf.匞展翅树.构造冫根深树乊起讫扌(起翼, 更深树, 讫翼, 左起丷右起=左端丷右端)


    @override
    def 弹出扌(sf, /, *, 左端丷右端):
        '展翅树{深度;} -> (展翅树{深度;}, 节点{深度;}) | ^错误牜空树'
        匞展翅树 = sf.匞展翅树
        (起翼, 更深树, 讫翼) = sf.拆包冫根深树乊起讫扌(左起丷右起=左端丷右端)
        if not 起翼.欤濒危:
            (起翼, 节点) = 起翼.外端弹出乊足员扌()
        elif not 更深树.欤空树:
            (更深树, 更深节点) = 更深树.弹出扌(左端丷右端=左端丷右端)
            (起翼, 节点) = 起翼.外端弹出乊濒危扌(更深节点)
        else:
            it = sf.枚举冫节点扌(左起丷右起=左端丷右端)
            节点 = next(it)
            光杆树 = 匞展翅树.构造冫光杆树扌(it, 左起丷右起=左端丷右端)
                # !! 简化退化=>[1+最大节点数纟光杆树 >= 最大节点数纟翅膀+最小节点数纟翅膀]
            return (光杆树, 节点)
        根深树 = 匞展翅树.构造冫根深树乊起讫扌(起翼, 更深树, 讫翼, 左起丷右起=左端丷右端)
        return (根深树, 节点)


#end-class 魖根深树牜通用具现冫压入弹出(魖根深树):



class 魖翅膀牜通用具现(魖翅膀):
    __slots__ = ()
    @property
    @override
    def 欤濒危(sf, /):
        '-> bool/欤临界缺员'
        return sf.节点数 == sf.匞展翅树.毶展翅树.最小节点数纟翅膀
    @property
    @override
    def 欤满员(sf, /):
        '-> bool'
        return sf.节点数 == sf.匞展翅树.毶展翅树.最大节点数纟翅膀
    @override
    def 外端压入扌(sf, 节点, /):
        '翅膀{深度;左翼丷右翼} -> 节点{深度;} -> (翅膀{深度;左翼丷右翼}, 鬽 更深节点{深度;})'
        左起丷右起 = 左翼丷右翼 = sf.左翼丷右翼
        it = chain([节点], sf.枚举冫节点扌(左起丷右起=左起丷右起))
        匞展翅树 = sf.匞展翅树
        if not sf.欤满员:
            翅膀 = 匞展翅树.构造冫翅膀扌(it, 左翼丷右翼=左翼丷右翼, 左起丷右起=左起丷右起)
            return (翅膀, None)
        sz = (sf.节点数+1)
        sz1 = 匞展翅树.毶展翅树.最优节点数纟更深节点
        sz0 = sz -sz1
        翅膀 = 匞展翅树.构造冫翅膀扌(islice(it, sz0), 左翼丷右翼=左翼丷右翼, 左起丷右起=左起丷右起)
        更深节点 = 匞展翅树.构造冫更深节点扌(islice(it, sz1), 左起丷右起=左起丷右起)
        assert 翅膀.节点数 == sz0
        assert 更深节点.节点数 == sz1
        [] = it
        return (翅膀, 更深节点)


    @override
    def 外端弹出乊足员扌(sf, /):
        '翅膀{深度;左翼丷右翼} -> (翅膀{深度;左翼丷右翼}, 节点{深度;})'
        左起丷右起 = 左翼丷右翼 = sf.左翼丷右翼
        it = sf.枚举冫节点扌(左起丷右起=左起丷右起)
        节点 = next(it)
        翅膀 = sf.匞展翅树.构造冫翅膀扌(it, 左翼丷右翼=左翼丷右翼, 左起丷右起=左起丷右起)
        return (翅膀, 节点)

    @override
    def 外端弹出乊濒危扌(sf, 更深节点, /):
        '翅膀{深度;左翼丷右翼} -> 更深节点{深度;} -> (翅膀{深度;左翼丷右翼}, 节点{深度;})'
        左起丷右起 = 左翼丷右翼 = sf.左翼丷右翼
        it0 = sf.枚举冫节点扌(左起丷右起=左起丷右起)
        节点 = next(it0)
        it1 = 更深节点.枚举冫节点扌(左起丷右起=左起丷右起)
        it = chain(it0, it1)
        翅膀 = sf.匞展翅树.构造冫翅膀扌(it, 左翼丷右翼=左翼丷右翼, 左起丷右起=左起丷右起)
        return (翅膀, 节点)
#end-class 魖翅膀牜通用具现(魖翅膀):


class 魖匞展翅树牜通用具现(魖匞展翅树):
    __slots__ = ()

    @override
    def 构造冫根深树乊起讫扌(sf, 起翼, 更深树, 讫翼, /, *, 左起丷右起):
        '起翼{深度,左起丷右起;} -> 更深树{深度;}/展翅树{深度+1;} -> 讫翼{深度,左起丷右起;} -> 根深树{深度;}/魖根深树'
        (左翼,右翼) = (起翼,讫翼) if not 左起丷右起 else (讫翼,起翼)
        return sf.构造冫根深树乊左右扌(左翼,更深树,右翼)
    @override
    def 构造冫翅膀扌(sf, 节点序列, /, *, 左翼丷右翼, 左起丷右起):
        '节点序列{深度,左起丷右起;}/Iter 节点{深度;} -> 翅膀{深度;左翼丷右翼}/魖翅膀'
        if 左翼丷右翼:
            return sf.构造冫右翼扌(节点序列, 左起丷右起=左起丷右起)
        return sf.构造冫左翼扌(节点序列, 左起丷右起=左起丷右起)
    @override
    def 构造冫空树扌(sf, /):
        '-> 展翅树{深度;}/魖展翅树'
        return sf.构造冫光杆树扌('', 左起丷右起=False)
    @override
    def 构造冫展翅树扌(sf, 节点序列, /, *, 左起丷右起):
        '节点序列{深度,左起丷右起;}/Iter 节点{深度;} -> 展翅树{深度;}/魖展翅树'
        (树, 总长) = sf.构造冫展翅树丶总长扌(节点序列, 左起丷右起=左起丷右起)
        return 树
    @override
    def 构造冫展翅树丶总长扌(sf, 节点序列, /, *, 左起丷右起):
        '节点序列{深度,左起丷右起;}/Iter 节点{深度;} -> (展翅树{深度;}, 总长/uint)'
        it = iter(节点序列)
        it0 = islice(it, sf.毶展翅树.最大节点数纟光杆树)
        树 = sf.构造冫光杆树扌(it0, 左起丷右起=左起丷右起)
        长度 = 树.节点数
        左端丷右端 = not 左起丷右起
        (树, 新增长度) = 树.压入牜序列牜计长度扌(it, 左端丷右端=左端丷右端, 左起丷右起=左起丷右起)
        return (树, 长度+新增长度)
#end-class 魖匞展翅树牜通用具现(魖匞展翅树):





class 魖光杆树牜通用具现(*''
    ,魖光杆树牜通用具现冫分裂
    ,魖光杆树牜通用具现冫合并
    ,魖光杆树牜通用具现冫压入弹出
    ,魖展翅树牜通用具现
    ):
    __slots__ = ()
    魖部件容器牜搜索定位爫部件即节点
    @property
    @override
    def 欤满员(sf, /):
        '-> bool'
        return sf.节点数 == sf.匞展翅树.毶展翅树.最大节点数纟光杆树

class 魖根深树牜通用具现(*''
    ,魖根深树牜通用具现冫合并
    ,魖根深树牜通用具现冫压入弹出
    ,魖根深树牜通用具现冫琐碎
    ,魖展翅树牜通用具现
    ):
    __slots__ = ()
    魖根深树牜特化具现冫分裂爫魖路径纟节点牜部件容器暨节点容器

class 魖光杆树牜特化具现爫部件即节点(*''
    ,魖光杆树牜通用具现
    ,魖部件容器牜搜索定位爫部件即节点
    ):
    __slots__ = ()
class 魖根深树牜特化具现爫魖路径纟节点牜部件容器暨节点容器(*''
    ,魖根深树牜特化具现冫分裂爫魖路径纟节点牜部件容器暨节点容器
    ,魖根深树牜通用具现
    ):
    __slots__ = ()

class 魖左翼牜通用具现(魖翅膀牜通用具现,魖左翼):
    __slots__ = ()
    魖部件容器牜搜索定位爫部件即节点
class 魖右翼牜通用具现(魖翅膀牜通用具现,魖右翼):
    __slots__ = ()
    魖部件容器牜搜索定位爫部件即节点

class 魖翅膀牜特化具现爫部件即节点(魖翅膀牜通用具现,魖部件容器牜搜索定位爫部件即节点):
    __slots__ = ()
class 魖左翼牜特化具现爫部件即节点(魖左翼牜通用具现,魖翅膀牜特化具现爫部件即节点):
    __slots__ = ()
class 魖右翼牜特化具现爫部件即节点(魖右翼牜通用具现,魖翅膀牜特化具现爫部件即节点):
    __slots__ = ()


class 魖更深节点牜特化具现爫部件即节点(魖更深节点,魖部件容器牜搜索定位爫部件即节点):
    __slots__ = ()

魖元素容器爫展翅树牜通用具现
魖匞展翅树牜通用具现

魖展翅树牜通用具现
魖光杆树牜通用具现
魖根深树牜通用具现
魖翅膀牜通用具现
魖左翼牜通用具现
魖右翼牜通用具现







魖根深树牜特化具现爫魖路径纟节点牜部件容器暨节点容器

魖光杆树牜特化具现爫部件即节点
魖翅膀牜特化具现爫部件即节点
魖左翼牜特化具现爫部件即节点
魖右翼牜特化具现爫部件即节点
魖更深节点牜特化具现爫部件即节点

























#元组具现:
class _魖成员:pass
_魖成员 = abstractmethod(_魖成员())
assert _魖成员.__isabstractmethod__

class _魖容器牜元组具现(tuple, ABC):
    __slots__ = ()
    __bool__ = None
    __len__ = None
    __iter__ = None
    __reversed__ = None
    #取消:@classmethod
    #   !! _移至子类冫重要属性纟所有类型扌 要求 不含 classmethod
    @abstractmethod
    def 罒类忄取冫匞展翅树扌(cls, /):
        '-> 匞展翅树'
    @property
    @override
    def 匞展翅树(sf, /):
        '-> 魖匞展翅树'
        cls = type(sf)
        匞展翅树 = cls.罒类忄取冫匞展翅树扌(cls)
        return 匞展翅树
class _魖部件容器牜元组具现(_魖容器牜元组具现,魖部件容器牜搜索定位):
    '[部件 :: 魖含冫度量值]'
    __slots__ = ()
    def __repr__(sf, /):
        return repr_helper(sf, *sf[1:])

    def __new__(cls, /, *部件列表):
        #if not cls.最小部件数 <= len(部件列表) <= cls.最大部件数:raise TypeError
        #匞度量值 = cls.匞度量值

        (最小部件数,最大部件数) = cls.罒类忄取冫最小部件数丶最大部件数扌(cls)
        匞度量值 = cls.罒类忄取冫匞度量值扌(cls)

        if not 最小部件数 <= len(部件列表) <= 最大部件数:raise TypeError
        度量值 = 匞度量值.零度量值
        for 部件 in 部件列表:
            度量值 = 匞度量值.结合冫度量值扌(度量值, 部件.度量值)
        度量值
        sf = tuple.__new__(cls, [度量值, *部件列表])
        return sf

    if 0:
        @property
        #@class_property
        @abstractmethod
        def 最小部件数(cls, /):
            '-> uint'
        @property
        #@class_property
        @abstractmethod
        def 最大部件数(cls, /):
            '-> uint'

        @property
        #@class_property
        @abstractmethod
        def 匞度量值(cls, /):
            '-> 魖匞度量值'

    if 0:
        最小部件数 = _魖成员
        最大部件数 = _魖成员
        匞度量值 = _魖成员

    #取消:@classmethod
    #   !! _移至子类冫重要属性纟所有类型扌 要求 不含 classmethod
    @abstractmethod
    def 罒类忄取冫最小部件数丶最大部件数扌(cls, /):
        '-> (最小部件数,最大部件数)'
    #@abstractmethod
    def 罒类忄取冫匞度量值扌(cls, /):
        '-> 匞度量值'
        匞展翅树 = cls.罒类忄取冫匞展翅树扌(cls)
        return 匞展翅树.匞度量值

    ['匞展翅树', '取冫部件丶度量值巛扁索引扌', '取冫部件巛扁索引扌', '度量值', '枚举冫扁索引丶部件丶度量值扌', '枚举冫部件扌', '测距冫部件乊起端扌', '部件数']
    #==>>:
    #['匞展翅树', '匞度量值', '最大部件数', '最小部件数']


    @property
    @override
    def 度量值(sf, /):
        '-> 度量值'
        return sf[0]

    @property
    @override
    def 部件数(sf, /):
        '-> uint'
        return tuple.__len__(sf) -1

    @override
    def 枚举冫部件扌(sf, /, *, 左起丷右起):
        '部件容器 -> Iter 部件'
        if not 左起丷右起:
            it = tuple.__iter__(sf)
            next(it)
            return it
        js = range(1, tuple.__len__(sf))[::-1]
        return (sf[j] for j in js)
        #return map(tuple.__getitem__, )

    @override
    def 测距冫部件乊起端扌(sf, 扁索引纟部件, /, *, 左起丷右起):
        '扁索引纟部件{左起丷右起;} -> 部件到容器起端的距离/焦点与容器起端相隔部件数{0=>焦点是起端端点}/uint#部件数=>反向'
        return 扁索引纟部件



    @override
    def 取冫部件巛扁索引扌(sf, 扁索引纟部件, /, *, 左起丷右起):
        '扁索引纟部件{左起丷右起;} -> 部件'
        if not 左起丷右起:
            return sf[1+扁索引纟部件]
        return sf[-1-扁索引纟部件]
    @override
    def 取冫部件丶度量值巛扁索引扌(sf, 扁索引纟部件, /, *, 左起丷右起):
        '扁索引纟部件{左起丷右起;} -> (部件,度量值纟部件)#注意:[不一定:[部件::魖含冫度量值]]'
        部件 = sf.取冫部件巛扁索引扌(扁索引纟部件, 左起丷右起=左起丷右起)
        return (部件,部件.度量值)


    @override
    def 枚举冫扁索引丶部件丶度量值扌(sf, /, *, 左起丷右起):
        '-> Iter (扁索引纟部件{左起丷右起;},部件,度量值纟部件)#注意:[不一定:[部件::魖含冫度量值]]'
        it = sf.枚举冫部件扌(左起丷右起=左起丷右起)
        for j, 部件 in enumerate(it):
            yield (j,部件,部件.度量值)
    @override
    def 解读冫部件类别牜搜索定位扌(sf, 扁索引纟部件,部件, /):
        '-> 筐部件类别牜搜索定位'
        if 扁索引纟部件 == 1:
            return 匡部件即更深节点容器
        return 匡部件即节点容器
#end-class _魖部件容器牜元组具现(_魖容器牜元组具现,魖部件容器):

class 魖元素节点牜元组具现(_魖容器牜元组具现,魖元素节点):
    '元素封包节点 改名为 元素节点'
    __slots__ = ()
    def __repr__(sf, /):
        return repr_helper(sf, *sf[:])
    def __new__(cls, 度量值, 元素, /):
        sf = tuple.__new__(cls, [度量值, 元素])
        return sf
    @property
    @override
    def 度量值(sf, /):
        '-> 度量值'
        return sf[0]
    @property
    @override
    def 元素(sf, /):
        '-> 元素'
        return sf[1]

    @override
    def 拆包冫元素节点扌(sf, /):
        '元素节点/节点{深度:=0;} -> (度量值, 元素)'
        return (sf.度量值, sf.元素)











class 魖根深树牜元组具现爫魖路径纟节点牜部件容器暨节点容器(_魖部件容器牜元组具现,魖根深树牜特化具现爫魖路径纟节点牜部件容器暨节点容器):
    __slots__ = ()
    @override
    def 罒类忄取冫最小部件数丶最大部件数扌(cls, /):
        '-> (最小部件数,最大部件数)'
        return (3, 3)

class 魖光杆树牜元组具现爫部件即节点(_魖部件容器牜元组具现,魖光杆树牜特化具现爫部件即节点):
    __slots__ = ()
    @override
    def 罒类忄取冫最小部件数丶最大部件数扌(cls, /):
        '-> (最小部件数,最大部件数)'
        匞展翅树 = cls.罒类忄取冫匞展翅树扌(cls)
        参 = 匞展翅树.毶展翅树
        return (0, 参.最大节点数纟光杆树)
class 魖翅膀牜元组具现爫部件即节点(_魖部件容器牜元组具现,魖翅膀牜特化具现爫部件即节点):
    __slots__ = ()
    @override
    def 罒类忄取冫最小部件数丶最大部件数扌(cls, /):
        '-> (最小部件数,最大部件数)'
        匞展翅树 = cls.罒类忄取冫匞展翅树扌(cls)
        参 = 匞展翅树.毶展翅树
        return (参.最小节点数纟翅膀,参.最大节点数纟翅膀)
class 魖左翼牜元组具现爫部件即节点(魖翅膀牜元组具现爫部件即节点,魖左翼牜特化具现爫部件即节点):
    __slots__ = ()
class 魖右翼牜元组具现爫部件即节点(魖翅膀牜元组具现爫部件即节点,魖右翼牜特化具现爫部件即节点):
    __slots__ = ()
class 魖更深节点牜元组具现爫部件即节点(_魖部件容器牜元组具现,魖更深节点牜特化具现爫部件即节点):
    __slots__ = ()
    @override
    def 罒类忄取冫最小部件数丶最大部件数扌(cls, /):
        '-> (最小部件数,最大部件数)'
        匞展翅树 = cls.罒类忄取冫匞展翅树扌(cls)
        参 = 匞展翅树.毶展翅树
        return (参.最小节点数纟更深节点,参.最大节点数纟更深节点)



魖根深树牜元组具现爫魖路径纟节点牜部件容器暨节点容器

魖光杆树牜元组具现爫部件即节点
魖翅膀牜元组具现爫部件即节点
魖左翼牜元组具现爫部件即节点
魖右翼牜元组具现爫部件即节点
魖更深节点牜元组具现爫部件即节点

魖元素节点牜元组具现








######################
######################
######################
class 乸匞度量值爫自然数加法半群(魖匞度量值):
    __slots__ = ()
    @property
    @override
    def 零度量值(sf, /):
        '-> 度量值'
        return 0
    @override
    def 结合冫度量值扌(sf, 度量值纟左, 度量值纟右, /):
        '-> 度量值'
        return int.__add__(度量值纟左, 度量值纟右)
匞度量值爫自然数加法半群 = 乸匞度量值爫自然数加法半群()
class 乸匞度量值爫无度量值(魖匞度量值):
    __slots__ = ()
    @property
    @override
    def 零度量值(sf, /):
        '-> 度量值'
        return None
    @override
    def 结合冫度量值扌(sf, 度量值纟左, 度量值纟右, /):
        '-> 度量值'
        return None
匞度量值爫无度量值 = 乸匞度量值爫无度量值()

def _is_importance(nm, /):
    return (not nm.startswith('_')) or (not max(map(ord, nm)) < 0x100)
    #
    return (not nm.startswith('_')) or (len(nm) > 4 and nm.startswith('__') and nm.endswith('__')) or (not max(map(ord, nm)) < 0x100)
def _列出冫重要属性巛类型扌(cls, /):
    nms = dir(cls)
    nms = {*filter(_is_importance, nms)}
    nms |= cls.__abstractmethods__
    nms = sorted(nms)
    return nms
def _移至子类冫重要属性扌(cls, /):
    if cls.__abstractmethods__:
        return
    nms4f = _列出冫重要属性巛类型扌(cls)
    for nm4f in nms4f:
        # !! [has no classmethod]
        f = getattr(cls, nm4f)
        assert not getattr(f, '__isabstractmethod__', False)
        setattr(cls, nm4f, f)


######################
######################
######################
#具现爫元组:
######################
######################
######################
def _构造冫部件容器爫元组扌(cls, 部件序列, /, *, 左起丷右起):
    '部件序列{深度;左起丷右起}/Iter 部件 -> 部件容器{深度;}/魖部件容器'
    check_type_is(bool, 左起丷右起)
    it = _蛮力反向枚举扌(部件序列) if 左起丷右起 else 部件序列
    return cls(*it)
def _蛮力反向枚举扌(it, /):
    try:
        return reversed(it)
    except TypeError:
        pass
    ls = list(it)
    return reversed(ls)




def 构造冫匞展翅树爫元组具现扌(_毶展翅树, _匞度量值, /):
  if 1:
    ...
  #class 乸匞展翅树(魖匞展翅树):
  class 乸匞展翅树(魖匞展翅树牜通用具现):
    __slots__ = ()
    毶展翅树 = _毶展翅树
    匞度量值 = _匞度量值

    @override
    def 构造冫元素节点扌(sf, 度量值, 元素, /):
        '度量值 -> 元素 -> 节点{深度:=0;}/元素节点/魖元素节点'
        return 乸元素节点(度量值, 元素)
    @override
    def 构造冫更深节点扌(sf, 节点序列, /, *, 左起丷右起):
        '节点序列{深度,左起丷右起;}/Iter 节点{深度;} -> 节点{深度+1;}/更深节点{深度;}/魖更深节点'
        cls = 乸更深节点
        return _构造冫部件容器爫元组扌(cls, 节点序列, 左起丷右起=左起丷右起)
    @override
    def 构造冫左翼扌(sf, 节点序列, /, *, 左起丷右起):
        '节点序列{深度,左起丷右起;}/Iter 节点{深度;} -> 左翼{深度;}/魖左翼'
        cls = 乸左翼
        return _构造冫部件容器爫元组扌(cls, 节点序列, 左起丷右起=左起丷右起)
    @override
    def 构造冫右翼扌(sf, 节点序列, /, *, 左起丷右起):
        '节点序列{深度,左起丷右起;}/Iter 节点{深度;} -> 右翼{深度;}/魖右翼'
        cls = 乸右翼
        return _构造冫部件容器爫元组扌(cls, 节点序列, 左起丷右起=左起丷右起)
    @override
    def 构造冫光杆树扌(sf, 节点序列, /, *, 左起丷右起):
        '节点序列{深度,左起丷右起;}/Iter 节点{深度;} -> 光杆树{深度;}/魖光杆树'
        cls = 乸光杆树
        return _构造冫部件容器爫元组扌(cls, 节点序列, 左起丷右起=左起丷右起)
    @override
    def 构造冫根深树乊左右扌(sf, 左翼, 更深树, 右翼, /):
        '左翼{深度;} -> 更深树{深度;}/展翅树{深度+1;} -> 右翼{深度;} -> 根深树{深度;}/魖根深树'
        return 乸根深树(左翼, 更深树, 右翼)

  if 1:
    匞展翅树 = 乸匞展翅树()
    @override
    def _罒类忄取冫匞展翅树扌(cls, /):
        '-> 匞展翅树'
        return 匞展翅树
    class 乸根深树(魖根深树牜元组具现爫魖路径纟节点牜部件容器暨节点容器):
        __slots__ = ()
        罒类忄取冫匞展翅树扌 = _罒类忄取冫匞展翅树扌
    class 乸光杆树(魖光杆树牜元组具现爫部件即节点):
        __slots__ = ()
        罒类忄取冫匞展翅树扌 = _罒类忄取冫匞展翅树扌
    class 乸左翼(魖左翼牜元组具现爫部件即节点):
        __slots__ = ()
        罒类忄取冫匞展翅树扌 = _罒类忄取冫匞展翅树扌
    class 乸右翼(魖右翼牜元组具现爫部件即节点):
        __slots__ = ()
        罒类忄取冫匞展翅树扌 = _罒类忄取冫匞展翅树扌
    class 乸更深节点(魖更深节点牜元组具现爫部件即节点):
        __slots__ = ()
        罒类忄取冫匞展翅树扌 = _罒类忄取冫匞展翅树扌
    class 乸元素节点(魖元素节点牜元组具现):
        __slots__ = ()
        罒类忄取冫匞展翅树扌 = _罒类忄取冫匞展翅树扌
    def __(ps, /):
        for nm, x in ps:
            if nm.startswith('乸'):
                assert not x.__abstractmethods__, (nm, x.__abstractmethods__)
                _移至子类冫重要属性扌(x)
    __(sorted(locals().items()))
    del __

    return 匞展翅树
#end-def 构造冫匞展翅树爫元组具现扌(毶展翅树, 匞度量值, /):

毶展翅树牜一二三四四牜有分裂有合并牜分裂濒危
匞度量值爫无度量值
匞度量值爫自然数加法半群
匞展翅树牜一二三四四爫自然数加法半群 = 构造冫匞展翅树爫元组具现扌(毶展翅树牜一二三四四牜有分裂有合并牜分裂濒危, 匞度量值爫自然数加法半群)
匞展翅树牜一二三四四爫无度量值 = 构造冫匞展翅树爫元组具现扌(毶展翅树牜一二三四四牜有分裂有合并牜分裂濒危, 匞度量值爫无度量值)










class 魖元素容器爫展翅树牜元组具现(魖元素容器爫展翅树牜通用具现,tuple):
    __slots__ = ()
    __len__ = None
    def __repr__(sf, /):
        if not sf:
            return repr_helper(sf)
        return repr_helper(sf, [*sf])
    def __str__(sf, /):
        if not sf:
            return repr_helper(sf)
        return repr_helper(sf, None, sf.展翅树乊底层)
    def __new__(cls, 鬽元素序列=(), 鬽展翅树乊底层=None, /, *, 左起丷右起=False):
        #check_type_is(bool, 左起丷右起)
        if 鬽展翅树乊底层 is None:
            if type(鬽元素序列) is cls:
                sf = 鬽元素序列
                if 左起丷右起 is False:
                    return sf
            元素序列 = '' if 鬽元素序列 is None else 鬽元素序列
            匞展翅树 = cls.罒类忄取冫匞展翅树扌(cls)
            展翅树乊底层 = 匞展翅树.构造冫展翅树扌((匞展翅树.构造冫元素节点扌(cls.罒类忄度量值巛元素扌(cls, 元素), 元素) for 元素 in 元素序列), 左起丷右起=左起丷右起)
        else:
            展翅树乊底层 = 鬽展翅树乊底层
            if not 鬽元素序列 is None:raise TypeError
            if not 左起丷右起 is False:raise TypeError
        展翅树乊底层
        sf = tuple.__new__(cls, [展翅树乊底层])
        return sf
    @override
    def 罒类忄包装冫展翅树乊底层扌(cls, 展翅树乊底层, /):
        '展翅树乊底层/魖展翅树 -> 树/元素容器/魖元素容器爫展翅树'
        return cls(None, 展翅树乊底层)
    @property
    @override
    def 展翅树乊底层(sf, /):
        '-> 魖展翅树'
        return tuple.__getitem__(sf, 0)

class 乸元素容器爫展翅树牜度量值为长度(魖元素容器爫展翅树牜元组具现,魖元素容器爫展翅树牜度量值含长度):
    __slots__ = ()
    ######################
    if 1:
        # 被覆盖:魖元素容器爫展翅树牜元组具现[__len__:=None]
        __len__ = 魖元素容器爫展翅树牜带总长.__len__
    ######################

    ######################
    @classmethod
    @override
    def 度量值讠长度(cls, 度量值, /):
        '-> 度量值 -> 长度/uint'
        return 度量值
    ######################
    if 1:
        #非必要:
        @property
        @override
        def 总长(sf, /):
            return sf.度量值
        @override
        def __len__(sf, /):
            return sf.度量值
    ######################
    匞展翅树 = 匞展翅树牜一二三四四爫自然数加法半群
    @override
    def 罒类忄度量值巛元素扌(cls, 元素, /):
        '元素 -> 度量值'
        return 1
    @override
    def 罒类忄取冫匞展翅树扌(cls, /):
        '-> 匞展翅树'
        return cls.匞展翅树


if 1:
    # [:纯虚函数冫魖元素容器爫展翅树]:goto
    (__r:=['__bool__', '__iter__', '__reversed__', '分裂乊元素扌', '分裂乊元素间隙扌', '压入冫元素序列扌', '压入冫元素序列牜计长度扌', '压入冫元素扌', '取冫元素丶度量值巛路径扌', '取冫元素巛路径扌', '取冫端点元素扌', '右端元素', '合并扌', '合并灬扌', '同端弹压冫元素扌', '展翅树乊底层', '左端元素', '度量值', '异端压弹冫元素序列扌', '异端压弹冫元素扌', '弹出冫元素列表扌', '弹出冫元素扌', '搜索定位冫元素扌', '枚举冫元素丶度量值扌', '枚举冫元素扌', '枚举冫路径丶元素丶度量值扌', '类忄合并牜序列扌', '类忄构造冫展翅树丶总长扌', '类忄构造冫空树扌', '罒类忄包装冫展翅树乊底层扌', '罒类忄取冫匞展翅树扌', '罒类忄度量值巛元素扌'])
    assert (__l:=sorted(魖元素容器爫展翅树.__abstractmethods__)) == __r, (set(__l)-set(__r), set(__r)-set(__l), __l)
    del __l, __r
    ######################
    ######################



if 1:
    # [:纯虚函数冫魖元素容器爫展翅树]:goto
    __attr_mapping4IFingerTree = (dict
(__bool__='__bool__'
,__iter__='__iter__'
,__reversed__='__reversed__'
,度量值='measurement' #measure
,展翅树乊底层='...underlying_tree'
,取冫端点元素扌='get_endpoint_'
,左端元素='first'
,右端元素='last'
,枚举冫元素扌='iter_'
,枚举冫元素丶度量值扌='iter_value_measurement_pairs_'
,枚举冫路径丶元素丶度量值扌='iter_path_value_measurement_triples_'
,取冫元素丶度量值巛路径扌='path2value_measurement_pair'
,取冫元素巛路径扌='path2value' #[path == 路径全纟元素 == (左起丷右起,路径纟节点)]


,类忄构造冫展翅树丶总长扌='...类忄构造冫展翅树丶总长扌'
,压入冫元素序列牜计长度扌='...压入冫元素序列牜计长度扌'
,罒类忄包装冫展翅树乊底层扌='...罒类忄包装冫展翅树乊底层扌'
,罒类忄取冫匞展翅树扌='...罒类忄取冫匞展翅树扌'
,罒类忄度量值巛元素扌='...罒类忄度量值巛元素扌'

,压入冫元素序列扌='ipushs__' #压入牜序列扌
,压入冫元素扌='ipush_'
,弹出冫元素列表扌='ipops_le__'
,弹出冫元素扌='ipop_'
,同端弹压冫元素扌='ipop_then_ipush_on_same_endpoint_'
,异端压弹冫元素序列扌='ipushs_then_ipops_on_diff_endpoints_'
,异端压弹冫元素扌='ipush_then_ipop_on_diff_endpoints_'

,合并扌='__add__'
,合并灬扌='join'
,类忄合并牜序列扌='joins'
,类忄构造冫空树扌='mk_empty_tree'
,搜索定位冫元素扌='search_via_measurement___'
,分裂乊元素扌='split4value'
,分裂乊元素间隙扌='split4gap'
))


if 1:
    # [:纯虚函数冫魖元素容器爫展翅树]:goto
    __r = sorted(__attr_mapping4IFingerTree.keys())
    assert (__l:=sorted(魖元素容器爫展翅树.__abstractmethods__)) == __r, (set(__l)-set(__r), set(__r)-set(__l), __l)
    del __l, __r
    ######################
    ######################


from seed.data_funcs.finger_tree__errors import Error4FingerTree, Error__empty_tree, Error__known_non_overflow

class IWithMeasurement(ABC):
    #class IMeasureable(ABC):
    __slots__ = ()
    #@abstractmethod
    #def measure(sf, /):
    #    '-> measurement'
    @property
    @abstractmethod
    def measurement(sf, /):
        '-> measurement'
        #return sf.measure()

class IFingerTree(IWithMeasurement):
    # left_vs_right === 左端丷右端
    # reverse === 左起丷右起
    # leftward_vs_rightward === 左出丷右出
    r'''[[[
[:list_attrs__IFingerTree]:here
py_adhoc_call  seed.helper.print_methods  @wrapped_print_methods   %seed.data_funcs.finger_tree__ABC:IFingerTree@T    =T    +exclude_attrs5listed_in_cls_doc
abstract_methods:
    `measurement
new_abstract_methods:
    `path2reverse
    `__len__
    `iter_
    `iter_value_measurement_pairs_
    `iter_path_value_measurement_triples_
    `path2value_measurement_pair
    `path2value
    `ipush_
    `ipop_
    `_add_
    `mk_empty_tree
    `split4value
    `split4gap
    `search_via_measurement___
new_concrete_methods:
    __bool__
    __iter__
    __reversed__
    get_endpoint_
    first
    last
    __add__
    __iadd__
    join
    joins
    ipushs__
    ipops_le__
    ipop_then_ipush_on_same_endpoint_
    ipush_then_ipop_on_diff_endpoints_
    ipushs_then_ipops_on_diff_endpoints_





    #]]]'''#'''
    __slots__ = ()
    @classmethod
    @abstractmethod
    def path2reverse(cls, path, /):
        '-> path{;reverse} -> reverse/bool'

    @abstractmethod
    def __len__(sf, /):
        '-> uint'
    @abstractmethod
    def iter_(sf, /, *, reverse):
        '-> Iter v'
    @abstractmethod
    def iter_value_measurement_pairs_(sf, /, *, reverse):
        '-> Iter (v, measurement<v>)'
    @abstractmethod
    def iter_path_value_measurement_triples_(sf, /, *, reverse):
        '-> Iter (path{;reverse}, v, measurement<v>)'
    @abstractmethod
    def path2value_measurement_pair(sf, path, /):
        '-> path{;reverse} -> (v, measurement<v>)'
    @abstractmethod
    def path2value(sf, path, /):
        '-> path{;reverse} -> v'

    @abstractmethod
    def ipush_(sf, v, /, *, left_vs_right):
        '-> v -> IFingerTree'
    @abstractmethod
    def ipop_(sf, /, *, left_vs_right):
        '-> (IFingerTree, v) | ^Error__empty_tree'

    @abstractmethod
    def _add_(sf, ot, /):
        'IFingerTree -> IFingerTree -> IFingerTree'
    @classmethod
    @abstractmethod
    def mk_empty_tree(cls, /):
        '-> IFingerTree'

    @abstractmethod
    def split4value(sf, path, /):
        '-> path{;reverse} -> (IFingerTree, v, IFingerTree){reverse;}'
    @abstractmethod
    def split4gap(sf, xpath, /):
        '-> xpath{;reverse} -> (IFingerTree, IFingerTree){reverse;} # [xpath{;reverse} == (reverse/bool | path{;reverse})]'


    @abstractmethod
    def search_via_measurement___(sf, acc_begin, accumulate, acc2forward, /, *, reverse, known_non_underflow, known_non_overflow):
        r'''[[[
        :: acc -> (acc->measurement->acc) -> (acc->bool) -> (case, yyy)
        ######################
        case :: ... | bool
        ######################
        -> (case, yyy)
        | -> (Underflow/False,acc_begin/acc)
        | -> (Overflow/True,acc_end/acc)
        | -> (Path4focus/..., (acc_pre, path{;reverse},focus/v,measurement<focus>, acc_post))
        ######################
        acc_begin :: acc
        accumulate :: acc -> measurement<?> -> acc
        acc2forward :: acc -> backward_vs_forward/bool
        ######################
        #]]]'''#'''







    ######################
    ######################
    ######################
    ######################
    ######################

    def __bool__(sf, /):
        '-> bool'
        return bool(len(sf))
    def __iter__(sf, /):
        '-> Iter v'
        return sf.iter_(reverse=False)
    def __reversed__(sf, /):
        '-> Iter v'
        return sf.iter_(reverse=True)
    def get_endpoint_(sf, /, *, left_vs_right):
        '-> v | ^Error__empty_tree'
        for v in sf.iter_(reverse=left_vs_right):
            return v
        raise Error__empty_tree
    @property
    def first(sf, /):
        '-> v | ^Error__empty_tree'
        return sf.get_endpoint_(left_vs_right=False)

    @property
    def last(sf, /):
        '-> v | ^Error__empty_tree'
        return sf.get_endpoint_(left_vs_right=True)


    #@abstractmethod
    def __add__(sf, ot, /):
        'IFingerTree -> IFingerTree -> IFingerTree'
        check_type_is(type(sf), ot)
        if not ot:
            return sf
        if not sf:
            return ot
        return sf._add_(ot)
    def __iadd__(sf, ot, /):
        'IFingerTree -> IFingerTree -> IFingerTree'
        return sf + ot
    #@abstractmethod
    def join(sf, /, *others):
        'IFingerTree -> *[IFingerTree] -> IFingerTree'
        return type(sf).joins(chain([sf], others))
    @classmethod
    #@abstractmethod
    def joins(cls, others, /):
        '-> Iter IFingerTree -> IFingerTree'
        it = iter(others)
        sf = None
        for sf in it:
            break
        else:
            if sf is None:
                sf = cls.mk_empty_tree()
        check_type_is(cls, sf)
        for ot in it:
            sf += ot
        return sf
    #@abstractmethod
    def ipushs__(sf, vs, /, *, left_vs_right, reverse):
        '-> (Iter v){reverse;} -> IFingerTree'
        #压入牜序列扌
        check_type_is(bool, reverse)
        check_type_is(bool, left_vs_right)
        if reverse is left_vs_right:
            vs = _蛮力反向枚举扌(vs)
            reverse = not reverse
        assert reverse ^ left_vs_right
        for v in vs:
            sf = sf.ipush_(v, left_vs_right=left_vs_right)
        return sf

    #@abstractmethod
    def ipops_le__(sf, may_max, /, *, left_vs_right, reverse):
        '-> may_max/uint -> (IFingerTree, [v]{reverse;}{len<=may_max})'
        #弹出牜列表扌
        check_type_is(bool, reverse)
        check_type_is(bool, left_vs_right)
        if not may_max is None:
            max0 = may_max
            check_int_ge(0, max0)
            it = repeat(1, max0)
        else:
            it = repeat(1)
        it
        ls = []
        for _ in it:
            if not sf:break
            (sf, v) = sf.ipop_(left_vs_right=left_vs_right)
            ls.append(v)
        if may_max is None:
            assert not sf
        else:
            assert len(ls) <= max0
            assert not sf or len(ls) == max0
        if reverse ^ left_vs_right:
            ls.reverse()
        return (sf, ls)

    #@abstractmethod
    def ipop_then_ipush_on_same_endpoint_(sf, v, /, *, left_vs_right):
        '-> v -> (IFingerTree, v) | ^Error__empty_tree'
        (sf, y) = sf.ipop_(left_vs_right=left_vs_right)
            # ^Error__empty_tree
        sf = sf.ipush_(v, left_vs_right=left_vs_right)
        return (sf, y)
    def ipush_then_ipop_on_diff_endpoints_(sf, v, /, *, leftward_vs_rightward):
        '-> v -> (IFingerTree, v)'
        sf = sf.ipush_(v, left_vs_right=not leftward_vs_rightward)
        (sf, y) = sf.ipop_(left_vs_right=leftward_vs_rightward)
        return (sf, y)
    def ipushs_then_ipops_on_diff_endpoints_(sf, vs, /, *, leftward_vs_rightward):
        '-> vs/(Iter v){reverse=leftward_vs_rightward;} -> (IFingerTree, [v]/{reverse:=leftward_vs_rightward;}{len==len(vs)})'
        #保长流动:
        #异端压弹牜序列扌
        #ipushs_then_ipops_on_diff_endpoints_
        L = len(sf)
        ls = []
        for v in vs:
            (sf, v) = sf.ipush_then_ipop_on_diff_endpoints_(v, leftward_vs_rightward=leftward_vs_rightward)
            ls.append(v)
        assert L == len(sf)
        return (sf, ls)
    ######################
    ######################
    ######################
    ######################
    ######################
    #extras5Sequence:
    def __contains__(sf, v, /):
        '-> v -> bool'
        return any(map([v].__contains__, sf))
    def count(sf, v, /):
        return sum(map([v].__contains__, sf))
    #def index(sf, v, begin=0, end=None, /):
    #   see:IFingerTree__wrapper__measurement_contains_len
    #extras5tuple:
    def __mul__(sf, sz, /):
        '-> int -> IFingerTree'
        if type(sz) is int:
            if (sz < 0) or not sf:
                sz = 0
                    #try:avoid:OverflowError
        if not sf:
            ls = []*sz
                # ^TypeError
                # OverflowError: cannot fit 'int' into an index-sized integer
        else:
            ls = [sf]*sz
                # ^TypeError
        return type(sf).joins(ls)
    def __rmul__(sf, sz, /):
        '-> int -> IFingerTree'
        return type(sf).__mul__(sf, sz)
def __():
    # [:纯虚函数冫魖元素容器爫展翅树]:goto
    ls = []
    for old, nm in sorted(__attr_mapping4IFingerTree.items()):
        if nm.startswith('...'):
            continue
        if not hasattr(IFingerTree, nm):
            ls.append((old, nm))
    assert not ls, ls
__()
#end-class IFingerTree(IWithMeasurement):

class IFingerTree__wrapper__not_yet_support_split_ops(IFingerTree):
    # path == 路径全纟元素
    __slots__ = ()
    #___no_slots_ok___ = True
        # !! lazy-hash:__hash__ <<== _mh
    _base_type4underlying_tree_ = 魖元素容器爫展翅树
    @classmethod
    @abstractmethod
    def _get_underlying_tree_type_(cls, /):
        '-> type(underlying_tree) <: 魖元素容器爫展翅树 # [++__len__/__hash__/__eq__] # [分裂操作:需求:魖元素容器爫展翅树牜带总长]'
        # 计算总长:压入弹出合并:魖元素容器爫展翅树
        # 计算总长:分裂:需要:魖元素容器爫展翅树牜带总长

    @property
    def underlying_tree(sf, /):
        '-> underlying:finger_tree'
        return sf._tr

    def __str__(sf, /):
        if not sf:
            return repr_helper(sf)
        return repr_helper(sf, len(sf), sf._tr)
    def __repr__(sf, /):
        vs = [*sf]
        if not len(vs) == len(sf):raise 000
        if not sf:
            if len(sf):raise 000
            return repr_helper(sf)
        if not len(sf):raise 000
        return repr_helper(sf, vs)

    def __hash__(sf, /):
        if sf._mh is None:
            sf._mh = hash((id(type(sf)), len(sf), *sf._tr))
        return sf._mh
    def __eq__(sf, ot, /):
        if ot is sf:
            return True
        if not type(ot) is type(sf):
            return False
                # !! __hash__
            return NotImplemented
        if not len(ot) == len(sf):
            return False
        if ot._tr is sf._tr:
            return True
        if not (ot._mh is None or sf._mh is None):
            if not ot._mh == sf._mh:
                return False
        return all(a in [b] for a, b in zip(sf, ot))
    def __init__(sf, may_vs_or_sz=(), may_underlying_tree=None, /, *, reverse=False):
        pass
    def __new__(cls, may_vs_or_sz=(), may_underlying_tree=None, /, *, reverse=False):
        check_type_is(bool, reverse)
        乸元素容器爫展翅树 = cls._get_underlying_tree_type_()
        if may_underlying_tree is None:
            may_vs = may_vs_or_sz
            if type(may_vs) is cls:
                if reverse is False:
                    sf = may_vs
                    return sf
            元素序列 = '' if may_vs is None else may_vs

            (展翅树乊底层,总长) = 乸元素容器爫展翅树.类忄构造冫展翅树丶总长扌(乸元素容器爫展翅树, 元素序列, 左起丷右起=reverse)
        else:
            展翅树乊底层 = may_underlying_tree
            check_type_is(乸元素容器爫展翅树, 展翅树乊底层)
            if not reverse is False:raise TypeError
            may_sz = may_vs_or_sz
            if may_sz is None:
                try:
                    sz = 展翅树乊底层.总长
                except AttributeError:
                    raise TypeError(('分裂操作:需求:自带总长', cls, 乸元素容器爫展翅树, 魖元素容器爫展翅树牜带总长))
            else:
                sz = may_sz
            check_int_ge(0, sz)
            总长 = sz
        总长, 展翅树乊底层
        if 总长 == 0:
            if 展翅树乊底层:raise TypeError
            m = getattr(cls, '_empty', None)
            if type(m) is cls:
                sf = m
                return sf
        else:
            if not 展翅树乊底层:raise TypeError
        sf = super(__class__, cls).__new__(cls)
        sf._tr = 展翅树乊底层
        sf._mh = None
        sf._sz = 总长

        if 总长 == 0:
            cls._empty = sf
            return cls()
        return sf


    ######################
    ######################
    ######################
    ######################
    @classmethod
    @override
    def path2reverse(cls, path, /):
        '-> path{;reverse} -> reverse/bool'
        路径全纟元素 = path
            # !! [__class__ 特化版]
        return 路径全纟元素.左起丷右起
    @classmethod
    @override
    def mk_empty_tree(cls, /):
        '-> IFingerTree'
        return cls()


    @property
    @override
    def measurement(sf, /):
        '-> measurement'
        return sf._tr.度量值

    @override
    def __len__(sf, /):
        '-> uint'
        return sf._sz
    @override
    def iter_(sf, /, *, reverse):
        '-> Iter v'
        return sf._tr.枚举冫元素扌(左起丷右起=reverse)
    @override
    def iter_value_measurement_pairs_(sf, /, *, reverse):
        '-> Iter (v, measurement<v>)'
        return sf._tr.枚举冫元素丶度量值扌(左起丷右起=reverse)
    @override
    def iter_path_value_measurement_triples_(sf, /, *, reverse):
        '-> Iter (path{;reverse}, v, measurement<v>)'
        return sf._tr.枚举冫路径丶元素丶度量值扌(左起丷右起=reverse)
    @override
    def path2value_measurement_pair(sf, path, /):
        '-> path{;reverse} -> (v, measurement<v>)'
        return sf._tr.取冫元素丶度量值巛路径扌(path)
    @override
    def path2value(sf, path, /):
        '-> path{;reverse} -> v'
        return sf._tr.取冫元素巛路径扌(path)

    @override
    def ipush_(sf, v, /, *, left_vs_right):
        '-> v -> IFingerTree'
        cls = type(sf)
        底树 = sf._tr.压入冫元素扌(v, 左端丷右端=left_vs_right)
        sz = len(sf) +1
        ot = cls(sz, 底树)
        return ot
    @override
    def ipop_(sf, /, *, left_vs_right):
        '-> (IFingerTree, v) | ^Error__empty_tree'
        if not sf:
            raise Error__empty_tree
        cls = type(sf)
        (底树, v) = sf._tr.弹出冫元素扌(左端丷右端=left_vs_right)
        sz = len(sf) -1
        ot = cls(sz, 底树)
        return (ot, v)

    @override
    def _add_(sf, ot, /):
        'IFingerTree -> IFingerTree -> IFingerTree'
        cls = type(sf)
        底树 = sf._tr.合并扌(ot._tr)
        sz = len(sf) +len(ot)
        r = cls(sz, 底树)
        return r

    @override
    def search_via_measurement___(sf, acc_begin, accumulate, acc2forward, /, *, reverse, known_non_underflow, known_non_overflow):
        'acc -> (acc->measurement->acc) -> (acc->bool) -> (case, yyy)'
        cls = type(sf)
        try:
            (况态, yyy) = sf._tr.搜索定位冫元素扌(acc_begin, accumulate, acc2forward, 左起丷右起=reverse, 欤已知非超后退=known_non_underflow, 欤已知非超前进=known_non_overflow)
                # ^错误牜欤已知非超前进
        except 错误牜欤已知非超前进 as e:
            raise Error__known_non_overflow(*e.args)

        #def 搜索定位冫元素扌(sf, 初始累计值, 累积扌, 进退判定扌, /, *, 左起丷右起, 欤已知非超后退, 欤已知非超前进):
        # | -> (匡超后退,初始累计值)
        # | -> (匡超前进,终末累计值)
        # | -> (匡路径全纟元素, (累计值牜前进, 路径全纟元素{;左起丷右起},焦点元素,度量值纟元素, 累计值牜后退))
        # | ^错误牜欤已知非超前进
        if 况态 is 匡路径全纟元素:
            # Path4focus/...
            case = ...
        elif 况态 is 匡超前进:
            # Overflow/True
            case = True
        elif 况态 is 匡超后退:
            # Underflow/False
            case = False
        else:
            raise 000
        return (case, yyy)
#end-class IFingerTree__wrapper__not_yet_support_split_ops(IFingerTree):

class IFingerTree__wrapper(IFingerTree__wrapper__not_yet_support_split_ops):
    # path == 路径全纟元素
    r'''[[[
[:list_attrs__IFingerTree]:goto
[:list_attrs__IFingerTree__wrapper]:here
py_adhoc_call  seed.helper.print_methods  @wrapped_print_methods   %seed.data_funcs.finger_tree__ABC:IFingerTree__wrapper@T    =T    +exclude_attrs5listed_in_cls_doc
new_abstract_methods:
    `_get_underlying_tree_type_
new_concrete_methods:
    underlying_tree
    __str__
    __repr__
    __hash__
    __eq__
    __init__
    __new__
    path2reverse
    measurement
    __len__
    iter_
    iter_value_measurement_pairs_
    iter_path_value_measurement_triples_
    path2value_measurement_pair
    path2value
    ipush_
    ipop_
    _add_
    mk_empty_tree
    split4value
    split4gap
    search_via_measurement___







    #]]]'''#'''
    __slots__ = ()
    #___no_slots_ok___ = True
        # !! lazy-hash:__hash__ <<== _mh
    _base_type4underlying_tree_ = 魖元素容器爫展翅树牜带总长

    @override
    def split4value(sf, path, /):
        '[分裂操作:需求:自带总长]=>: -> path{;reverse} -> (IFingerTree, v, IFingerTree){reverse;}'
        cls = type(sf)
        (起树, v, 讫树) = sf._tr.分裂乊元素扌(path)

        lhs = cls(None, 起树) #要求:自带总长
        rhs = cls(None, 讫树) #要求:自带总长
        return (lhs, v, rhs)

    @override
    def split4gap(sf, xpath, /):
        '[分裂操作:需求:自带总长]=>: -> xpath{;reverse} -> (IFingerTree, IFingerTree){reverse;} # [xpath{;reverse} == (reverse/bool | path{;reverse})]'
        cls = type(sf)
        if type(xpath) is bool:
            reverse = xpath
            路径全纟元素间隙 = 乸路径全纟元素间隙(左起丷右起:=reverse, None)
        else:
            path = xpath
            路径全纟元素 = path
                # !! [__class__ 特化版]
            路径全纟元素间隙 = 路径全纟元素
                # !! [父类对象 := 子类对象]
        路径全纟元素间隙
        (起树, 讫树) = sf._tr.分裂乊元素间隙扌(路径全纟元素间隙)
        if not 起树:
            return (cls.mk_empty_tree(), sf)
        if not 讫树:
            return (sf, cls.mk_empty_tree())

        lhs = cls(None, 起树) #要求:自带总长
        rhs = cls(None, 讫树) #要求:自带总长
        return (lhs, rhs)


#end-class IFingerTree__wrapper:

class IFingerTree__wrapper__measurement_contains_len(IFingerTree__wrapper):
    # [[度量值含长度] ==>> [自带总长]]
    __slots__ = ()
    #___no_slots_ok___ = True
        # !! lazy-hash:__hash__ <<== _mh
    _base_type4underlying_tree_ = 魖元素容器爫展翅树牜度量值含长度

    @classmethod
    #@abstractmethod
    def measurement2len(cls, measurement, /):
        '-> measurement<?> -> length/uint'
        return cls._get_underlying_tree_type_().度量值讠长度(measurement)
    @classmethod
    def accumulate4len(cls, sz, measurement, /):
        '-> uint -> measurement<?> -> uint'
        return int.__add__(sz, cls.measurement2len(measurement))


    def slice_between(sf, begin, end, /):
        '-> begin/(may int) -> end/(may int) -> IFingerTree__wrapper__measurement_contains_len'
        js = range(L:=len(sf))[begin:end]
        if not js:
            return type(sf).mk_empty_tree()
        (lhs, mid, rhs) = sf.split_between(begin, end)
        return mid
    def split_between(sf, begin, end, /):
        '-> begin/(may int) -> end/(may int) -> (IFingerTree__wrapper__measurement_contains_len, IFingerTree__wrapper__measurement_contains_len, IFingerTree__wrapper__measurement_contains_len)'
        js = range(L:=len(sf))[begin:end]
        if not js:
            (lhs, rhs) = sf.split_at4gap(begin)
            mid = type(sf).mk_empty_tree()
            return (lhs, mid, rhs)
        begin = js[0]
        end = js[-1] + 1
        (lhs_mid, rhs) = sf.split_at4gap(end)
        (lhs, mid) = lhs_mid.split_at4gap(begin)
        return (lhs, mid, rhs)
    def split_at4value(sf, idx, /, *, value_only=False):
        '-> idx/(int) -> (IFingerTree__wrapper__measurement_contains_len, v, IFingerTree__wrapper__measurement_contains_len) | ^IndexError'
        js = range(L:=len(sf))
        idx = js[idx]
            # ^IndexError
        assert 0 <= idx < L
        cls = type(sf)
        (case, yyy) = sf.search_via_measurement___(0, cls.accumulate4len, idx.__ge__, reverse=False, known_non_underflow=True, known_non_overflow=True)
        if not case is ...: raise 000
        (acc_pre, path,focus,measurement, acc_post) = yyy
        if value_only:
            return sf.path2value(path)
        return sf.split4value(path)
    def split_at4gap(sf, idx, /):
        '-> idx/(int) -> (IFingerTree__wrapper__measurement_contains_len, IFingerTree__wrapper__measurement_contains_len)'
        js = range(L:=len(sf))
        _js = js[idx:]
        if not sf:
            return (sf, sf)
        if not _js:
            return (sf, type(sf).mk_empty_tree())
        idx = _js[0]
        if idx == 0:
            return (type(sf).mk_empty_tree(), sf)
        assert 0 < idx < L
        cls = type(sf)
        (case, yyy) = sf.search_via_measurement___(0, cls.accumulate4len, idx.__ge__, reverse=False, known_non_underflow=True, known_non_overflow=True)
        if not case is ...: raise 000
        (acc_pre, path,focus,measurement, acc_post) = yyy
        return sf.split4gap(path)
    def __getitem__(sf, k, /):
        if type(k) is slice:
            sl = k
            if not sl.step is None: raise TypeError(type(sl.step))
            return sf.slice_between(sl.start, sl.stop)
        idx = k
        return sf.split_at4value(idx, value_only=True)
    ######################
    ######################
    ######################
    #extras5Sequence:
    def index(sf, v, begin=0, end=None, /):
        '-> v -> idx/uint | ^IndexError'
        return sf.index_(v, begin, end, lowest_vs_highest=False)
    def rindex(sf, v, begin=0, end=None, /):
        '-> v -> idx/uint | ^IndexError'
        return sf.index_(v, begin, end, lowest_vs_highest=True)
    def index_(sf, v, begin=0, end=None, /, *, lowest_vs_highest):
        '-> v -> idx/uint | ^IndexError'
        js = range(L:=len(sf))[begin:end]
        if not js:
            raise IndexError(v)
        (lhs, mid, rhs) = sf.split_between(begin, end)
        it = map([v].__contains__, mid.iter_(reverse=lowest_vs_highest))
        for i, b in enumerate(it):
            if b:
                break
        else:
            raise IndexError(v)
        if lowest_vs_highest:
            i = len(mid)-i-1
        return len(lhs) + i
#end-class IFingerTree__wrapper__measurement_contains_len(IFingerTree__wrapper):




class FingerTree__measurement_is_len(IFingerTree__wrapper__measurement_contains_len, Sequence):
    r'''[[[
[:list_attrs__IFingerTree]:goto
[:list_attrs__IFingerTree__wrapper]:goto
[:list_attrs__FingerTree__measurement_is_len]:here
py_adhoc_call  seed.helper.print_methods  @wrapped_print_methods   %seed.data_funcs.finger_tree__ABC:FingerTree__measurement_is_len@T    =T    +exclude_attrs5listed_in_cls_doc
new_concrete_methods:
    ___no_slots_ok___
    _get_underlying_tree_type_
    slice_between
    split_at4value
    split_at4gap
    __getitem__
    _empty




__add__
__bool__
__eq__
__getitem__
__hash__
__iadd__
__init__
__iter__
__len__
__new__
__repr__
__reversed__
__str__
first
get_endpoint_
ipop_
ipop_then_ipush_on_same_endpoint_
ipops_le__
ipush_
ipush_then_ipop_on_diff_endpoints_
ipushs__
ipushs_then_ipops_on_diff_endpoints_
iter_
iter_path_value_measurement_triples_
iter_value_measurement_pairs_
join
joins
last
measurement
mk_empty_tree
path2reverse
path2value
path2value_measurement_pair
search_via_measurement___
slice_between
split4gap
split4value
split_at4gap
split_at4value
underlying_tree

_add_

extras-common:
    __class__
    __class_getitem__
    __init_subclass__
    __subclasshook__
others:
    _base_type4underlying_tree_
    accumulate4len
    measurement2len

extras-Sequence:
    __contains__
    count
    index
    rindex
    index_

extras-tuple:
    __mul__
    __rmul__

news:
    split_between

    #]]]'''#'''
    ___no_slots_ok___ = True

    if 1:
        #非必要:
        #@override
        measurement2len = staticmethod(echo)


    @classmethod
    @override
    def _get_underlying_tree_type_(cls, /):
        '-> type(underlying_tree) <: 魖元素容器爫展翅树 # [++__len__/__hash__/__eq__] # [分裂操作:需求:魖元素容器爫展翅树牜带总长]'
        return 乸元素容器爫展翅树牜度量值为长度

assert not FingerTree__measurement_is_len.__abstractmethods__
assert FingerTree__measurement_is_len() is FingerTree__measurement_is_len()







######################
######################
######################
def _枚举冫名丶类型扌():
    nms = sorted(set(__all__))
    for nm in nms:
        x = globals()[nm]
        if not isinstance(x, type):
            continue
        if issubclass(x, Exception):
            continue
        #if 0b001:print(nm)
        cls = x
        yield nm, cls
def _列出冫重要属性纟所有类型扌():
    return [(nm, _列出冫重要属性巛类型扌(cls)) for nm, cls in _枚举冫名丶类型扌()]

def _移至子类冫重要属性纟所有类型扌(*, excludes):
    for nm, cls in _枚举冫名丶类型扌():
        if cls in excludes:
            continue
        _移至子类冫重要属性扌(cls)
if 0b0001:
    _移至子类冫重要属性纟所有类型扌(excludes=[IFingerTree,IFingerTree__wrapper, FingerTree__measurement_is_len])


def __():
    树 = 乸元素容器爫展翅树牜度量值为长度()
    x = 树.压入冫元素扌(999, 左端丷右端=True)
    print(x)
if 0b0000:
    __()












__all__




######################
######################
######################
from seed.data_funcs.finger_tree__ABC import 魖匞度量值,魖匞展翅树,魖含冫度量值,魖展翅树,魖光杆树,魖根深树,魖翅膀,魖左翼,魖右翼,魖节点,魖更深节点,魖元素节点


from seed.data_funcs.finger_tree__ABC import 魖匞展翅树牜通用具现,魖展翅树牜通用具现,魖光杆树牜通用具现,魖根深树牜通用具现,魖根深树牜特化具现爫魖路径纟节点牜部件容器暨节点容器,魖翅膀牜通用具现,魖左翼牜通用具现,魖右翼牜通用具现



######################
######################
######################
#度量版节点版
from seed.data_funcs.finger_tree__ABC import 构造冫匞展翅树爫元组具现扌,匞度量值爫自然数加法半群,匞度量值爫无度量值
from seed.data_funcs.finger_tree__ABC import 匞展翅树牜一二三四四爫自然数加法半群,匞展翅树牜一二三四四爫无度量值
    # 面向:节点{深度;}

######################
######################
######################
#度量版元素版中文版
from seed.data_funcs.finger_tree__ABC import 魖元素容器爫展翅树,魖元素容器爫展翅树牜带总长,魖元素容器爫展翅树牜度量值含长度,魖元素容器爫展翅树牜通用具现, 魖元素容器爫展翅树牜元组具现
    # 面向:元素
from seed.data_funcs.finger_tree__ABC import 乸元素容器爫展翅树牜度量值为长度
    # 自带总长
    #   固化==>>不缓存散列



######################
######################
######################
#度量版元素版英文版
from seed.data_funcs.finger_tree__ABC import IWithMeasurement
from seed.data_funcs.finger_tree__ABC import IFingerTree
from seed.data_funcs.finger_tree__ABC import IFingerTree__wrapper
    # 包装:魖元素容器爫展翅树,魖元素容器爫展翅树牜带总长
    # 通用:自带散列
    # 通用:自计总长
    #   不一定能使用分裂操作
    # 分裂操作:要求:底层==魖元素容器爫展翅树牜带总长
from seed.data_funcs.finger_tree__ABC import IFingerTree__wrapper__measurement_contains_len
    # 包装:魖元素容器爫展翅树牜度量值含长度
    # 通用:自带散列
    # 通用:自带总长<<==底层
    # 支持:分裂操作,__getitem__
from seed.data_funcs.finger_tree__ABC import FingerTree__measurement_is_len
    # 包装:乸元素容器爫展翅树牜度量值为长度
    #   ++惰性散列






from seed.data_funcs.finger_tree__ABC import *
