#__all__:goto
r'''[[[
e ../../python3_src/seed/data_funcs/finger_tree2/finger_tree_basic_types.py


seed.data_funcs.finger_tree2.finger_tree_basic_types
py -m nn_ns.app.debug_cmd   seed.data_funcs.finger_tree2.finger_tree_basic_types -x
py -m nn_ns.app.doctest_cmd seed.data_funcs.finger_tree2.finger_tree_basic_types:__doc__
py -m nn_ns.app.doctest_cmd seed.data_funcs.finger_tree2.finger_tree_basic_types:__doc__  -ff -v --ndiff
py_adhoc_call   seed.data_funcs.finger_tree2.finger_tree_basic_types   @f
py_adhoc_call  seed.helper.print_methods  @wrapped_print_methods   %seed.data_funcs.finger_tree2.finger_tree_basic_types:XXX@T    =T      ++exclude_prefixes:_       +exclude_attrs5listed_in_cls_doc
from seed.data_funcs.finger_tree2.finger_tree_basic_types import *
#]]]'''
__all__ = r'''
'''.split()#'''
__all__
from seed.abc.abc__ver1 import abstractmethod, override, ABC, ABC__no_slots
from seed.tiny_.check import check_int_ge
from seed.for_libs.for_inspect import get_signature_of__py3_



from enum import Enum, auto
from seed.data_funcs.finger_tree2.scene_role import 魖场景包暨角色名注册处, 乸场景包暨角色名注册处

class 冭乸双侧展翅树囗场景包(乸场景包暨角色名注册处):
    ___no_slots_ok___ = True
    #def 指派囗角色扌(匞场景包, 圁角色名, 乸算子包, /):
    #    ':: 匞场景包 -> 圁角色名 -> 乸算子包/(匞场景包 -> 圁角色名 -> (*算子包模板参数...)-> 匴算子包<匞场景包;圁角色名;算子包模板参数>) -> None'
    #def 构造囗算子包扌(匞场景包, 圁角色名, /, *算子包模板参数冖冖位次, **算子包模板参数冖冖具名):
    #    '-> 匴算子包<匞场景包;圁角色名;算子包模板参数>'
    def 注册囗标准转发构造扌(匞场景包, /):
        '注册 乸双侧展翅树囗场景角色名 中的7个别名'
        匞场景包.指派囗角色扌(圁双侧展翅树, 乸匴双侧展翅树)
        匞场景包.指派囗角色扌(圁双侧更深树, 乸匴双侧更深树)
        匞场景包.指派囗角色扌(圁翅膀, 乸匴翅膀)
        匞场景包.指派囗角色扌(圁异翅, 乸匴异翅)
        匞场景包.指派囗角色扌(圁起翼, 乸匴起翼)
        匞场景包.指派囗角色扌(圁讫翼, 乸匴讫翼)
        匞场景包.指派囗角色扌(圁此翼, 乸匴起翼)
        匞场景包.指派囗角色扌(圁彼翼, 乸匴讫翼)
        匞场景包.指派囗角色扌(圁节点, 乸匴节点)

def 乸匴双侧展翅树(匞场景包, 圁角色名, /, *, 高度, 深度):
    assert 圁角色名 is 圁双侧展翅树
    if 高度 == 0:
        return 匞场景包.构造囗算子包扌(圁双侧光杆树, 深度=深度)
    return 匞场景包.构造囗算子包扌(圁双侧根深树, 高度=高度-1, 深度=深度)
def 乸匴双侧更深树(匞场景包, 圁角色名, /, *, 高度, 深度):
    assert 圁角色名 is 圁双侧更深树
    return 匞场景包.构造囗算子包扌(圁双侧展翅树, 高度=高度, 深度=深度+1)
    # 『高度-1』发生在 双侧展翅树-->双侧根深树
    # 『深度+1』发生在 双侧展翅树<--双侧更深树
    #   所以 主干上的所有 双侧展翅树 的 (高度+深度) 不变 #不变量

def 乸匴翅膀(匞场景包, 圁角色名, /, *, 左翼丷右翼, 深度):
    assert 圁角色名 is 圁翅膀
    圁角色名 = 圁左翼 if not 左翼丷右翼 else 圁右翼
    return 匞场景包.构造囗算子包扌(圁角色名, 深度=深度)
def 乸匴异翅(匞场景包, 圁角色名, /, *, 左翼丷右翼, 深度):
    assert 圁角色名 is 圁异翅
    return 匞场景包.构造囗算子包扌(圁翅膀, 左翼丷右翼=not 左翼丷右翼, 深度=深度)

def 乸匴起翼(匞场景包, 圁角色名, /, *,左起丷右起, 深度):
    assert 圁角色名 is 圁起翼
    return 匞场景包.构造囗算子包扌(圁翅膀, 左翼丷右翼=左起丷右起, 深度=深度)
def 乸匴讫翼(匞场景包, 圁角色名, /, *,左起丷右起, 深度):
    assert 圁角色名 is 圁讫翼
    return 匞场景包.构造囗算子包扌(圁翅膀, 左翼丷右翼=not(左起丷右起), 深度=深度)

def 乸匴此翼(匞场景包, 圁角色名, /, *, 起翼丷讫翼,左起丷右起, 深度):
    assert 圁角色名 is 圁此翼
    return 匞场景包.构造囗算子包扌(圁翅膀, 左翼丷右翼=起翼丷讫翼^左起丷右起, 深度=深度)
def 乸匴彼翼(匞场景包, 圁角色名, /, *, 起翼丷讫翼,左起丷右起, 深度):
    assert 圁角色名 is 圁彼翼
    return 匞场景包.构造囗算子包扌(圁翅膀, 左翼丷右翼=not(起翼丷讫翼^左起丷右起), 深度=深度)


def 乸匴节点(匞场景包, 圁角色名, /, *, 深度):
    assert 圁角色名 is 圁节点
    if 深度 == 0:
        return 匞场景包.构造囗算子包扌(圁元素封包节点)
    return 匞场景包.构造囗算子包扌(圁更深节点, 深度=深度-1)

class 乸双侧展翅树囗场景角色名(Enum):
    r'''[[[
######################
！！高度 作为 模板参数 不合理！！
    构造之后 才能 确定！！
也不对，匴算子包 确实依 高度 而特化
    构造之前 便确定 高度 ==>> 局部单层构造器
    类似 树巛节点序列 无法 实现
    只能: 光杆树巛节点序列
    或:   根深树巛左翼丶更深树丶右翼
######################


######################
#共15个:
#   基本角色:6个
#   转发别名9个:见:注册囗标准转发构造扌
#   其余:
#       直接别名3个:更高，无高
#       临时用注水版实体名3个:含高
#       外部实体名1个
######################
双侧根深树
双侧光杆树
左翼
右翼
更深节点
元素封包节点
######################
双侧展翅树
双侧更深树
翅膀
异翅
起翼
讫翼
此翼
彼翼
节点
######################
含高双侧展翅树
含高双侧根深树
含高双侧更深树
######################
双侧无高树 = 双侧光杆树
双侧更高树 = 双侧根深树
含高双侧更高树 = 含高双侧根深树
######################
节点序列
######################

    #]]]'''#'''
    圁双侧展翅树 = auto()
    圁双侧根深树 = auto() #基础
    圁双侧更深树 = auto()
        # 高度,深度
    圁双侧光杆树 = auto() #基础
        ###高度=0,深度
        # 深度

    圁左翼 = auto() #基础
    圁右翼 = auto() #基础
        # 深度
    圁翅膀 = auto()
    圁异翅 = auto()
        # 左翼丷右翼,深度
    圁起翼 = auto()
    圁讫翼 = auto()
        # 左起丷右起,深度
    圁此翼 = auto()
    圁彼翼 = auto()
        # 起翼丷讫翼,左起丷右起,深度

    圁节点 = auto()
    圁更深节点 = auto() #基础
        # 深度
    圁元素封包节点 = auto() #基础
        ####深度=0
        # ()

    ####以下:注水版:附加/自带『高度』
    圁含高双侧展翅树 = auto()
    圁含高双侧根深树 = auto()
    圁含高双侧更深树 = auto()
        # 深度
    ####以下:直接别名
    圁双侧无高树 = 圁双侧光杆树
    圁双侧更高树 = 圁双侧根深树
    圁含高双侧更高树 = 圁含高双侧根深树
    ####以下:用于 输入/输出，并非 双侧展翅树 的 零件
    圁节点序列 = auto()
        # 左起丷右起,深度
#end-class 乸双侧展翅树囗场景角色名

圁双侧展翅树 = 乸双侧展翅树囗场景角色名.圁双侧展翅树
圁双侧根深树 = 乸双侧展翅树囗场景角色名.圁双侧根深树
圁双侧更深树 = 乸双侧展翅树囗场景角色名.圁双侧更深树
圁双侧光杆树 = 乸双侧展翅树囗场景角色名.圁双侧光杆树
圁左翼 = 乸双侧展翅树囗场景角色名.圁左翼
圁右翼 = 乸双侧展翅树囗场景角色名.圁右翼
圁翅膀 = 乸双侧展翅树囗场景角色名.圁翅膀
圁异翅 = 乸双侧展翅树囗场景角色名.圁异翅
圁起翼 = 乸双侧展翅树囗场景角色名.圁起翼
圁讫翼 = 乸双侧展翅树囗场景角色名.圁讫翼
圁此翼 = 乸双侧展翅树囗场景角色名.圁此翼
圁彼翼 = 乸双侧展翅树囗场景角色名.圁彼翼
圁节点 = 乸双侧展翅树囗场景角色名.圁节点
圁更深节点 = 乸双侧展翅树囗场景角色名.圁更深节点
圁元素封包节点 = 乸双侧展翅树囗场景角色名.圁元素封包节点
圁节点序列 = 乸双侧展翅树囗场景角色名.圁节点序列



class _魖匴算子包纟基础类型纟双侧展翅树(ABC):
    #__slots__ = ()
    ___no_slots_ok___ = True
    @classmethod
    def _init_(cls, *, sf, 圁角色名, **kw):
        d = vars(sf)
        for nm, v in kw.items():
            d[f'_{nm}'] = v
    @property
    @abstractmethod
    def 匞场景包(sf, /):
        '-> 匞场景包'
    def __call__(sf, 圁角色名, /, *算子包模板参数冖冖位次, **算子包模板参数冖冖具名):
        '转发以节省笔墨'
        return sf.匞场景包.构造囗算子包扌(圁角色名, *算子包模板参数冖冖位次, **算子包模板参数冖冖具名)

class _只用作属性方法容器(_魖匴算子包纟基础类型纟双侧展翅树):
    ___no_slots_ok___ = True
    @property
    @override
    def 匞场景包(sf, /):
        '-> 匞场景包'
        return sf._匞场景包
    @property
    def 深度(sf, /):
        '-> 深度'
        return sf._深度
    @property
    def 高度(sf, /):
        '-> 高度'
        return sf._高度
    @property
    def 左翼丷右翼(sf, /):
        '-> 左翼丷右翼'
        return sf._左翼丷右翼
    @property
    def 起翼丷讫翼(sf, /):
        '-> 起翼丷讫翼'
        return sf._起翼丷讫翼
    @property
    def 左起丷右起(sf, /):
        '-> 左起丷右起'
        return sf._左起丷右起
def _添加只读属性扌(cls, /):
    (infoss4input, tmay_return_annotation) = get_signature_of__py3_(cls.__init__)
    (infos4idx_only, infos4idx_nm_both, tmay_info4varargs, infos4nm_only, tmay_info4varkwds) = infoss4input
    for nm, tmay_annotation, tmay_default in infos4nm_only:
        assert not tmay_annotation
        assert not tmay_default
        f = getattr(_只用作属性方法容器, nm)
        setattr(cls, nm, f)



class 魖匴节点(_魖匴算子包纟基础类型纟双侧展翅树):
    @property
    @abstractmethod
    def 深度纟节点(sf, /):
        '-> 深度@节点'
    def 讠含深节点扌(sf, 节点, /):
        '节点<深度> -> 含深节点/(深度,节点<深度>)'
        return sf.深度纟节点, 节点
    @abstractmethod
    def 取囗差分度量扌(sf, 节点, /, *, 正丷负):
        '节点<深度> -> 差分/内建可差分度量'

class 魖匴元素封包节点(魖匴节点):
    def __init__(sf, 匞场景包, 圁角色名, /):
        assert 圁角色名 is 圁元素封包节点
        sf._init_(**locals())
    深度纟节点 = 0
    @abstractmethod
    def 构造囗元素封包节点扌(sf, 元素, /):
        '元素 -> 元素封包节点<>'
    @abstractmethod
    def 拆包囗元素封包节点扌(sf, 元素封包节点, /):
        '元素封包节点<> -> 元素'
_添加只读属性扌(魖匴元素封包节点)

class 魖匴更深节点(魖匴节点):
    def __init__(sf, 匞场景包, 圁角色名, /, *, 深度):
        assert 圁角色名 is 圁更深节点
        sf._init_(**locals())
    @property
    @override
    def 深度纟节点(sf, /):
        '-> 深度@节点'
        return sf.深度+1
    @abstractmethod
    def 构造囗更深节点扌(sf, 节点序列, /, *, 左起丷右起):
        '节点序列<左起丷右起;深度>/(Iter 节点<深度>) -> 更深节点<深度>'
    @abstractmethod
    def 枚举囗子节点扌(sf, 更深节点, /, *, 左起丷右起):
        '更深节点<深度> -> 节点序列<左起丷右起;深度>/(Iter 节点<深度>)'
    @abstractmethod
    def 取囗长度扌(sf, 更深节点, /):
        '更深节点<深度> -> 长度/即 数目<节点<深度> >'
_添加只读属性扌(魖匴更深节点)






class 魖匴翅膀(_魖匴算子包纟基础类型纟双侧展翅树):
    def 讠含位翅膀扌(sf, 翅膀, /):
        '翅膀<左翼丷右翼,深度> -> 含位翅膀<深度>/(左翼丷右翼, 翅膀<左翼丷右翼,深度>)'
        return sf.左翼丷右翼, 翅膀
    @property
    @abstractmethod
    def 左翼丷右翼(sf, /):
        '-> 左翼丷右翼/bool'
    @abstractmethod
    def 构造囗翅膀扌(sf, 节点序列, /, *, 左起丷右起):
        '节点序列<左起丷右起;深度>/(Iter 节点<深度>) -> 翅膀<左翼丷右翼,深度>'
    @abstractmethod
    def 枚举囗节点扌(sf, 翅膀, /, *, 左起丷右起):
        '翅膀<左翼丷右翼,深度> -> 节点序列<左起丷右起;深度>/(Iter 节点<深度>)'
    @abstractmethod
    def 取囗长度扌(sf, 翅膀, /):
        '翅膀<左翼丷右翼,深度> -> 长度/即 数目<节点<深度> >'
    @abstractmethod
    def 外端压入节点暨内端弹出魊更深节点扌(sf, 翅膀, 节点, /):
        '翅膀<左翼丷右翼,深度> -> 节点<深度> -> (翅膀<左翼丷右翼,深度>, 魊更深节点<深度>)'
    @abstractmethod
    def 外端弹出节点囗囗足员扌(sf, 翅膀, /):
        '翅膀<左翼丷右翼,深度> -> (翅膀<左翼丷右翼,深度>, 节点<深度>) | ^匪足员未定义'
    @abstractmethod
    def 外端弹出节点暨内端压入更深节点囗囗缺员乊厚势扌(sf, 翅膀, 更深节点, /):
        '翅膀<左翼丷右翼,深度> -> 更深节点<深度> -> (翅膀<左翼丷右翼,深度>, 节点<深度>) | ??^匪缺员未定义'
    @abstractmethod
    def 外端弹出节点暨均衡双翼囗囗缺员乊空心乊均衡有余扌(sf, 翅膀, 异翅, /):
        '翅膀<左翼丷右翼,深度> -> 异翅<左翼丷右翼,深度> -> (翅膀<左翼丷右翼,深度>, 异翅<左翼丷右翼,深度>, 节点<深度>) | ??^匪此翼缺员双翼均衡有余未定义'
    @abstractmethod
    def 外端弹出节点暨变态退化囗囗缺员乊空心乊临界退化扌(sf, 翅膀, 异翅, /):
        '翅膀<左翼丷右翼,深度> -> 异翅<左翼丷右翼,深度> -> (双侧无高树<深度>, 节点<深度>) | ??^匪此翼缺员双翼临界退化未定义'
    @abstractmethod
    def 外端先弹出再压入囗节点扌(sf, 翅膀, 节点, /):
        '翅膀<左翼丷右翼,深度> -> 节点<深度> -> (翅膀<左翼丷右翼,深度>, 节点<深度>)'
class 魖左翼(魖匴翅膀):
    左翼丷右翼 = False
    def __init__(sf, 匞场景包, 圁角色名, /, *, 深度):
        assert 圁角色名 is 圁左翼
        sf._init_(**locals())
_添加只读属性扌(魖匴左翼)

class 魖右翼(魖匴翅膀):
    左翼丷右翼 = True
    def __init__(sf, 匞场景包, 圁角色名, /, *, 深度):
        assert 圁角色名 is 圁右翼
        sf._init_(**locals())
_添加只读属性扌(魖匴右翼)




class 魖匴双侧展翅树(_魖匴算子包纟基础类型纟双侧展翅树):
    @property
    @abstractmethod
    def 高度纟双侧展翅树(sf, /):
        '-> 高度@双侧展翅树'
    def 讠含高双侧展翅树扌(sf, 双侧展翅树, /):
        '双侧展翅树<高度,深度> -> 含高双侧展翅树<深度>'
        return sf.高度纟双侧展翅树, 双侧展翅树
    @abstractmethod
    def 是囗空树扌(sf, 双侧展翅树, /):
        '双侧展翅树<高度,深度> -> 欤空树/bool'
    @abstractmethod
    def 枚举囗节点扌(sf, 双侧展翅树, /, *, 左起丷右起):
        '双侧展翅树<高度,深度> -> 节点序列<左起丷右起;深度>/(Iter 节点<深度>)'
    @abstractmethod
    def 查询囗魊长度扌(sf, 双侧展翅树, /):
        '双侧展翅树<高度,深度> -> 魊 长度/即 数目<节点<深度> >'
    @abstractmethod
    def 压入囗节点扌(sf, 双侧展翅树, 节点, /, *, 左端丷右端):
        '双侧展翅树<高度,深度> -> 节点<深度> -> (含高双侧展翅树<深度>, 差分/内建可差分度量)'
        #内建可差分度量:比如:长度==>>『+1』
    @abstractmethod
    def 弹出囗节点扌(sf, 双侧展翅树, /, *, 左端丷右端):
        '双侧展翅树<高度,深度> -> (含高双侧展翅树<深度>, 差分/内建可差分度量, 节点<深度>) | ^错误囗空树'
        #内建可差分度量:比如:长度==>>『-1』
    @abstractmethod
    def 先讫端压入再起端弹出囗节点扌(sf, 双侧展翅树, 节点, /, *, 左起丷右起):
        '双侧展翅树<高度,深度> -> 节点<深度> -> (含高双侧展翅树<深度>, 差分/内建可差分度量, 节点<深度>)'
        ops = sf
        差分囗累计值 = 取囗加法零元纟差分度量扌(ops.匞场景包)
        加囗差分扌 = 取囗加法纟差分度量扌(ops.匞场景包)
        (含高双侧展翅树, 差分) = sf.压入囗节点扌(双侧展翅树, 节点, 左端丷右端=not 左起丷右起)
            #讫端
        差分囗累计值 = 加囗差分扌(差分囗累计值, 差分)
        ops, 双侧展翅树 = 匹配新高度囗含高双侧展翅树扌(ops, 含高双侧展翅树)
        (含高双侧展翅树, 差分, 节点) = sf.弹出囗节点扌(双侧展翅树, 左端丷右端=左起丷右起)
            #起端
        差分囗累计值 = 加囗差分扌(差分囗累计值, 差分)
        return (含高双侧展翅树, 差分囗累计值, 节点)
    @abstractmethod
    def 同端先弹出再压入囗节点扌(sf, 双侧展翅树, 节点, /, *, 左端丷右端):
        '双侧展翅树<高度,深度> -> 节点<深度> -> (含高双侧展翅树<深度>, 差分/内建可差分度量, 节点<深度>) | ^错误囗空树'
        ops = sf
        差分囗累计值 = 取囗加法零元纟差分度量扌(ops.匞场景包)
        加囗差分扌 = 取囗加法纟差分度量扌(ops.匞场景包)
        (含高双侧展翅树, 差分, 节点囗囗出) = sf.弹出囗节点扌(双侧展翅树, 左端丷右端=左端丷右端)
            # ^错误囗空树
        差分囗累计值 = 加囗差分扌(差分囗累计值, 差分)
        ops, 双侧展翅树 = 匹配新高度囗含高双侧展翅树扌(ops, 含高双侧展翅树)
        (含高双侧展翅树, 差分) = sf.压入囗节点扌(双侧展翅树, 节点, 左端丷右端=左端丷右端)
        差分囗累计值 = 加囗差分扌(差分囗累计值, 差分)
        return (含高双侧展翅树, 差分囗累计值, 节点囗囗出)
    def 连续压入囗节点扌(ops, 双侧展翅树, 节点序列, /, *, 左起丷右起, 左端丷右端):
        '双侧展翅树<高度,深度> -> 节点序列<左起丷右起,深度>/(Iter 节点<深度>) -> (含高双侧展翅树<深度>, 差分/内建可差分度量)'
        it = 枚举囗节点扌(节点序列, 反转=左起丷右起 is 左端丷右端)
        差分囗累计值 = 取囗加法零元纟差分度量扌(ops.匞场景包)
        加囗差分扌 = 取囗加法纟差分度量扌(ops.匞场景包)
        for 节点 in it:
            (含高双侧展翅树, 差分) = ops.压入囗节点扌(双侧展翅树, 节点)
            差分囗累计值 = 加囗差分扌(差分囗累计值, 差分)
            ops, 双侧展翅树 = 匹配新高度囗含高双侧展翅树扌(ops, 含高双侧展翅树)
        return (含高双侧展翅树, 差分囗累计值)
    def 连续弹出囗节点扌(ops, 双侧展翅树, 最大数目, /, *, 左起丷右起, 左端丷右端):
        '双侧展翅树<高度,深度> -> 最大数目 -> (含高双侧展翅树<深度>, 差分/内建可差分度量, 节点列表<左起丷右起,深度>/[节点<深度>])'
        节点列表 = []
        差分囗累计值 = 取囗加法零元纟差分度量扌(ops.匞场景包)
        加囗差分扌 = 取囗加法纟差分度量扌(ops.匞场景包)
        for _ in range(最大数目):
            if ops.是囗空树扌(双侧展翅树):
                break
            (含高双侧展翅树, 差分, 节点) = ops.弹出囗节点扌(双侧展翅树)
            节点列表.append(节点)
            差分囗累计值 = 加囗差分扌(差分囗累计值, 差分)
            ops, 双侧展翅树 = 匹配新高度囗含高双侧展翅树扌(ops, 含高双侧展翅树)
        if 左起丷右起 ^ 左端丷右端:
            节点列表.reverse()
        return (含高双侧展翅树, 差分囗累计值, 节点列表)

def 匹配新高度囗含高双侧展翅树扌(ops, 含高双侧展翅树, /):
    旧高度 = ops.高度纟双侧展翅树
    (新高度, 双侧展翅树) = 含高双侧展翅树
    if not 新高度 == 旧高度:
        深度 = ops.深度
        ops = ops(圁双侧展翅树, 高度=新高度, 深度=深度)
    return ops, 双侧展翅树

class 魖匴双侧无高树(魖匴双侧展翅树):
    def __init__(sf, 匞场景包, 圁角色名, /, *, 深度):
        assert 圁角色名 is 圁双侧光杆树
        sf._init_(**locals())
    高度纟双侧展翅树 = 0
    def 构造囗双侧光杆树扌(sf, 节点序列, /, *, 左起丷右起):
        '节点序列<左起丷右起;深度>/(Iter 节点<深度>) -> 双侧光杆树<深度>'
        节点列表 = [*节点序列]
        if 左起丷右起:
            节点列表.reverse()
        return sf.构造囗双侧无高树扌(节点列表)
    @abstractmethod
    def 构造囗双侧无高树扌(sf, 节点列表, /):
        '节点列表<左起;深度>/[节点<深度>] -> 双侧无高树<深度>'
    @override
    def 查询囗魊长度扌(sf, 双侧展翅树, /):
        '双侧展翅树<高度,深度> -> 魊 长度/即 数目<节点<深度> >'
        return (sf.取囗长度扌(双侧无高树),)
    @abstractmethod
    def 取囗长度扌(sf, 双侧无高树, /):
        '双侧无高树<深度> -> 长度/即 数目<节点<深度> >'
    @override
    def 弹出囗节点扌(sf, 双侧无高树, /, *, 左端丷右端):
        '双侧无高树<深度> -> (含高双侧展翅树<深度>, 差分/内建可差分度量, 节点<深度>) | ^错误囗空树'
        '双侧展翅树<高度,深度> -> (含高双侧展翅树<深度>, 差分/内建可差分度量, 节点<深度>) | ^错误囗空树'
        # 统一形式:与『双侧根深树』使用同一接口 使得 『圁双侧展翅树』有用
        if sf.是囗空树扌(双侧展翅树):
            raise 错误囗空树
        (双侧无高树, 差分, 节点) = sf.彳忄亍弹出囗节点囗囗非空无高树扌(双侧无高树, 左端丷右端=左端丷右端)
        含高双侧展翅树 = 高度,双侧展翅树 = 0,双侧无高树
        return (含高双侧展翅树, 差分, 节点)

    @abstractmethod
    def 彳忄亍弹出囗节点囗囗非空无高树扌(sf, 双侧光杆树, /, *, 左端丷右端):
        '非空:双侧光杆树<深度> -> (双侧光杆树<深度>, 差分/内建可差分度量, 节点<深度>)'
        #内建可差分度量:比如:长度==>>『-1』
_添加只读属性扌(魖匴双侧无高树)




class 魖匴双侧更高树(魖匴双侧展翅树):
    def __init__(sf, 匞场景包, 圁角色名, /, *, 高度, 深度):
        assert 圁角色名 is 圁双侧更高树
        sf._init_(**locals())
    @property
    @override
    def 高度纟双侧展翅树(sf, /):
        '-> 高度@双侧展翅树'
        return sf.高度+1
    def 构造囗双侧根深树扌(sf, 起翼, 双侧更深树, 讫翼, /, *, 左起丷右起):
        '起翼<左起丷右起,深度> -> 双侧更深树<高度,深度> -> 讫翼<左起丷右起,深度> -> 双侧更高树<高度,深度>'
        左翼, 右翼 = _调整次序(起翼, 讫翼, 左起丷右起=左起丷右起)
        return sf.构造囗双侧更高树扌(左翼, 双侧更深树, 右翼)
    @abstractmethod
    def 构造囗双侧更高树扌(sf, 左翼, 双侧更深树, 右翼, /):
        '左翼<深度> -> 双侧更深树<高度,深度> -> 右翼<深度> -> 双侧更高树<高度,深度>'
    @abstractmethod
    def 拆包囗双侧更高树扌(sf, 双侧更高树, /):
        '双侧更高树<高度,深度> -> (左翼<深度>, 双侧更深树<高度,深度>, 右翼<深度>)'
    def 拆包囗双侧根深树扌(sf, 双侧更高树, /, *, 左起丷右起):
        '双侧更高树<高度,深度> -> (起翼<左起丷右起,深度>, 双侧更深树<高度,深度>, 讫翼<左起丷右起,深度>)'
        (左翼, 双侧更深树, 右翼) = sf.拆包囗双侧更高树扌(双侧更高树)
        起翼, 讫翼 = _调整次序(左翼, 右翼, 左起丷右起=左起丷右起)
        return (起翼, 双侧更深树, 讫翼)
    @override
    def 先讫端压入再起端弹出囗节点扌(sf, 双侧展翅树, 节点, /, *, 左起丷右起):
        '双侧展翅树<高度,深度> -> 节点<深度> -> (含高双侧展翅树<深度>, 差分/内建可差分度量, 节点<深度>)'
        return super().先讫端压入再起端弹出囗节点扌(双侧展翅树, 节点, 左起丷右起=左起丷右起)
    @override
    def 同端先弹出再压入囗节点扌(sf, 双侧更高树, 节点, /, *, 左端丷右端):
        '双侧展翅树<高度,深度> -> 节点<深度> -> (含高双侧展翅树<深度>, 差分/内建可差分度量, 节点<深度>) | ^错误囗空树'
        (起翼, 双侧更深树, 讫翼) = sf.拆包囗双侧根深树扌(双侧更高树, 左起丷右起=左端丷右端)
        ops = sf(圁起翼, 左起丷右起=左端丷右端, 深度=sf.深度)
        起翼, 节点囗囗出 = ops.外端先弹出再压入囗节点扌(起翼, 节点)
            # ^错误囗空树
        双侧更高树 = sf.构造囗双侧根深树扌(起翼, 双侧更深树, 讫翼, 左起丷右起=左端丷右端)
        含高双侧展翅树 = sf.讠含高双侧展翅树扌(双侧更高树)
        ops = sf(圁节点, 深度=sf.深度)
        差分囗累计值 = 取囗加法零元纟差分度量扌(ops.匞场景包)
        加囗差分扌 = 取囗加法纟差分度量扌(ops.匞场景包)
        差分 = ops.取囗差分度量扌(节点, 正丷负=False)
        差分囗累计值 = 加囗差分扌(差分囗累计值, 差分)
        差分 = ops.取囗差分度量扌(节点囗囗出, 正丷负=True)
        差分囗累计值 = 加囗差分扌(差分囗累计值, 差分)
        return (含高双侧展翅树, 差分囗累计值, 节点囗囗出)
_添加只读属性扌(魖匴双侧更高树)






def __():
    from seed.tiny import ifNonef, ifNone, echo
    from seed.tiny import check_type_is, fst, snd, at
    from seed.tiny_.check import check_uint_lt, check_int_ge_lt, check_int_ge, check_int_ge_le
    from seed.tiny import print_err, mk_fprint, mk_assert_eq_f, expectError
    from seed.func_tools.fmapT.fmapT__tiny import dot, fmapT__dict, fmapT__list, fmapT__iter
    from seed.helper.repr_input import repr_helper

def __():
    from seed.helper.repr_input import repr_helper
    class _(ABC):
        raise NotImplementedError
        ___no_slots_ok___ = True
        def __repr__(sf, /):
            #return repr_helper(sf, *args, **kwargs)
            #return repr_helper_ex(sf, args, ordered_attrs, kwargs, ordered_attrs_only=False)
            ...
if __name__ == "__main__":
    pass
__all__


from seed.data_funcs.finger_tree2.finger_tree_basic_types import *
