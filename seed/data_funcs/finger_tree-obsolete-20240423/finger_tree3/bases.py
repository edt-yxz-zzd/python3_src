#__all__:goto
r'''[[[
暂停:goto


seed.data_funcs.finger_tree3.bases
py -m nn_ns.app.debug_cmd   seed.data_funcs.finger_tree3.bases -x
py -m nn_ns.app.doctest_cmd seed.data_funcs.finger_tree3.bases:__doc__
py_adhoc_call   seed.data_funcs.finger_tree3.bases   @f
from seed.data_funcs.finger_tree3.bases import *

匞:指 构造用工厂+参数配置包
浅包装:<<==针对接口编程
命名规范:索引纟元素匕容器vs索引乚容器
    索引类纟元素类匕容器类
    索引类乚容器类
    索引值纟元素值匕容器值
    索引值乚容器值
    view ../../python3_src/useful__cjk_naming.txt
        [:区别冖冖纟匕乚]:goto

[[
本模块默认变量是 浅包装器 除非 冠以『裸冫』:
浅包装:
    展翅树
    节点
    翅膀
无包装:
    裸冫展翅树
    裸冫节点
    裸冫翅膀
]]
#更名:双侧展翅树-->展翅树

[[
操作:
    构造<<==空树+压入
    枚举
    压入
    弹出
    异端压弹
    同端弹压
    合并
    路径乚展翅树=>分裂,索引
        分裂扌
        索引扌
    度量=>定位
        定位扌
特化:
    各级:++欤反转?
        各级:++度量乊反转无关?
        各级:++左右两个=度量乊反转有关?
    ######################
    ######################
    * 欤反转
    * 元素数量/长度<节点{深度:=0}>/节点数{深度:=0}
        ==>>正负长度暨欤反转
    ######################
    ######################
]]

[[
深度:
[展翅树{深度}.节点 =[def]= 节点{深度}]
    即:
    [光杆树{深度}.节点 =[def]= 节点{深度}]
    [根深树{深度}.节点 =[def]= 节点{深度}]
[更高树{高度} =[def]= 展翅树{高度+1}]
[更深树{深度} =[def]= 展翅树{深度+1}]
[根深树{深度,高度+1} == 更高树{深度,高度} == (左翼, 更深树{深度+1,高度}, 右翼)]

[更深树{深度}.节点 =[def]= 更深节点{深度}]
[更深节点{深度} =[def]= 节点{深度+1}]
[节点{深度+1}.节点 =[def]= 节点{深度}]
[节点{深度:=0} =[def]= 元素封包节点]

[翅膀{深度}.节点 =[def]= 节点{深度}]
    即:
    [左翼{深度}.节点 =[def]= 节点{深度}]
    [右翼{深度}.节点 =[def]= 节点{深度}]
    [异翅{深度}.节点 =[def]= 节点{深度}]
]]
[[
高度:
[展翅树{高度:=0} =[def]= 光杆树]
[展翅树{高度:=高度纟根深树+1} =[def]= 根深树{高度纟根深树}]
===
[:取消冫高度纟树]:here
取消:树<高度> #虽 占用空间 极少:log(1)
    并非必须，只需知道 欤光杆
    欤光杆 可以 静态绑定在 类型 里

]]
[[
长度:
[展翅树{深度}.长度 =[def]= 节点数<节点{深度}>]
[节点数<节点{0}> === 元素数量]
===
[:取消冫长度纟树]:here
取消:树<长度> #虽 占用空间 极少:log(元素数量)
    树<深度/高度>:在运算时实时计算可得
    长度<翅膀/更深节点/光杆树>: 甚至可以 静态绑定在 类型 里
]]

[[
[路径乊左起 =!= 路径乊右起]
    不可比较是否相等，哪怕逻辑等价
    但给定一颗树，则可比较、可换向
逻辑含义:
路径乚展翅树{深度,左起丷右起} -> 展翅树{深度} -> 间隙纟节点{深度}

路径乚展翅树{深度,左起丷右起} = (深度,左起丷右起,裸路径乚展翅树)
    #魖浅包装器纟路径乚展翅树:goto
    #浅包装:外附:深度,左起丷右起
    #
当下:采用外翻设计，层层外包:
    [外翻出:扁索引{更深节点}] ==>> 一系列『乊子』
裸路径乚展翅树 =:
    | 整树讫
    | 裸路径乊子纟展翅树
裸路径乊子纟展翅树 =:
    | 裸路径乊子纟光杆树
    | 裸路径乊子纟根深树
裸路径乊子纟根深树 =:
    | 裸路径乊子纟左翼
    | 裸路径乊子纟右翼
    | (裸路径乊子纟更深树, 扁索引乊子{更深节点})
裸路径乊子纟更深树{深度,左起丷右起} = 裸路径乊子纟展翅树{深度+1,左起丷右起}
裸路径乊子纟光杆树 = 扁索引乊子{光杆树}
裸路径乊子纟左翼 = 扁索引乊子{左翼}
裸路径乊子纟右翼 = 扁索引乊子{右翼}

扁索引乊子 eg: 索引号{0..<长度}
    子部件/细胞
    非讫
扁索引乊内 eg: 索引号{1..<长度}
    内部间隙
    非起讫
===
操作:
欤相等乊同深同向扌
    :: 路径乚展翅树{深度,左起丷右起} -> 路径乚展翅树{深度,左起丷右起} -> bool
换向乊特定树扌
    :: 路径乚展翅树{深度,左起丷右起} -> 展翅树{深度} -> 路径乚展翅树{深度,not 左起丷右起}
取冫魊节点乊特定树扌
    :: 路径乚展翅树{深度,左起丷右起} -> 展翅树{深度} -> 魊节点{深度}
分裂冫树扌
    :: 路径乚展翅树{深度,左起丷右起} -> 展翅树{深度} -> (展翅树{深度}, 魊焦点/魊节点{深度}, 展翅树{深度})
索引冫节点纟树扌
    :: 路径乚展翅树{深度,左起丷右起} -> 展翅树{深度} -> 魊节点{深度}
更换冫节点纟树扌
更换冫后裔树纟树扌
欤反转=>反转冫节点纟树扌
欤反转=>反转冫后裔树纟树扌
===
构造:
起路径乊树
讫路径乊树
路径巛扁索引乊子纟光杆树
路径巛扁索引乊子纟翅膀
路径巛路径乊子纟更深树
构造冫定位冫节点纟树扌
]]


[[
分裂=>半扇
半扇:
半扇纟翅膀
半扇纟更深节点
半扇纟展翅树 =:
    | 半扇纟光杆树
    | 半扇纟根深树
半扇纟根深树{左半扇丷右半扇} = 起半扇纟根深树{左起丷右起:=左半扇丷右半扇}
起半扇纟根深树{左起丷右起} =:
    | (左起丷右起, 起翼, 更深树, 起半扇纟讫翼)
    | (左起丷右起, 起翼, 起半扇纟更深树, 魊起半扇纟更深节点)
    | (左起丷右起, 起半扇纟起翼)


分裂纟树乊半态扌
    :: 路径乚展翅树{深度,左起丷右起} -> 展翅树{深度} -> (起半扇纟展翅树{深度,左起丷右起}, 魊焦点/魊节点{深度}, 讫半扇纟展翅树{深度,左起丷右起})
分裂纟更深节点乊半态扌
    :: 浅路径乚更深节点{深度,左起丷右起} -> 更深节点{深度} -> (起半扇纟更深节点{深度,左起丷右起}, 魊焦点/魊节点{深度}, 讫半扇纟更深节点{深度,左起丷右起})
(起半扇纟展翅树{深度,左起丷右起}, 魊焦点/魊节点{深度}, 讫半扇纟展翅树{深度,左起丷右起})
===(起半扇纟更深树{深度,左起丷右起}, 魊更深焦点/魊更深节点{深度}, 讫半扇纟更深树{深度,左起丷右起})
===(起半扇纟更深树{深度,左起丷右起}, 魊(起半扇纟更深节点{深度,左起丷右起}, 魊焦点/魊节点{深度}, 讫半扇纟更深节点{深度,左起丷右起}), 讫半扇纟更深树{深度,左起丷右起})
===(起翼{深度,左起丷右起}, (起半扇纟更深树{深度,左起丷右起}, 魊(起半扇纟更深节点{深度,左起丷右起}, 魊焦点/魊节点{深度}, 讫半扇纟更深节点{深度,左起丷右起}), 讫半扇纟更深树{深度,左起丷右起}), 讫翼{深度,左起丷右起})
===((起翼{深度,左起丷右起}, 起半扇纟更深树{深度,左起丷右起}, 魊起半扇纟更深节点{深度,左起丷右起}), 魊焦点/魊节点{深度}, (魊讫半扇纟更深节点{深度,左起丷右起}, 讫半扇纟更深树{深度,左起丷右起}, 讫翼{深度,左起丷右起}))
===(起半扇纟根深树{左起丷右起}, 魊焦点/魊节点{深度}, 讫半扇纟根深树{左起丷右起})

#意图:减少计算纟度量
构造冫树巛半态扌
    :: 半扇纟展翅树{深度,左半扇丷右半扇} -> 展翅树{深度}

???暂停:好多类型接口...这正常吗？
]]





#]]]'''
__all__ = r'''
'''.split()#'''
__all__
from itertools import chain, islice, repeat
from seed.tiny import check_type_is, null_iter
from seed.abc.abc__ver1 import abstractmethod, override, ABC, ABC__no_slots
    #___no_slots_ok___ = True
#from seed.helper.repr_input import repr_helper
    #def __repr__(sf, /):
        #return repr_helper(sf, *args, **kwargs)
        #return repr_helper_ex(sf, args, ordered_attrs, kwargs, ordered_attrs_only=False)

def _重定次序扌(*args, 左起丷右起):
    if not 左起丷右起:
        #左起
        return args
    #右起
    return args[::-1]
def _槑节点纟死():
    raise 000
######################
class 魖匞纟浅包装器(ABC):
    '匞纟浅包装器:构造器集中处/工厂+参数配置+匞纟浅包装器纟子部件'
    __slots__ = ()
class 魖浅包装器(ABC):
    '浅包装器:假设存在一个被包装底层对象:提供必要接口'
    __slots__ = ()
    @property
    @abstractmethod
    def 匞纟浅包装器(sf, /):
        '-> 魖匞纟浅包装器'

######################
class 魖匞纟浅包装器纟路径乚展翅树(ABC):
    r'''[[[
    匞纟路径乚展翅树
    路径乚展翅树{深度,左起丷右起}
    ===
    路径乚更深树{深度,左起丷右起}
    浅路径乚翅膀{深度,左翼丷右翼,左起丷右起}
    浅路径乚节点{深度,左起丷右起}
    浅路径乚更深节点{深度,左起丷右起}

    ===
    向性路径:
        [起路径{左起} 不可比较 讫路径{右起}]
            虽然 逻辑上等价，但 允许 不同具现，所以 不可比较，除非 指定 特定的树
    ===
    路径 = 内路径 | (起路径&|&讫路径)
        内路径 = 路径乊非起讫
        起路径,讫路径 可能 相同 #空树
        内路径 可能 不存在 #[节点数 < 2]
    ===
    [扁索引:裸]
        扁索引:非浅包装，需外附{深度,左起丷右起}
    ===
    #]]]'''#'''
    __slots__ = ()
    @abstractmethod
    def 构造冫起路径乚树扌(sf, 展翅树, /, *, 左起丷右起):
        '展翅树{深度} -> 起路径乚树/路径乚展翅树{深度,左起丷右起}'
    @abstractmethod
    def 构造冫讫路径乚树扌(sf, 展翅树, /, *, 左起丷右起):
        '展翅树{深度} -> 讫路径乚树/路径乚展翅树{深度,左起丷右起}'
    ######################
    @abstractmethod
    def 构造冫路径巛路径乚更深树扌(sf, 路径乚更深树, 扁索引乊子纟更深节点, /):
        '路径乚更深树{深度,左起丷右起}/路径乚展翅树{深度+1,左起丷右起} -> 扁索引乊子纟更深节点 -> 路径乚展翅树{深度,左起丷右起}'
        #采用外翻设计:goto
    @abstractmethod
    def 构造冫路径巛浅路径乚翅膀扌(sf, 浅路径乚翅膀, /):
        '浅路径乚翅膀{深度,左翼丷右翼,左起丷右起} -> 路径乚展翅树{深度,左起丷右起}'
    @abstractmethod
    def 构造冫路径巛扁索引乚光杆树扌(sf, 扁索引乚光杆树, /, *, 深度, 左起丷右起):
        '扁索引乚光杆树{深度,左起丷右起} -> 路径乚展翅树{深度,左起丷右起} # [扁索引:裸]'
        #采用外翻设计:goto
class 魖匞纟浅包装器纟浅路径乚翅膀(ABC):
    '浅路径乚翅膀{深度,左翼丷右翼,左起丷右起}'
    __slots__ = ()
    @abstractmethod
    def 构造冫起路径乚翅膀扌(sf, 翅膀, /, *, 左起丷右起):
        '翅膀{深度,左翼丷右翼} -> 起浅路径乚翅膀/浅路径乚翅膀{深度,左翼丷右翼,左起丷右起}'
    @abstractmethod
    def 构造冫讫路径乚翅膀扌(sf, 翅膀, /, *, 左起丷右起):
        '翅膀{深度,左翼丷右翼} -> 讫浅路径乚翅膀/浅路径乚翅膀{深度,左翼丷右翼,左起丷右起}'
    ######################
    @abstractmethod
    def 构造冫浅路径巛扁索引乚翅膀扌(sf, 扁索引乚翅膀, /, *, 深度, 左翼丷右翼, 左起丷右起):
        '扁索引乚翅膀{深度,左翼丷右翼,左起丷右起} -> 浅路径乚翅膀{深度,左翼丷右翼,左起丷右起}'
        #采用外翻设计:goto
class 魖匞纟浅包装器纟浅路径乚节点(ABC):
    '浅路径乚节点{深度,左起丷右起}'
    __slots__ = ()
    @abstractmethod
    def 构造冫起路径乚节点扌(sf, 节点, /, *, 左起丷右起):
        '节点{深度} -> 起浅路径乚节点/浅路径乚节点{深度,左起丷右起}'
    @abstractmethod
    def 构造冫讫路径乚节点扌(sf, 节点, /, *, 左起丷右起):
        '节点{深度} -> 讫浅路径乚节点/浅路径乚节点{深度,左起丷右起}'
    ######################
    #now:采用外翻设计:see:构造冫路径巛路径乚更深树扌
    #@abstractmethod
    #def 构造冫路径巛扁索引乚更深节点扌(sf, 扁索引乚更深节点, 路径乚节点, /):
    #    '扁索引乚更深节点{深度,左起丷右起} -> 路径乚节点{深度,左起丷右起} -> 路径乚更深节点{深度,左起丷右起}/路径乚节点{深度+1,左起丷右起}'
    ######################
    @abstractmethod
    def 构造冫浅路径巛扁索引乚更深节点扌(sf, 扁索引乚更深节点, /, *, 深度, 左起丷右起):
        '扁索引乚更深节点{深度,左起丷右起} -> 浅路径乚节点/浅路径乚更深节点{深度,左起丷右起}'
        #采用外翻设计:goto
    @abstractmethod
    def 构造冫浅路径巛扁索引乚元素封包节点扌(sf, 扁索引乚元素封包节点, /, *, 左起丷右起):
        '扁索引乚元素封包节点{左起丷右起} -> 浅路径乚节点{深度:=0,左起丷右起}/浅路径乚元素封包节点{左起丷右起}'
        #采用外翻设计:goto
    def 构造冫浅路径巛扁索引乚节点扌(sf, 扁索引乚节点, /, *, 深度, 左起丷右起):
        '扁索引乚节点{深度,左起丷右起} -> 浅路径乚节点{深度,左起丷右起}'
        if 深度 == 0:
            #元素封包节点
            扁索引乚元素封包节点 = 扁索引乚节点
            浅路径乚节点 = sf.构造冫浅路径巛扁索引乚元素封包节点扌(扁索引乚元素封包节点, 左起丷右起=左起丷右起)
        else:
            #更深节点
            扁索引乚更深节点 = 扁索引乚节点
            深度 -= 1
            浅路径乚节点 = sf.构造冫浅路径巛扁索引乚更深节点扌(扁索引乚更深节点, 深度=深度, 左起丷右起=左起丷右起)
        return 浅路径乚节点
class 魖浅包装器纟浅路径乚节点(魖浅包装器):
    '浅路径乚节点{深度,左起丷右起}'
    __slots__ = ()
    #@property
    #@abstractmethod
    #def 匞纟浅包装器(sf, /):
    #    '-> 魖匞纟浅包装器纟浅路径乚节点'






class 魖浅包装器纟路径乚展翅树(ABC):
    '路径乚展翅树{深度,左起丷右起}'
    __slots__ = ()
    #分裂扌
    #索引扌
    #定位扌
    #更换扌
    #反转扌
    @property
    @abstractmethod
    def 匞纟浅包装器纟路径乚展翅树(sf, /):
        '-> 魖匞纟浅包装器纟路径乚展翅树'

    @property
    @abstractmethod
    def 深度(sf, /):
        '-> 深度/uint'
    @property
    @abstractmethod
    def 左起丷右起(sf, /):
        '-> bool'

    @abstractmethod
    def 欤相等纟同向性路径扌(sf, ot, /):
        '路径{深度,左起丷右起} -> 路径{深度,左起丷右起} -> bool'
    @abstractmethod
    def 欤相等纟异向性路径乚特定树扌(sf, ot, 展翅树, /):
        '路径{深度,左起丷右起} -> 路径{深度,not 左起丷右起} -> 展翅树{深度} -> bool'
    @abstractmethod
    def 欤起路径乚特定树扌(sf, 展翅树, /):
        '-> bool'
    @abstractmethod
    def 欤讫路径乚特定树扌(sf, 展翅树, /):
        '-> bool'
    @abstractmethod
    def 欤内路径乚特定树扌(sf, 展翅树, /):
        '-> bool #非起讫'

    @abstractmethod
    def 换向冫路径乚特定树扌(sf, 展翅树, /):
        '路径{深度,左起丷右起} -> 路径{深度,not 左起丷右起}'

######################
######################
######################
class 魖匞含节点数(ABC):
    '匞含节点数=>魖含节点数'
    __slots__ = ()
    @property
    @abstractmethod
    def 节点数乊最大(sf, /):
        '-> 节点数/长度/uint'
    @property
    @abstractmethod
    def 节点数乊最小(sf, /):
        '-> 节点数/长度/uint'
######################
class 魖匞含节点数纟更深节点(魖匞含节点数):
    '匞含节点数纟更深节点=>魖匞纟浅包装器纟节点'
    __slots__ = ()
    @property
    @abstractmethod
    def 节点数乊最优(sf, /):
        '-> 节点数/长度/uint #=>下沉冫相邻双翼纟异树扌'
######################
class 魖匞纟浅包装器纟节点(ABC):
    '匞纟浅包装器纟节点'
    __slots__ = ()
    @property
    @abstractmethod
    def 匞含节点数纟更深节点(sf, /):
        '-> 魖匞含节点数纟更深节点'
    @abstractmethod
    def 构造冫元素封包节点扌(sf, 元素, /):
        '-> 元素封包节点/节点{深度:=0}'
    @abstractmethod
    def 构造冫更深节点扌(sf, 节点序列, /, *, 深度, 左起丷右起):
        '(Iter 节点{深度}){左起丷右起} -> 更深节点{深度}/节点{深度+1}'
######################
######################
class 魖匞纟浅包装器纟翅膀(ABC):
    '匞纟浅包装器纟翅膀'
    __slots__ = ()

    @abstractmethod
    def 构造冫左翼扌(sf, 节点序列, /, *, 深度, 左起丷右起):
        '(Iter 节点{深度}){左起丷右起} -> 左翼{深度}'
    @abstractmethod
    def 构造冫右翼扌(sf, 节点序列, /, *, 深度, 左起丷右起):
        '(Iter 节点{深度}){左起丷右起} -> 右翼{深度}'

    def 构造冫翅膀扌(sf, 节点序列, /, *, 深度, 左起丷右起, 左翼丷右翼):
        '(Iter 节点{深度}){左起丷右起} -> 翅膀{深度,左翼丷右翼}'
        构造扌 = sf.构造冫左翼扌 if not 左翼丷右翼 else sf.构造冫右翼扌
        return 构造扌(节点序列, 深度=深度, 左起丷右起=左起丷右起)

######################
######################
class 魖匞纟浅包装器纟展翅树(ABC):
    '匞纟浅包装器纟展翅树=>魖浅包装器纟展翅树'
    __slots__ = ()
    @property
    @abstractmethod
    def 匞纟浅包装器纟节点(sf, /):
        '-> 魖匞纟浅包装器纟节点'
    @property
    @abstractmethod
    def 匞纟浅包装器纟翅膀(sf, /):
        '-> 魖匞纟浅包装器纟翅膀'
    @property
    def 匞含节点数纟更深节点(sf, /):
        '-> 魖匞含节点数纟更深节点'
        # #=>下沉冫相邻双翼纟异树扌
        return sf.匞纟浅包装器纟节点.匞含节点数纟更深节点
    #@property
    #def 节点数乊最优(sf, /):
    #    '-> 节点数/长度/uint #=>下沉冫相邻双翼纟异树扌'
    #    return sf.匞纟浅包装器纟节点.匞含节点数纟更深节点.节点数乊最优

    @abstractmethod
    def 构造冫空树扌(sf, /, *, 深度):
        '-> 光杆树{深度,高度:=0,长度:=0}'
    @abstractmethod
    def 罓构造冫根深树扌(sf, 左翼, 更深树, 右翼, /):
        '-> 根深树'
    def 构造冫根深树扌(sf, 起翼, 更深树, 讫翼, /, *, 左起丷右起):
        '-> 根深树'
        return sf.罓构造冫根深树扌(*_重定次序扌(起翼, 更深树, 讫翼, 左起丷右起=左起丷右起))
    #@abstractmethod
    def 构造冫展翅树扌(sf, 节点序列, /, *, 深度, 左起丷右起):
        '(Iter 节点{深度}){左起丷右起} -> 展翅树{深度,高度:=??,长度:=??}'
        左端丷右端 = not 左起丷右起
        树 = sf.构造冫空树扌(深度=深度)
        树 = 树.连续压入扌(节点序列, 左端右起丷右端左起=左端丷右端)
        return 树


######################
######################
######################
######################
######################
######################
######################
######################
class 魖含度量(ABC):
    __slots__ = ()
    @property
    @abstractmethod
    def 度量值(sf, /):
        '-> 度量值'
######################
class 魖含扁索引方法(魖含度量):
    '=>节点(含:元素封包节点(子部件:单)),翅膀,展翅树(含:根深树(子部件:多态))'
    #魖浅包装器纟节点:goto
    #魖浅包装器纟翅膀:goto
    #魖浅包装器纟展翅树:goto
    #命名规范:索引纟元素匕容器vs索引乚容器
    __slots__ = ()
    @property
    @abstractmethod
    def 子部件数(sf, /):
        '-> 子部件数/uint'
        #不一定 等同于 节点数
        #   元素封包节点:没有 子节点
        #   根深树: 子节点:节点数 无上限
        #   [元素封包节点.子部件数===1]
        #   [根深树.子部件数===3]
    @abstractmethod
    def 欤讫扁索引乚本容器扌(sf, 扁索引乚本容器, /, *, 左起丷右起):
        '-> bool #用于区分:扁索引乚本容器:扁索引乊子纟本容器vs讫扁索引乚本容器'
    @abstractmethod
    def 欤起扁索引乚本容器扌(sf, 扁索引乚本容器, /, *, 左起丷右起):
        '-> bool'
    @abstractmethod
    def 分裂纟扁索引扌(sf, 扁索引乚本容器, /):
        '本容器{深度} -> 扁索引乚本容器{左起丷右起} -> (起半扇纟本容器{深度,左起丷右起}, 魊子部件乊中间{深度}, 讫半扇纟本容器{深度,左起丷右起})'
    @abstractmethod
    def 索引乚扁索引扌(sf, 扁索引乚本容器, /):
        '本容器{深度} -> 扁索引乚本容器{左起丷右起} -> 魊子部件乊中间{深度}'
        (起半扇纟本容器, 魊子部件乊中间, 讫半扇纟本容器) = sf.分裂纟扁索引扌(扁索引乚本容器)
        return 魊子部件乊中间
    @abstractmethod
    def 定位冫扁索引扌(sf, 度量名纟全序, 累计值纟初始, 累积扌, 欤前进扌, /, *, 左起丷右起, 欤已知冫前进乊起, 欤已知冫后退乊讫):
        '本容器{深度} -> 度量名纟全序 -> 累计值<全序> -> 累积扌/(累计值<全序> -> 度量<度量名纟全序> -> 累计值<全序>) -> 欤前进扌/(累计值<全序> -> 后退丷前进/bool) -> (扁索引乚本容器{左起丷右起}, 魊子部件{深度}) # 后置条件:[[子部件前后的判定状态分别是:(前进,后退)][子部件不存在==>>返回:讫索引乚本容器]] #前置条件: [起索引乚本容器的判定状态:前进]'
    @abstractmethod
    def 忄强求冫扁索引扌(sf, 位置纟节点, /, *, 左起丷右起):
        '本容器{深度} -> 位置纟子部件{深度}/uint -> 扁索引乚本容器{左起丷右起}'


######################
class 魖浅包装器纟半扇纟容器(ABC):
    '半扇纟容器{深度,左起丷右起}'
    #半扇纟节点
    #   半扇纟更深节点
    #   半扇纟元素封包节点
    #半扇纟翅膀
    #   半扇纟左翼
    #   半扇纟右翼
    #半扇纟展翅树
    #   半扇纟光杆树
    #   半扇纟根深树
    __slots__ = ()
    @property
    @abstractmethod
    def 左起丷右起(sf, /):
        '-> bool'
    @property
    @abstractmethod
    def 深度(sf, /):
        '-> 深度/uint'
######################
class 魖含节点数(魖含扁索引方法):
    __slots__ = ()
    @property
    @abstractmethod
    def 匞含节点数(sf, /):
        '-> 匞含节点数/魖匞含节点数'
    @property
    @abstractmethod
    def 节点数(sf, /):
        '-> 节点数/长度/uint'
    @property
    def 节点数乊最大(sf, /):
        '-> 节点数/长度/uint'
        return sf.匞含节点数.节点数乊最大
    @property
    def 节点数乊最小(sf, /):
        '-> 节点数<子节点>/长度/uint'
        return sf.匞含节点数.节点数乊最小
    @property
    def 欤临界满溢(sf, /):
        '-> bool'
        return sf.节点数 == sf.节点数乊最大
    @property
    def 欤临界缺补(sf, /):
        '-> bool'
        return sf.节点数 == sf.节点数乊最小
    @property
    @override
    def 子部件数(sf, /):
        '-> 子部件数/uint'
        return sf.节点数
######################
######################
class 魖浅包装器纟节点(魖含扁索引方法):
    '[节点{深度} =[def]=元素封包节点|更深节点]'
    __slots__ = ()

    @property
    @abstractmethod
    def 匞纟浅包装器纟节点(sf, /):
        '-> 魖匞纟浅包装器纟节点'
    #@property
    #@abstractmethod
    #def 深度(sf, /):
    #    '-> 深度/uint #[节点{深度:=0} =[def]= 元素封包节点][展翅树{深度}.节点 =[def]= 节点{深度}]'
    @property
    @abstractmethod
    def 欤更深节点(sf, /):
        '-> bool'
        #return not sf.深度

class 魖浅包装器纟元素封包节点(魖浅包装器纟节点):
    '元素封包节点'
    __slots__ = ()
    #@override
    欤更深节点 = False
    #@override
    子部件数 = 1
    @property
    @abstractmethod
    def 元素(sf, /):
        '-> 元素'

class 魖浅包装器纟更深节点(魖含节点数, 魖浅包装器纟节点):
    '更深节点{深度}'
    __slots__ = ()
    #@override
    欤更深节点 = True
    @abstractmethod
    def 枚举冫节点序列扌(sf, /, *, 左起丷右起):
        '更深节点{深度}/节点{深度+1} -> Iter 节点{深度}'
######################
class 魖浅包装器纟翅膀(魖含节点数, 魖含扁索引方法):
    '[翅膀{深度,左翼丷右翼}=[def]=左翼|右翼]'
    __slots__ = ()

    @property
    @abstractmethod
    def 匞纟浅包装器纟翅膀(sf, /):
        '-> 魖匞纟浅包装器纟翅膀'
    @property
    @abstractmethod
    def 左翼丷右翼(sf, /):
        '-> bool'
    @abstractmethod
    def 枚举冫节点序列扌(sf, /, *, 左起丷右起):
        '翅膀{深度,左翼丷右翼} -> Iter 节点{深度}'
    @abstractmethod
    def 同端压入纟翅膀扌(sf, 节点纟入, /):
        '翅膀{深度,左翼丷右翼} -> 节点{深度} -> (翅膀{深度,左翼丷右翼}, 鬽更深节点纟出)'
    @abstractmethod
    def 同端弹出纟翅膀乊足员扌(sf, /):
        '翅膀{深度,左翼丷右翼} -> (翅膀{深度,左翼丷右翼}, 节点纟出)'
    @abstractmethod
    def 同端弹出纟翅膀乊临界缺补扌(sf, 更深节点纟入, /):
        '翅膀{深度,左翼丷右翼} -> 更深节点纟入{深度}/节点{深度+1} -> (翅膀{深度,左翼丷右翼}, 节点纟出)'
class 魖浅包装器纟左翼(魖浅包装器纟翅膀):
    '左翼{深度}'
    __slots__ = ()
    左翼丷右翼 = False
class 魖浅包装器纟右翼(魖浅包装器纟翅膀):
    '右翼{深度}'
    __slots__ = ()
    左翼丷右翼 = True
######################
class 魖浅包装器纟展翅树(魖含扁索引方法):
    '[展翅树{深度,高度,长度}=[def]=光杆树|根深树]'
    __slots__ = ()

    @property
    @abstractmethod
    def 匞纟浅包装器纟展翅树(sf, /):
        '-> 魖匞纟浅包装器纟展翅树'
    @property
    @abstractmethod
    def 欤空树(sf, /):
        '-> bool'
    @property
    @abstractmethod
    def 欤光杆(sf, /):
        '-> bool'
    @property
    @abstractmethod
    def 深度(sf, /):
        '-> 深度/uint #[节点{深度:=0} =[def]= 元素封包节点][展翅树{深度}.节点 =[def]= 节点{深度}]'
    @property
    @abstractmethod
    def 冃更深树(sf, /):
        '-> 更深树/魖浅包装器纟更深树'
    ######################
    ######################
    # [:取消冫高度纟树]:goto
    ######################
    #@property
    #@abstractmethod
    #def 高度(sf, /):
    #    '-> 高度/uint # [展翅树{高度:=0} =[def]= 光杆树]'
    ######################
    ######################
    # [:取消冫长度纟树]:goto
    ######################
    #@property
    #@abstractmethod
    #def 长度(sf, /):
    #    '-> 长度/uint # 节点数<节点{深度}>'
    ######################
    ######################
    @abstractmethod
    def 枚举冫节点序列扌(sf, /, *, 左起丷右起):
        '展翅树{深度} -> Iter 节点{深度}'
    @abstractmethod
    def 罓压入扌(sf, 节点纟入, /, *, 左端丷右端):
        '展翅树{深度} -> 节点{深度} -> (欤增高/bool, 满溢层数/uint, 展翅树{深度,??高度??})'
    @abstractmethod
    def 罓弹出扌(sf, /, *, 左端丷右端):
        '非空 展翅树{深度} -> (欤降高/bool, 缺补层数/uint, 展翅树{深度,??高度??}, 节点{深度})'
    @abstractmethod
    def 罓合并扌(sf, 节点数纟节点序列, 节点序列, ot, /, *, 左起丷右起):
        '起树/展翅树{深度} -> 节点数{节点序列} -> 节点序列{深度,左起丷右起} -> 讫树/展翅树{深度} -> 展翅树{深度}'
        #'展翅树{深度,??高度甲??} -> 展翅树{深度,??高度乙??} -> 展翅树{深度,??高度丙??}'
        #'展翅树{深度,??高度甲??} -> 展翅树{深度,??高度乙??} -> (展翅树{深度,??高度丙??}, 路径乚展翅树)'
    if 0:
        #移动到:魖浅包装器纟路径乚展翅树:goto
        @abstractmethod
        def 分裂扌(sf, 路径乚展翅树, /):
            '展翅树{深度,??高度甲??} -> 路径乚展翅树 -> (展翅树{深度,??高度乙??}, 展翅树{深度,??高度丙??})'
        @abstractmethod
        def 索引扌(sf, 路径乚展翅树, 深度纟节点纟出, /):
            #bug:采用外翻设计:goto
            '展翅树{深度} -> 路径乚展翅树 -> 深度纟节点纟出 -> 鬽 (路径乚展翅树乊剩余,节点纟出{深度纟节点纟出})'
        @abstractmethod
        def 定位扌(sf, 度量名纟全序, 累计值纟初始, 累积扌, 欤前进扌, /, *, 左起丷右起):
            '展翅树{深度} -> 度量名纟全序 -> 累计值<全序> -> 累积扌/(累计值<全序> -> 度量<度量名纟全序> -> 累计值<全序>) -> 欤前进扌/(累计值<全序> -> 后退丷前进/bool) -> (路径乚展翅树{深度}, 魊节点{深度})'
        @abstractmethod
        def 忄强求冫路径乚展翅树扌(sf, 位置纟节点, /, *, 左起丷右起):
            '展翅树{深度} -> 位置纟节点{深度}/uint -> 路径乚展翅树{深度}'

    ######################
    ######################
    #异端压弹:先压入后弹出
    #同端弹压:先弹出后压入
    #@abstractmethod
    def 异端压弹扌(sf, 节点纟入, /, *, 左出丷右出):
        '展翅树{深度} -> 节点{深度} -> (展翅树{深度,??高度??}, 节点{深度})'
        if not sf.欤空树:
            sf = sf.压入扌(节点纟入, 左端丷右端=not 左出丷右出)
            (sf, 欤弹出, 节点纟出) = sf.弹出扌(_槑节点纟死, 左端丷右端=左出丷右出)
        return sf, 节点纟出
    #@abstractmethod
    def 同端弹压扌(sf, 槑节点纟出, 节点纟入, /, *, 左端丷右端):
        '展翅树{深度} -> 槑节点纟出/(() -> 节点{深度}) -> 节点{深度} -> (展翅树{深度,??高度??}, 欤弹出/bool, 节点{深度})'
        (sf, 欤弹出, 节点纟出) = sf.弹出扌(槑节点纟出, 左端丷右端=左端丷右端)
        sf = sf.压入扌(节点纟入, 左端丷右端=左端丷右端)
        return sf, 欤弹出, 节点纟出
    #@abstractmethod
    def 连续压入扌(sf, 节点序列, /, *, 左端右起丷右端左起):
        '展翅树{深度} -> 节点序列{深度,左起丷右起=not 左端丷右端} -> 展翅树{深度,??高度??}'
        左端丷右端 = 左端右起丷右端左起
        左起丷右起 = not 左端右起丷右端左起
        树 = sf
        for 节点 in 节点序列:
            树 = 树.压入扌(节点, 左端丷右端=左端丷右端)
        return 树

    #@abstractmethod
    def 压入扌(sf, 节点纟入, /, *, 左端丷右端):
        '展翅树{深度} -> 节点{深度} -> 展翅树{深度,??高度??}'
        (欤增高, 满溢层数, sf) = sf.罓压入扌(节点纟入, 左端丷右端=左端丷右端)
        return sf
    #@abstractmethod
    def 弹出扌(sf, 槑节点纟出, /, *, 左端丷右端):
        '展翅树{深度} -> 槑节点纟出/(() -> 节点{深度}) -> (展翅树{深度,??高度??}, 欤弹出/bool, 节点{深度})'
        if sf.欤空树:
            return (sf, 欤弹出:=False, 槑节点纟出())
        (欤降高, 缺补层数, sf, 节点纟出) = sf.罓弹出扌(左端丷右端=左端丷右端)
        return (sf, 欤弹出:=True, 节点纟出)
    #@abstractmethod
    def 合并扌(sf, ot, /, *, 起讫丷讫起):
        '展翅树{深度,??高度甲??} -> 展翅树{深度,??高度乙??} -> 展翅树{深度,??高度丙??}'
        #'展翅树{深度,??高度甲??} -> 展翅树{深度,??高度乙??} -> (展翅树{深度,??高度丙??}, 路径乚展翅树)'
        sf, ot = _重定次序扌(sf, ot, 左起丷右起=起讫丷讫起)
        return sf.罓合并扌(0, null_iter, ot, 左起丷右起=False)
    ######################
    ######################
######################

class 魖浅包装器纟光杆树(魖含节点数, 魖浅包装器纟展翅树):
    '光杆树{深度,长度}'
    __slots__ = ()
    #@override
    欤光杆 = True
    #@override
    节点数乊最小 = 0
    @override
    def 罓合并扌(sf, 节点数纟节点序列, 节点序列, ot, /, *, 左起丷右起):
        '起树/展翅树{深度} -> 节点数{节点序列} -> 节点序列{深度,左起丷右起} -> 讫树/展翅树{深度} -> 展翅树{深度}'
        起讫丷讫起 = ot.欤光杆 and ot.节点数 < sf.节点数
            #欤交换
        if 起讫丷讫起:
            sf, ot = ot, sf
        return sf.合并乊大树扌(节点数纟节点序列, 节点序列, ot, 起讫丷讫起=起讫丷讫起, 左起丷右起=左起丷右起)
    #@abstractmethod
    def 合并乊大树扌(sf, 节点数纟节点序列, 节点序列, ot, /, *, 起讫丷讫起, 左起丷右起):
        '小树/光杆树{深度} -> 节点数{节点序列} -> 节点序列{深度,左起丷右起} -> 大树/展翅树{深度} -> 展翅树{深度}'
        assert not (ot.欤光杆 and ot.节点数 < sf.节点数)
        check_type_is(bool, 左起丷右起)
        左端丷右端纟大树 = 欤交换 = 起讫丷讫起
            # ot/大树:左端丷右端
        左起丷右起纟节点序列 = 左起丷右起
            #节点序列
        左起丷右起纟小树 = not 左端丷右端纟大树
            # sf/小树:左起丷右起
        if not 左起丷右起纟节点序列 is 左起丷右起纟小树:
            节点序列 = _反转枚举扌(节点序列)
            左起丷右起纟节点序列 = 左起丷右起纟小树
        assert 左起丷右起纟节点序列 is 左起丷右起纟小树
        ot = ot.连续压入扌(节点序列, 左端右起丷右端左起=左端丷右端纟大树)
        节点序列 = sf.枚举冫节点序列扌(左起丷右起=左起丷右起纟小树)
        ot = ot.连续压入扌(节点序列, 左端右起丷右端左起=左端丷右端纟大树)
        return ot
        #路径乚展翅树 = 树.忄强求冫路径乚展翅树扌(树, 位置:=sf.节点数, 左起丷右起=左端丷右端)
        #return (树, 路径乚展翅树)
def _反转枚举扌(节点序列, /):
    'O(n)'
    try:
        return reversed(节点序列)
    except TypeError:
        pass
    节点序列 = [*节点序列]
    return reversed(节点序列)


class 魖浅包装器纟更深树(ABC):
    '更深树{深度,高度,长度}'
    __slots__ = ()
    @property
    @abstractmethod
    def 冃展翅树(sf, /):
        '-> 展翅树/魖浅包装器纟展翅树'
class 魖浅包装器纟根深树(魖浅包装器纟展翅树):
    '根深树{深度,高度,长度}'
    __slots__ = ()
    #@override
    欤光杆 = False
    #@override
    欤空树 = False
    #@override
    子部件数 = 3

    @abstractmethod
    def 罓拆包冫根深树扌(sf, /):
        '-> (左翼, 更深树, 右翼)'
    @abstractmethod
    def 罓弹出乊临界缺补乊空心双翼扌(sf, /, *, 左端丷右端):
        '空心 根深树{深度} -> (欤降高/bool, 缺补层数/uint, 展翅树{深度,??高度??}, 节点{深度})'
    #@abstractmethod
    def 下沉冫相邻双翼纟异树扌(sf, 讫翼纟起树, 节点数纟节点序列, 节点序列, 起翼纟讫树, /, *, 左起丷右起):
        '-> (更深节点数, 更深节点序列)'
        匞含节点数纟更深节点 = sf.匞含节点数纟更深节点
        节点数乊最优 = 匞含节点数纟更深节点.节点数乊最优
        节点数乊最小 = 匞含节点数纟更深节点.节点数乊最小
        ######################
        sz0 = 讫翼纟起树.节点数
        sz1 = 节点数纟节点序列
        sz2 = 起翼纟讫树.节点数
        sz = sz0 + sz1 + sz2

        ######################
        it0 = 讫翼纟起树.枚举冫节点序列扌(左起丷右起=左起丷右起)
        it1 = iter(节点序列)
        it2 = 起翼纟讫树.枚举冫节点序列扌(左起丷右起=左起丷右起)
        it = chain(it0, it1, it2)
        ######################
        sz, it
        ######################
        d = 节点数乊最优
        q, r = divmod(sz, d)
        if r < 节点数乊最小:
            assert q > 0
                # <<== 要求: [节点数纟左翼+节点数纟右翼 >= 节点数乊最小]
            q -= 1
            r += d
                # <<== 要求: [节点数乊最小+节点数乊最优 < 节点数乊最大]
        assert q >= 0
        assert 节点数乊最小 <= r <= 匞含节点数纟更深节点.节点数乊最大
        ######################
        q, d, r, it
        ######################
        for n in chain(repeat(d, q), [r]):
            yield 构造冫更深节点扌(节点序列:=islice(it, n), 深度=sf.深度, 左起丷右起=左起丷右起)
        return



    def 拆包冫根深树扌(sf, /, *, 左起丷右起):
        '-> (起翼, 更深树, 讫翼)'
        return _重定次序扌(sf.罓拆包冫根深树扌(), 左起丷右起=左起丷右起)


    @override
    def 枚举冫节点序列扌(sf, /, *, 左起丷右起):
        '展翅树{深度} -> Iter 节点{深度}'
        (起翼, 更深树, 讫翼) = sf.拆包冫根深树扌(左起丷右起=左起丷右起)
        yield from 起翼.枚举冫节点序列扌(左起丷右起=左起丷右起)
        for 更深节点 in 更深树.冃展翅树.枚举冫节点序列扌(左起丷右起=左起丷右起):
            yield from 更深节点.枚举冫节点序列扌(左起丷右起=左起丷右起)
        yield from 讫翼.枚举冫节点序列扌(左起丷右起=左起丷右起)
    @override
    def 罓压入扌(sf, 节点纟入, /, *, 左端丷右端):
        '展翅树{深度} -> 节点{深度} -> (欤增高/bool, 满溢层数/uint, 展翅树{深度,??高度??})'
        左起丷右起 = 左端丷右端
        (起翼, 更深树, 讫翼) = sf.拆包冫根深树扌(左起丷右起=左起丷右起)
        (起翼, 鬽更深节点纟出) = 起翼.同端压入纟翅膀扌(节点纟入)
        if not 鬽更深节点纟出 is None:
            更深节点纟入 = 鬽更深节点纟出
            (欤增高, 满溢层数, 展翅树) = 更深树.冃展翅树.罓压入扌(更深节点纟入, 左端丷右端=左端丷右端)
            更深树 = 展翅树.冃更深树
            满溢层数 += 1
            欤增高
        else:
            更深树
            满溢层数 = 0
            欤增高 = False
        根深树 = 构造冫根深树扌(起翼, 更深树, 讫翼, 左起丷右起=左起丷右起)
        return (欤增高, 满溢层数, 根深树)
    @override
    def 罓弹出扌(sf, /, *, 左端丷右端):
        '非空 展翅树{深度} -> (欤降高/bool, 缺补层数/uint, 展翅树{深度,??高度??}, 节点{深度})'
        左起丷右起 = 左端丷右端
        (起翼, 更深树, 讫翼) = sf.拆包冫根深树扌(左起丷右起=左起丷右起)
        if 起翼.欤临界缺补:
            if 更深树.冃展翅树.欤空树:
                return sf.罓弹出乊临界缺补乊空心双翼扌(左端丷右端=左端丷右端)
            (欤降高, 缺补层数, 中树, 更深节点纟出) = 更深树.冃展翅树.罓弹出扌(左端丷右端=左端丷右端)
            更深树 = 中树.冃更深树
            (起翼, 节点纟出) = 起翼.同端弹出纟翅膀乊临界缺补扌(更深节点纟入:=更深节点纟出)
            节点纟出, 起翼, 更深树
            欤降高
            缺补层数 += 1
        else:
            (起翼, 节点纟出) = 起翼.同端弹出纟翅膀乊足员扌()
            欤降高 = False
            缺补层数 = 0
        根深树 = 构造冫根深树扌(起翼, 更深树, 讫翼, 左起丷右起=左起丷右起)
        return (欤降高, 缺补层数, 根深树, 节点纟出)
    @override
    def 罓合并扌(sf, 节点数纟节点序列, 节点序列, ot, /, *, 左起丷右起):
        '起树/展翅树{深度} -> 节点数{节点序列} -> 节点序列{深度,左起丷右起} -> 讫树/展翅树{深度} -> 展翅树{深度}'
        if ot.欤光杆:
            return ot.合并乊大树扌(节点数纟节点序列, 节点序列, sf, 起讫丷讫起=True)
        (起翼纟起树, 更深树纟起树, 讫翼纟起树) = sf.拆包冫根深树扌(左起丷右起=左起丷右起)
        (起翼纟讫树, 更深树纟讫树, 讫翼纟讫树) = ot.拆包冫根深树扌(左起丷右起=左起丷右起)
        (更深节点数, 更深节点序列) = sf.下沉冫相邻双翼纟异树扌(讫翼纟起树, 节点数纟节点序列, 节点序列, 起翼纟讫树, 左起丷右起=左起丷右起)
        更深树纟中间 = 更深树纟起树.冃展翅树.罓合并扌(节点数纟节点序列, 节点序列, 更深树纟讫树, 左起丷右起=左起丷右起).冃更深树
        根深树 = 构造冫根深树扌(起翼纟起树, 更深树纟中间, 讫翼纟讫树, 左起丷右起=左起丷右起)
        return 根深树

魖匞纟浅包装器纟路径乚展翅树
魖匞纟浅包装器纟浅路径乚翅膀
魖匞纟浅包装器纟浅路径乚节点

魖匞含节点数
魖匞含节点数纟更深节点

魖匞纟浅包装器纟节点
魖匞纟浅包装器纟翅膀
魖匞纟浅包装器纟展翅树

魖含度量
魖含扁索引方法
魖浅包装器纟半扇纟容器
魖含节点数

魖匞纟浅包装器纟路径乚展翅树
魖匞纟浅包装器纟浅路径乚翅膀
魖匞纟浅包装器纟浅路径乚节点
魖浅包装器纟路径乚展翅树
魖浅包装器纟浅路径乚翅膀
魖浅包装器纟浅路径乚节点

魖匞纟浅包装器纟节点
魖浅包装器纟节点
魖浅包装器纟元素封包节点
魖浅包装器纟更深节点

魖匞纟浅包装器纟翅膀
魖浅包装器纟翅膀
魖浅包装器纟左翼
魖浅包装器纟右翼

魖匞纟浅包装器纟展翅树
魖浅包装器纟展翅树
魖浅包装器纟光杆树
魖浅包装器纟根深树

魖浅包装器纟更深树


魖匞纟浅包装器纟半扇纟节点
魖匞纟浅包装器纟半扇纟翅膀
魖匞纟浅包装器纟半扇纟展翅树

魖浅包装器纟半扇纟容器
魖浅包装器纟半扇纟节点
魖浅包装器纟半扇纟翅膀
魖浅包装器纟半扇纟展翅树
    #半扇纟节点(节点, 扁索引乚节点{深度,左起丷右起}, 起半扇丷讫半扇)
    #半扇纟翅膀(翅膀, 浅路径乚翅膀/扁索引乚翅膀{深度,左翼丷右翼,左起丷右起}, 起半扇丷讫半扇)
    #xxx:半扇纟展翅树(展翅树, 路径乚展翅树{深度,左起丷右起}, 起半扇丷讫半扇)
    #半扇纟光杆树(光杆树, 路径乚展翅树/扁索引乚光杆树{深度,左起丷右起}, 起半扇丷讫半扇)
    #半扇纟根深树(根深树, ???, 起半扇丷讫半扇)
__all__
from seed.data_funcs.finger_tree3.bases import *
