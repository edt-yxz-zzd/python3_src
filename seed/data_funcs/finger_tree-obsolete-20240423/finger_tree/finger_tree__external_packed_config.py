#__all__:goto
#所有 定义 先看:finger_tree_common.py
#   例如:命名解释
#魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程:goto
#具名参数囗囗定义:goto
#魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程囗囗囗囗基础:goto
r'''[[[
e ../../python3_src/seed/data_funcs/finger_tree/finger_tree__external_packed_config.py
see first:
    view ../../python3_src/seed/data_funcs/finger_tree/finger_tree_common.py

seed.data_funcs.finger_tree.finger_tree__external_packed_config
py -m nn_ns.app.debug_cmd   seed.data_funcs.finger_tree.finger_tree__external_packed_config -x
py -m nn_ns.app.doctest_cmd seed.data_funcs.finger_tree.finger_tree__external_packed_config:__doc__ --ndiff -ff -v
py_adhoc_call   seed.data_funcs.finger_tree.finger_tree__external_packed_config   @f
py_adhoc_call  seed.helper.print_methods  @wrapped_print_methods   %seed.data_funcs.finger_tree.finger_tree__external_packed_config:XXX@T    =T      ++exclude_prefixes:_


py_adhoc_call  seed.helper.print_methods  @wrapped_print_methods   %seed.data_funcs.finger_tree.finger_tree__external_packed_config:魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程囗囗囗囗基础囗无优化@T    =T       +exclude_attrs5listed_in_cls_doc

py_adhoc_call  seed.helper.print_methods  @wrapped_print_methods   %seed.data_funcs.finger_tree.finger_tree__external_packed_config:魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程囗囗囗囗基础@T    =T       +exclude_attrs5listed_in_cls_doc


py_adhoc_call  seed.helper.print_methods  @wrapped_print_methods   %seed.data_funcs.finger_tree.finger_tree__external_packed_config:魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程囗囗囗囗固化方法@T    =T       +exclude_attrs5listed_in_cls_doc

py_adhoc_call  seed.helper.print_methods  @wrapped_print_methods   %seed.data_funcs.finger_tree.finger_tree__external_packed_config:魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程囗囗囗囗部分可优化方法缺省具现囗囗下沉囗异心双翼@T    =T       +exclude_attrs5listed_in_cls_doc

py_adhoc_call  seed.helper.print_methods  @wrapped_print_methods   %seed.data_funcs.finger_tree.finger_tree__external_packed_config:魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程@T    =T       +exclude_attrs5listed_in_cls_doc


#]]]'''
#now:export to finger_tree__EPC5PL.py###not:export:魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程囗囗囗囗基础囗无优化
__all__ = r'''
魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程囗囗囗囗基础囗无优化
    魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程囗囗囗囗基础
        魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程囗囗囗囗固化方法
            魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程囗囗囗囗部分可优化方法缺省具现囗囗下沉囗异心双翼
            魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程

转化为囗魊累积囗巛丨丮累积囗丶退进决断囗丶已知初始累计值决断进厈囗
'''.split()#'''
    #魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程囗囗囗囗基础囗无优化
    #is4bool_
    #xor4bool_
    #overrideable
__all__



from seed.data_funcs.finger_tree.finger_tree_common import 错误囗囗空树囗囗光杆树
from seed.data_funcs.finger_tree.finger_tree_common import 翅膀囗绝对定位巛相对定位囗
from seed.data_funcs.finger_tree.finger_tree_common import 半扇囗绝对定位巛相对定位囗
from seed.data_funcs.finger_tree.finger_tree_common import is4bool_
from seed.data_funcs.finger_tree.finger_tree_common import 错误
from seed.abc.abc__ver1 import abstractmethod, override, ABC, ABC__no_slots
from itertools import repeat, islice, chain
from seed.tiny_.check import check_int_ge
from seed.tiny import check_type_is
from seed.tiny import null_tuple, null_iter
from seed.tiny import chains
from seed.mapping_tools.key_as_attr import key_as_attr
from seed.tiny import echo, curry1
import operator as opss

from seed.tiny import print_err


__all__
#class 魖双侧展翅树囗数据类型配置囗囗显式参数列举式囗囗面向适配底层数据类型(ABC):
    #底层接口冖冖某某某
#class 魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程(ABC):
    #外参接口冖冖某某某(..., 参数配置=???)
#class 魖双侧展翅树囗数据类型配置囗囗隐式参数囗囗面向树子类设计者囗囗节点版(ABC):
    #内参接口冖冖某某某<参数配置>(...)
    #元素版内参接口冖冖某某某
#class 魖双侧展翅树囗相关操作囗囗面向树实例终端用户囗囗元素版(ABC):
    #某某某#元素版
#
__all__

######################
def _gets(kw, nms__str, /):
    return {nm:kw[nm] for nm in nms__str.split()}
######################
def _to_kw2(kw, /):
    return _gets(kw, '参数配置 深度')
######################
def _to_kw3(kw, /):
    return _gets(kw, '左起丷右起  参数配置 深度')
######################
def _to_kw3A(kw, /):
    return _gets(kw, '左翼丷右翼  左起丷右起  参数配置 深度')
######################
def _to_kwA(kw, /):
    return _gets(kw, '左翼丷右翼  参数配置 深度')
######################
def _to_kwm__kw3(kw, /):
    '_to_kwm__kw3(locals())'
    return _gets(kw, '是否需囗焦点居前囗起半扇  是否需囗焦点诸后囗讫半扇  是否需囗焦点  是否需囗焦点居后囗讫半扇  左起丷右起  参数配置  深度')
######################
_to_kw2, _to_kw3, _to_kwm__kw3
######################
######################
def _调整次序囗(*args, 左起丷右起):
    check_type_is(bool, 左起丷右起)
    if 左起丷右起:
        args = args[::-1]
    return args
######################
def _更深囗(kw, /):
    kw = {**kw}
    kw['深度'] += 1
    return kw
######################
def _惰魊若囗(是否需囗值, 惰值囗, /):
    if 是否需囗值:
        return (惰值囗(),)
    return null_tuple
######################
def _魊若囗(是否需囗值, 值, /):
    if 是否需囗值:
        return (值,)
    return null_tuple
######################
def _魊变囗(f, tmay, /, *args, **kwds):
    if tmay:
        [x] = tmay
        y = f(x, *args, **kwds)
        return (y,)
    return null_tuple
######################
_调整次序囗, _更深囗, _魊若囗, _魊变囗
######################
######################
def _翅膀次序绝对化囗(kwds, /, **kw):
    'eg: kw4 --> kwA'
    return __翅膀次序绝对化囗(**kwds, **kw)
def __翅膀次序绝对化囗(*, 起翼丷讫翼, 左起丷右起, **kwds):
    左翼丷右翼 = 翅膀囗绝对定位巛相对定位囗(左起丷右起=左起丷右起, 起翼丷讫翼=起翼丷讫翼)
    return dict(左翼丷右翼=左翼丷右翼, **kwds)
    #左翼, 右翼 = _调整次序囗(起翼, 讫翼, 左起丷右起=左端丷右端)
######################
def _半扇次序绝对化囗(kwds, /, **kw):
    'eg: kw4g --> kwAg'
    return __半扇次序绝对化囗(**kwds, **kw)
def __半扇次序绝对化囗(*, 起半扇丷讫半扇, 左起丷右起, **kwds):
    左半扇丷右半扇 = 半扇囗绝对定位巛相对定位囗(左起丷右起=左起丷右起, 起半扇丷讫半扇=起半扇丷讫半扇)
    return dict(左半扇丷右半扇=左半扇丷右半扇, **kwds)

######################
def _外参接口冖冖分流囗囗节点形态囗(sf, 针对囗元素封包节点囗, 针对囗更深节点囗, 节点, /, *args, 参数配置, 深度, **kwds):
    check_int_ge(0, 深度)
    (_订正深度囗, f) = (echo, 针对囗元素封包节点囗) if 深度 == 0 else ((-1).__add__, 针对囗更深节点囗)
    return f(节点, *args, 参数配置=参数配置, 深度=_订正深度囗(深度), **kwds)
    #bug: !! [节点<深度+1> === 更深节点<深度>]
    f = 针对囗元素封包节点囗 if 深度 == 0 else 针对囗更深节点囗
    return f(节点, *args, 参数配置=参数配置, 深度=深度, **kwds)
######################
def _外参接口冖冖分流囗囗树形态囗(sf, 针对囗光杆树囗, 针对囗根深树囗, 双侧展翅树, /, *args, 参数配置, 深度, **kwds):
    光杆树丷根深树 = sf.外参接口冖冖区分树形态囗(双侧展翅树, 参数配置=参数配置, 深度=深度)
    if 光杆树丷根深树 is False:
        光杆树 = 双侧展翅树
        f = 针对囗光杆树囗
    elif 光杆树丷根深树 is True:
        根深树 = 双侧展翅树
        f = 针对囗根深树囗
    else:
        raise 000
    return f(双侧展翅树, *args, 参数配置=参数配置, 深度=深度, **kwds)
######################
######################
__all__
overrideable = abstractmethod
#魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程:goto
class 魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程囗囗囗囗基础囗无优化(ABC):
    #固化方法:goto
    #可优化方法:goto
    r'''[[[
new_concrete_methods:
<NONE>
new_abstract_methods:
`外参接口冖冖构造囗元素封包节点囗
`外参接口冖冖构造囗更深节点囗
`外参接口冖冖构造囗光杆树囗
`外参接口冖冖构造囗翅膀囗囗绝对定位囗
`外参接口冖冖构造囗根深树囗囗绝对定位囗
`外参接口冖冖拆包囗元素封包节点囗
`外参接口冖冖拆包囗根深树囗囗绝对定位囗
`外参接口冖冖区分树形态囗
`外参接口冖冖是空树囗囗光杆树囗
`外参接口冖冖迭代囗子节点囗囗光杆树囗
`外参接口冖冖迭代囗子节点囗囗翅膀囗囗绝对定位囗
`外参接口冖冖迭代囗子节点囗囗更深节点囗
`外参接口冖冖取囗长度囗囗光杆树囗
`外参接口冖冖取囗长度囗囗翅膀囗囗绝对定位囗
`外参接口冖冖取囗长度囗囗更深节点囗
`外参接口冖冖取囗缓存度量囗囗元素封包节点囗
`外参接口冖冖取囗缓存度量囗囗更深节点囗
`外参接口冖冖取囗缓存度量囗囗光杆树囗
`外参接口冖冖取囗缓存度量囗囗翅膀囗囗绝对定位囗
`外参接口冖冖取囗缓存度量囗囗根深树囗

    #]]]'''#'''
    __slots__ = ()
    @abstractmethod
    def 外参接口冖冖构造囗元素封包节点囗(sf, 元素, /, *, 参数配置, 深度):
        '-> 元素封包节点/节点<0>/封包<元素> #用于 缓存 度量，否则 无需 封包'
    @abstractmethod
    def 外参接口冖冖构造囗更深节点囗(sf, 节点序列, /, *, 左起丷右起, 参数配置, 深度):
        '-> 节点<深度+1>/更深节点<深度> #可能需要 缓存 度量'
    @abstractmethod
    def 外参接口冖冖构造囗光杆树囗(sf, 节点序列, /, *, 左起丷右起, 参数配置, 深度):
        '-> 光杆树<深度> #可能需要 缓存 度量'
        #光杆树:封顶双侧栈<光杆树最大许可长度>
    @abstractmethod
    def 外参接口冖冖构造囗翅膀囗囗绝对定位囗(sf, 节点序列, /, *, 左起丷右起, 左翼丷右翼, 参数配置, 深度):
        '节点序列<左起丷右起,深度> -> 翅膀<左翼丷右翼,深度> #区分左右:栈开口方向不同！#可能需要 缓存 度量'
        #翅膀:封顶单侧保底栈<左起丷右起,翅膀最大许可长度,翅膀最小许可长度>
    @abstractmethod
    def 外参接口冖冖构造囗根深树囗囗绝对定位囗(sf, 左翼, 更深树, 右翼, /, *, 参数配置, 深度):
        '-> 根深树<深度> #可能需要 缓存 度量'


    @abstractmethod
    def 外参接口冖冖拆包囗元素封包节点囗(sf, 元素封包节点, /, *, 参数配置, 深度):
        '-> 元素'
    @abstractmethod
    def 外参接口冖冖拆包囗根深树囗囗绝对定位囗(sf, 根深树, /, *, 参数配置, 深度):
        '-> (左翼, 更深树, 右翼)'

    @abstractmethod
    def 外参接口冖冖区分树形态囗(sf, 双侧展翅树, /, *, 参数配置, 深度):
        '-> 光杆树丷根深树/bool'
    @abstractmethod
    def 外参接口冖冖是空树囗囗光杆树囗(sf, 光杆树, /, *, 参数配置, 深度):
        '-> bool'

    @abstractmethod
    def 外参接口冖冖迭代囗子节点囗囗光杆树囗(sf, 光杆树, /, *, 左起丷右起, 参数配置, 深度):
        '-> Iter 节点<深度>'
    @abstractmethod
    def 外参接口冖冖迭代囗子节点囗囗翅膀囗囗绝对定位囗(sf, 左翼丨右翼, /, *, 左起丷右起, 左翼丷右翼, 参数配置, 深度):
        '-> Iter 节点<深度>'
    @abstractmethod
    def 外参接口冖冖迭代囗子节点囗囗更深节点囗(sf, 更深节点, /, *, 左起丷右起, 参数配置, 深度):
        '更深节点<深度> -> Iter 节点<深度>'


    @abstractmethod
    def 外参接口冖冖取囗长度囗囗光杆树囗(sf, 光杆树, /, *, 参数配置, 深度):
        '-> 长度'
    @abstractmethod
    def 外参接口冖冖取囗长度囗囗翅膀囗囗绝对定位囗(sf, 左翼丨右翼, /, *, 左翼丷右翼, 参数配置, 深度):
        '-> 长度'
    @abstractmethod
    def 外参接口冖冖取囗长度囗囗更深节点囗(sf, 更深节点, /, *, 参数配置, 深度):
        '-> 长度'

    ######################
    ######################
    ######################
    @abstractmethod
    def 外参接口冖冖取囗缓存度量囗囗元素封包节点囗(sf, 元素封包节点, /, *, 参数配置, 深度):
        '-> 缓存度量'
    @abstractmethod
    def 外参接口冖冖取囗缓存度量囗囗更深节点囗(sf, 更深节点, /, *, 参数配置, 深度):
        '-> 缓存度量'
    @abstractmethod
    def 外参接口冖冖取囗缓存度量囗囗光杆树囗(sf, 光杆树, /, *, 参数配置, 深度):
        '-> 缓存度量'
    @abstractmethod
    def 外参接口冖冖取囗缓存度量囗囗翅膀囗囗绝对定位囗(sf, 左翼丨右翼, /, *, 左翼丷右翼, 参数配置, 深度):
        '-> 缓存度量'
    @abstractmethod
    def 外参接口冖冖取囗缓存度量囗囗根深树囗(sf, 根深树, /, *, 参数配置, 深度):
        '-> 缓存度量'

    ######################
    #构造
    外参接口冖冖构造囗元素封包节点囗
    外参接口冖冖构造囗更深节点囗
    外参接口冖冖构造囗光杆树囗
    外参接口冖冖构造囗翅膀囗囗绝对定位囗
        #构造囗翅膀囗囗相对定位囗
    外参接口冖冖构造囗根深树囗囗绝对定位囗
        #构造囗根深树囗囗相对定位囗
    ######################
    #元素封包节点,根深树:定长:拆包
    外参接口冖冖拆包囗元素封包节点囗
    外参接口冖冖拆包囗根深树囗囗绝对定位囗
        #拆包囗根深树囗囗相对定位囗
    #更深节点,光杆树,翅膀:变长:迭代:取囗长度
    外参接口冖冖迭代囗子节点囗囗更深节点囗
    外参接口冖冖迭代囗子节点囗囗光杆树囗
    外参接口冖冖迭代囗子节点囗囗翅膀囗囗绝对定位囗
        #迭代囗子节点囗囗翅膀囗囗相对定位囗
    #
    外参接口冖冖取囗长度囗囗更深节点囗
    外参接口冖冖取囗长度囗囗光杆树囗
    外参接口冖冖取囗长度囗囗翅膀囗囗绝对定位囗
        #取囗长度囗囗翅膀囗囗相对定位囗
    ######################
    ######################
    ######################

class 魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程囗囗囗囗基础(魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程囗囗囗囗基础囗无优化):
    #固化方法:goto
    #可优化方法:goto
    r'''[[[
#具名参数囗囗定义:here
    [kw2.keys() == {参数配置, 深度}]
    [kw3.keys() == {左起丷右起, 参数配置, 深度}]
    [kw4.keys() == {起翼丷讫翼, 左起丷右起, 参数配置, 深度}]
    [kw4g.keys() == {起半扇丷讫半扇, 左起丷右起, 参数配置, 深度}]
    [kwA.keys() == {左翼丷右翼, 参数配置, 深度}]
    [kwAg.keys() == {左半扇丷右半扇, 参数配置, 深度}]
    [kw3A.keys() == {左翼丷右翼, 左起丷右起, 参数配置, 深度}]
        #..见:...可优化方法.缺省具现
    [kwm.keys() == {是否需囗焦点居前囗起半扇, 是否需囗焦点诸后囗讫半扇, 是否需囗焦点, 是否需囗焦点居后囗讫半扇}]
    [kwm__kw3 == kwm \-/ kw3]
    ######################
    required:
    参数配置
    深度
        ==>> kw2
    ######################
    optional:
    绝对定位:
        左端丷右端
        左翼丷右翼
        左半扇丷右半扇
        左起丷右起
        ### d,y,b,q
        ### kw2q <==> kw3
        ### kw2y <==> kwA
        ### kw2b <==> kwAg
    相对定位:
        起半扇丷讫半扇<左起丷右起>
        起翼丷讫翼<左起丷右起>
        ### B,Y
        ### kw2qY <==> kw3Y <==> kw4
        ### kw2qB <==> kw3B <==> kw4g
    ######################

new_concrete_methods:
<NONE>
new_abstract_methods:
`外参接口冖冖压入节点囗囗光杆树囗囗溢出时分裂成均衡双翼囗
`外参接口冖冖巜外端压入节点囗囗翅膀囗囗溢出时异端弹出更深节点囗囗绝对定位囗
`外参接口冖冖巜弹出节点囗囗光杆树囗囗缺员时未定义囗
`外参接口冖冖弹出节点囗空心树退化成光杆树囗囗绝对定位囗
`外参接口冖冖巜先内端压入更深节点再外端弹出节点囗囗翅膀囗囗临界缺员囗囗绝对定位囗
`外参接口冖冖巜外端弹出节点囗囗翅膀囗囗缺员时未定义囗囗绝对定位囗
`外参接口冖冖巜同端先弹出再压入节点囗囗光杆树囗
`外参接口冖冖巜外端先弹出再压入节点囗囗翅膀囗囗绝对定位囗
`外参接口冖冖彳忄亍囗巜合并囗囗光杆树囗囗绝对定位囗
`外参接口冖冖示意分裂囗囗焦点不存在时未定义囗囗半扇版囗囗光杆树囗
`外参接口冖冖示意分裂囗囗焦点不存在时未定义囗囗半扇版囗囗翅膀囗囗绝对定位囗囗绝对定位囗
`外参接口冖冖示意分裂囗囗焦点不存在时未定义囗囗半扇版囗囗更深节点囗
`外参接口冖冖拼装巛光杆树半扇囗囗绝对定位囗
`外参接口冖冖拼装巛翅膀外端半扇囗囗绝对定位囗
`外参接口冖冖取囗长度囗囗翅膀内端半扇囗囗绝对定位囗
`外参接口冖冖拼装巛翅膀内端半扇囗囗足员囗囗绝对定位囗
`外参接口冖冖拼装巛翅膀内端半扇囗囗缺员囗囗厚势囗囗绝对定位囗
`外参接口冖冖拼装巛翅膀内端半扇囗囗缺员囗囗空心囗囗绝对定位囗
`外参接口冖冖取囗长度囗囗更深节点半扇囗囗绝对定位囗
`外参接口冖冖拼装巛更深节点半扇囗囗足员囗囗绝对定位囗
`外参接口冖冖拼装巛更深节点半扇囗囗缺员囗囗厚势囗囗绝对定位囗
`外参接口冖冖拼装巛更深节点半扇囗囗缺员囗囗空心囗囗绝对定位囗

    #]]]'''#'''
    __slots__ = ()
    ######################
    ######################
    ######################
    ######################
    ######################
    ######################
    # 可优化方法:here
    @overrideable
    def 外参接口冖冖压入节点囗囗光杆树囗囗溢出时分裂成均衡双翼囗(sf, 光杆树, 节点, /, *, 左端丷右端, 参数配置, 深度):
        #可优化方法:底层接口
        '-> 光杆树屮均衡双翼/(光杆树丷均衡双翼, 光杆树丨均衡双翼) #均衡双翼/(左翼,右翼)'
        L = sf.外参接口冖冖取囗长度囗囗光杆树囗(光杆树, 参数配置=参数配置, 深度=深度)
        if L == 参数配置.光杆树最大许可长度:
            ...
        raise NotImplementedError
    ######################
    @overrideable
    def 外参接口冖冖巜外端压入节点囗囗翅膀囗囗溢出时异端弹出更深节点囗囗绝对定位囗(sf, 翅膀, 节点, /, *, 左翼丷右翼, 参数配置, 深度):
        '-> (翅膀<深度>, 魊 更深节点) #注意使用:更深节点最优许可长度'   ' # 内端vs外端 为避免混乱 面向内外端的函数 没有 相对定位版'
        #可优化方法:底层接口
        raise NotImplementedError
    ######################
    @overrideable
    def 外参接口冖冖巜弹出节点囗囗光杆树囗囗缺员时未定义囗(sf, 光杆树, /, *, 左端丷右端, 参数配置, 深度):
        #可优化方法:底层接口
        '-> (双侧展翅树<深度>, 节点)'
        assert 参数配置.缩水
        raise NotImplementedError
    ######################
    @overrideable
    def 外参接口冖冖弹出节点囗空心树退化成光杆树囗囗绝对定位囗(sf, 左翼, 右翼, /, *, 左端丷右端, **kw2):
        '-> (光杆树<深度>, 节点)'
    @overrideable
    def 外参接口冖冖巜先内端压入更深节点再外端弹出节点囗囗翅膀囗囗临界缺员囗囗绝对定位囗(sf, 翅膀, 更深节点, /, **kwA):
        '-> (翅膀<深度>, 节点)'   ' # 内端vs外端 为避免混乱 面向内外端的函数 没有 相对定位版'
    @overrideable
    def 外参接口冖冖巜外端弹出节点囗囗翅膀囗囗缺员时未定义囗囗绝对定位囗(sf, 翅膀, /, **kwA):
        '-> (翅膀<深度>, 节点)'   ' # 内端vs外端 为避免混乱 面向内外端的函数 没有 相对定位版'
    ######################
    @overrideable
    def 外参接口冖冖巜同端先弹出再压入节点囗囗光杆树囗(sf, 光杆树, 节点, /, *, 左端丷右端, **kw2):
        '-> (双侧展翅树, 节点)'
    @overrideable
    def 外参接口冖冖巜外端先弹出再压入节点囗囗翅膀囗囗绝对定位囗(sf, 翅膀, 节点, /, **kwA):
        '-> (翅膀, 节点)'   ' # 内端vs外端 为避免混乱 面向内外端的函数 没有 相对定位版'
    ######################
    @overrideable
    def 外参接口冖冖彳忄亍囗巜合并囗囗光杆树囗囗绝对定位囗(sf, 左囗光杆树, 右囗光杆树, /, *, 参数配置, 深度):
        '左/光杆树<深度> -> 右/光杆树<深度> -> (NotImplemented|(双侧展翅树<深度>, None))'
        return NotImplemented
        #左长 = sf.外参接口冖冖取囗长度囗囗光杆树囗(左囗光杆树, **kw2)
    ######################
    ######################
    # 优化囗囗巨大囗最大许可长度:goto
    #
    # -> (魊囗焦点居前囗起半扇, 焦点居前囗累计值, 魊囗焦点诸后囗讫半扇, 魊囗焦点, 魊囗焦点居后囗讫半扇)
    @overrideable
    def 外参接口冖冖示意分裂囗囗焦点不存在时未定义囗囗半扇版囗囗光杆树囗(sf, 光杆树, 初始累计值, 魊累积囗, /, *, 是否需囗焦点居前囗起半扇, 是否需囗焦点诸后囗讫半扇, 是否需囗焦点, 是否需囗焦点居后囗讫半扇, 左起丷右起, 参数配置, 深度):
        '-> (魊 焦点居前囗起半扇, 焦点居前囗累计值, 魊 焦点诸后囗讫半扇, 魊 焦点, 魊 焦点居后囗讫半扇)'
    @overrideable
    def 外参接口冖冖示意分裂囗囗焦点不存在时未定义囗囗半扇版囗囗翅膀囗囗绝对定位囗囗绝对定位囗(sf, 翅膀, 初始累计值, 魊累积囗, /, *, 是否需囗焦点居前囗起半扇, 是否需囗焦点诸后囗讫半扇, 是否需囗焦点, 是否需囗焦点居后囗讫半扇, 左翼丷右翼, 左起丷右起, 参数配置, 深度):
        '-> (魊 焦点居前囗起半扇, 焦点居前囗累计值, 魊 焦点诸后囗讫半扇, 魊 焦点, 魊 焦点居后囗讫半扇)'   ' # 内端vs外端 为避免混乱 面向内外端的函数 没有 相对定位版'
    @overrideable
    def 外参接口冖冖示意分裂囗囗焦点不存在时未定义囗囗半扇版囗囗更深节点囗(sf, 更深节点, 初始累计值, 魊累积囗, /, *, 是否需囗焦点居前囗起半扇, 是否需囗焦点诸后囗讫半扇, 是否需囗焦点, 是否需囗焦点居后囗讫半扇, 左起丷右起, 参数配置, 深度):
        '-> (魊 焦点居前囗起半扇, 焦点居前囗累计值, 魊 焦点诸后囗讫半扇, 魊 焦点, 魊 焦点居后囗讫半扇)'

    @overrideable
    def 外参接口冖冖拼装巛光杆树半扇囗囗绝对定位囗(sf, 光杆树半扇, /, *, 左半扇丷右半扇, 参数配置, 深度):
        '-> 光杆树'
    @overrideable
    def 外参接口冖冖拼装巛翅膀外端半扇囗囗绝对定位囗(sf, 翅膀外端半扇, /, *, 左翼丷右翼, 参数配置, 深度):
        '-> 光杆树屮均衡双翼 #MAY_BE 根深树/光杆树'   ' # 内端vs外端 为避免混乱 面向内外端的函数 没有 相对定位版'
        #bug:'-> 光杆树'   ' # 内端vs外端 为避免混乱 面向内外端的函数 没有 相对定位版'
        #   MAY_BE: [光杆树最大许可长度+1 < 翅膀最大许可长度]
        #   although: [光杆树最大许可长度+1 >= 2*翅膀最小许可长度]
        # 外端 ==>> [起半扇丷讫半扇 == 起翼丷讫翼]
        # 外端 ==>> [左半扇丷右半扇 == 左翼丷右翼]

    #see: def 外参接口冖冖拼装巛翅膀内端半扇囗(sf, 翅膀内端半扇, 更深树, 异翅, /, *, 左翼丷右翼, 参数配置, 深度):
    @overrideable
    def 外参接口冖冖取囗长度囗囗翅膀内端半扇囗囗绝对定位囗(sf, 翅膀内端半扇, /, *, 左翼丷右翼, 参数配置, 深度):
        '-> 长度'   ' # 内端vs外端 为避免混乱 面向内外端的函数 没有 相对定位版'
        # 内端 ==>> [起半扇丷讫半扇 == not 起翼丷讫翼]
        # 内端 ==>> [左半扇丷右半扇 == not 左翼丷右翼]

    @overrideable
    def 外参接口冖冖拼装巛翅膀内端半扇囗囗足员囗囗绝对定位囗(sf, 翅膀内端半扇囗囗足员, /, *, 左翼丷右翼, 参数配置, 深度):
        '翅膀内端半扇<足员> -> 翅膀<同侧>'   ' # 内端vs外端 为避免混乱 面向内外端的函数 没有 相对定位版'
    @overrideable
    def 外参接口冖冖拼装巛翅膀内端半扇囗囗缺员囗囗厚势囗囗绝对定位囗(sf, 翅膀内端半扇囗囗缺员, 更深节点, /, *, 左翼丷右翼, 参数配置, 深度):
        '翅膀内端半扇<缺员> -> 更深节点 -> 翅膀<同侧>'   ' # 内端vs外端 为避免混乱 面向内外端的函数 没有 相对定位版'
        #required:参数配置.缩水分裂#==>>断肢再造,滴血重生
    @overrideable
    def 外参接口冖冖拼装巛翅膀内端半扇囗囗缺员囗囗空心囗囗绝对定位囗(sf, 翅膀内端半扇囗囗缺员, 异翅, /, *, 左翼丷右翼, 参数配置, 深度):
        '翅膀内端半扇<缺员> -> 异翅 -> 光杆树屮均衡双翼/(光杆树丷均衡双翼, 光杆树丨均衡双翼)'   ' # 内端vs外端 为避免混乱 面向内外端的函数 没有 相对定位版'
    #####
    #see:def 外参接口冖冖拼装巛更深节点半扇囗(sf, 更深节点半扇, 外端囗更深树, 同侧浅翼, /, *, 左半扇丷右半扇, 参数配置, 深度):
    @overrideable
    def 外参接口冖冖取囗长度囗囗更深节点半扇囗囗绝对定位囗(sf, 更深节点半扇, /, *, 左半扇丷右半扇, 参数配置, 深度):
        '更深节点半扇<左半扇丷右半扇> -> 长度'
    @overrideable
    def 外参接口冖冖拼装巛更深节点半扇囗囗足员囗囗绝对定位囗(sf, 更深节点半扇囗囗足员, /, *, 左半扇丷右半扇, 参数配置, 深度):
        '更深节点半扇<足员;左半扇丷右半扇> -> 异侧浅翼/翅膀<左翼丷右翼=not 左半扇丷右半扇>'
    @overrideable
    def 外参接口冖冖拼装巛更深节点半扇囗囗缺员囗囗厚势囗囗绝对定位囗(sf, 更深节点半扇囗囗缺员, 外端囗更深节点, /, *, 左半扇丷右半扇, 参数配置, 深度):
        '更深节点半扇<缺员;左半扇丷右半扇> -> 外端囗更深节点/更深节点<原囗更深节点:外端> -> 异侧浅翼/翅膀<左翼丷右翼=not 左半扇丷右半扇>'
        #required:参数配置.缩水分裂#==>>断肢再造,滴血重生
    @overrideable
    def 外参接口冖冖拼装巛更深节点半扇囗囗缺员囗囗空心囗囗绝对定位囗(sf, 更深节点半扇囗囗缺员, 同侧浅翼, /, *, 左半扇丷右半扇, 参数配置, 深度):
        '更深节点半扇<缺员;左半扇丷右半扇> -> 同侧浅翼/翅膀<左翼丷右翼=左半扇丷右半扇> -> 光杆树屮均衡双翼/(光杆树丷均衡双翼, 光杆树丨均衡双翼)'


    ######################
    ######################
    ######################
    ######################
    ######################
    ######################
    ######################
    @overrideable
    def 外参接口冖冖下沉囗异心双翼囗囗间夹囗节点序列囗(sf, 起树讫翼, 节点数目, 节点序列, 讫树起翼, /, **kw3):
        '起树讫翼/翅膀<深度> -> 节点数目 -> 节点序列<左起丷右起;深度>{len=节点数目} -> 讫树起翼/翅膀<深度> -> (更深节点数目, 更深节点序列/Iter 更深节点<深度>)'
    ######################
    @overrideable
    def 外参接口冖冖计算囗更深节点各类长度囗囗用于下沉囗足够长囗节点序列囗(sf, 节点数目囗囗足够大, /, *, 参数配置, 深度):
        '[紧致假设:] => 节点数目{>更深节点最大的不可表达节点数} -> (更深节点数目, 更深节点数目归类/Iter (更深节点长度, 更深节点数目囗囗此长度))'
    ######################
    @overrideable
    def 外参接口冖冖更深节点序列巛节点序列囗囗囗必须足够长囗(sf, 节点数目, 节点序列, /, *, 左起丷右起, 参数配置, 深度):
        '节点数目{>=更深节点最小许可长度} -> Iter (节点<深度>){len=节点数目} -> (更深节点数目, 更深节点序列/Iter (更深节点<深度>))'







    ######################
class 魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程囗囗囗囗固化方法(魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程囗囗囗囗基础):
    #固化方法:goto
    #可优化方法:goto
    r'''[[[
new_abstract_methods:
<NONE>
new_concrete_methods:
外参接口冖冖取囗缓存度量囗囗节点囗
外参接口冖冖构造囗根深树囗囗相对定位囗
外参接口冖冖拆包囗根深树囗囗相对定位囗
外参接口冖冖构造囗翅膀囗囗相对定位囗
外参接口冖冖迭代囗子节点囗囗翅膀囗囗相对定位囗
外参接口冖冖取囗长度囗囗翅膀囗囗相对定位囗
外参接口冖冖取囗缓存度量囗囗翅膀囗囗相对定位囗
外参接口冖冖弹出节点囗空心树退化成光杆树囗囗相对定位囗
外参接口冖冖拼装巛光杆树半扇囗囗相对定位囗
外参接口冖冖取囗缓存度量囗囗双侧展翅树囗
外参接口冖冖构造囗空树囗
外参接口冖冖是空树囗囗双侧展翅树囗
外参接口冖冖拼装巛更深节点半扇囗
外参接口冖冖拼装巛翅膀内端半扇囗
外参接口冖冖拼装巛光杆树屮均衡双翼囗
    外参接口冖冖拼装巛翅膀外端半扇囗囗绝对定位囗囗补全囗
外参接口冖冖构造囗空心树囗囗绝对定位囗
    #]]]'''#'''
    __slots__ = ()
    ######################
    ######################
    #固化方法:
    #分流#统一:节点:元素封包节点,深度节点
    def 外参接口冖冖取囗缓存度量囗囗节点囗(sf, 节点, /, *, 参数配置, 深度):
        '-> 缓存度量'
        return _外参接口冖冖分流囗囗节点形态囗(sf, sf.外参接口冖冖取囗缓存度量囗囗元素封包节点囗, sf.外参接口冖冖取囗缓存度量囗囗更深节点囗, 节点, 参数配置=参数配置, 深度=深度)
    ######################
    ######################
    #固化方法:
    #相对:根深树:相对次序
    def 外参接口冖冖构造囗根深树囗囗相对定位囗(sf, 起翼, 更深树, 讫翼, /, *, 左起丷右起, **kw2):
        '-> 根深树<深度> #可能需要 缓存 度量'
        (左翼, 更深树, 右翼) = _调整次序囗(起翼, 更深树, 讫翼, 左起丷右起=左起丷右起)
        return sf.外参接口冖冖构造囗根深树囗囗绝对定位囗(左翼, 更深树, 右翼, **kw2)

    def 外参接口冖冖拆包囗根深树囗囗相对定位囗(sf, 根深树, /, *, 左起丷右起, **kw2):
        '-> (起翼, 更深树, 讫翼)'
        (左翼, 更深树, 右翼) = sf.外参接口冖冖拆包囗根深树囗囗绝对定位囗(根深树, **kw2)
        (起翼, 更深树, 讫翼) = _调整次序囗(左翼, 更深树, 右翼, 左起丷右起=左起丷右起)
        return (起翼, 更深树, 讫翼)

    ######################
    ######################
    #固化方法:
    #相对:翅膀:相对次序
    def 外参接口冖冖构造囗翅膀囗囗相对定位囗(sf, 节点序列, /, *, 左起丷右起, 起翼丷讫翼, **kw2):
        '节点序列<左起丷右起,深度> -> 翅膀<左翼丷右翼=(not 起翼丷讫翼 is 左起丷右起),深度> #区分左右:栈开口方向不同！#可能需要 缓存 度量'
        #翅膀:封顶单侧保底栈<左起丷右起,翅膀最大许可长度,翅膀最小许可长度>
        左翼丷右翼 = 翅膀囗绝对定位巛相对定位囗(左起丷右起=左起丷右起, 起翼丷讫翼=起翼丷讫翼)
        return sf.外参接口冖冖构造囗翅膀囗囗绝对定位囗(节点序列, 左起丷右起=左起丷右起, 左翼丷右翼=左翼丷右翼, **kw2)
    ######################
    def 外参接口冖冖迭代囗子节点囗囗翅膀囗囗相对定位囗(sf, 起翼丨讫翼, /, *, 左起丷右起, 起翼丷讫翼, **kw2):
        '-> Iter 节点<深度>'
        左翼丷右翼 = 翅膀囗绝对定位巛相对定位囗(左起丷右起=左起丷右起, 起翼丷讫翼=起翼丷讫翼)
        左翼丨右翼 = 翅膀 = 起翼丨讫翼
        return sf.外参接口冖冖迭代囗子节点囗囗翅膀囗囗绝对定位囗(左翼丨右翼, 左起丷右起=左起丷右起, 左翼丷右翼=左翼丷右翼, **kw2)
    ######################
    def 外参接口冖冖取囗长度囗囗翅膀囗囗相对定位囗(sf, 起翼丨讫翼, /, *, 左起丷右起, 起翼丷讫翼, **kw2):
        '-> 长度'
        左翼丷右翼 = 翅膀囗绝对定位巛相对定位囗(左起丷右起=左起丷右起, 起翼丷讫翼=起翼丷讫翼)
        左翼丨右翼 = 翅膀 = 起翼丨讫翼
        return sf.外参接口冖冖取囗长度囗囗翅膀囗囗绝对定位囗(左翼丨右翼, 左翼丷右翼=左翼丷右翼, **kw2)
    ######################
    def 外参接口冖冖取囗缓存度量囗囗翅膀囗囗相对定位囗(sf, 起翼丨讫翼, /, *, 左起丷右起, 起翼丷讫翼, **kw2):
        '-> 缓存度量'
        左翼丷右翼 = 翅膀囗绝对定位巛相对定位囗(左起丷右起=左起丷右起, 起翼丷讫翼=起翼丷讫翼)
        左翼丨右翼 = 翅膀 = 起翼丨讫翼
        return sf.外参接口冖冖取囗缓存度量囗囗翅膀囗囗绝对定位囗(左翼丨右翼, 左翼丷右翼=左翼丷右翼, **kw2)
    ######################
    ######################
    def 外参接口冖冖弹出节点囗空心树退化成光杆树囗囗相对定位囗(sf, 起翼, 讫翼, /, *, 左端丷右端, 左起丷右起, **kw2):
        '-> (光杆树<深度>, 节点)'
        #def 外参接口冖冖先双翼合并再弹出节点而成光杆树囗囗翅膀囗囗临界缺员囗(sf, 翅膀, 异翅, /, **kw3):
        左翼, 右翼 = _调整次序囗(起翼, 讫翼, 左起丷右起=左起丷右起)
        return sf.外参接口冖冖弹出节点囗空心树退化成光杆树囗囗绝对定位囗(左翼, 右翼, 左端丷右端=左端丷右端, **kw2)
        #xxx'-> (光杆树<深度>, 节点) #弹出节点 意味着 迭代次序 ==>> [左起丷右起==左端丷右端]'
    ######################
    def 外参接口冖冖拼装巛光杆树半扇囗囗相对定位囗(sf, 光杆树半扇, /, **kw4g):
        '-> 光杆树'
        return sf.外参接口冖冖拼装巛光杆树半扇囗囗绝对定位囗(光杆树半扇, **_半扇次序绝对化囗(kw4g))
    ######################
    ######################
    #固化方法:
    #分流:
    def 外参接口冖冖取囗缓存度量囗囗双侧展翅树囗(sf, 双侧展翅树, /, **kw2):
        '-> 缓存度量'
        return _外参接口冖冖分流囗囗树形态囗(sf, sf.外参接口冖冖取囗缓存度量囗囗光杆树囗, sf.外参接口冖冖取囗缓存度量囗囗根深树囗, 双侧展翅树, **kw2)
    #####
    def 外参接口冖冖构造囗空树囗(sf, /, **kw2):
        '-> 空树/双侧展翅树<深度>'
        空树 = 双侧展翅树 = 光杆树 = sf.外参接口冖冖构造囗光杆树囗('', 左起丷右起=False, **kw2)
        return 空树
    #####
    #def 外参接口冖冖是空树囗囗双侧展翅树囗(sf, 双侧展翅树, /, *, 参数配置, 深度):
    def 外参接口冖冖是空树囗囗双侧展翅树囗(sf, 双侧展翅树, /, **kw2):
        '-> bool'
        return _外参接口冖冖分流囗囗树形态囗(sf, sf.外参接口冖冖是空树囗囗光杆树囗, lambda *_, **_2:False, 双侧展翅树, **kw2)
    #####


    ######################
    ######################
    #固化方法:
    #简单明了:
    def 外参接口冖冖拼装巛更深节点半扇囗(sf, 更深节点半扇, 外端囗更深树, 同侧浅翼, /, *, 左半扇丷右半扇, **kw2):
        '更深节点半扇<缺员;左半扇丷右半扇> -> 外端囗更深树/更深树<原囗更深节点:外端> -> 同侧浅翼/翅膀<左翼丷右翼=左半扇丷右半扇> -> 双侧展翅树'
        return _外参接口冖冖拼装巛半扇组织囗(sf
        ,sf.外参接口冖冖取囗长度囗囗更深节点半扇囗囗绝对定位囗
        ,sf.外参接口冖冖拼装巛更深节点半扇囗囗足员囗囗绝对定位囗
        ,sf.外参接口冖冖拼装巛更深节点半扇囗囗缺员囗囗厚势囗囗绝对定位囗
        ,sf.外参接口冖冖拼装巛更深节点半扇囗囗缺员囗囗空心囗囗绝对定位囗
        ,dict(左半扇丷右半扇=左半扇丷右半扇)
        ,更深节点半扇, 外端囗更深树, 同侧浅翼
        ,左起丷右起=not 左半扇丷右半扇
            #更深节点半扇 是 左半扇，则 同侧浅翼 是 左翼, 而 二元组『(原囗更深节点,同侧浅翼)』 是 右起 次序
        , **kw2
        )

    def 外参接口冖冖拼装巛翅膀内端半扇囗(sf, 翅膀内端半扇, 更深树, 异翅, /, *, 左翼丷右翼, **kw2):
        '-> 双侧展翅树<深度>' \
        ' #翅膀内端半扇 === 翅膀<左翼丷右翼, 左半扇丷右半扇=not 左翼丷右翼>'
        return _外参接口冖冖拼装巛半扇组织囗(sf
        ,sf.外参接口冖冖取囗长度囗囗翅膀内端半扇囗囗绝对定位囗
        ,sf.外参接口冖冖拼装巛翅膀内端半扇囗囗足员囗囗绝对定位囗
        ,sf.外参接口冖冖拼装巛翅膀内端半扇囗囗缺员囗囗厚势囗囗绝对定位囗
        ,sf.外参接口冖冖拼装巛翅膀内端半扇囗囗缺员囗囗空心囗囗绝对定位囗
        ,dict(左翼丷右翼=左翼丷右翼)
        ,翅膀内端半扇, 更深树, 异翅
        ,左起丷右起=左翼丷右翼
            #翅膀 是 左翼，则 二元组『(翅膀,异翅)』 是 左起 次序
        , **kw2
        )

    def 外参接口冖冖拼装巛翅膀外端半扇囗囗绝对定位囗囗补全囗(sf, 翅膀外端半扇, /, *, 左翼丷右翼, 参数配置, 深度):
        '-> 双侧展翅树 #MAY_BE 根深树/光杆树'   ' # 内端vs外端 为避免混乱 面向内外端的函数 没有 相对定位版'
        kwA = _to_kwA(locals())
        kw2 = _to_kw2(locals())
        光杆树屮均衡双翼 = sf.外参接口冖冖拼装巛翅膀外端半扇囗囗绝对定位囗(翅膀外端半扇, **kwA)
        双侧展翅树 = sf.外参接口冖冖拼装巛光杆树屮均衡双翼囗(光杆树屮均衡双翼, **kw2)
        return 双侧展翅树
    def 外参接口冖冖拼装巛光杆树屮均衡双翼囗(sf, 光杆树屮均衡双翼, /, **kw2):
        '-> 双侧展翅树<深度>'
        (光杆树丷均衡双翼, 光杆树丨均衡双翼) = 光杆树屮均衡双翼
        if 光杆树丷均衡双翼 is False:
            双侧展翅树 = 光杆树 = 光杆树丨均衡双翼
        elif 光杆树丷均衡双翼 is True:
            (左翼, 右翼) = 均衡双翼 = 光杆树丨均衡双翼
            双侧展翅树 = 空心树 = sf.外参接口冖冖构造囗空心树囗囗绝对定位囗(左翼, 右翼, **kw2)
        else:
            raise 000
        return 双侧展翅树
    def 外参接口冖冖构造囗空心树囗囗绝对定位囗(sf, 左翼, 右翼, /, **kw2):
        '-> 空心树/双侧展翅树<深度>'
        更深树 = 空树囗囗更深 = sf.外参接口冖冖构造囗空树囗(**_更深囗(kw2))
        空心树 = 双侧展翅树 = 根深树 = sf.外参接口冖冖构造囗根深树囗囗绝对定位囗(左翼, 空树囗囗更深, 右翼, **kw2)
        return 空心树
#end-class 魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程囗囗囗囗固化方法




class 魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程囗囗囗囗部分可优化方法缺省具现囗囗下沉囗异心双翼(魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程囗囗囗囗固化方法):
    #固化方法:goto
    #可优化方法:goto
    r'''[[[
new_abstract_methods:
<NONE>
new_concrete_methods:
外参接口冖冖下沉囗异心双翼囗囗间夹囗节点序列囗
外参接口冖冖计算囗更深节点各类长度囗囗用于下沉囗足够长囗节点序列囗
外参接口冖冖更深节点序列巛节点序列囗囗囗必须足够长囗
    #]]]'''#'''
    __slots__ = ()
    ######################
    @override
    def 外参接口冖冖下沉囗异心双翼囗囗间夹囗节点序列囗(sf, 起树讫翼, 节点数目, 节点序列, 讫树起翼, /, **kw3):
        '起树讫翼/翅膀<深度> -> 节点数目 -> 节点序列<左起丷右起;深度>{len=节点数目} -> 讫树起翼/翅膀<深度> -> (更深节点数目, 更深节点序列/Iter 更深节点<深度>)'
        L0 = sf.外参接口冖冖取囗长度囗囗翅膀囗囗相对定位囗(起树讫翼, 起翼丷讫翼=True, **kw3)
            #讫翼
        L1 = sf.外参接口冖冖取囗长度囗囗翅膀囗囗相对定位囗(讫树起翼, 起翼丷讫翼=False, **kw3)
            #起翼
        it0 = sf.外参接口冖冖迭代囗子节点囗囗翅膀囗囗相对定位囗(起树讫翼, 起翼丷讫翼=True, **kw3)
        it1 = sf.外参接口冖冖迭代囗子节点囗囗翅膀囗囗相对定位囗(讫树起翼, 起翼丷讫翼=False, **kw3)
        ######################
        #[节点数目==0]:
        #   L0+L1, chain(it0, it1)
        ######################
        _ = key_as_attr(kw3)
        参数配置 = _.参数配置
        assert L0+L1 >= 2*参数配置.翅膀最小许可长度 >= 参数配置.更深节点最小许可长度
            ##<<==即使:[节点数目==0]
        更深节点数目, 更深节点序列 = sf.外参接口冖冖更深节点序列巛节点序列囗囗囗必须足够长囗(L0+节点数目+L1, chain(it0, 节点序列, it1), **kw3)
        return (更深节点数目, 更深节点序列)
        ######################
    ######################
    @override
    def 外参接口冖冖计算囗更深节点各类长度囗囗用于下沉囗足够长囗节点序列囗(sf, 节点数目囗囗足够大, /, *, 参数配置, 深度):
        '[紧致假设:] => 节点数目{>更深节点最大的不可表达节点数} -> (更深节点数目, 更深节点数目归类/Iter (更深节点长度, 更深节点数目囗囗此长度))'
        if not 节点数目囗囗足够大 > 参数配置.更深节点最大的不可表达节点数:raise 错误('不够多')
        ######################
        if not 参数配置.紧致假设:#简化拆分#并非必要
            raise NotImplementedError
        assert 2*参数配置.翅膀最小许可长度 >= 参数配置.更深节点最小许可长度 == 参数配置.更深节点最大的不可表达节点数+1
        if not 节点数目囗囗足够大 >= 参数配置.更深节点最小许可长度:raise 错误('??logic-err??:紧致假设?不满足?')
        q, r = divmod(节点数目囗囗足够大 -参数配置.更深节点最小许可长度, 参数配置.更深节点最优许可长度)
        # [0 <= r < 更深节点最优许可长度 <= 更深节点最大许可长度]
        if r < 参数配置.更深节点最小许可长度:
            # [0 <= r < 更深节点最小许可长度]
            r += 参数配置.更深节点最小许可长度
            # [更深节点最小许可长度 <= r < 2*更深节点最小许可长度]
            # !! [更深节点最大许可长度 >= 2*更深节点最小许可长度 -1]
            # [更深节点最小许可长度 <= r <= 2*更深节点最小许可长度-1 <= 更深节点最大许可长度]
            # [更深节点最小许可长度 <= r <= 更深节点最大许可长度]
            b = 0 # 保底与否:否
        else:
            # [更深节点最小许可长度 <= r < 更深节点最优许可长度 <= 更深节点最大许可长度]
            # [更深节点最小许可长度 <= r <= 更深节点最大许可长度]
            b = 1 # 保底与否:是
        # [更深节点最小许可长度 <= r <= 更深节点最大许可长度]
        assert 参数配置.更深节点最小许可长度 <= r <= 参数配置.更深节点最大许可长度
        assert 节点数目囗囗足够大 == r +b*参数配置.更深节点最小许可长度 + q*参数配置.更深节点最优许可长度
        assert r
        def f(参数配置, r, b, q, /):
            yield (r, 1)
            yield (参数配置.更深节点最小许可长度, b)
            yield (参数配置.更深节点最优许可长度, q)
        更深节点数目 = 1+b+q
            # [r > 0] ==>> 『1+...』
        更深节点数目归类 = f(参数配置, r, b, q)
        return (更深节点数目, 更深节点数目归类)

    ######################
    @override
    def 外参接口冖冖更深节点序列巛节点序列囗囗囗必须足够长囗(sf, 节点数目, 节点序列, /, *, 左起丷右起, 参数配置, 深度):
        '节点数目{>=更深节点最小许可长度} -> Iter (节点<深度>){len=节点数目} -> (更深节点数目, 更深节点序列/Iter (更深节点<深度>))'
        节点序列 = iter(节点序列)
        kw2 = dict(参数配置=参数配置, 深度=深度)
        kw3 = dict(左起丷右起=左起丷右起, **kw2)
        (更深节点数目, 更深节点数目归类) = sf.外参接口冖冖计算囗更深节点各类长度囗囗用于下沉囗足够长囗节点序列囗(节点数目, **kw2)
        szs = chains(repeat(更深节点长度, 更深节点数目囗囗此长度) for 更深节点长度, 更深节点数目囗囗此长度 in 更深节点数目归类)
        mk_ = sf.外参接口冖冖构造囗更深节点囗
        len_ = sf.外参接口冖冖取囗长度囗囗更深节点囗
        def f(节点数目, 节点序列, szs, mk_, kw3, len_, kw2, /):
            for sz in szs:
                更深节点 = mk_(islice(节点序列, sz), **kw3)
                if not sz == len_(更深节点, **kw2):
                    #少于声明数量
                    raise 错误(f'有误:节点数目=={节点数目}')
                yield 更深节点
            for 节点 in 节点序列:
                #多于声明数量
                raise 错误(f'有误:节点数目=={节点数目}')
        更深节点序列 = f(节点数目, 节点序列, szs, mk_, kw3, len_, kw2)
        return (更深节点数目, 更深节点序列)

    ######################
    ######################
    ######################
#end-class 魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程囗囗囗囗部分可优化方法缺省具现囗囗下沉囗异心双翼




class 魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程(魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程囗囗囗囗固化方法):
    #固化方法:goto
    #可优化方法:goto
    r'''[[[
new_abstract_methods:
<NONE>
new_concrete_methods:
外参接口冖冖迭代囗子节点囗囗双侧展翅树囗
外参接口冖冖迭代囗子节点囗囗根深树囗
外参接口冖冖迭代囗子更深节点囗囗更深树囗
外参接口冖冖迭代囗孙节点囗囗更深树囗
外参接口冖冖取囗端点囗囗双侧展翅树囗
外参接口冖冖取囗魊端点囗囗光杆树囗
外参接口冖冖取囗魊端点囗囗根深树囗
外参接口冖冖取囗外端点囗囗翅膀囗
外参接口冖冖巜压入节点囗囗双侧展翅树囗
外参接口冖冖巜压入节点囗囗光杆树囗
外参接口冖冖巜压入节点囗囗根深树囗
外参接口冖冖巜弹出节点囗囗双侧展翅树囗
外参接口冖冖巜弹出魊节点囗囗双侧展翅树囗
外参接口冖冖巜弹出魊节点囗囗光杆树囗
外参接口冖冖巜弹出魊节点囗囗根深树囗
外参接口冖冖巜连续压入节点囗囗双侧展翅树囗
外参接口冖冖巜弹出节点构成树囗囗双侧展翅树囗
外参接口冖冖巜弹出节点列表囗囗双侧展翅树囗
外参接口冖冖巜同端先弹出再压入节点囗囗双侧展翅树囗
外参接口冖冖巜同端先弹出再压入节点囗囗根深树囗
外参接口冖冖巜先讫端压入再起端弹出节点囗囗双侧展翅树囗
外参接口冖冖巜先讫端压入再起端弹出节点囗囗光杆树囗
外参接口冖冖巜先讫端压入再起端弹出节点囗囗根深树囗
外参接口冖冖构造囗双侧展翅树囗
外参接口冖冖巜合并囗囗双侧展翅树囗囗间夹囗节点序列囗
外参接口冖冖巜合并囗囗光杆树囗囗相对定位囗
外参接口冖冖巜合并囗囗光杆树囗囗绝对定位囗
外参接口冖冖巜合并囗囗根深树囗囗间夹囗节点序列囗
外参接口冖冖巜合并囗囗双侧展翅树囗
外参接口冖冖分裂囗囗定位囗魊焦点囗囗返回值依起讫次序囗囗精简版囗囗双侧展翅树囗
外参接口冖冖分裂囗囗定位囗魊焦点囗囗全魊囗囗双侧展翅树囗
外参接口冖冖分裂囗囗定位囗焦点囗囗全魊囗囗焦点不存在时未定义囗囗双侧展翅树囗
外参接口冖冖分裂囗囗定位囗焦点囗囗全魊囗囗焦点不存在时未定义囗囗光杆树囗
外参接口冖冖分裂囗囗定位囗焦点囗囗全魊囗囗焦点不存在时未定义囗囗根深树囗

    #]]]'''#'''
    __slots__ = ()
    ######################
    ######################
    ######################
    ######################
    ######################
    ######################
    r'''[[[
    # 优化囗囗巨大囗最大许可长度:goto
    # 可优化方法:栈操作:光杆树,翅膀
    #   #错误处理:未定义/报错/魊/追加修复
    #   取囗端点
    #   压入节点
    #   弹出节点
    #   同端先弹出再压入节点
    #   先讫端压入再起端弹出节点
    #   连续压入<正序/反序！>
    #   压入指定数目<恰好>
    #   弹出指定数目<恰好>
    #   合并/分裂
    #   #无错:
    #   构造囗空栈囗
    #   是空栈囗 #O(1)
    #   取囗长度 #可能O(n)#kw:bigO_1__vs__bigO_log_L__vs_bigO_L
    #   迭代子节点
    #
    #   #细节:
    #   取囗端点:缺员时未定义
    #   取囗端点:缺员时报错/魊
    #   压入节点:溢出时未定义
    #   压入节点:溢出时报错/魊
    #   压入节点:翅膀:溢出时异端弹出更深节点
    #   压入节点:光杆树:溢出时分裂成均衡双翼
    #   弹出节点:缺员时未定义
    #   弹出节点:光杆树:缺员时报错/魊
    #   xxx弹出节点:翅膀:缺员时索取异端更深节点
    #   先内端压入更深节点再外端弹出节点:翅膀#用于:临界缺员时:损耗精血
    #   先双翼合并再弹出节点而成光杆树:翅膀#用于:临界缺员时:变态:退化
    #   同端先弹出再压入节点:光杆树:缺员时报错/魊
    #   同端先弹出再压入节点:翅膀:缺员时未定义
    #   先讫端压入再起端弹出节点:光杆树:无错
    #
    #   连续压入
    #   压入指定数目<恰好>:翅膀/光杆树:溢出时未定义#用于 连续压入不溢出时#数目足够小
    #   弹出指定数目<恰好>:翅膀/光杆树:缺员时未定义#用于 连续弹出不缺员时#数目足够小
    #   ???合并???无用
    #   分裂起翼:起翼+更深节点-->光杆树+焦点+起翼+损耗精血与否
    #   分裂起翼空心:起翼+讫翼-->光杆树+焦点+(双翼|光杆树)
    #   分裂讫翼空心:起翼+讫翼-->(双翼|光杆树)+焦点+光杆树
    #   分裂讫翼:更深节点+讫翼-->讫翼+光杆树+焦点+损耗精血与否
    ######################
    ######################
    #class:魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程
    ######################
    #主要目标:
    是空树囗囗双侧展翅树囗
    迭代囗子节点囗囗双侧展翅树囗
    取囗端点囗囗双侧展翅树囗#空树报错丷魊
    巜压入节点囗囗双侧展翅树囗
    巜弹出节点囗囗双侧展翅树囗#空树报错丷魊
    #巜连续压入节点囗囗双侧展翅树囗囗注意反序囗
    巜连续压入节点囗囗双侧展翅树囗#次序
    巜弹出节点列表囗囗双侧展翅树囗#次序,最大弹出数目
    巜同端先弹出再压入节点囗囗双侧展翅树囗#更换端点
    巜先讫端压入再起端弹出节点囗囗双侧展翅树囗#保长流动,允空
    构造囗双侧展翅树囗
    构造囗空树囗
    巜合并囗囗双侧展翅树囗
    巜合并囗囗双侧展翅树囗囗间夹囗节点序列囗
    #分裂囗囗搜索定位囗囗精简版囗囗双侧展翅树囗囗返回值为起讫次序囗
    巜分裂囗囗搜索定位囗囗焦点囗#无焦点报错丷魊
    巜分裂囗囗搜索定位囗
    ######################
    #次要目标:
    # 优化囗囗巨大囗最大许可长度:goto
    ######################
    #次要目标:
    是空树囗囗光杆树囗
    迭代囗子节点囗囗光杆树囗
    取囗端点囗囗光杆树囗#空树报错丷魊
    巜压入节点囗囗光杆树囗
    巜弹出节点囗囗光杆树囗#空树报错丷魊
    巜弹出魊节点囗囗双侧展翅树囗
    ######################
    #]]]'''#'''
    ######################
    ######################
    ######################
    ######################
    #构造囗空树囗
    #见上面:def 外参接口冖冖构造囗空树囗(sf, /, **kw2):
    ######################
    #是空树囗囗双侧展翅树囗
    #见上面:def 外参接口冖冖是空树囗囗双侧展翅树囗(sf, 双侧展翅树, /, *, 参数配置, 深度):


    ######################
    #迭代囗子节点囗囗双侧展翅树囗
    def 外参接口冖冖迭代囗子节点囗囗双侧展翅树囗(sf, 双侧展翅树, /, **kw3):
        '-> Iter 节点<深度>'
        return _外参接口冖冖分流囗囗树形态囗(sf, sf.外参接口冖冖迭代囗子节点囗囗光杆树囗, sf.外参接口冖冖迭代囗子节点囗囗根深树囗, 双侧展翅树, **kw3)
    def 外参接口冖冖迭代囗子节点囗囗根深树囗(sf, 根深树, /, **kw3):
        '-> Iter 节点<深度>'
        (起翼, 更深树, 讫翼) = sf.外参接口冖冖拆包囗根深树囗囗相对定位囗(根深树, **kw3)
        yield from sf.外参接口冖冖迭代囗子节点囗囗翅膀囗囗相对定位囗(起翼, 起翼丷讫翼=False, **kw3)
        yield from sf.外参接口冖冖迭代囗孙节点囗囗更深树囗(更深树, **kw3)
        yield from sf.外参接口冖冖迭代囗子节点囗囗翅膀囗囗相对定位囗(讫翼, 起翼丷讫翼=True, **kw3)
        return

    ######################
    def 外参接口冖冖迭代囗子更深节点囗囗更深树囗(sf, 更深树, /, *, 深度, **kw):
        '更深树<深度>/双侧展翅树<深度+1> -> Iter 更深节点<深度>'
        深度囗囗更深节点 = 深度囗囗更深树 = 深度
        双侧展翅树 = 更深树
        深度囗囗树 = 深度囗囗更深树+1
        return sf.外参接口冖冖迭代囗子节点囗囗双侧展翅树囗(双侧展翅树, 深度=深度囗囗树, **kw)
    ######################
    def 外参接口冖冖迭代囗孙节点囗囗更深树囗(sf, 更深树, /, **kw3):
        '更深树<深度> -> Iter 节点<深度>'
        for 更深节点 in sf.外参接口冖冖迭代囗子更深节点囗囗更深树囗(更深树, **kw3):
            yield from sf.外参接口冖冖迭代囗子节点囗囗更深节点囗(更深节点, **kw3)
    ######################


    ######################
    #取囗端点囗囗双侧展翅树囗#空树报错丷魊
    def 外参接口冖冖取囗端点囗囗双侧展翅树囗(sf, 双侧展翅树, /, *, 空树报错丷魊, **kw3):
        '-> ((节点|^错误) if not 空树报错丷魊 else 魊节点)'
        魊节点 = _外参接口冖冖分流囗囗树形态囗(sf, sf.外参接口冖冖取囗魊端点囗囗光杆树囗, sf.外参接口冖冖取囗魊端点囗囗根深树囗, 双侧展翅树, **kw3)
        if 空树报错丷魊:
            return 魊节点
        if 魊节点:
            [节点] = 魊节点
            return 节点
        raise 错误囗囗空树囗囗光杆树
    ######################
    def 外参接口冖冖取囗魊端点囗囗光杆树囗(sf, 光杆树, /, **kw3):
        '-> 魊节点'
        it = sf.外参接口冖冖迭代囗子节点囗囗光杆树囗(光杆树, **kw3)
        for 节点 in it:
            return (节点,)
        else:
            return null_tuple
    ######################
    def 外参接口冖冖取囗魊端点囗囗根深树囗(sf, 根深树, /, **kw3):
        '-> 魊节点'
        (起翼, 更深树, 讫翼) = sf.外参接口冖冖拆包囗根深树囗囗相对定位囗(根深树, **kw3)
        节点 = sf.外参接口冖冖取囗外端点囗囗翅膀囗(起翼, 起翼丷讫翼=False, **kw3)
        return (节点,)
    ######################
    def 外参接口冖冖取囗外端点囗囗翅膀囗(sf, 翅膀, /, **kw4):
        '-> 节点'
        it = sf.外参接口冖冖迭代囗子节点囗囗翅膀囗囗相对定位囗(翅膀, **kw4)
        for 节点 in it:
            return 节点
        else:
            raise 000
    ######################
    #巜压入节点囗囗双侧展翅树囗
    def 外参接口冖冖巜压入节点囗囗双侧展翅树囗(sf, 双侧展翅树, 节点, /, *, 左端丷右端, 参数配置, 深度):
        '-> (双侧展翅树<深度>, None)'
        assert 参数配置.增长
        return _外参接口冖冖分流囗囗树形态囗(sf, sf.外参接口冖冖巜压入节点囗囗光杆树囗, sf.外参接口冖冖巜压入节点囗囗根深树囗, 双侧展翅树, 节点, 左端丷右端=左端丷右端, 参数配置=参数配置, 深度=深度)
    ######################
    def 外参接口冖冖巜压入节点囗囗光杆树囗(sf, 光杆树, 节点, /, *, 左端丷右端, 参数配置, 深度):
        '-> (双侧展翅树<深度>, None)'
        assert 参数配置.增长
        kw2 = dict(参数配置=参数配置, 深度=深度)
        光杆树屮均衡双翼 = sf.外参接口冖冖压入节点囗囗光杆树囗囗溢出时分裂成均衡双翼囗(光杆树, 节点, 左端丷右端=左端丷右端, **kw2)
        双侧展翅树 = sf.外参接口冖冖拼装巛光杆树屮均衡双翼囗(光杆树屮均衡双翼, **kw2)
        return 双侧展翅树, None
    ######################
    def 外参接口冖冖巜压入节点囗囗根深树囗(sf, 根深树, 节点, /, *, 左端丷右端, 参数配置, 深度):
        '-> (双侧展翅树<深度>, None)'
        assert 参数配置.增长
        kw2 = dict(参数配置=参数配置, 深度=深度)
        kw3 = dict(左起丷右起=左端丷右端, **kw2)
        左翼丷右翼 = 左端丷右端#起翼
        kwA = dict(左翼丷右翼=左翼丷右翼, **kw2)
        (起翼, 更深树, 讫翼) = sf.外参接口冖冖拆包囗根深树囗囗相对定位囗(根深树, **kw3)
        起翼, 魊更深节点 = sf.外参接口冖冖巜外端压入节点囗囗翅膀囗囗溢出时异端弹出更深节点囗囗绝对定位囗(起翼, 节点, **kwA)
        if 魊更深节点:
            [更深节点] = 魊更深节点
            更深树, _ = sf.外参接口冖冖巜压入节点囗囗双侧展翅树囗(更深树, 更深节点, 左端丷右端=左端丷右端, **_更深囗(kw2))
        双侧展翅树 = 根深树 = sf.外参接口冖冖构造囗根深树囗囗相对定位囗(起翼, 更深树, 讫翼, **kw3)
        return 双侧展翅树, None
    ######################
    ######################
    #巜弹出节点囗囗双侧展翅树囗#空树报错丷魊
    def 外参接口冖冖巜弹出节点囗囗双侧展翅树囗(sf, 双侧展翅树, /, *, 空树报错丷魊, 左端丷右端, **kw2):
        '-> (双侧展翅树<深度>, ((节点|^错误) if not 空树报错丷魊 else 魊节点))'
        双侧展翅树, 魊节点 = sf.外参接口冖冖巜弹出魊节点囗囗双侧展翅树囗(双侧展翅树, 左端丷右端=左端丷右端, **kw2)
        if 空树报错丷魊:
            return (双侧展翅树, 魊节点)
        if 魊节点:
            [节点] = 魊节点
            return (双侧展翅树, 节点)
        raise 错误囗囗空树囗囗光杆树
    ######################
    def 外参接口冖冖巜弹出魊节点囗囗双侧展翅树囗(sf, 双侧展翅树, /, *, 左端丷右端, 参数配置, 深度):
        '-> (双侧展翅树<深度>, 魊节点)'
        assert 参数配置.缩水
        return _外参接口冖冖分流囗囗树形态囗(sf, sf.外参接口冖冖巜弹出魊节点囗囗光杆树囗, sf.外参接口冖冖巜弹出魊节点囗囗根深树囗, 双侧展翅树, 左端丷右端=左端丷右端, 参数配置=参数配置, 深度=深度)
    ######################
    def 外参接口冖冖巜弹出魊节点囗囗光杆树囗(sf, 光杆树, /, *, 左端丷右端, **kw2):
        '-> (双侧展翅树<深度>, 魊节点)'
        if sf.外参接口冖冖是空树囗囗光杆树囗(光杆树, **kw2):
            魊节点 = null_tuple
        else:
            光杆树, 节点 = sf.外参接口冖冖巜弹出节点囗囗光杆树囗囗缺员时未定义囗(光杆树, 左端丷右端=左端丷右端, **kw2)
            魊节点 = (节点,)
        return (光杆树, 魊节点)
    ######################
    def 外参接口冖冖巜弹出魊节点囗囗根深树囗(sf, 根深树, /, *, 左端丷右端, 参数配置, 深度):
        '-> (双侧展翅树<深度>, 魊节点)'
        assert 参数配置.缩水
        kw2 = dict(参数配置=参数配置, 深度=深度)
        kw3 = dict(左起丷右起=左端丷右端, **kw2)
        左翼丷右翼 = 左端丷右端#起翼
        kwA = dict(左翼丷右翼=左翼丷右翼, **kw2)
        (起翼, 更深树, 讫翼) = sf.外参接口冖冖拆包囗根深树囗囗相对定位囗(根深树, **kw3)

        L = sf.外参接口冖冖取囗长度囗囗翅膀囗囗绝对定位囗(起翼, **kwA)
        if not L == 参数配置.翅膀最小许可长度:
            if not L > 参数配置.翅膀最小许可长度:raise 000
            起翼, 节点 = sf.外参接口冖冖巜外端弹出节点囗囗翅膀囗囗缺员时未定义囗囗绝对定位囗(起翼, **kwA)
            完成 = True
        else:
            完成 = False
            更深树, 魊更深节点 = sf.外参接口冖冖巜弹出节点囗囗双侧展翅树囗(更深树, 空树报错丷魊=True, 左端丷右端=左端丷右端, **_更深囗(kw2))
        if 完成:
            pass
        elif 魊更深节点:
            [更深节点] = 魊更深节点
            起翼, 节点 = sf.外参接口冖冖巜先内端压入更深节点再外端弹出节点囗囗翅膀囗囗临界缺员囗囗绝对定位囗(起翼, 更深节点, **kwA)
            完成 = True
        if 完成:
            双侧展翅树 = 根深树 = sf.外参接口冖冖构造囗根深树囗囗相对定位囗(起翼, 更深树, 讫翼, **kw3)
        else:
            光杆树, 节点 = sf.外参接口冖冖弹出节点囗空心树退化成光杆树囗囗相对定位囗(起翼, 讫翼, 左端丷右端=左端丷右端, **kw3)
            双侧展翅树 = 光杆树
        双侧展翅树
        魊节点 = (节点,)
        return (双侧展翅树, 魊节点)

    ######################
    #巜连续压入节点囗囗双侧展翅树囗#次序
    def 外参接口冖冖巜连续压入节点囗囗双侧展翅树囗(sf, 双侧展翅树, 节点序列, /, *, 左起丷右起, 左端丷右端, 参数配置, 深度):
        '双侧展翅树<深度> -> 节点序列<左起丷右起> -> (双侧展翅树<深度>, None)'
        assert 参数配置.增长
        assert 参数配置.增长防板荡
        kw2 = dict(参数配置=参数配置, 深度=深度)
        if is4bool_(左起丷右起, 左端丷右端):
            #reversed
            try:
                节点序列 = reversed(节点序列)
            except TypeError:
                pass
            else:
                左起丷右起 = not 左起丷右起

        if 左起丷右起 is 左端丷右端:
            #reversed
            异侧树 = 空树 = sf.外参接口冖冖构造囗空树囗(**kw2)
            异侧树, _ = sf.外参接口冖冖巜连续压入节点囗囗双侧展翅树囗(异侧树, 节点序列, 左起丷右起=左起丷右起, 左端丷右端=not 左端丷右端, **kw2)
            双侧展翅树, _ = sf.外参接口冖冖巜合并囗囗双侧展翅树囗(双侧展翅树, 异侧树, 左起丷右起=not 左端丷右端, **kw2)
        else:
            kw = dict(kw2, 左端丷右端=左端丷右端)
            for 节点 in 节点序列:
                双侧展翅树, _ = sf.外参接口冖冖巜压入节点囗囗双侧展翅树囗(双侧展翅树, 节点, **kw)
        return 双侧展翅树, None
    ######################
    #巜弹出节点列表囗囗双侧展翅树囗#次序,最大弹出数目
    def 外参接口冖冖巜弹出节点构成树囗囗双侧展翅树囗(sf, 双侧展翅树, 最大弹出数目, /, *, 左起丷右起, 左端丷右端, **kw2):
        '双侧展翅树<深度> -> 最大弹出数目/int -> (剩/双侧展翅树<深度>, 出/双侧展翅树<左起丷右起>)'
        #用于 『分裂』
        _ = key_as_attr(kw2)
        参数配置 = _.参数配置
        assert 参数配置.缩水
        assert 参数配置.缩水防板荡
        输出 = 空树 = sf.外参接口冖冖构造囗空树囗(**kw2)
        kw = dict(左端丷右端=左端丷右端, **kw2)
        _kw = dict(左端丷右端=not 左起丷右起, **kw2)
        for _ in range(最大弹出数目):
            双侧展翅树, 魊节点 = sf.外参接口冖冖巜弹出魊节点囗囗双侧展翅树囗(双侧展翅树, **kw)
            if 魊节点:
                [节点] = 魊节点
                输出, _ = sf.外参接口冖冖巜压入节点囗囗双侧展翅树囗(输出, 节点, **_kw)
            else:
                break
        return 双侧展翅树, 输出
    ######################
    def 外参接口冖冖巜弹出节点列表囗囗双侧展翅树囗(sf, 双侧展翅树, 最大弹出数目, /, *, 左起丷右起, 左端丷右端, **kw2):
        '双侧展翅树<深度> -> 最大弹出数目/int -> (双侧展翅树<深度>, 节点列表<左起丷右起>)'
        _ = key_as_attr(kw2)
        参数配置 = _.参数配置
        assert 参数配置.缩水
        assert 参数配置.缩水防板荡
        ls = []
        for _ in range(最大弹出数目):
            双侧展翅树, 魊节点 = sf.外参接口冖冖巜弹出魊节点囗囗双侧展翅树囗(双侧展翅树, 左端丷右端=左端丷右端, **kw2)
            if 魊节点:
                [节点] = 魊节点
                ls.append(节点)
            else:
                break
        if not is4bool_(左起丷右起, 左端丷右端):
            ls.reverse()
        return 双侧展翅树, ls
    ######################
    #巜同端先弹出再压入节点囗囗双侧展翅树囗#更换端点
    def 外参接口冖冖巜同端先弹出再压入节点囗囗双侧展翅树囗(sf, 双侧展翅树, 节点, /, *, 左端丷右端, **kw2):
        '-> (双侧展翅树, 节点)'
        return _外参接口冖冖分流囗囗树形态囗(sf, sf.外参接口冖冖巜同端先弹出再压入节点囗囗光杆树囗, sf.外参接口冖冖巜同端先弹出再压入节点囗囗根深树囗, 双侧展翅树, 节点, 左端丷右端=左端丷右端, **kw2)
    ######################
    def 外参接口冖冖巜同端先弹出再压入节点囗囗根深树囗(sf, 根深树, 节点, /, *, 左端丷右端, **kw2):
        '-> (双侧展翅树, 节点)'
        (起翼, 更深树, 讫翼) = sf.外参接口冖冖拆包囗根深树囗囗相对定位囗(根深树, 左起丷右起=左端丷右端, **kw2)
        起翼, 节点 = sf.外参接口冖冖巜外端先弹出再压入节点囗囗翅膀囗囗绝对定位囗(起翼, 节点, 左翼丷右翼=左端丷右端, **kw2)
        双侧展翅树 = 根深树 = sf.外参接口冖冖构造囗根深树囗囗相对定位囗(起翼, 更深树, 讫翼, 左起丷右起=左端丷右端, **kw2)
        return 双侧展翅树, 节点
    ######################
    #巜先讫端压入再起端弹出节点囗囗双侧展翅树囗#保长流动,允空
    def 外参接口冖冖巜先讫端压入再起端弹出节点囗囗双侧展翅树囗(sf, 双侧展翅树, 节点, /, **kw3):
        '-> (双侧展翅树, 节点)'
        return _外参接口冖冖分流囗囗树形态囗(sf, sf.外参接口冖冖巜先讫端压入再起端弹出节点囗囗光杆树囗, sf.外参接口冖冖巜先讫端压入再起端弹出节点囗囗根深树囗, 双侧展翅树, 节点, **kw3)
    ######################
    def 外参接口冖冖巜先讫端压入再起端弹出节点囗囗光杆树囗(sf, 光杆树, 节点, /, **kw3):
        '-> (双侧展翅树, 节点)'
        if sf.外参接口冖冖是空树囗囗光杆树囗(光杆树, **_to_kw2(kw3)):
            pass
        else:
            光杆树, 节点 = sf.外参接口冖冖巜起端弹出讫端压入节点囗囗光杆树囗囗缺员时未定义囗(光杆树, **kw3)
        return 光杆树, 节点
    ######################
    def 外参接口冖冖巜先讫端压入再起端弹出节点囗囗根深树囗(sf, 根深树, 节点, /, 左起丷右起, **kw2):
        '-> (双侧展翅树, 节点)'
        双侧展翅树, _ = sf.外参接口冖冖巜压入节点囗囗双侧展翅树囗(双侧展翅树, 节点, 左端丷右端=not 左起丷右起, **kw2)
            #讫端
        双侧展翅树, 节点 = sf.外参接口冖冖巜弹出节点囗囗双侧展翅树囗(双侧展翅树, 空树报错丷魊=True, 左端丷右端=左起丷右起, **kw2)
            #起端
        return 双侧展翅树, 节点
    ######################
    #构造囗双侧展翅树囗
    def 外参接口冖冖构造囗双侧展翅树囗(sf, 节点序列, /, *, 左起丷右起, **kw2):
        '-> 双侧展翅树<深度>'
        双侧展翅树 = 空树 = sf.外参接口冖冖构造囗空树囗(**kw2)
        双侧展翅树, _ = sf.外参接口冖冖巜连续压入节点囗囗双侧展翅树囗(双侧展翅树, 节点序列, 左起丷右起=左起丷右起, 左端丷右端=not 左起丷右起, **kw2)
        return 双侧展翅树
    ######################
    #巜合并囗囗双侧展翅树囗囗间夹囗节点序列囗
    def 外参接口冖冖巜合并囗囗双侧展翅树囗囗间夹囗节点序列囗(sf, 起囗双侧展翅树, 节点数目, 节点序列, 讫囗双侧展翅树, /, *, 左起丷右起, **kw2):
        '起/双侧展翅树<深度> -> 节点数目 -> 节点序列<左起丷右起;深度>{len=节点数目} -> 讫/双侧展翅树<深度> -> 双侧展翅树<深度> # 左起丷右起 - 即是 节点序列 的次序，也是 三元组『(起树,节点序列,讫树)』的次序，但不影响 树内部次序; 依照 迭代次序=>先将 中间节点 压入 起树'
        _ = key_as_attr(kw2)
        参数配置 = _.参数配置
        assert 参数配置.增长合并
        assert 参数配置.紧致假设
        check_int_ge(0, 节点数目)
        if 节点数目 == 0:
            for _ in 节点序列:
                raise 错误(f'有误:节点数目=={节点数目}')
        ######################
        起是光杆 = not sf.外参接口冖冖区分树形态囗(起囗双侧展翅树, **kw2)
        讫是光杆 = not sf.外参接口冖冖区分树形态囗(讫囗双侧展翅树, **kw2)
        if not 起是光杆 and not 讫是光杆:
            return sf.外参接口冖冖巜合并囗囗根深树囗囗间夹囗节点序列囗(起囗双侧展翅树, 节点数目, 节点序列, 讫囗双侧展翅树, 左起丷右起=左起丷右起, **kw2)
        assert 起是光杆 or 讫是光杆
        if 节点数目 > 0:
            #光杆树 出现:基本情形:直接注入，无需下沉
            起囗双侧展翅树, _ = sf.外参接口冖冖巜连续压入节点囗囗双侧展翅树囗(起囗双侧展翅树, 节点序列, 左起丷右起=左起丷右起, 左端丷右端=not 左起丷右起, **kw2)
            节点序列 = null_iter
            节点数目 = 0
            #可能 起 不再是 光杆树
            return sf.外参接口冖冖巜合并囗囗双侧展翅树囗囗间夹囗节点序列囗(起囗双侧展翅树, 0, null_iter, 讫囗双侧展翅树, 左起丷右起=左起丷右起, **kw2)

        elif 起是光杆 and 讫是光杆:
            assert 节点数目 == 0
            return sf.外参接口冖冖巜合并囗囗光杆树囗囗相对定位囗(起囗双侧展翅树, 讫囗双侧展翅树, 左起丷右起=左起丷右起, **kw2)

        elif 起是光杆 and not 讫是光杆:
            小树 = 起囗双侧展翅树
            大树 = 讫囗双侧展翅树
            左小丷右小 = 左起丷右起
        elif not 起是光杆 and 讫是光杆:
            小树 = 讫囗双侧展翅树
            大树 = 起囗双侧展翅树
            左小丷右小 = not 左起丷右起
        else:
            raise 000
        assert 节点数目 == 0
            #此后:左起丷右起 只作用于二元组『(起树,讫树)』
            #   也就是可以 转化为『(左翼,右翼)』而无需顾及 中间节点序列的迭代次序
        assert 起是光杆 ^ 讫是光杆
        左小丷右小
        左起丷右起 = not 左小丷右小
        小囗节点序列 = sf.外参接口冖冖迭代囗子节点囗囗光杆树囗(小树, 左起丷右起=左起丷右起, **kw2)
        左端丷右端 = not 左起丷右起
        return sf.外参接口冖冖巜连续压入节点囗囗双侧展翅树囗(大树, 小囗节点序列, 左起丷右起=左起丷右起, 左端丷右端=左端丷右端, **kw2)

            # 注入
    ######################
    def 外参接口冖冖巜合并囗囗光杆树囗囗相对定位囗(sf, 起囗光杆树, 讫囗光杆树, /, *, 左起丷右起, **kw2):
        '起/光杆树<深度> -> 讫/光杆树<深度> -> (双侧展翅树<深度>, None)'
        左囗光杆树, 右囗光杆树 = _调整次序囗(起囗光杆树, 讫囗光杆树, 左起丷右起=左起丷右起)
        m = sf.外参接口冖冖彳忄亍囗巜合并囗囗光杆树囗囗绝对定位囗(左囗光杆树, 右囗光杆树, **kw2)
        if m is not NotImplemented:
            return m
        起长 = sf.外参接口冖冖取囗长度囗囗光杆树囗(起囗光杆树, **kw2)
        讫长 = sf.外参接口冖冖取囗长度囗囗光杆树囗(讫囗光杆树, **kw2)
        if 起长 < 讫长:
            小树 = 起囗光杆树
            大树 = 讫囗光杆树
            左小丷右小 = 左起丷右起
        else:
            小树 = 讫囗光杆树
            大树 = 起囗光杆树
            左小丷右小 = not 左起丷右起
        左小丷右小
        左起丷右起 = not 左小丷右小
        小囗节点序列 = sf.外参接口冖冖迭代囗子节点囗囗光杆树囗(小树, 左起丷右起=左起丷右起, **kw2)
        左端丷右端 = not 左起丷右起
        return sf.外参接口冖冖巜连续压入节点囗囗双侧展翅树囗(大树, 小囗节点序列, 左起丷右起=左起丷右起, 左端丷右端=左端丷右端, **kw2)
            # 注入
    ######################
    def 外参接口冖冖巜合并囗囗光杆树囗囗绝对定位囗(sf, 左囗光杆树, 右囗光杆树, /, **kw2):
        '左/光杆树<深度> -> 右/光杆树<深度> -> (双侧展翅树<深度>, None)'
        return sf.外参接口冖冖巜合并囗囗光杆树囗囗相对定位囗(左囗光杆树, 右囗光杆树, 左起丷右起=False, **kw2)
    ######################
    def 外参接口冖冖巜合并囗囗根深树囗囗间夹囗节点序列囗(sf, 起囗根深树, 节点数目, 节点序列, 讫囗根深树, /, **kw3):
        '起/双侧展翅树<深度> -> 节点数目 -> 节点序列<左起丷右起;深度>{len=节点数目} -> 讫/双侧展翅树<深度> -> 双侧展翅树<深度>'
        (起囗起翼, 起囗更深树, 起囗讫翼) = sf.外参接口冖冖拆包囗根深树囗囗相对定位囗(起囗根深树, **kw3)
        (讫囗起翼, 讫囗更深树, 讫囗讫翼) = sf.外参接口冖冖拆包囗根深树囗囗相对定位囗(讫囗根深树, **kw3)
        更深节点数目, 更深节点序列 = sf.外参接口冖冖下沉囗异心双翼囗囗间夹囗节点序列囗(起囗讫翼, 节点数目, 节点序列, 讫囗起翼, **kw3)
        更深树, _ = sf.外参接口冖冖巜合并囗囗双侧展翅树囗囗间夹囗节点序列囗(起囗更深树, 更深节点数目, 更深节点序列, 讫囗更深树, **_更深囗(kw3))
        双侧展翅树 = 根深树 = sf.外参接口冖冖构造囗根深树囗囗相对定位囗(起囗起翼, 更深树, 讫囗讫翼, **kw3)
        return 双侧展翅树, None

    ######################
    #巜合并囗囗双侧展翅树囗
    def 外参接口冖冖巜合并囗囗双侧展翅树囗(sf, 起囗双侧展翅树, 讫囗双侧展翅树, /, **kw3):
        '起/双侧展翅树<左起丷右起;深度> -> 讫/双侧展翅树<左起丷右起=not 左起丷右起,深度> -> (双侧展翅树<深度>, None)'
        return sf.外参接口冖冖巜合并囗囗双侧展翅树囗囗间夹囗节点序列囗(起囗双侧展翅树, 0, null_iter, 讫囗双侧展翅树, **kw3)
    ######################
    ######################
    ######################
    ######################
    ######################
    ######################
    ######################
    ######################
    ######################
    ######################
    ######################
    ######################
    ######################
    #巜分裂囗囗搜索定位囗囗焦点囗#无焦点报错丷魊
    ######################
    def 外参接口冖冖分裂囗囗定位囗魊焦点囗囗返回值依起讫次序囗囗精简版囗囗双侧展翅树囗(sf, 双侧展翅树, 初始累计值, 魊累积囗丨丮抽取差分囗丶累积囗丶退进决断囗丶已知初始累计值决断进厈, /, *, 已知焦点存在, **kw3):
        '-> (焦点居前囗双侧展翅树<左起丷右起;深度>, 焦点居前囗累计值/累计值, 焦点诸后囗双侧展翅树<左起丷右起;深度>)'
        ([焦点居前囗双侧展翅树], 焦点居前囗累计值, [焦点诸后囗双侧展翅树], [], []) = sf.外参接口冖冖分裂囗囗定位囗魊焦点囗囗全魊囗囗双侧展翅树囗(双侧展翅树, 初始累计值, 魊累积囗丨丮抽取差分囗丶累积囗丶退进决断囗丶已知初始累计值决断进厈, 已知焦点存在=已知焦点存在, 是否需囗焦点居前囗起半扇=True, 是否需囗焦点诸后囗讫半扇=True, 是否需囗焦点=False, 是否需囗焦点居后囗讫半扇=False, **kw3)
        return (焦点居前囗双侧展翅树, 焦点居前囗累计值, 焦点诸后囗双侧展翅树)





    ######################
    def 外参接口冖冖分裂囗囗定位囗魊焦点囗囗全魊囗囗双侧展翅树囗(sf, 双侧展翅树, 初始累计值, 魊累积囗丨丮抽取差分囗丶累积囗丶退进决断囗丶已知初始累计值决断进厈, /, *, 已知焦点存在, 是否需囗焦点居前囗起半扇, 是否需囗焦点诸后囗讫半扇, 是否需囗焦点, 是否需囗焦点居后囗讫半扇, 左起丷右起, 参数配置, 深度):
        r'''[[[
        :: 双侧展翅树 -> 初始累计值 -> (魊累积囗 | (may 抽取差分囗, may 累积囗, (退进决断囗|最大许可累计值<起树>), 已知初始累计值决断进/bool)) -> (魊囗焦点居前囗双侧展翅树, 焦点居前囗累计值, 魊囗焦点诸后囗双侧展翅树, 魊囗魊中间焦点, 魊囗焦点居后囗双侧展翅树)

        ===
        后置条件:
            [在许可情形下，最大化 起树]
        ===
        * 情形囗魊:
            魊累积囗
            [魊累积囗 :: 累计值 -> 缓存度量 -> 魊 累计值]
            后置条件:[存在 焦点居前囗累计值/即 起树居后囗累计值]
                #最大化 起树
            前置条件:
                对 初始累计值 无约束

        ===
        * 情形囗条件判断:
            (抽取差分囗,累积囗,退进决断囗,已知初始累计值决断进/bool)
            [抽取差分囗 :: 缓存度量 -> 差分值]
            [累积囗 :: 累计值 -> 差分值 -> 累计值]
            [退进决断囗 :: 累计值 -> 退丷进]
            后置条件:
                [[焦点不存在] -> [焦点居前囗累计值 === 累计值囗囗整树]]
                [退进决断囗(焦点居前囗累计值) === True]#进
            前置条件:
                [退进决断囗(初始累计值) === True]#进
            [[推导过程:[后置条件->前置条件]:
            !! [[焦点不存在] -> [焦点居前囗累计值 === 累计值囗囗整树]]
            !! [[空树] -> [焦点不存在]]
            [[空树] -> [焦点居前囗累计值 === 累计值囗囗整树 === 累计值囗囗空树 === 初始累计值]]
            [空树]:
                [焦点居前囗累计值 === 初始累计值]
                !! [退进决断囗(焦点居前囗累计值) === True]#进
                [退进决断囗(初始累计值) === True]#进
            [退进决断囗(初始累计值) === True]#进
            !推导完毕!
            ]]

        #]]]'''#'''
        魊累积囗 = 转化为囗魊累积囗巛丨丮累积囗丶退进决断囗丶已知初始累计值决断进厈囗(初始累计值, 魊累积囗丨丮抽取差分囗丶累积囗丶退进决断囗丶已知初始累计值决断进厈)
        ######################
        assert 参数配置.缩水分裂#==>>断肢再造,滴血重生
        check_type_is(bool, 已知焦点存在)
        assert not (是否需囗焦点诸后囗讫半扇 and 是否需囗焦点居后囗讫半扇) # <<== 可以有，但只能在最顶层，为避免误用，直接禁用
        if not 已知焦点存在:
            kw2 = _to_kw2(locals())
            整树 = 双侧展翅树
            已知焦点不存在 = sf.外参接口冖冖是空树囗囗双侧展翅树囗(整树, **kw2)
            if 已知焦点不存在:
                累计值囗囗整树 = 初始累计值
        if not 已知焦点存在 and not 已知焦点不存在:
            缓存度量囗囗整树 = sf.外参接口冖冖取囗缓存度量囗囗双侧展翅树囗(整树, **kw2)
            魊累计值囗囗整树 = 魊累积囗(初始累计值, 缓存度量囗囗整树)
            焦点存在 = not 魊累计值囗囗整树
            已知焦点存在 = 焦点存在
            已知焦点不存在 = not 焦点存在
            #if 魊累计值囗囗整树:
            if not 焦点存在:
                [累计值囗囗整树] = 魊累计值囗囗整树
        if not 已知焦点存在:
            assert 已知焦点不存在
            整树
            累计值囗囗整树
            空树 = sf.外参接口冖冖构造囗空树囗(**kw2)
            焦点居前囗双侧展翅树 = 整树
            焦点诸后囗双侧展翅树 = 空树
            焦点居后囗双侧展翅树 = 空树
            焦点居前囗累计值 = 累计值囗囗整树
            魊囗焦点 = null_tuple
            ######################
            魊囗焦点居前囗双侧展翅树 = _魊若囗(是否需囗焦点居前囗起半扇, 焦点居前囗双侧展翅树)
            魊囗焦点诸后囗双侧展翅树 = _魊若囗(是否需囗焦点诸后囗讫半扇, 焦点诸后囗双侧展翅树)
            魊囗魊中间焦点 = _魊若囗(是否需囗焦点, 魊囗焦点)
            魊囗焦点居后囗双侧展翅树 = _魊若囗(是否需囗焦点居后囗讫半扇, 焦点居后囗双侧展翅树)
            ######################
            return (魊囗焦点居前囗双侧展翅树, 焦点居前囗累计值, 魊囗焦点诸后囗双侧展翅树, 魊囗魊中间焦点, 魊囗焦点居后囗双侧展翅树)

        assert 已知焦点存在
        kwm__kw3 = _to_kwm__kw3(locals())
        (魊囗焦点居前囗双侧展翅树, 焦点居前囗累计值, 魊囗焦点诸后囗双侧展翅树, 魊囗焦点, 魊囗焦点居后囗双侧展翅树) = sf.外参接口冖冖分裂囗囗定位囗焦点囗囗全魊囗囗焦点不存在时未定义囗囗双侧展翅树囗(双侧展翅树, 初始累计值, 魊累积囗, **kwm__kw3)
        魊囗魊中间焦点 = _魊若囗(是否需囗焦点, 魊囗焦点)
        return (魊囗焦点居前囗双侧展翅树, 焦点居前囗累计值, 魊囗焦点诸后囗双侧展翅树, 魊囗魊中间焦点, 魊囗焦点居后囗双侧展翅树)



    ######################
    def 外参接口冖冖分裂囗囗定位囗焦点囗囗全魊囗囗焦点不存在时未定义囗囗双侧展翅树囗(sf, 双侧展翅树, 初始累计值, 魊累积囗, /, **kwm__kw3):
        '-> (魊囗焦点居前囗双侧展翅树, 焦点居前囗累计值, 魊囗焦点诸后囗双侧展翅树, 魊囗焦点, 魊囗焦点居后囗双侧展翅树)'
        _ = key_as_attr(kwm__kw3)
        是否需囗焦点诸后囗讫半扇 = _.是否需囗焦点诸后囗讫半扇
        是否需囗焦点居后囗讫半扇 = _.是否需囗焦点居后囗讫半扇
        assert not (是否需囗焦点诸后囗讫半扇 and 是否需囗焦点居后囗讫半扇) # <<== 可以有，但只能在最顶层，为避免误用，直接禁用
        return _外参接口冖冖分流囗囗树形态囗(sf, sf.外参接口冖冖分裂囗囗定位囗焦点囗囗全魊囗囗焦点不存在时未定义囗囗光杆树囗, sf.外参接口冖冖分裂囗囗定位囗焦点囗囗全魊囗囗焦点不存在时未定义囗囗根深树囗, 双侧展翅树, 初始累计值, 魊累积囗, **kwm__kw3)
    ######################
    ######################
    ######################
    def 外参接口冖冖分裂囗囗定位囗焦点囗囗全魊囗囗焦点不存在时未定义囗囗光杆树囗(sf, 光杆树, 初始累计值, 魊累积囗, /, **kwm__kw3):
        '-> (魊囗焦点居前囗双侧展翅树, 焦点居前囗累计值, 魊囗焦点诸后囗双侧展翅树, 魊囗焦点, 魊囗焦点居后囗双侧展翅树)'
        _ = key_as_attr(kwm__kw3)
        是否需囗焦点诸后囗讫半扇 = _.是否需囗焦点诸后囗讫半扇
        是否需囗焦点居后囗讫半扇 = _.是否需囗焦点居后囗讫半扇
        assert not (是否需囗焦点诸后囗讫半扇 and 是否需囗焦点居后囗讫半扇) # <<== 可以有，但只能在最顶层，为避免误用，直接禁用
        (魊囗焦点居前囗起半扇, 焦点居前囗累计值, 魊囗焦点诸后囗讫半扇, 魊囗焦点, 魊囗焦点居后囗讫半扇) = sf.外参接口冖冖示意分裂囗囗焦点不存在时未定义囗囗半扇版囗囗光杆树囗(光杆树, 初始累计值, 魊累积囗, **kwm__kw3)
        kw3 = _to_kw3(kwm__kw3)
        魊囗焦点居前囗双侧展翅树 = _魊变囗(sf.外参接口冖冖拼装巛光杆树半扇囗囗相对定位囗, 魊囗焦点居前囗起半扇, 起半扇丷讫半扇=False, **kw3)
        魊囗焦点诸后囗双侧展翅树 = _魊变囗(sf.外参接口冖冖拼装巛光杆树半扇囗囗相对定位囗, 魊囗焦点诸后囗讫半扇, 起半扇丷讫半扇=True, **kw3)
        魊囗焦点
        魊囗焦点居后囗双侧展翅树 = _魊变囗(sf.外参接口冖冖拼装巛光杆树半扇囗囗相对定位囗, 魊囗焦点居后囗讫半扇, 起半扇丷讫半扇=True, **kw3)
        return (魊囗焦点居前囗双侧展翅树, 焦点居前囗累计值, 魊囗焦点诸后囗双侧展翅树, 魊囗焦点, 魊囗焦点居后囗双侧展翅树)
    ######################
    ######################
    def 外参接口冖冖分裂囗囗定位囗焦点囗囗全魊囗囗焦点不存在时未定义囗囗根深树囗(sf, 根深树, 初始累计值, 魊累积囗, /, **kwm__kw3):
        '-> (魊囗焦点居前囗双侧展翅树, 焦点居前囗累计值, 魊囗焦点诸后囗双侧展翅树, 魊囗焦点, 魊囗焦点居后囗双侧展翅树)'
        _ = key_as_attr(kwm__kw3)
        左起丷右起 = _.左起丷右起
        是否需囗焦点诸后囗讫半扇 = _.是否需囗焦点诸后囗讫半扇
        是否需囗焦点居后囗讫半扇 = _.是否需囗焦点居后囗讫半扇
        assert not (是否需囗焦点诸后囗讫半扇 and 是否需囗焦点居后囗讫半扇) # <<== 可以有，但只能在最顶层，为避免误用，直接禁用
        kw3 = _to_kw3(kwm__kw3)
        kw2 = _to_kw2(kwm__kw3)
        (起翼, 更深树, 讫翼) = sf.外参接口冖冖拆包囗根深树囗囗相对定位囗(根深树, **kw3)

        ######################
        (起翼, 更深树, 讫翼)
        ######################
        缓存度量囗囗起翼 = sf.外参接口冖冖取囗缓存度量囗囗翅膀囗囗相对定位囗(起翼, 起翼丷讫翼=False, **kw3)
        魊累计值囗囗起翼之后 = 魊累积囗(初始累计值, 缓存度量囗囗起翼)
        if not 魊累计值囗囗起翼之后:
            # 焦点在起翼
            #起翼丷讫翼 = False
            左翼丷右翼 = 左起丷右起#起翼
            (魊囗焦点居前囗起半扇, 焦点居前囗累计值, 魊囗焦点诸后囗讫半扇, 魊囗焦点, 魊囗焦点居后囗讫半扇) = sf.外参接口冖冖示意分裂囗囗焦点不存在时未定义囗囗半扇版囗囗翅膀囗囗绝对定位囗囗绝对定位囗(起翼, 初始累计值, 魊累积囗, 左翼丷右翼=左翼丷右翼, **kwm__kw3)
            ########
            魊囗焦点居前囗双侧展翅树 = _魊变囗(sf.外参接口冖冖拼装巛翅膀外端半扇囗囗绝对定位囗囗补全囗, 魊囗焦点居前囗起半扇, 左翼丷右翼=左翼丷右翼, **kw2)
                # 起半扇[不含焦点]
            魊囗焦点诸后囗双侧展翅树 = _魊变囗(sf.外参接口冖冖拼装巛翅膀内端半扇囗, 魊囗焦点诸后囗讫半扇, 更深树, 讫翼, 左翼丷右翼=左翼丷右翼, **kw2)
                # ([含焦点]讫半扇, 更深树, 讫翼)
            魊囗焦点
            魊囗焦点居后囗双侧展翅树 = _魊变囗(sf.外参接口冖冖拼装巛翅膀内端半扇囗, 魊囗焦点居后囗讫半扇, 更深树, 讫翼, 左翼丷右翼=左翼丷右翼, **kw2)
                # ([不含焦点]讫半扇, 更深树, 讫翼)
            return (魊囗焦点居前囗双侧展翅树, 焦点居前囗累计值, 魊囗焦点诸后囗双侧展翅树, 魊囗焦点, 魊囗焦点居后囗双侧展翅树)
                #相对/起讫次序
                #不是:绝对/左右次序
                #_调整次序囗()
        ######################
        ######################
        ######################
        (起翼, 更深树, 讫翼)
        ######################
        [累计值囗囗起翼之后] = 魊累计值囗囗起翼之后

        整树空心 = sf.外参接口冖冖是空树囗囗双侧展翅树囗(更深树, **_更深囗(kw2))
        if 整树空心:
            魊累计值囗囗讫翼之前 = 魊累计值囗囗起翼之后
        else:
            非空更深树 = 更深树
            缓存度量囗囗更深树 = sf.外参接口冖冖取囗缓存度量囗囗双侧展翅树囗(更深树, **_更深囗(kw2))
            魊累计值囗囗讫翼之前 = 魊累积囗(累计值囗囗起翼之后, 缓存度量囗囗更深树)
        魊累计值囗囗讫翼之前

        if 魊累计值囗囗讫翼之前:
            # 焦点在讫翼
            #   !! 已知焦点存在
            #起翼丷讫翼 = True
            左翼丷右翼 = not 左起丷右起#讫翼
            [累计值囗囗讫翼之前] = 魊累计值囗囗讫翼之前
            (魊囗焦点居前囗起半扇, 焦点居前囗累计值, 魊囗焦点诸后囗讫半扇, 魊囗焦点, 魊囗焦点居后囗讫半扇) = sf.外参接口冖冖示意分裂囗囗焦点不存在时未定义囗囗半扇版囗囗翅膀囗囗绝对定位囗囗绝对定位囗(讫翼, 累计值囗囗讫翼之前, 魊累积囗, 左翼丷右翼=左翼丷右翼, **kwm__kw3)
            ########
            魊囗焦点居前囗双侧展翅树 = _魊变囗(sf.外参接口冖冖拼装巛翅膀内端半扇囗, 魊囗焦点居前囗起半扇, 更深树, 起翼, 左翼丷右翼=左翼丷右翼, **kw2)
                # (起翼, 更深树, 起半扇[不含焦点])
            魊囗焦点诸后囗双侧展翅树 = _魊变囗(sf.外参接口冖冖拼装巛翅膀外端半扇囗囗绝对定位囗囗补全囗, 魊囗焦点诸后囗讫半扇, 左翼丷右翼=左翼丷右翼, **kw2)
                # [含焦点]讫半扇
            魊囗焦点
            魊囗焦点居后囗双侧展翅树 = _魊变囗(sf.外参接口冖冖拼装巛翅膀外端半扇囗囗绝对定位囗囗补全囗, 魊囗焦点居后囗讫半扇, 左翼丷右翼=左翼丷右翼, **kw2)
                # [不含焦点]讫半扇
            return (魊囗焦点居前囗双侧展翅树, 焦点居前囗累计值, 魊囗焦点诸后囗双侧展翅树, 魊囗焦点, 魊囗焦点居后囗双侧展翅树)
                #相对/起讫次序
                #不是:绝对/左右次序


        assert not 魊累计值囗囗讫翼之前
            # 焦点在主干
        assert not 整树空心
        (魊囗起囗更深树, 更深焦点居前囗累计值, [], [更深焦点], 魊囗讫囗更深树) = sf.外参接口冖冖分裂囗囗定位囗焦点囗囗全魊囗囗焦点不存在时未定义囗囗双侧展翅树囗(非空更深树, 累计值囗囗起翼之后, 魊累积囗, **_更深囗(dict(kwm__kw3, 是否需囗焦点=True, 是否需囗焦点诸后囗讫半扇=False, 是否需囗焦点居后囗讫半扇=是否需囗焦点诸后囗讫半扇 or 是否需囗焦点居后囗讫半扇)))
            #kwm__kw3 修改:所有参数 相应于『深度+1』 而作改变
            #需要:更深焦点<<==因为是『更深焦点』而非『焦点』
            #取消『诸后』改为『居后』
        ######################
        (起翼, (魊囗起囗更深树, 更深焦点居前囗累计值, 更深焦点, 魊囗讫囗更深树), 讫翼)
        ######################
        #深度囗囗更深节点 = 深度##
        (魊囗焦点居前囗起半扇, 焦点居前囗累计值, 魊囗焦点诸后囗讫半扇, 魊囗焦点, 魊囗焦点居后囗讫半扇) = sf.外参接口冖冖示意分裂囗囗焦点不存在时未定义囗囗半扇版囗囗更深节点囗(更深焦点, 更深焦点居前囗累计值, 魊累积囗, **kwm__kw3)
            #kwm__kw3 不用改:所有参数 针对 『深度』
        ######################
        (起翼, (魊囗起囗更深树, (魊囗焦点居前囗起半扇, 焦点居前囗累计值, 魊囗焦点诸后囗讫半扇, 魊囗焦点, 魊囗焦点居后囗讫半扇), 魊囗讫囗更深树), 讫翼)
        ######################
        ((起翼, 魊囗起囗更深树, 魊囗焦点居前囗起半扇), 焦点居前囗累计值, (魊囗焦点诸后囗讫半扇, 魊囗焦点, 魊囗焦点居后囗讫半扇, 魊囗讫囗更深树, 讫翼))
        ######################
        (起翼, 魊囗起囗更深树, 魊囗焦点居前囗起半扇)
        if 魊囗焦点居前囗起半扇:
            [起囗更深树] = 魊囗起囗更深树
            左半扇丷右半扇 = 左起丷右起#起半扇
        else:
            起囗更深树 = 左半扇丷右半扇 = ...
        ########
        魊囗焦点居前囗双侧展翅树 = _魊变囗(sf.外参接口冖冖拼装巛更深节点半扇囗, 魊囗焦点居前囗起半扇, 起囗更深树, 起翼, 左半扇丷右半扇=左半扇丷右半扇, **kw2)
                # (起翼, 起囗更深树, 起半扇[不含焦点])
        ######################
        (魊囗焦点诸后囗讫半扇, 魊囗焦点, 魊囗焦点居后囗讫半扇, 魊囗讫囗更深树, 讫翼)
        if 魊囗焦点诸后囗讫半扇 or 魊囗焦点居后囗讫半扇:
            [讫囗更深树] = 魊囗讫囗更深树
            左半扇丷右半扇 = not 左起丷右起#讫半扇
        else:
            讫囗更深树 = 左半扇丷右半扇 = ...
        ########
        魊囗焦点诸后囗双侧展翅树 = _魊变囗(sf.外参接口冖冖拼装巛更深节点半扇囗, 魊囗焦点诸后囗讫半扇, 讫囗更深树, 讫翼, 左半扇丷右半扇=左半扇丷右半扇, **kw2)
                # ([含焦点]讫半扇, 讫囗更深树, 讫翼)
        魊囗焦点
        魊囗焦点居后囗双侧展翅树 = _魊变囗(sf.外参接口冖冖拼装巛更深节点半扇囗, 魊囗焦点居后囗讫半扇, 讫囗更深树, 讫翼, 左半扇丷右半扇=左半扇丷右半扇, **kw2)
                # ([不含焦点]讫半扇, 讫囗更深树, 讫翼)
        ######################
        return (魊囗焦点居前囗双侧展翅树, 焦点居前囗累计值, 魊囗焦点诸后囗双侧展翅树, 魊囗焦点, 魊囗焦点居后囗双侧展翅树)
            #相对/起讫次序
            #不是:绝对/左右次序

        ######################
        ######################

    #end-分裂囗囗搜索定位囗


    ######################
    ######################
    ######################

    ######################
    ######################

    ######################
    ######################
    ######################
    ######################
    ######################
    ######################
    ######################
    ######################
    ######################
#
    ######################
    ######################
    ######################
def _外参接口冖冖拼装巛半扇组织囗(sf
    ,取囗长度囗
    ,拼装囗囗足员囗
    ,拼装囗囗缺员囗囗厚势囗
    ,拼装囗囗缺员囗囗空心囗
    ,kw_ex
    , 半扇组织, 更深树, 异翅, /, *, 左起丷右起, 参数配置, 深度):
    '-> 双侧展翅树<深度> #左起丷右起 是 三元组『(半扇组织, 更深树, 异翅)』 的 方位次序' \
    ' #半扇组织===(翅膀内端半扇|更深节点半扇)'
    #外参接口冖冖拼装巛翅膀内端半扇囗:goto
    #外参接口冖冖拼装巛更深节点半扇囗:goto
    assert 参数配置.缩水分裂#==>>断肢再造,滴血重生
    kw2 = dict(参数配置=参数配置, 深度=深度)
    kw = dict(**kw2, **kw_ex)
    左翼丷右翼 = 左起丷右起#翅膀
    L = 取囗长度囗(半扇组织, **kw)
    if L >= 参数配置.翅膀最小许可长度:
        #足员
        翅膀 = 拼装囗囗足员囗(半扇组织, **kw)
        完成 = True
    #elif sf.外参接口冖冖是空树囗囗双侧展翅树囗(更深树, **_更深囗(kw2)):
        #缺员:厚势
    else:
        完成 = False
        左端丷右端 = 左翼丷右翼
        更深树, 魊更深节点 = sf.外参接口冖冖巜弹出节点囗囗双侧展翅树囗(更深树, 空树报错丷魊=True, 左端丷右端=左端丷右端, **_更深囗(kw2))
    if not 完成 and 魊更深节点:
        #缺员:厚势
        [更深节点] = 魊更深节点
        翅膀 = 拼装囗囗缺员囗囗厚势囗(半扇组织, 更深节点, **kw)
            #required:参数配置.缩水分裂#==>>断肢再造,滴血重生
        完成 = True
    if not 完成:
        #缺员:空心
        assert not 魊更深节点
        光杆树屮均衡双翼 = 拼装囗囗缺员囗囗空心囗(半扇组织, 异翅, **kw)
        双侧展翅树 = sf.外参接口冖冖拼装巛光杆树屮均衡双翼囗(光杆树屮均衡双翼, **kw2)
    else:
        双侧展翅树 = 根深树 = sf.外参接口冖冖构造囗根深树囗囗相对定位囗(翅膀, 更深树, 异翅, 左起丷右起=左起丷右起, **kw2)
    return 双侧展翅树
    ######################
def 转化为囗魊累积囗巛丨丮累积囗丶退进决断囗丶已知初始累计值决断进厈囗(初始累计值, 魊累积囗丨丮抽取差分囗丶累积囗丶退进决断囗丶已知初始累计值决断进厈, /):
    'see:外参接口冖冖分裂囗囗定位囗魊焦点囗囗全魊囗囗双侧展翅树囗'
    if type(魊累积囗丨丮抽取差分囗丶累积囗丶退进决断囗丶已知初始累计值决断进厈) is tuple:
        (抽取差分囗, 累积囗, 退进决断囗, 已知初始累计值决断进) = 魊累积囗丨丮抽取差分囗丶累积囗丶退进决断囗丶已知初始累计值决断进厈
        if 抽取差分囗 is None:
            抽取差分囗 = echo
        if 累积囗 is None:
            累积囗 = opss.__add__
        if not callable(退进决断囗):
            最大许可累计值囗囗起树 = 退进决断囗
            退进决断囗 = curry1(type(最大许可累计值囗囗起树).__ge__, 最大许可累计值囗囗起树)
        if not 已知初始累计值决断进:
            if not 退进决断囗(初始累计值):
                #退
                raise 错误(f'初始累计值 不满足 前置条件:{初始累计值}')
        def 魊累积囗(累计值, 缓存度量, /):
            '-> 魊 累计值'
            差分值 = 抽取差分囗(缓存度量)
            #if 0b0001:print_err(转化为囗魊累积囗巛丨丮累积囗丶退进决断囗丶已知初始累计值决断进厈囗, 抽取差分囗, (缓存度量, 差分值))
            #if 0b0001:print_err((累积囗, 累计值))
            累计值 = 累积囗(累计值, 差分值)
            退丷进 = 退进决断囗(累计值)
            return _魊若囗(退丷进, 累计值)
    else:
        魊累积囗 = 魊累积囗丨丮抽取差分囗丶累积囗丶退进决断囗丶已知初始累计值决断进厈
    return 魊累积囗
    ######################
#end-def _外参接口冖冖拼装巛半扇组织囗
#end-class 魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程
######################



__all__

from seed.data_funcs.finger_tree.finger_tree__external_packed_config import _to_kw2, _to_kw3, _to_kw3A, _to_kwA, _to_kwm__kw3
    #imported by:
        #view ../../python3_src/seed/data_funcs/finger_tree/finger_tree__EPC__default.py
from seed.data_funcs.finger_tree.finger_tree__external_packed_config import _调整次序囗, _更深囗, _惰魊若囗, _魊若囗, _魊变囗
    #imported by:
        #view ../../python3_src/seed/data_funcs/finger_tree/finger_tree__EPC__default.py

from seed.data_funcs.finger_tree.finger_tree__external_packed_config import 魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程囗囗囗囗基础囗无优化

from seed.data_funcs.finger_tree.finger_tree__external_packed_config import 魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程囗囗囗囗基础
from seed.data_funcs.finger_tree.finger_tree__external_packed_config import 魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程囗囗囗囗固化方法

from seed.data_funcs.finger_tree.finger_tree__external_packed_config import 魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程囗囗囗囗部分可优化方法缺省具现囗囗下沉囗异心双翼

from seed.data_funcs.finger_tree.finger_tree__external_packed_config import 魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程
from seed.data_funcs.finger_tree.finger_tree__external_packed_config import *

