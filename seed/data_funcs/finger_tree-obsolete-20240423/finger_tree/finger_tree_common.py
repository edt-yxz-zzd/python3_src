#__all__:goto
#约束集中出现处:goto
#约束推导分析:goto
#
#命名解释:goto
#   具名参数囗囗定义:kw2/kw3/...:见:finger_tree__external_packed_config.py
# 优化囗囗巨大囗最大许可长度:goto
#
#
#魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程
##obsolete:魖双侧展翅树囗数据类型配置囗囗紧致假设:goto
#
r'''[[[
e ../../python3_src/seed/data_funcs/finger_tree/finger_tree_common.py
    本文件:
    约束推导
    参数配置

# ../../python3_src/seed/data_funcs/finger_tree/finger_tree__obsolete.py
    废弃版

e ../../python3_src/seed/data_funcs/finger_tree/finger_tree__external_packed_config.py
    EPC/外参配置算子包
    #接口一致化 需要 kw2
e ../../python3_src/seed/data_funcs/finger_tree/finger_tree__physical_layer.py
    PL/物理适配层
    #定义基础数据类型
e ../../python3_src/seed/data_funcs/finger_tree/finger_tree__EPC__default.py
    可优化方法缺省具现
    即 无优化具现
e ../../python3_src/seed/data_funcs/finger_tree/finger_tree__EPC5PL.py
    EPC5PL
    粘合:物理适配层*外参一致层
e ../../python3_src/seed/data_funcs/finger_tree/finger_tree_ops.py
    面向树实例终端用户
    即 操作面向元素而非节点
e ../../python3_src/seed/data_funcs/finger_tree/finger_tree_ops__instances.py
    类具现++调试:见:真值变量:『finger_tree_ops__instances::_正常丷调试』
e ../../python3_src/seed/data_funcs/finger_tree/measurement.py
    缓存度量 具现
    词典映射

e ../../python3_src/seed/data_funcs/finger_tree/FingerTree.py
    对象版

ls ../../python3_src/seed/data_funcs/finger_tree/

grep '^class [^魖_乸]' -r ../../python3_src/seed/data_funcs/finger_tree/*.py -h
    类名:统一形式:
        抽象类『魖』
        具象类『乸』
    实例/对象:命名:
        ops算子包/操作方法包『匴』
        参数配置包『匞』#匞/匠#xxx『毶』


seed.data_funcs.finger_tree.finger_tree_common
from seed.data_funcs.finger_tree.finger_tree__physical_layer import 魖双侧展翅树囗数据类型配置囗囗显式参数列举式囗囗面向适配底层数据类型, 魖属性界面
from seed.data_funcs.finger_tree.finger_tree__external_packed_config import 魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程囗囗囗囗基础, 魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程

from seed.data_funcs.finger_tree.finger_tree__EPC__default import 魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程囗囗囗囗可优化方法缺省具象化
from seed.data_funcs.finger_tree.finger_tree__EPC5PL import 魖双侧展翅树囗数据类型配置囗囗囗囗粘合囗囗物理适配层囗囗外参一致层
from seed.data_funcs.finger_tree.finger_tree_ops import 魖双侧展翅树囗相关操作囗囗面向树实例终端用户囗囗元素版
from seed.data_funcs.finger_tree.finger_tree_ops import 魖双侧展翅树囗相关操作
from seed.data_funcs.finger_tree.finger_tree_ops import 乸双侧展翅树囗相关操作

from seed.data_funcs.finger_tree.measurement import 乸词典映射冃缓存度量, 乸词典映射冃缓存度量囗囗长度丶散列值, 加法零元囗囗长度丶散列值

from seed.data_funcs.finger_tree.finger_tree_ops__instances import (
匴双侧展翅树囗相关操作囗囗无长度囗囗二三树
,匴双侧展翅树囗相关操作囗囗仅长度囗囗二三树
,匴双侧展翅树囗相关操作囗囗丮长度丶散列值厈囗囗二三树
)
from seed.data_funcs.finger_tree.FingerTree import FingerTree

adaptive
physical

required from:
    view ../../python3_src/seed/recognize/toy/poor_efficiency_toy_recognizer.py
        FIFO

view ../../python3_src/script/finger_tree_ops.py
view others/数学/编程/tree/finger_tree.txt

view ../../python3_src/seed/math/cut_uint_into_uints.py
view ../../python3_src/seed/math/generate_partition4additive_semigroup__total_ordering__increasing.py


seed.data_funcs.finger_tree.finger_tree_common
py -m nn_ns.app.debug_cmd   seed.data_funcs.finger_tree.finger_tree_common -x

py -m nn_ns.app.doctest_cmd seed.data_funcs.finger_tree.finger_tree_common:__doc__
py -m nn_ns.app.doctest_cmd seed.data_funcs.finger_tree.finger_tree_common:__doc__ --ndiff -ff -v

#obsolete:py_adhoc_call  seed.helper.print_methods  @wrapped_print_methods   %seed.data_funcs.finger_tree.finger_tree_common:魖双侧展翅树囗数据类型配置囗囗紧致假设@T    =T

py_adhoc_call  seed.helper.print_methods  @wrapped_print_methods   %seed.data_funcs.finger_tree.finger_tree_common:XXX@T    =T        +exclude_attrs5listed_in_cls_doc
from seed.data_funcs.finger_tree.finger_tree_common import *


[[
命名解释:here
===
#魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程
    ##obsolete:魖双侧展翅树囗数据类型配置囗囗紧致假设:goto
===
魖:抽象类
魊:tmay:Maybe x
    或:返回值 是 魊
巛:『源自』
巜:返回值 为:『(目标对象的新值,操作返回值)』
彳忄亍囗:『小心使用』，允许返回『NotImplemented』
===
参数化一致性:
    例如:f(..., x, ..., *, nm)
        则: x<nm=...>
    例如:f(节点,更深节点, 树, 更深树, ..., *, 深度)
        则: 节点<深度>
        则: 更深节点<深度> :: 节点<深度+1>
        则: 树<深度>
        则: 更深树<深度> :: 树<深度+1>
    例如:f(翅膀, 异翅, ..., *, 左翼丷右翼)
        则:翅膀<左翼丷右翼>
        则:异翅<左翼丷右翼> :: 翅膀<not 左翼丷右翼>
    例如:f(起翼, 讫翼, ..., *, 左起丷右起)
        则:起翼<左起丷右起> :: 翅膀<左翼丷右翼:=左起丷右起>
        则:讫翼<左起丷右起> :: 翅膀<左翼丷右翼:=not 左起丷右起>
也就是说:命名本身 包含了 对参数的变换(类型别称/类型构造器)，从而 一致的参数 有 不同的类型
    !!需要小心的是:在 调用子函数 时，需要 人工维护 这一约定:
    例如:
    def f(翅膀, ...左翼丷右翼)
    def g(翅膀, 异翅, ...左翼丷右翼)
        f(翅膀, ...左翼丷右翼)
        f(异翅, ...not 左翼丷右翼)
    例如:
    def f(树, ...深度)
    def g(起翼,更深树,讫翼, ...深度)
        f(树, ...深度)
        f(更深树, ...深度+1)
===
左端丷右端:
    序列操作焦点端口
    [压入囗<左端丷右端:=False> === 压入囗<在左端>]
左起丷右起:
    序列遍历方向
    [序列<左起丷右起:=False> ==== 序列<左起/正向遍历/从左往右>]
    左起丷右起 即 『从左端起开始迭代 还是 从右端起开始迭代』
    左起丷右起 即 『左端是起点 还是 右端是起点』
左翼丷右翼:
    翅膀方位/翅膀绝对方位
    [左翼丨右翼 === 翅膀<左翼丷右翼>]
起翼丷讫翼:
    翅膀方位/翅膀相对方位
    相对于 遍历方向
    [起翼丨讫翼 === 翅膀<左翼丷右翼:=左起丷右起xor起翼丷讫翼>]
翅膀 vs 异翅:
    [异翅<翅膀<左翼丷右翼> > === 翅膀<左翼丷右翼:=not 左翼丷右翼>]
外端丷内端
    翅膀端口方位
    左起 起翼 外端 == 左翼 外端 == 左端
    左起 讫翼 外端 == 右翼 外端 == 右端
    右起 讫翼 外端 == 左端
半扇/半扇示意:
    优化囗囗巨大囗最大许可长度:goto
居前/居后/诸前/诸后:
    居:不含焦点
    诸:含焦点
    优化囗囗巨大囗最大许可长度:goto
光杆树屮均衡双翼
    === (光杆树丷均衡双翼, 光杆树丨均衡双翼)
    * == (False, 光杆树)
    * == (True, 均衡双翼)
    均衡双翼 == (左翼, 右翼) #绝对定位！！
===
]]


[[[[[[[
[[
约束推导分析:here
===
view others/数学/编程/tree/finger_tree.txt
===
约束来源:
(<|):: a -> FingerTree a -> FingerTree a
viewL:: FingerTree a -> ViewL FingerTree a
app3:: FingerTree a -> [a] -> FingerTree a -> FingerTree a
splitAt:: N -> Seq a -> (Seq a,Seq a)
===
简单地说:
单侧增加一个元素+避免反复增的非线性板荡
    #非必须<<==若用途是『只删』
单侧分离一个元素+避免反复删的非线性板荡
    #非必须<<==若用途是『只增』

    #
    #下一行 无理 <<== 此时用 数组 更合适
        #?非必须<<==若用途是『只读/无增删』
    #
避免反复增删的非线性板荡
    #非必须<<==若用途是『只增』或『只删』
串接两树成一树
    #非必须<<==若用途是『只删』
分裂一树成两树
    #非必须<<==若用途是『只增』
===
树形态:
光杆树:直线数组
根深树:(左翅膀,更深树,右翅膀)
===
#白鹤亮翅
#展翅高飞
#翼展
#双翼齐飞
#限长:封顶+保底
双侧展翅树<节点<深度> > ==:
    | 光杆树<节点<深度> >
    | 根深树<节点<深度> >
光杆树<节点<深度> >:封顶双侧栈<节点<深度> >
    def:光杆树最小许可长度
    def:光杆树最大许可长度
    『必须:』[0 <= 光杆树最小许可长度 <= 光杆树最大许可长度]
        # 约束之一出现处
根深树<节点<深度> >:(左翅膀<节点<深度> >,更深树<节点<深度> >,右翅膀<节点<深度> >)
更深树<节点<深度> > == 双侧展翅树<更深节点<深度> >
更深节点<深度>:直线数组<节点<深度> >
    def:更深节点许可长度集合
    def:更深节点最小许可长度
    def:更深节点最大许可长度
    def:更深节点最优许可长度
    『对半优先:』[更深节点最优许可长度 == 2**floor_log2(更深节点最优许可长度)]
        # 新约束之一出现处
        # 约束之一出现处
    #改变:『必须:』[0 <= 更深节点最小许可长度 <= 更深节点最大许可长度]
    『必须:』[0 <= 更深节点最小许可长度 <= 更深节点最优许可长度 <= 更深节点最大许可长度]
        # 新约束之一出现处
        # 约束之一出现处
    『必须:』[len(更深节点许可长度集合) > 0]
        # 约束之一出现处
    『必须:』『定义:』[更深节点最小许可长度==min(更深节点许可长度集合)]
        # 约束之一出现处
    『必须:』『定义:』[更深节点最大许可长度==max(更深节点许可长度集合)]
        # 约束之一出现处
节点<深度+1> == 更深节点<深度>
节点<0> == 封包<元素>
翅膀<节点<深度> >:封顶单侧保底栈<节点<深度> >
    def:翅膀最小许可长度
    def:翅膀最大许可长度
    『必须:』[0 <= 翅膀最小许可长度 <= 翅膀最大许可长度]
        # 约束之一出现处
===
或者其他候选具现方案:
光杆树:封顶双侧栈<光杆树最大许可长度>
封顶双侧栈<最大许可长度>:
    * 直线数组{len<=最大许可长度}
    * 双侧栈{len<=最大许可长度}
双侧栈/队列 某些具现:
    # 长度无限制 不能是 数组
    * 红黑树
    * 双侧展翅树
翅膀:封顶单侧保底栈<左翼丷右翼,翅膀最大许可长度,翅膀最小许可长度>
    左翅膀:封顶左开右闭保底栈
    右翅膀:封顶左闭右开保底栈
    封顶左闭右开保底栈==封顶单侧保底栈<左闭右开>
    封顶左开右闭保底栈==封顶单侧保底栈<左开右闭>
封顶单侧保底栈<最大许可长度,最小许可长度> == 封顶单侧栈<最大许可长度-最小许可长度> + 直线数组{len=最小许可长度}
封顶单侧栈<最大许可长度>:
    * 直线数组{len<=最大许可长度}
    * 单侧栈{len<=最大许可长度}
单侧栈 某些具现:
    # 长度无限制 不能是 数组
    * 单侧展翅树
    * 单侧链表 #但是，跳读 有点慢
    * 双侧栈 #但是，不够优化
===
单侧增加一个元素+避免反复增的非线性板荡
    #非必须<<==若用途是『只删』
光杆树 由空树 不断增长 直至 最大许可长度
    !! 空树 <: 光杆树
    『必须:』『定义:』[光杆树最小许可长度==0]
        # 约束之一出现处
光杆树 进化为 根深树:
    [光杆树最大许可长度+1>=根深树最小长度==翅膀最小许可长度*2+树最小许可长度*更深节点最小许可长度]
    !! [光杆树最小许可长度==0]
    [树最小许可长度==0]
    『必须:』[光杆树最大许可长度+1>=翅膀最小许可长度*2]
        # 约束之一出现处
    拆分为 (左翅膀,中间节点,右翅膀)
    #xxx:奇数:def:光杆树溢出时分裂出的翅膀的长度
    def:光杆树溢出时分裂出的双翼的长度
    def:光杆树溢出时分裂出的更深节点的各自长度
    def:光杆树溢出时分裂出的更深节点的数目
    def:光杆树溢出时分裂出的中间节点的数目
    『最优更深:』[光杆树溢出时分裂出的更深节点的各自长度 == [更深节点最优许可长度]*光杆树溢出时分裂出的更深节点的数目]
        # 新约束之一出现处
        # 约束之一出现处
    『必须:』[2*翅膀最小许可长度 <= 光杆树溢出时分裂出的双翼的长度 <= 2*翅膀最大许可长度]
        # 约束之一出现处
    『增长:』[set(光杆树溢出时分裂出的更深节点的各自长度) <= 更深节点许可长度集合]
        # 约束之一出现处
    『增长:』『定义:』[光杆树溢出时分裂出的中间节点的数目==sum(光杆树溢出时分裂出的更深节点的各自长度)]
        # 约束之一出现处
    『增长:』『定义:』[光杆树溢出时分裂出的更深节点的数目==len(光杆树溢出时分裂出的更深节点的各自长度)]
        # 约束之一出现处

    『增长:』[光杆树最大许可长度+1 == 光杆树溢出时分裂出的中间节点的数目 + 光杆树溢出时分裂出的双翼的长度]
        # 约束之一出现处
        # 约束囗源自光杆树溢出时
根深树 不断增长 --> 翅膀 由 最小许可长度 不断增长 直至 最大许可长度
翅膀 溢出 --> 分裂出 几个 更深节点 加塞到 更深树
    #注意:后来新增:更深节点最优许可长度
    def:翅膀溢出时分裂出的更深节点的各自长度
    def:翅膀溢出时分裂出的更深节点的数目
    def:翅膀溢出时分裂出的节点的数目
        #减轻 翅膀 压力
    『最优更深:』[翅膀溢出时分裂出的更深节点的各自长度 == [更深节点最优许可长度]*翅膀溢出时分裂出的更深节点的数目]
        # 新约束之一出现处
        # 约束之一出现处
    『增长:』[set(翅膀溢出时分裂出的更深节点的各自长度) <= 更深节点许可长度集合]
        # 约束之一出现处
    『增长:』『定义:』[翅膀溢出时分裂出的节点的数目==sum(翅膀溢出时分裂出的更深节点的各自长度)]
        # 约束之一出现处
    『增长:』『定义:』[翅膀溢出时分裂出的更深节点的数目==len(翅膀溢出时分裂出的更深节点的各自长度)]
        # 约束之一出现处
    『增长:』[翅膀最小许可长度 <= 翅膀最大许可长度+1-翅膀溢出时分裂出的节点的数目 <= 翅膀最大许可长度]
        # 约束囗源自翅膀溢出时
    <==>:
    『增长:』[1 <= 翅膀溢出时分裂出的节点的数目 <= 翅膀最大许可长度+1-翅膀最小许可长度]
        # 约束之一出现处
    =======================
    =======================
    更进++避免反复增的非线性板荡:
    =======================
    原版:
        『增长:』[光杆树最大许可长度+1 == 光杆树溢出时分裂出的中间节点的数目 + 光杆树溢出时分裂出的双翼的长度]
            # 约束囗源自光杆树溢出时
        『必须:』[2*翅膀最小许可长度 <= 光杆树溢出时分裂出的双翼的长度 <= 2*翅膀最大许可长度]
    更进为:
        『可疑:』『增长防板荡:』[2*翅膀最小许可长度 <= 光杆树溢出时分裂出的双翼的长度 <= 2*(翅膀最大许可长度-1)]
    <==>:
    『可疑:』『增长防板荡:』[2*翅膀最小许可长度 <= 光杆树溢出时分裂出的双翼的长度 <= 2*翅膀最大许可长度-2]
        # 约束之一出现处
        # 约束囗源自光杆树溢出时囗避免反复增的非线性板荡
    =======================
    原版:
        『增长:』[翅膀最小许可长度 <= 翅膀最大许可长度+1-翅膀溢出时分裂出的节点的数目 <= 翅膀最大许可长度]
            # 约束囗源自翅膀溢出时
    更进为:
        『增长防板荡:』[翅膀最小许可长度 <= 翅膀最大许可长度+1-翅膀溢出时分裂出的节点的数目 < 翅膀最大许可长度]
            # 约束囗源自翅膀溢出时囗避免反复增的非线性板荡
    <==>:
    『增长防板荡:』[2 <= 翅膀溢出时分裂出的节点的数目 <= 翅膀最大许可长度+1-翅膀最小许可长度]
        # 约束之一出现处
        # 更进类比于:一进制数-->二进制数
    =======================
===
单侧分离一个元素+避免反复删的非线性板荡
    #非必须<<==若用途是『只增』
光杆树 不断缩水 直至 最小许可长度/空树
根深树 不断缩水 --> 翅膀 不断缩水 直至 最小许可长度
    翅膀缺员&&更深树未空 --> 从 更深树 分离出 几个 更深节点
        #由于翅膀越箐越合理，下面两个毫无道理:
        #   def:翅膀缺员时多次填充上限
        #   def:翅膀缺员时多次填充下限
        『缩水:』[翅膀最小许可长度<=翅膀最小许可长度-1+更深节点最小许可长度<=翅膀最小许可长度-1+更深节点最大许可长度<=翅膀最大许可长度]
            # 约束囗源自翅膀缺员更深树未空时
        <==>:
        『缩水:』[1 <= 更深节点最小许可长度 <= 更深节点最大许可长度 <= 翅膀最大许可长度+1-翅膀最小许可长度]
            # 约束之一出现处
    翅膀缺员&&更深树已空 --> 从 异侧翼 分离出 几个 节点 或 退化为 光杆树
        def:翅膀缺员时退化上限
        『缩水:』[翅膀缺员时退化上限+1 >= 翅膀最小许可长度*2] [翅膀缺员时退化上限 <= 光杆树最大许可长度]
            # 约束囗源自翅膀缺员更深树已空时
        <==>:
        『缩水:』[翅膀最小许可长度*2-1 <= 翅膀缺员时退化上限 <= 光杆树最大许可长度]
            # 约束之一出现处
    =======================
    =======================
    更进++避免反复删的非线性板荡:
    =======================
    原版:
        『缩水:』[翅膀最小许可长度<=翅膀最小许可长度-1+更深节点最小许可长度<=翅膀最小许可长度-1+更深节点最大许可长度<=翅膀最大许可长度]
            # 约束囗源自翅膀缺员更深树未空时
    更进为:
        『缩水防板荡:』[翅膀最小许可长度<翅膀最小许可长度-1+更深节点最小许可长度<=翅膀最小许可长度-1+更深节点最大许可长度<=翅膀最大许可长度]
            # 约束囗源自翅膀缺员更深树未空时囗避免反复删的非线性板荡
    <==>:
    『缩水防板荡:』[2 <= 更深节点最小许可长度 <= 更深节点最大许可长度 <= 翅膀最大许可长度+1-翅膀最小许可长度]
        # 约束之一出现处
        # 更进类比于:一进制数-->二进制数

    =======================
    原版:
        『缩水:』[翅膀缺员时退化上限+1 >= 翅膀最小许可长度*2] [翅膀缺员时退化上限 <= 光杆树最大许可长度]
            # 约束囗源自翅膀缺员更深树已空时
    更进为:
        『可疑:』『缩水防板荡:』[翅膀缺员时退化上限+1 >= (翅膀最小许可长度+1)*2] [翅膀缺员时退化上限 <= 光杆树最大许可长度]
            # 约束囗源自翅膀缺员更深树已空时囗避免反复删的非线性板荡
    <==>:
    『可疑:』『缩水防板荡:』[翅膀最小许可长度*2+1 <= 翅膀缺员时退化上限 <= 光杆树最大许可长度]
        # 约束之一出现处
    =======================

===
===
避免反复增删的非线性板荡
    #非必须<<==若用途是『只增』『只删』
    =======================
    原版:
        『增长:』[光杆树最大许可长度+1 == 光杆树溢出时分裂出的中间节点的数目 + 光杆树溢出时分裂出的双翼的长度]
            # 约束囗源自光杆树溢出时
        『必须:』[2*翅膀最小许可长度 <= 光杆树溢出时分裂出的双翼的长度 <= 2*翅膀最大许可长度]
    更进为:
        『可疑:』『增长防板荡:』[2*(翅膀最小许可长度+1) <= 光杆树溢出时分裂出的双翼的长度 <= 2*(翅膀最大许可长度-1)]
    <==>:
    『可疑:』『消息盈虚防板荡:』[2*翅膀最小许可长度+2 <= 光杆树溢出时分裂出的双翼的长度 <= 2*翅膀最大许可长度-2]
        # 约束之一出现处
        # 约束囗源自光杆树溢出时囗避免反复增删的非线性板荡
    =======================
    原版:
        『增长:』[翅膀最小许可长度 <= 翅膀最大许可长度+1-翅膀溢出时分裂出的节点的数目 <= 翅膀最大许可长度]
            # 约束囗源自翅膀溢出时
    更进为:
        『消息盈虚防板荡:』[翅膀最小许可长度 < 翅膀最大许可长度+1-翅膀溢出时分裂出的节点的数目 < 翅膀最大许可长度]
            # 约束囗源自翅膀溢出时囗避免反复增删的非线性板荡
    <==>:
    『消息盈虚防板荡:』[2 <= 翅膀溢出时分裂出的节点的数目 <= 翅膀最大许可长度-翅膀最小许可长度]
        # 约束之一出现处
        # 更进类比于:二进制数-->冗余编码 避免 0b0111-->0b1000-->0b0111...loop

    =======================
    原版:
        『缩水:』[翅膀最小许可长度<=翅膀最小许可长度-1+更深节点最小许可长度<=翅膀最小许可长度-1+更深节点最大许可长度<=翅膀最大许可长度]
            # 约束囗源自翅膀缺员更深树未空时
    更进为:
        『消息盈虚防板荡:』[翅膀最小许可长度<翅膀最小许可长度-1+更深节点最小许可长度<=翅膀最小许可长度-1+更深节点最大许可长度<翅膀最大许可长度]
            # 约束囗源自翅膀缺员更深树未空时囗避免反复增删的非线性板荡
    <==>:
    『消息盈虚防板荡:』[2 <= 更深节点最小许可长度 <= 更深节点最大许可长度 <= 翅膀最大许可长度-翅膀最小许可长度]
        # 约束之一出现处

    =======================
    原版:
        『缩水:』[翅膀缺员时退化上限+1 >= 翅膀最小许可长度*2] [翅膀缺员时退化上限 <= 光杆树最大许可长度]
            # 约束囗源自翅膀缺员更深树已空时
    更进为:
        『可疑:』『消息盈虚防板荡:』[翅膀缺员时退化上限+1 >= (翅膀最小许可长度+1)*2] [翅膀缺员时退化上限 < 光杆树最大许可长度]
            # 约束囗源自翅膀缺员更深树已空时囗避免反复增删的非线性板荡
    <==>:
    『可疑:』『消息盈虚防板荡:』[翅膀最小许可长度*2+1 <= 翅膀缺员时退化上限 <= 光杆树最大许可长度-1]
        # 约束之一出现处
    =======================


===
串接两树成一树
    #非必须<<==若用途是『只删』
* [至少有一 是 光杆树]: 直接连续单增
* [两者均为 根深树]:
    接触处 翅膀 融并 切分成 更深节点 下沉
    接触处 翅膀 以及中间的自上层下沉而来的 节点 序列 融并 切分成 更深节点 下沉
    ...
    要求一: 更深节点许可长度集合 的 加法 不可表达的最大值 小于 两翅膀的节点数
        def:更深节点最大的不可表达节点数
    要求二: 下沉节点数目 存在上限
        def:tmp:下沉节点数目上限

    『增长合并:』『定义:』[更深节点最大的不可表达节点数==search_max_miss_ex__pint_additive_generators_(更深节点许可长度集合)[0]]
        # 约束之一出现处

    『增长合并:』[更深节点最大的不可表达节点数 < 2*翅膀最小许可长度]
    <==>:
    『增长合并:』[更深节点最大的不可表达节点数 <= 翅膀最小许可长度*2-1]
        # 约束之一出现处

    # 因为 不知 具体拆分，故而 假设最糟情形:更深节点最小许可长度
    #   更深节点最优许可长度:并不能体现作用
    『增长合并:』[0 <= (下沉节点数目上限+2*翅膀最大许可长度)/更深节点最小许可长度 <= 下沉节点数目上限]
    <==>:
    [-下沉节点数目上限 <= 2*翅膀最大许可长度 <= 下沉节点数目上限*(更深节点最小许可长度-1)]
    <==>:
    『增长合并:』『半定义:』[更深节点最小许可长度 >= 2][下沉节点数目上限 >= 翅膀最大许可长度*2/(更深节点最小许可长度-1)]
    <==>:
    『增长合并:』[更深节点最小许可长度 >= 2]
        # 约束之一出现处
    delete:下沉节点数目上限
===
#断肢再造，滴血重生，肉身不灭
分裂一树成两树
    #非必须<<==若用途是『只增』
    半边树 --> 提取出 缺失 翅膀 的 邻接 更深节点 来重生翅膀，不断向上重复这一过程
    要求 更深节点 填充 单侧 翅膀 还有 富余
    『缩水分裂:』[翅膀最小许可长度+1 <= 更深节点最小许可长度 <= 更深节点最大许可长度 <= 翅膀最大许可长度]
        # 约束之一出现处
===
===
]]
[[
综上:
===
约束集中出现处:here
===
    『必须:』[0 <= 光杆树最小许可长度 <= 光杆树最大许可长度]
        # 约束之一集中出现处
    『必须:』[0 <= 更深节点最小许可长度 <= 更深节点最大许可长度]
        # 约束之一集中出现处
    『必须:』[0 <= 翅膀最小许可长度 <= 翅膀最大许可长度]
        # 约束之一集中出现处
    『必须:』[len(更深节点许可长度集合) > 0]
        # 约束之一集中出现处
    『必须:』『定义:』[更深节点最小许可长度==min(更深节点许可长度集合)]
        # 约束之一集中出现处
    『必须:』『定义:』[更深节点最大许可长度==max(更深节点许可长度集合)]
        # 约束之一集中出现处
    『必须:』『定义:』[光杆树最小许可长度==0]
        # 约束之一集中出现处
    『必须:』[光杆树最大许可长度+1>=翅膀最小许可长度*2]
        # 约束之一集中出现处
    『必须:』[2*翅膀最小许可长度 <= 光杆树溢出时分裂出的双翼的长度 <= 2*翅膀最大许可长度]
        # 约束之一集中出现处
    『增长:』[set(光杆树溢出时分裂出的更深节点的各自长度) <= 更深节点许可长度集合]
        # 约束之一集中出现处
    『增长:』『定义:』[光杆树溢出时分裂出的中间节点的数目==sum(光杆树溢出时分裂出的更深节点的各自长度)]
        # 约束之一集中出现处
    『增长:』『定义:』[光杆树溢出时分裂出的更深节点的数目==len(光杆树溢出时分裂出的更深节点的各自长度)]
        # 约束之一集中出现处

    『增长:』[光杆树最大许可长度+1 == 光杆树溢出时分裂出的中间节点的数目 + 光杆树溢出时分裂出的双翼的长度]
        # 约束之一集中出现处
        # 约束囗源自光杆树溢出时
    『增长:』[set(翅膀溢出时分裂出的更深节点的各自长度) <= 更深节点许可长度集合]
        # 约束之一集中出现处
    『增长:』『定义:』[翅膀溢出时分裂出的节点的数目==sum(翅膀溢出时分裂出的更深节点的各自长度)]
        # 约束之一集中出现处
    『增长:』『定义:』[翅膀溢出时分裂出的更深节点的数目==len(翅膀溢出时分裂出的更深节点的各自长度)]
        # 约束之一集中出现处
    『增长:』[1 <= 翅膀溢出时分裂出的节点的数目 <= 翅膀最大许可长度+1-翅膀最小许可长度]
        # 约束之一集中出现处
    『可疑:』『增长防板荡:』[2*翅膀最小许可长度 <= 光杆树溢出时分裂出的双翼的长度 <= 2*翅膀最大许可长度-2]
        # 约束之一集中出现处
        # 约束囗源自光杆树溢出时囗避免反复增的非线性板荡
        # ###2_3_finger_tree满足此约束
    『增长防板荡:』[2 <= 翅膀溢出时分裂出的节点的数目 <= 翅膀最大许可长度+1-翅膀最小许可长度]
        # 约束之一集中出现处
    『缩水:』[1 <= 更深节点最小许可长度 <= 更深节点最大许可长度 <= 翅膀最大许可长度+1-翅膀最小许可长度]
        # 约束之一集中出现处
    『缩水:』[翅膀最小许可长度*2-1 <= 翅膀缺员时退化上限 <= 光杆树最大许可长度]
        # 约束之一集中出现处
    『缩水防板荡:』[2 <= 更深节点最小许可长度 <= 更深节点最大许可长度 <= 翅膀最大许可长度+1-翅膀最小许可长度]
        # 约束之一集中出现处
    『可疑:』『缩水防板荡:』[翅膀最小许可长度*2+1 <= 翅膀缺员时退化上限 <= 光杆树最大许可长度]
        # 约束之一集中出现处
        # 2_3_finger_tree无法满足此约束
    『可疑:』『消息盈虚防板荡:』[2*翅膀最小许可长度+2 <= 光杆树溢出时分裂出的双翼的长度 <= 2*翅膀最大许可长度-2]
        # 约束之一集中出现处
        # 约束囗源自光杆树溢出时囗避免反复增删的非线性板荡
        # 2_3_finger_tree无法满足此约束
    『消息盈虚防板荡:』[2 <= 翅膀溢出时分裂出的节点的数目 <= 翅膀最大许可长度-翅膀最小许可长度]
        # 约束之一集中出现处
    『消息盈虚防板荡:』[2 <= 更深节点最小许可长度 <= 更深节点最大许可长度 <= 翅膀最大许可长度-翅膀最小许可长度]
        # 约束之一集中出现处
    『可疑:』『消息盈虚防板荡:』[翅膀最小许可长度*2+1 <= 翅膀缺员时退化上限 <= 光杆树最大许可长度-1]
        # 约束之一集中出现处
        # 2_3_finger_tree无法满足此约束
    『增长合并:』『定义:』[更深节点最大的不可表达节点数==search_max_miss_ex__pint_additive_generators_(更深节点许可长度集合)[0]]
        # 约束之一集中出现处
    『增长合并:』[更深节点最大的不可表达节点数 <= 翅膀最小许可长度*2-1]
        # 约束之一集中出现处
    『增长合并:』[更深节点最小许可长度 >= 2]
        # 约束之一集中出现处
    『缩水分裂:』[翅膀最小许可长度+1 <= 更深节点最小许可长度 <= 更深节点最大许可长度 <= 翅膀最大许可长度]
        # 约束之一集中出现处
    ===后来添加的:
    『紧致假设:』[更深节点许可长度集合 == {更深节点最小许可长度..=更深节点最大许可长度}]
        # 约束之一集中出现处

    #### 关于[更深节点最优许可长度]
    『对半优先:』[更深节点最优许可长度 == 2**floor_log2(更深节点最优许可长度)]
        # 新约束之一集中出现处
        # 约束之一集中出现处
    『必须:』[0 <= 更深节点最小许可长度 <= 更深节点最优许可长度 <= 更深节点最大许可长度]
        # 新约束之一集中出现处
        # 约束之一集中出现处
    『最优更深:』[光杆树溢出时分裂出的更深节点的各自长度 == [更深节点最优许可长度]*光杆树溢出时分裂出的更深节点的数目]
        # 新约束之一集中出现处
        # 约束之一集中出现处
    『最优更深:』[翅膀溢出时分裂出的更深节点的各自长度 == [更深节点最优许可长度]*翅膀溢出时分裂出的更深节点的数目]
        # 新约束之一集中出现处
        # 约束之一集中出现处
===
其中:
特别注意:
    『增长合并:』并不依赖于『增长:』!
    『缩水分裂:』并不依赖于『缩水:』!
    『消息盈虚防板荡:』强于『增长防板荡:』『缩水防板荡:』这两者结合！
正常依赖关系:
    『增长防板荡:』依赖于『增长:』
    『缩水防板荡:』依赖于『缩水:』
    『消息盈虚防板荡:』依赖于『增长:』『缩水:』
===
2_3_finger_tree<not$对半优先>:
    [光杆树最大许可长度==1]
    [翅膀最小许可长度==1]
    [翅膀最大许可长度==4]
    [更深节点许可长度集合=={2,3}]
    [光杆树溢出时分裂出的更深节点的各自长度==[]]
    [翅膀溢出时分裂出的更深节点的各自长度==[3]]
    [更深节点最优许可长度==3]
    ==>>:
    [更深节点最小许可长度==2]
    [更深节点最大许可长度==3]
    [光杆树溢出时分裂出的更深节点的数目==0]
    [光杆树溢出时分裂出的中间节点的数目==0]
    [光杆树溢出时分裂出的双翼的长度==2]
    [翅膀溢出时分裂出的更深节点的数目==1]
    [翅膀溢出时分裂出的节点的数目==3]
    [翅膀缺员时退化上限==1]
    [更深节点最大的不可表达节点数==1]
    ==>>:
    2_3_finger_tree无法满足 其中三个『可疑:』约束
    #此2_3_finger_tree配置不满足 『对半优先』
===
2_3_finger_tree<对半优先>:
    [光杆树最大许可长度==1]
    [翅膀最小许可长度==1]
    [翅膀最大许可长度==4]
    [更深节点许可长度集合=={2,3}]
    [光杆树溢出时分裂出的更深节点的各自长度==[]]
    [翅膀溢出时分裂出的更深节点的各自长度==[2]]
    [更深节点最优许可长度==2]
    ==>>:
    [更深节点最小许可长度==2]
    [更深节点最大许可长度==3]
    [光杆树溢出时分裂出的更深节点的数目==0]
    [光杆树溢出时分裂出的中间节点的数目==0]
    [光杆树溢出时分裂出的双翼的长度==2]
    [翅膀溢出时分裂出的更深节点的数目==1]
    [翅膀溢出时分裂出的节点的数目==2]
    [翅膀缺员时退化上限==1]
    [更深节点最大的不可表达节点数==1]
    ==>>:
    2_3_finger_tree<对半优先>无法满足 其中三个『可疑:』约束
    #此2_3_finger_tree<对半优先>配置满足 『对半优先』
===
]]
[[
本小区只考虑最强要求:
即:
    『增长:』
    『缩水:』
    『消息盈虚防板荡:』
    『增长合并:』
    『缩水分裂:』
    ??『最优更深:』『对半优先:』
===
过滤无趣+过滤可导出:之后:
    『可疑:』『消息盈虚防板荡:』[翅膀最小许可长度*2+1 <= 翅膀缺员时退化上限 <= 光杆树最大许可长度-1]
    『缩水:』[翅膀最小许可长度*2-1 <= 翅膀缺员时退化上限 <= 光杆树最大许可长度]

    『可疑:』『消息盈虚防板荡:』[2*翅膀最小许可长度+2 <= 光杆树溢出时分裂出的双翼的长度 <= 2*翅膀最大许可长度-2]
    『必须:』[2*翅膀最小许可长度 <= 光杆树溢出时分裂出的双翼的长度 <= 2*翅膀最大许可长度]
    『增长:』[光杆树最大许可长度+1 == 光杆树溢出时分裂出的中间节点的数目 + 光杆树溢出时分裂出的双翼的长度]

    『消息盈虚防板荡:』[2 <= 翅膀溢出时分裂出的节点的数目 <= 翅膀最大许可长度-翅膀最小许可长度]
    『消息盈虚防板荡:』[2 <= 更深节点最小许可长度 <= 更深节点最大许可长度 <= 翅膀最大许可长度-翅膀最小许可长度]
    『缩水分裂:』[翅膀最小许可长度+1 <= 更深节点最小许可长度 <= 更深节点最大许可长度 <= 翅膀最大许可长度]

    『增长合并:』[更深节点最大的不可表达节点数 <= 翅膀最小许可长度*2-1]

===
设计次序:
翅膀最大许可长度 只要 变大 就能满足
    (翅膀最小许可长度,翅膀最大许可长度) then 光杆树溢出时分裂出的双翼的长度
    (光杆树最大许可长度,光杆树溢出时分裂出的双翼的长度) then 光杆树溢出时分裂出的中间节点的数目
    放在最后确定
翅膀溢出时分裂出的节点的数目 只要 别的条件能满足，它的可行解 必然存在，例如 更深节点最大许可长度
    放在最后确定
翅膀缺员时退化上限,光杆树最大许可长度 只要 变大 就能满足
    翅膀最小许可长度 then 翅膀缺员时退化上限 then 光杆树最大许可长度
    放在最后确定

==>>:
关键循环约束:
    [2 <= 更深节点最小许可长度]
    [翅膀最小许可长度+1 <= 更深节点最小许可长度]
    [更深节点最大的不可表达节点数 <= 翅膀最小许可长度*2-1]

===
!! [翅膀最小许可长度+1 <= 更深节点最小许可长度]
!! [更深节点最大的不可表达节点数 <= 翅膀最小许可长度*2-1]
[更深节点最大的不可表达节点数 <= 翅膀最小许可长度*2-1 <= 更深节点最小许可长度*2-3]

[更深节点最小许可长度 :<- [2..]]:
    [更深节点最大许可长度<更深节点最小许可长度> := min[更深节点最大许可长度 :<- [更深节点最小许可长度+1..<2*更深节点最小许可长度] | [更深节点许可长度集合 := {更深节点最小许可长度..=更深节点最大许可长度}][更深节点最大的不可表达节点数<更深节点许可长度集合> <= 更深节点最小许可长度*2-3]]]

see:迭代囗给定囗更深节点最小许可长度囗最小囗更深节点最大许可长度囗
[最小囗更深节点最大许可长度<更深节点最小许可长度> == 更深节点最小许可长度*2-1]
    [[proof:
    !! [更深节点最大的不可表达节点数<更深节点许可长度集合> <= 更深节点最小许可长度*2-3]
    [(更深节点最小许可长度*2-2) <- positive_span<更深节点许可长度集合>]
    !! [更深节点最小许可长度 >= 2]
    [(更深节点最小许可长度*2-2) <- [更深节点最小许可长度..<更深节点最小许可长度*2]]
    !! [[@x <- [更深节点最小许可长度..<更深节点最小许可长度*2]] -> [x <- positive_span<更深节点许可长度集合>] -> [x <- 更深节点许可长度集合]]
    [(更深节点最小许可长度*2-2) <- 更深节点许可长度集合]
    [(更深节点最小许可长度*2-1) <- 更深节点许可长度集合]
    [最小囗更深节点最大许可长度<更深节点最小许可长度> >= (更深节点最小许可长度*2-1)]
    !! [{更深节点最小许可长度..<更深节点最小许可长度*2} is a good 更深节点许可长度集合]
    [最小囗更深节点最大许可长度<更深节点最小许可长度> <= (更深节点最小许可长度*2-1)]
    [最小囗更深节点最大许可长度<更深节点最小许可长度> == (更深节点最小许可长度*2-1)]
    DONE!
    ]]


[更深节点最大许可长度 >= (更深节点最小许可长度*2-1)]
设计次序:
    @[更深节点最小许可长度 >= 2]
    @[更深节点最大许可长度 >= (更深节点最小许可长度*2-1)]

    [{更深节点最小许可长度..=更深节点最大许可长度} 是 合法的 更深节点许可长度集合]
    选择 更深节点许可长度集合 满足:
        [更深节点最大的不可表达节点数 <= 更深节点最小许可长度*2-3]

    [(更深节点最小许可长度-1) 是 合法的 翅膀最小许可长度]
    选择 翅膀最小许可长度 满足:
        [更深节点最大的不可表达节点数 <= 翅膀最小许可长度*2-1 <= 更深节点最小许可长度*2-3]

    @[翅膀最大许可长度 >= 更深节点最大许可长度 +翅膀最小许可长度]

    [更深节点最大许可长度 是 合法的 翅膀溢出时分裂出的节点的数目]
    @[翅膀溢出时分裂出的节点的数目 <- {2..=翅膀最大许可长度-翅膀最小许可长度} /-\ positive_span<更深节点许可长度集合>]

    #####
    #见下面 推导:
    #

    @[光杆树溢出时分裂出的双翼的长度 <- [2*(翅膀最小许可长度+[可疑]) ..= 2*(翅膀最大许可长度-[可疑])]]

    @[光杆树溢出时分裂出的中间节点的数目 <- ({0}\-/positive_span<更深节点许可长度集合>)/-\{([[可疑][(光杆树溢出时分裂出的双翼的长度-2*翅膀最小许可长度)==2]])..}]

    [光杆树最大许可长度 := -1 + 光杆树溢出时分裂出的中间节点的数目 + 光杆树溢出时分裂出的双翼的长度]

    @[翅膀缺员时退化上限 <- [(翅膀最小许可长度+[可疑])*2-1 ..= (光杆树最大许可长度-[可疑])]]
    ######################

    ######################
    <<==:
    选择 光杆树溢出时分裂出的双翼的长度 <<==根据:
        ######################
        『可疑:』『消息盈虚防板荡:』[2*翅膀最小许可长度+2 <= 光杆树溢出时分裂出的双翼的长度 <= 2*翅膀最大许可长度-2]
        『必须:』[2*翅膀最小许可长度 <= 光杆树溢出时分裂出的双翼的长度 <= 2*翅膀最大许可长度]
        ######################
        ==>>:
        [2*翅膀最小许可长度+[可疑]*2 <= 光杆树溢出时分裂出的双翼的长度 <= 2*翅膀最大许可长度-[可疑]*2]
        ######################
        任选@[光杆树溢出时分裂出的双翼的长度 <- [2*(翅膀最小许可长度+[可疑]) ..= 2*(翅膀最大许可长度-[可疑])]]
        ######################


    选择 (光杆树溢出时分裂出的中间节点的数目,光杆树最大许可长度, 翅膀缺员时退化上限) <<==根据:
        ######################
        『可疑:』『消息盈虚防板荡:』[翅膀最小许可长度*2+1 <= 翅膀缺员时退化上限 <= 光杆树最大许可长度-1]
        『缩水:』[翅膀最小许可长度*2-1 <= 翅膀缺员时退化上限 <= 光杆树最大许可长度]
        ######################
        『增长:』[光杆树最大许可长度+1 == 光杆树溢出时分裂出的中间节点的数目 + 光杆树溢出时分裂出的双翼的长度]
        ######################
        ==>>:
        [(翅膀最小许可长度+[可疑])*2 -1 <= 翅膀缺员时退化上限 <= 光杆树最大许可长度-[可疑]]
        [光杆树最大许可长度 >= 翅膀最小许可长度*2-1 +[可疑]*3]
        ######################
        !! [2*翅膀最小许可长度+[可疑]*2 <= 光杆树溢出时分裂出的双翼的长度 <= 2*翅膀最大许可长度-[可疑]*2]
        [光杆树溢出时分裂出的双翼的长度-2*翅膀最小许可长度 >= [可疑]*2]
        ######################
        ######################
        !! [光杆树最大许可长度 >= 翅膀最小许可长度*2-1 +[可疑]*3]
        [光杆树溢出时分裂出的中间节点的数目 == 光杆树最大许可长度+1 -光杆树溢出时分裂出的双翼的长度 >= 翅膀最小许可长度*2-1 +[可疑]*3 +1 -光杆树溢出时分裂出的双翼的长度]
        [光杆树溢出时分裂出的中间节点的数目 >= [可疑]*3 -(光杆树溢出时分裂出的双翼的长度-2*翅膀最小许可长度)]
        !! [光杆树溢出时分裂出的双翼的长度-2*翅膀最小许可长度 >= [可疑]*2]
        [光杆树溢出时分裂出的中间节点的数目 >= [可疑]*3 -(光杆树溢出时分裂出的双翼的长度-2*翅膀最小许可长度) >= [可疑]]
        [光杆树溢出时分裂出的中间节点的数目 >= [可疑]]
        [光杆树溢出时分裂出的中间节点的数目 >= ([[可疑][(光杆树溢出时分裂出的双翼的长度-2*翅膀最小许可长度)==2]])]
        ==>>:
        任选:@[光杆树溢出时分裂出的中间节点的数目 <- ({0}\-/positive_span<更深节点许可长度集合>)/-\{([[可疑][(光杆树溢出时分裂出的双翼的长度-2*翅膀最小许可长度)==2]])..}]
        [光杆树最大许可长度 := -1 + 光杆树溢出时分裂出的中间节点的数目 + 光杆树溢出时分裂出的双翼的长度]
        !! [(翅膀最小许可长度+[可疑])*2-1 <= 翅膀缺员时退化上限 <= 光杆树最大许可长度-[可疑]]
        任选@[翅膀缺员时退化上限 <- [(翅膀最小许可长度+[可疑])*2-1 ..= (光杆树最大许可长度-[可疑])]]
        ######################
    ######################

@[更深节点最小许可长度 >= 2]:
    [双侧展翅树囗可疑版最小设计方案囗(更深节点最小许可长度) =[def]=: [
    [更深节点最大许可长度 := (更深节点最小许可长度*2-1)]
    [更深节点许可长度集合 := {更深节点最小许可长度..=更深节点最大许可长度}]
    [翅膀最小许可长度 := (更深节点最小许可长度-1)]
    [翅膀最小许可长度 == 更深节点最大的不可表达节点数]
    [翅膀最大许可长度 := 更深节点最大许可长度 +翅膀最小许可长度]
    [翅膀最大许可长度 == (更深节点最小许可长度*3 -2)]
    [翅膀溢出时分裂出的更深节点的各自长度 := [更深节点最大许可长度]]
    [翅膀溢出时分裂出的更深节点的数目 == 1]
    [翅膀溢出时分裂出的节点的数目 == 更深节点最大许可长度]
        # 只留下 (翅膀最小许可长度+1)
    [光杆树最小许可长度 := 0]

    #可疑版:
    [光杆树溢出时分裂出的双翼的长度 := 2*翅膀最小许可长度+3] #奇数
    [光杆树溢出时分裂出的中间节点的数目 := 0]
    [光杆树溢出时分裂出的更深节点的数目 := 0]
    [光杆树溢出时分裂出的更深节点的各自长度 := []]
    [光杆树最大许可长度 := (-1+光杆树溢出时分裂出的中间节点的数目+光杆树溢出时分裂出的双翼的长度)]
    [光杆树最大许可长度 == (2*翅膀最小许可长度+2)]
    [光杆树最大许可长度 == (更深节点最小许可长度*2)]

    [翅膀缺员时退化上限 := (光杆树最大许可长度-1)] #例:最大化
    [翅膀缺员时退化上限 == (翅膀最小许可长度*2+1)]
    [翅膀缺员时退化上限 == (更深节点最小许可长度*2-1)]

    ]]


===
发现 不连续的 更深节点许可长度集合 并无用处
『紧致假设:』[更深节点许可长度集合 == {更深节点最小许可长度..=更深节点最大许可长度}]
    # 约束之一出现处

===
]]
]]]]]]]
[[[
优化:缓存度量
===
* 没有 缓存度量
* 元素 缓存度量 固化:例如:长度
===
]]]
[[[
优化:
优化囗囗巨大囗最大许可长度:here
半扇:翅膀/光杆树/更深节点
===
假设 翅膀/光杆树/更深节点 的 最大许可长度 非常巨大
    迭代一一搜索太慢
    迭代构造太慢
===
搜索:
bisearch/二分搜索?bisect/对半搜索？
需要:缓存度量
构造器 ++计算器<缓存度量>
优先使用(2**e)更深节点 长度
    翅膀溢出时分裂出的更深节点的各自长度:goto
    增长合并
===
分裂:
针对:翅膀/光杆树/更深节点:分别特化:
    分裂出焦点 --> (焦点居前囗起半扇, 焦点居前囗累计值, 焦点, 焦点居后囗讫半扇)
    定位出焦点 --> (焦点居前囗累计值, 焦点)
    分裂 --> (焦点居前囗起半扇, 焦点居前囗累计值, 焦点诸后囗讫半扇)
    定位 --> (焦点居前囗累计值)
统一接口:
    示意分裂 --> (魊 焦点居前囗起半扇, 焦点居前囗累计值, 魊 焦点诸后囗讫半扇, 魊 焦点, 魊 焦点居后囗讫半扇)
===
半扇示意
半扇===(半扇示意,原组织)

===
拼装:光杆树半扇
    光杆树半扇<起半扇丷讫半扇> --> 光杆树
===
拼装:翅膀半扇
    翅膀外端半扇-->光杆树
        # 外端 ==>> [起半扇丷讫半扇 == 起翼丷讫翼]
        # 内端 ==>> [起半扇丷讫半扇 == not 起翼丷讫翼]
        # 外端 ==>> [左半扇丷右半扇 == 左翼丷右翼]
        # 内端 ==>> [左半扇丷右半扇 == not 左翼丷右翼]
    翅膀内端半扇-->长度
    翅膀内端半扇<长/足员> -->翅膀
    翅膀内端半扇<短/缺员> -> 更深节点 -->翅膀
    翅膀内端半扇<短/缺员> -> 异翅 -->光杆树屮均衡双翼/(光杆树丷均衡双翼, 光杆树丨均衡双翼)
===
拼装:更深节点半扇
    更深节点半扇<起半扇丷讫半扇> -> 长度
    更深节点半扇<足员;起半扇丷讫半扇> --> 异侧浅翼/翅膀<起翼丷讫翼=not 起半扇丷讫半扇>
    更深节点半扇<缺员;起半扇丷讫半扇> -> 外端囗更深节点/更深节点<原囗更深节点:外端> --> 异侧浅翼/翅膀<起翼丷讫翼=not 起半扇丷讫半扇>
    更深节点半扇<缺员;起半扇丷讫半扇> -> 同侧浅翼/翅膀<起翼丷讫翼=起半扇丷讫半扇> -->光杆树屮均衡双翼/(光杆树丷均衡双翼, 光杆树丨均衡双翼)
===
]]]





py_adhoc_call   seed.data_funcs.finger_tree.finger_tree_common   ,10:迭代囗给定囗更深节点最小许可长度囗最小囗更深节点最大许可长度囗
    验证: [最小囗更深节点最大许可长度<更深节点最小许可长度> == 更深节点最小许可长度*2-1]

>>> 双侧展翅树囗可疑版最小设计方案囗(2)
FrozenDict({'更深节点最小许可长度': 2, '更深节点最大许可长度': 3, '更深节点许可长度集合': range(2, 4), '更深节点最大的不可表达节点数': 1, '翅膀最小许可长度': 1, '翅膀最大许可长度': 4, '翅膀溢出时分裂出的更深节点的各自长度': (3,), '翅膀溢出时分裂出的节点的数目': 3, '翅膀溢出时分裂出的更深节点的数目': 1, '光杆树最小许可长度': 0, '光杆树溢出时分裂出的双翼的长度': 5, '光杆树溢出时分裂出的更深节点的各自长度': (), '光杆树溢出时分裂出的中间节点的数目': 0, '光杆树溢出时分裂出的更深节点的数目': 0, '光杆树最大许可长度': 4, '翅膀缺员时退化上限': 3})
>>> 双侧展翅树囗可疑版最小设计方案囗(3)
FrozenDict({'更深节点最小许可长度': 3, '更深节点最大许可长度': 5, '更深节点许可长度集合': range(3, 6), '更深节点最大的不可表达节点数': 2, '翅膀最小许可长度': 2, '翅膀最大许可长度': 7, '翅膀溢出时分裂出的更深节点的各自长度': (5,), '翅膀溢出时分裂出的节点的数目': 5, '翅膀溢出时分裂出的更深节点的数目': 1, '光杆树最小许可长度': 0, '光杆树溢出时分裂出的双翼的长度': 7, '光杆树溢出时分裂出的更深节点的各自长度': (), '光杆树溢出时分裂出的中间节点的数目': 0, '光杆树溢出时分裂出的更深节点的数目': 0, '光杆树最大许可长度': 6, '翅膀缺员时退化上限': 5})


>>> from seed.mapping_tools.dict_op import mapping_symmetric_diff4patch__immutable__default, mapping_symmetric_patch4lhs__immutable__default, mapping_symmetric_patch4rhs__immutable__default

>>> f = lambda n:mapping_symmetric_diff4patch__immutable__default(双侧展翅树囗可疑版最小设计方案囗(n), 双侧展翅树囗最小设计方案囗(n, 可疑=True, 优先支持对半搜索=False))
>>> f(2) == {'可疑': (1, True), '优先支持对半搜索': (1, False), '更深节点最优许可长度': (1, 3)}
True
>>> f(3) == {'可疑': (1, True), '优先支持对半搜索': (1, False), '更深节点最优许可长度': (1, 5)}
True
>>> f(4) == {'可疑': (1, True), '优先支持对半搜索': (1, False), '更深节点最优许可长度': (1, 7)}
True
>>> f(5) == {'可疑': (1, True), '优先支持对半搜索': (1, False), '更深节点最优许可长度': (1, 9)}
True


>>> g = lambda n:mapping_symmetric_diff4patch__immutable__default(双侧展翅树囗可疑版最小设计方案囗(n), 双侧展翅树囗最小设计方案囗(n, 可疑=False, 优先支持对半搜索=False))
>>> g(2) == {'光杆树最大许可长度': (3, (4, 1)), '光杆树溢出时分裂出的双翼的长度': (3, (5, 2)), '翅膀缺员时退化上限': (3, (3, 1)), '可疑': (1, False), '更深节点最优许可长度': (1, 3), '优先支持对半搜索': (1, False)}
True
>>> g(3) == {'光杆树最大许可长度': (3, (6, 3)), '光杆树溢出时分裂出的双翼的长度': (3, (7, 4)), '翅膀缺员时退化上限': (3, (5, 3)), '可疑': (1, False), '更深节点最优许可长度': (1, 5), '优先支持对半搜索': (1, False)}
True
>>> g(4) == {'光杆树最大许可长度': (3, (8, 5)), '光杆树溢出时分裂出的双翼的长度': (3, (9, 6)), '翅膀缺员时退化上限': (3, (7, 5)), '可疑': (1, False), '更深节点最优许可长度': (1, 7), '优先支持对半搜索': (1, False)}
True

>>> h = lambda n:mapping_symmetric_diff4patch__immutable__default(双侧展翅树囗可疑版最小设计方案囗(n), 双侧展翅树囗最小设计方案囗(n, 可疑=True, 优先支持对半搜索=True))
>>> h(2) == {'翅膀溢出时分裂出的节点的数目': (3, (3, 2)), '翅膀溢出时分裂出的更深节点的各自长度': (3, ((3,), (2,))), '可疑': (1, True), '更深节点最优许可长度': (1, 2), '优先支持对半搜索': (1, True)}
True
>>> h(3) == {'翅膀溢出时分裂出的节点的数目': (3, (5, 4)), '翅膀溢出时分裂出的更深节点的各自长度': (3, ((5,), (4,))), '可疑': (1, True), '更深节点最优许可长度': (1, 4), '优先支持对半搜索': (1, True)}
True
>>> h(4) == {'翅膀溢出时分裂出的节点的数目': (3, (7, 4)), '翅膀溢出时分裂出的更深节点的各自长度': (3, ((7,), (4,))), '可疑': (1, True), '更深节点最优许可长度': (1, 4), '优先支持对半搜索': (1, True)}
True
>>> h(5) == {'翅膀溢出时分裂出的节点的数目': (3, (9, 8)), '翅膀溢出时分裂出的更深节点的各自长度': (3, ((9,), (8,))), '可疑': (1, True), '更深节点最优许可长度': (1, 8), '优先支持对半搜索': (1, True)}
True







TODO:
test:双侧展翅树囗数据类型配置囗囗紧致假设囗囗缓存度量囗囗囗标准元组囗囗缓存度量为长度
vs:
    双侧展翅树囗相关操作囗囗囗配置囗囗二囗元组囗长度囗囗甲
    双侧展翅树囗相关操作囗囗囗配置囗囗二囗元组囗长度囗囗乙
#>>> ops = 双侧展翅树囗相关操作囗囗囗配置囗囗二囗元组囗长度囗囗甲
#>>> ops.构造树囗([], 左起丷右起=False)
#>>> ops.构造树囗([1], 左起丷右起=False)



#]]]'''
__all__ = r'''
迭代囗给定囗更深节点最小许可长度囗最小囗更深节点最大许可长度囗

双侧展翅树囗可疑版最小设计方案囗
双侧展翅树囗最小设计方案囗



乸双侧展翅树囗参数配置囗囗紧致假设
    检查约束囗双侧展翅树囗配置囗

is4bool_
    xor4bool_
    半扇囗相对定位巛绝对定位囗
    半扇囗绝对定位巛相对定位囗
    翅膀囗相对定位巛绝对定位囗
    翅膀囗绝对定位巛相对定位囗
    翅膀囗定位端口方位巛相对定位囗
    翅膀囗定位端口方位巛绝对定位囗


构造囗最小化方案囗囗双侧展翅树囗参数配置囗囗紧致假设囗
    匞双侧展翅树囗最小参数配置囗囗囗二囗对半


错误
    错误囗囗空树囗囗光杆树
    错误囗囗缺员囗囗光杆树
    错误囗囗缺员囗囗翅膀
    错误囗囗溢出囗囗光杆树
    错误囗囗溢出囗囗翅膀
    错误囗囗零深度节点囗子节点
    错误囗囗长度囗囗翅膀
    错误囗囗长度囗囗更深节点
    错误囗囗长度囗囗光杆树




匿双侧展翅树囗最小设计方案囗囗囗二囗无印
    匿双侧展翅树囗最小设计方案囗囗囗二囗对半
    匿双侧展翅树囗最小设计方案囗囗囗二囗可疑
    匿双侧展翅树囗最小设计方案囗囗囗二囗可疑囗对半
匞双侧展翅树囗最小参数配置囗囗囗二囗无印
    匞双侧展翅树囗最小参数配置囗囗囗二囗对半
    匞双侧展翅树囗最小参数配置囗囗囗二囗可疑
    匞双侧展翅树囗最小参数配置囗囗囗二囗可疑囗对半

'''.split()#'''


r'''
魖双侧展翅树囗数据类型配置囗囗紧致假设
    魖双侧展翅树囗数据类型配置囗囗紧致假设囗囗缓存度量
        魖双侧展翅树囗数据类型配置囗囗紧致假设囗囗缓存度量为长度
        魖双侧展翅树囗数据类型配置囗囗紧致假设囗囗缓存度量囗囗囗标准元组
            双侧展翅树囗数据类型配置囗囗紧致假设囗囗缓存度量囗囗囗标准元组
            双侧展翅树囗数据类型配置囗囗紧致假设囗囗缓存度量囗囗囗标准元组囗囗缓存度量为长度





魖双侧展翅树囗相关操作
    魖双侧展翅树囗相关操作囗囗囗配置
        双侧展翅树囗相关操作囗囗囗配置


数据类型配置囗囗囗元组囗长度
双侧展翅树囗相关操作囗囗囗配置囗囗二囗元组囗长度囗囗甲
双侧展翅树囗相关操作囗囗囗配置囗囗二囗元组囗长度囗囗乙









乸双侧展翅树囗参数配置囗囗紧致假设
    检查约束囗双侧展翅树囗配置囗
构造囗最小化方案囗囗双侧展翅树囗参数配置囗囗紧致假设囗
    匞双侧展翅树囗最小参数配置囗囗囗二囗无印
    匞双侧展翅树囗最小参数配置囗囗囗三囗无印
    匞双侧展翅树囗最小参数配置囗囗囗四囗无印
    匞双侧展翅树囗最小参数配置囗囗囗五囗无印
    匞双侧展翅树囗最小参数配置囗囗囗六囗无印
    匞双侧展翅树囗最小参数配置囗囗囗七囗无印
    匞双侧展翅树囗最小参数配置囗囗囗八囗无印
    匞双侧展翅树囗最小参数配置囗囗囗九囗无印
    匞双侧展翅树囗最小参数配置囗囗囗二囗可疑
    匞双侧展翅树囗最小参数配置囗囗囗三囗可疑
    匞双侧展翅树囗最小参数配置囗囗囗四囗可疑
    匞双侧展翅树囗最小参数配置囗囗囗五囗可疑
    匞双侧展翅树囗最小参数配置囗囗囗六囗可疑
    匞双侧展翅树囗最小参数配置囗囗囗七囗可疑
    匞双侧展翅树囗最小参数配置囗囗囗八囗可疑
    匞双侧展翅树囗最小参数配置囗囗囗九囗可疑

双侧展翅树囗最小设计方案囗
    匿双侧展翅树囗最小设计方案囗囗囗二囗无印
    匿双侧展翅树囗最小设计方案囗囗囗三囗无印
    匿双侧展翅树囗最小设计方案囗囗囗四囗无印
    匿双侧展翅树囗最小设计方案囗囗囗五囗无印
    匿双侧展翅树囗最小设计方案囗囗囗六囗无印
    匿双侧展翅树囗最小设计方案囗囗囗七囗无印
    匿双侧展翅树囗最小设计方案囗囗囗八囗无印
    匿双侧展翅树囗最小设计方案囗囗囗九囗无印
    匿双侧展翅树囗最小设计方案囗囗囗二囗可疑
    匿双侧展翅树囗最小设计方案囗囗囗三囗可疑
    匿双侧展翅树囗最小设计方案囗囗囗四囗可疑
    匿双侧展翅树囗最小设计方案囗囗囗五囗可疑
    匿双侧展翅树囗最小设计方案囗囗囗六囗可疑
    匿双侧展翅树囗最小设计方案囗囗囗七囗可疑
    匿双侧展翅树囗最小设计方案囗囗囗八囗可疑
    匿双侧展翅树囗最小设计方案囗囗囗九囗可疑
'''.split()#'''
__all__




from seed.math.floor_ceil import floor_log2
from seed.abc.abc__ver1 import abstractmethod, override, ABC, ABC__no_slots
from seed.types.NamespaceABC import StaticImmutableNamespaceBase

from seed.types.FrozenDict import FrozenDict, mk_FrozenDict
from seed.tiny_.check import check_int_ge
from seed.tiny import check_type_is

from itertools import count



#from seed.iters.PeekableIterator import PeekableIterator, echo_or_mk_PeekableIterator
#from seed.tiny import check_type_is, null_tuple, mk_reiterable, ifNone, echo
#from itertools import count, islice, chain
#import operator as opss






def 迭代囗给定囗更深节点最小许可长度囗最小囗更深节点最大许可长度囗(起始囗更深节点最小许可长度=None):
    '-> Iter (更深节点最小许可长度, 最小囗更深节点最大许可长度<更深节点最小许可长度>) # [最小囗更深节点最大许可长度<更深节点最小许可长度> == 更深节点最小许可长度*2-1]'
    from seed.math.generate_partition4additive_semigroup__total_ordering__increasing import search_max_miss_ex__pint_additive_generators_, partition_pint4max_miss_ex__pint_additive_generators_
    #from seed.math.cut_uint_into_uints import Helper4cut_uint_into_uints, calc_lowerbound_of_inf_compact_domain_rng4cut_uint_into_uints

    if 起始囗更深节点最小许可长度 is None:
        起始囗更深节点最小许可长度 = -1
    起始囗更深节点最小许可长度 = max(2, 起始囗更深节点最小许可长度)
    for 更深节点最小许可长度 in count(起始囗更深节点最小许可长度):
        max_begin = 2*更深节点最小许可长度-2
        for 更深节点最大许可长度 in range(更深节点最小许可长度+1, 2*更深节点最小许可长度):
            x = search_max_miss_ex__pint_additive_generators_(range(更深节点最小许可长度, 更深节点最大许可长度+1), may_max_begin=max_begin)
            if not x is False:
                break
        else:
            raise Exception(f'logic-err: {更深节点最小许可长度}')
        最小囗更深节点最大许可长度 = 更深节点最大许可长度
        yield (更深节点最小许可长度, 最小囗更深节点最大许可长度)

def 双侧展翅树囗可疑版最小设计方案囗(更深节点最小许可长度, /):
    check_int_ge(2, 更深节点最小许可长度)
    #
    [更深节点最大许可长度 := (更深节点最小许可长度*2-1)]
    [更深节点许可长度集合 := range(更深节点最小许可长度, 1+更深节点最大许可长度)]
    [更深节点最大的不可表达节点数 := (更深节点最小许可长度-1)]
    [翅膀最小许可长度 := (更深节点最小许可长度-1)]
    assert 翅膀最小许可长度 == 更深节点最大的不可表达节点数
    [翅膀最大许可长度 := 更深节点最大许可长度 +翅膀最小许可长度]
    assert 翅膀最大许可长度 == (更深节点最小许可长度*3 -2)
    [翅膀溢出时分裂出的更深节点的各自长度 := (更深节点最大许可长度,)]
    [翅膀溢出时分裂出的节点的数目 := sum(翅膀溢出时分裂出的更深节点的各自长度)]
    [翅膀溢出时分裂出的更深节点的数目 := len(翅膀溢出时分裂出的更深节点的各自长度)]
    assert 翅膀溢出时分裂出的更深节点的数目 == 1
    assert 翅膀溢出时分裂出的节点的数目 == 更深节点最大许可长度
        # 只留下 (翅膀最小许可长度+1)
    [光杆树最小许可长度 := 0]

    #可疑版:
    [光杆树溢出时分裂出的双翼的长度 := 2*翅膀最小许可长度+3] #奇数
    [光杆树溢出时分裂出的更深节点的各自长度 := ()]
    [光杆树溢出时分裂出的中间节点的数目 := sum(光杆树溢出时分裂出的更深节点的各自长度)]
    [光杆树溢出时分裂出的更深节点的数目 := len(光杆树溢出时分裂出的更深节点的各自长度)]
    assert 光杆树溢出时分裂出的中间节点的数目 == 0
    assert 光杆树溢出时分裂出的更深节点的数目 == 0
    [光杆树最大许可长度 := (-1+光杆树溢出时分裂出的中间节点的数目+光杆树溢出时分裂出的双翼的长度)]
    assert 光杆树最大许可长度 == (2*翅膀最小许可长度+2)
    assert 光杆树最大许可长度 == (更深节点最小许可长度*2)

    [翅膀缺员时退化上限 := (光杆树最大许可长度-1)] #例:最大化
    assert 翅膀缺员时退化上限 == (翅膀最小许可长度*2+1)
    assert 翅膀缺员时退化上限 == (更深节点最小许可长度*2-1)

    双侧展翅树囗可疑版最小设计方案 = mk_FrozenDict(locals())
    return 双侧展翅树囗可疑版最小设计方案





__all__
def 双侧展翅树囗最小设计方案囗(更深节点最小许可长度, /, *, 可疑, 优先支持对半搜索):
    check_type_is(bool, 可疑)
    check_type_is(bool, 优先支持对半搜索)
    check_int_ge(2, 更深节点最小许可长度)
    #
    [更深节点最大许可长度 := (更深节点最小许可长度*2-1)]
    [更深节点许可长度集合 := range(更深节点最小许可长度, 1+更深节点最大许可长度)]
    [更深节点最大的不可表达节点数 := (更深节点最小许可长度-1)]
    [翅膀最小许可长度 := (更深节点最小许可长度-1)]
    assert 翅膀最小许可长度 == 更深节点最大的不可表达节点数
    [翅膀最大许可长度 := 更深节点最大许可长度 +翅膀最小许可长度]
    assert 翅膀最大许可长度 == (更深节点最小许可长度*3 -2)
    更深节点最优许可长度 = 更深节点最大许可长度 if not 优先支持对半搜索 else 2**floor_log2(更深节点最大许可长度)
    assert 更深节点最小许可长度 <= 更深节点最优许可长度 <= 更深节点最大许可长度
    # [翅膀溢出时分裂出的更深节点的各自长度 := (更深节点最大许可长度,)]
    [翅膀溢出时分裂出的更深节点的各自长度 := (更深节点最优许可长度,)]
    [翅膀溢出时分裂出的节点的数目 := sum(翅膀溢出时分裂出的更深节点的各自长度)]
    [翅膀溢出时分裂出的更深节点的数目 := len(翅膀溢出时分裂出的更深节点的各自长度)]
    assert 翅膀溢出时分裂出的更深节点的数目 == 1
    if not 优先支持对半搜索:
        assert 翅膀溢出时分裂出的节点的数目 == 更深节点最大许可长度
            # 只留下 (翅膀最小许可长度+1)
    assert 翅膀溢出时分裂出的节点的数目 == 更深节点最优许可长度
    [光杆树最小许可长度 := 0]

    #可疑版:
    # @[光杆树溢出时分裂出的双翼的长度 <- [2*(翅膀最小许可长度+[可疑]) ..= 2*(翅膀最大许可长度-[可疑])]]
    if 0:
        [光杆树溢出时分裂出的双翼的长度 := 2*(翅膀最小许可长度+可疑)]
    else:
        if 可疑:
            #为保证下面: [光杆树溢出时分裂出的中间节点的数目==0]
            #   这里 『+1』
            [光杆树溢出时分裂出的双翼的长度 := 2*(翅膀最小许可长度+可疑) +1] #奇数
            assert 光杆树溢出时分裂出的双翼的长度 == 2*翅膀最小许可长度+3
        else:
            [光杆树溢出时分裂出的双翼的长度 := 2*(翅膀最小许可长度+可疑)]
            assert 光杆树溢出时分裂出的双翼的长度 == 2*翅膀最小许可长度+0
    assert 光杆树溢出时分裂出的双翼的长度 == 2*翅膀最小许可长度+3*可疑

    # @[光杆树溢出时分裂出的中间节点的数目 <- ({0}\-/positive_span<更深节点许可长度集合>)/-\{([[可疑][(光杆树溢出时分裂出的双翼的长度-2*翅膀最小许可长度)==2]])..}]
    assert (可疑 and (光杆树溢出时分裂出的双翼的长度-2*翅膀最小许可长度)==2) == 0
    # [光杆树溢出时分裂出的中间节点的数目 := 0]
    [光杆树溢出时分裂出的更深节点的各自长度 := ()]
    [光杆树溢出时分裂出的中间节点的数目 := sum(光杆树溢出时分裂出的更深节点的各自长度)]
    [光杆树溢出时分裂出的更深节点的数目 := len(光杆树溢出时分裂出的更深节点的各自长度)]
    assert 光杆树溢出时分裂出的中间节点的数目 == 0
    assert 光杆树溢出时分裂出的更深节点的数目 == 0

    [光杆树最大许可长度 := -1 + 光杆树溢出时分裂出的中间节点的数目 + 光杆树溢出时分裂出的双翼的长度]

    # @[翅膀缺员时退化上限 <- [(翅膀最小许可长度+[可疑])*2-1 ..= (光杆树最大许可长度-[可疑])]]
    [翅膀缺员时退化上限 := (光杆树最大许可长度-可疑)] #例外:最大化

    ######################
    双侧展翅树囗最小设计方案 = mk_FrozenDict(locals())
    return 双侧展翅树囗最小设计方案
#end-def 双侧展翅树囗最小设计方案囗(更深节点最小许可长度, /, *, 可疑):

匿双侧展翅树囗最小设计方案囗囗囗二囗无印 = 双侧展翅树囗最小设计方案囗(2, 可疑=False, 优先支持对半搜索=False)
匿双侧展翅树囗最小设计方案囗囗囗二囗对半 = 双侧展翅树囗最小设计方案囗(2, 可疑=False, 优先支持对半搜索=True)
匿双侧展翅树囗最小设计方案囗囗囗二囗可疑 = 双侧展翅树囗最小设计方案囗(2, 可疑=True, 优先支持对半搜索=False)
匿双侧展翅树囗最小设计方案囗囗囗二囗可疑囗对半 = 双侧展翅树囗最小设计方案囗(2, 可疑=True, 优先支持对半搜索=True)
def __():
    匿双侧展翅树囗最小设计方案囗囗囗二囗无印 = 双侧展翅树囗最小设计方案囗(2, 可疑=False)
    匿双侧展翅树囗最小设计方案囗囗囗三囗无印 = 双侧展翅树囗最小设计方案囗(3, 可疑=False)
    匿双侧展翅树囗最小设计方案囗囗囗四囗无印 = 双侧展翅树囗最小设计方案囗(4, 可疑=False)
    匿双侧展翅树囗最小设计方案囗囗囗五囗无印 = 双侧展翅树囗最小设计方案囗(5, 可疑=False)
    匿双侧展翅树囗最小设计方案囗囗囗六囗无印 = 双侧展翅树囗最小设计方案囗(6, 可疑=False)
    匿双侧展翅树囗最小设计方案囗囗囗七囗无印 = 双侧展翅树囗最小设计方案囗(7, 可疑=False)
    匿双侧展翅树囗最小设计方案囗囗囗八囗无印 = 双侧展翅树囗最小设计方案囗(8, 可疑=False)
    匿双侧展翅树囗最小设计方案囗囗囗九囗无印 = 双侧展翅树囗最小设计方案囗(9, 可疑=False)



    匿双侧展翅树囗最小设计方案囗囗囗二囗可疑 = 双侧展翅树囗最小设计方案囗(2, 可疑=True)
    匿双侧展翅树囗最小设计方案囗囗囗三囗可疑 = 双侧展翅树囗最小设计方案囗(3, 可疑=True)
    匿双侧展翅树囗最小设计方案囗囗囗四囗可疑 = 双侧展翅树囗最小设计方案囗(4, 可疑=True)
    匿双侧展翅树囗最小设计方案囗囗囗五囗可疑 = 双侧展翅树囗最小设计方案囗(5, 可疑=True)
    匿双侧展翅树囗最小设计方案囗囗囗六囗可疑 = 双侧展翅树囗最小设计方案囗(6, 可疑=True)
    匿双侧展翅树囗最小设计方案囗囗囗七囗可疑 = 双侧展翅树囗最小设计方案囗(7, 可疑=True)
    匿双侧展翅树囗最小设计方案囗囗囗八囗可疑 = 双侧展翅树囗最小设计方案囗(8, 可疑=True)
    匿双侧展翅树囗最小设计方案囗囗囗九囗可疑 = 双侧展翅树囗最小设计方案囗(9, 可疑=True)











def _check_ints__immutable_(xs, /):
    if type(xs) is range:
        return
    hash(xs)
    len(xs)
    if not type(xs) in (tuple, frozenset): raise TypeError
    for x in xs:
        check_type_is(int, x)
__all__
def 检查约束囗双侧展翅树囗配置囗(*
    ,更深节点最小许可长度
    ,更深节点最大许可长度
    ,更深节点最优许可长度
    ,更深节点许可长度集合
    ,更深节点最大的不可表达节点数
    ,翅膀最小许可长度
    ,翅膀最大许可长度
    ,翅膀溢出时分裂出的更深节点的各自长度
    ,翅膀溢出时分裂出的节点的数目
    ,翅膀溢出时分裂出的更深节点的数目
    ,光杆树最小许可长度
    ,光杆树溢出时分裂出的双翼的长度
    ,光杆树溢出时分裂出的更深节点的各自长度
    ,光杆树溢出时分裂出的中间节点的数目
    ,光杆树溢出时分裂出的更深节点的数目
    ,光杆树最大许可长度
    ,翅膀缺员时退化上限
    ######################
    ,优先支持对半搜索
    ,紧致假设
    ,增长
    ,缩水
    ,增长防板荡
    ,可疑
    ,缩水防板荡
    ,消息盈虚防板荡
    ,增长合并
    ,缩水分裂
    ):
    ######################
  if 1:
    check_type_is(bool, 优先支持对半搜索)
    check_type_is(bool, 紧致假设)
    check_type_is(bool, 增长)
    check_type_is(bool, 缩水)
    check_type_is(bool, 增长防板荡)
    check_type_is(bool, 可疑)
    check_type_is(bool, 缩水防板荡)
    check_type_is(bool, 消息盈虚防板荡)
    check_type_is(bool, 增长合并)
    check_type_is(bool, 缩水分裂)
    ######################
  if 紧致假设:
    check_type_is(range, 更深节点许可长度集合)
    ######################
  if 1:
    _check_ints__immutable_(更深节点许可长度集合)
    _check_ints__immutable_(翅膀溢出时分裂出的更深节点的各自长度)
    _check_ints__immutable_(光杆树溢出时分裂出的更深节点的各自长度)
    ######################
  if 1:
    check_type_is(int, 更深节点最小许可长度)
    check_type_is(int, 更深节点最大许可长度)
    check_type_is(int, 更深节点最优许可长度)
    if 增长合并 or not 更深节点最大的不可表达节点数 is None:
        check_type_is(int, 更深节点最大的不可表达节点数)
    check_type_is(int, 翅膀最小许可长度)
    check_type_is(int, 翅膀最大许可长度)
    check_type_is(int, 光杆树溢出时分裂出的双翼的长度)
    check_type_is(int, 光杆树溢出时分裂出的更深节点的数目)
    check_type_is(int, 光杆树溢出时分裂出的中间节点的数目)
    check_type_is(int, 翅膀溢出时分裂出的节点的数目)
    check_type_is(int, 翅膀溢出时分裂出的更深节点的数目)
    check_type_is(int, 翅膀缺员时退化上限)
    check_type_is(int, 光杆树最大许可长度)
    check_type_is(int, 光杆树最小许可长度)
    ######################
  if 1:
    #后来添加的:优先支持对半搜索
    assert 更深节点最小许可长度 <= 更深节点最优许可长度 <= 更深节点最大许可长度
    assert 更深节点最优许可长度 in 更深节点许可长度集合
  if 优先支持对半搜索:
    assert 更深节点最优许可长度 == 2**floor_log2(更深节点最优许可长度)
    assert 翅膀溢出时分裂出的更深节点的各自长度 == (更深节点最优许可长度,)*翅膀溢出时分裂出的更深节点的数目
    assert 光杆树溢出时分裂出的更深节点的各自长度 == (更深节点最优许可长度,)*光杆树溢出时分裂出的更深节点的数目
  if not 优先支持对半搜索:
    assert 更深节点最优许可长度 == 更深节点最大许可长度

  if 1:
    # 『必须:』[0 <= 光杆树最小许可长度 <= 光杆树最大许可长度]
    assert 0 <= 光杆树最小许可长度 <= 光杆树最大许可长度
    # 『必须:』[0 <= 更深节点最小许可长度 <= 更深节点最大许可长度]
    assert 0 <= 更深节点最小许可长度 <= 更深节点最大许可长度
    # 『必须:』[0 <= 翅膀最小许可长度 <= 翅膀最大许可长度]
    assert 0 <= 翅膀最小许可长度 <= 翅膀最大许可长度
    # 『必须:』[len(更深节点许可长度集合) > 0]
    assert len(更深节点许可长度集合) > 0
    # 『必须:』『定义:』[更深节点最小许可长度==min(更深节点许可长度集合)]
    assert 更深节点最小许可长度==min(更深节点许可长度集合)
    # 『必须:』『定义:』[更深节点最大许可长度==max(更深节点许可长度集合)]
    assert 更深节点最大许可长度==max(更深节点许可长度集合)
    # 『必须:』『定义:』[光杆树最小许可长度==0]
    assert 光杆树最小许可长度==0
    # 『必须:』[光杆树最大许可长度+1>=翅膀最小许可长度*2]
    assert 光杆树最大许可长度+1>=翅膀最小许可长度*2
    # 『必须:』[2*翅膀最小许可长度 <= 光杆树溢出时分裂出的双翼的长度 <= 2*翅膀最大许可长度]
    assert 2*翅膀最小许可长度 <= 光杆树溢出时分裂出的双翼的长度 <= 2*翅膀最大许可长度
  if 增长:
    # 『增长:』[set(光杆树溢出时分裂出的更深节点的各自长度) <= 更深节点许可长度集合]
    assert set(光杆树溢出时分裂出的更深节点的各自长度) <= set(更深节点许可长度集合)
    # 『增长:』『定义:』[光杆树溢出时分裂出的中间节点的数目==sum(光杆树溢出时分裂出的更深节点的各自长度)]
    assert 光杆树溢出时分裂出的中间节点的数目==sum(光杆树溢出时分裂出的更深节点的各自长度)
    # 『增长:』『定义:』[光杆树溢出时分裂出的更深节点的数目==len(光杆树溢出时分裂出的更深节点的各自长度)]
    assert 光杆树溢出时分裂出的更深节点的数目==len(光杆树溢出时分裂出的更深节点的各自长度)

    # 『增长:』[光杆树最大许可长度+1 == 光杆树溢出时分裂出的中间节点的数目 + 光杆树溢出时分裂出的双翼的长度]
    assert 光杆树最大许可长度+1 == 光杆树溢出时分裂出的中间节点的数目 + 光杆树溢出时分裂出的双翼的长度

    # 『增长:』[set(翅膀溢出时分裂出的更深节点的各自长度) <= 更深节点许可长度集合]
    assert set(翅膀溢出时分裂出的更深节点的各自长度) <= set(更深节点许可长度集合)
    # 『增长:』『定义:』[翅膀溢出时分裂出的节点的数目==sum(翅膀溢出时分裂出的更深节点的各自长度)]
    assert 翅膀溢出时分裂出的节点的数目==sum(翅膀溢出时分裂出的更深节点的各自长度)
    # 『增长:』『定义:』[翅膀溢出时分裂出的更深节点的数目==len(翅膀溢出时分裂出的更深节点的各自长度)]
    assert 翅膀溢出时分裂出的更深节点的数目==len(翅膀溢出时分裂出的更深节点的各自长度)
    # 『增长:』[1 <= 翅膀溢出时分裂出的节点的数目 <= 翅膀最大许可长度+1-翅膀最小许可长度]
    assert 1 <= 翅膀溢出时分裂出的节点的数目 <= 翅膀最大许可长度+1-翅膀最小许可长度
  if 增长防板荡:
    # 『可疑:』『增长防板荡:』[2*翅膀最小许可长度 <= 光杆树溢出时分裂出的双翼的长度 <= 2*翅膀最大许可长度-2]
    if 可疑:
        assert 2*翅膀最小许可长度 <= 光杆树溢出时分裂出的双翼的长度 <= 2*翅膀最大许可长度-2
    # 『增长防板荡:』[2 <= 翅膀溢出时分裂出的节点的数目 <= 翅膀最大许可长度+1-翅膀最小许可长度]
    assert 2 <= 翅膀溢出时分裂出的节点的数目 <= 翅膀最大许可长度+1-翅膀最小许可长度
  if 缩水:
    # 『缩水:』[1 <= 更深节点最小许可长度 <= 更深节点最大许可长度 <= 翅膀最大许可长度+1-翅膀最小许可长度]
    assert 1 <= 更深节点最小许可长度 <= 更深节点最大许可长度 <= 翅膀最大许可长度+1-翅膀最小许可长度
    # 『缩水:』[翅膀最小许可长度*2-1 <= 翅膀缺员时退化上限 <= 光杆树最大许可长度]
    assert 翅膀最小许可长度*2-1 <= 翅膀缺员时退化上限 <= 光杆树最大许可长度
  if 缩水防板荡:
    # 『缩水防板荡:』[2 <= 更深节点最小许可长度 <= 更深节点最大许可长度 <= 翅膀最大许可长度+1-翅膀最小许可长度]
    assert 2 <= 更深节点最小许可长度 <= 更深节点最大许可长度 <= 翅膀最大许可长度+1-翅膀最小许可长度
    # 『可疑:』『缩水防板荡:』[翅膀最小许可长度*2+1 <= 翅膀缺员时退化上限 <= 光杆树最大许可长度]
    #     # 2_3_finger_tree无法满足此约束
    if 可疑:
        assert 翅膀最小许可长度*2+1 <= 翅膀缺员时退化上限 <= 光杆树最大许可长度
  if 消息盈虚防板荡:
    # 『可疑:』『消息盈虚防板荡:』[2*翅膀最小许可长度+2 <= 光杆树溢出时分裂出的双翼的长度 <= 2*翅膀最大许可长度-2]
    if 可疑:
        assert 2*翅膀最小许可长度+2 <= 光杆树溢出时分裂出的双翼的长度 <= 2*翅膀最大许可长度-2
    # 『消息盈虚防板荡:』[2 <= 翅膀溢出时分裂出的节点的数目 <= 翅膀最大许可长度-翅膀最小许可长度]
    assert 2 <= 翅膀溢出时分裂出的节点的数目 <= 翅膀最大许可长度-翅膀最小许可长度
    # 『消息盈虚防板荡:』[2 <= 更深节点最小许可长度 <= 更深节点最大许可长度 <= 翅膀最大许可长度-翅膀最小许可长度]
    assert 2 <= 更深节点最小许可长度 <= 更深节点最大许可长度 <= 翅膀最大许可长度-翅膀最小许可长度
    # 『可疑:』『消息盈虚防板荡:』[翅膀最小许可长度*2+1 <= 翅膀缺员时退化上限 <= 光杆树最大许可长度-1]
    #     # 2_3_finger_tree无法满足此约束
    if 可疑:
        assert 翅膀最小许可长度*2+1 <= 翅膀缺员时退化上限 <= 光杆树最大许可长度-1
  if 增长合并:
    # 『增长合并:』『定义:』[更深节点最大的不可表达节点数==search_max_miss_ex__pint_additive_generators_(更深节点许可长度集合)[0]]
    if not 紧致假设:
        from seed.math.generate_partition4additive_semigroup__total_ordering__increasing import search_max_miss_ex__pint_additive_generators_, partition_pint4max_miss_ex__pint_additive_generators_
        max_begin = 1+更深节点最大的不可表达节点数
        assert 更深节点最大的不可表达节点数==search_max_miss_ex__pint_additive_generators_(更深节点许可长度集合, may_max_begin=max_begin)[0]
    else:
        assert 更深节点最大的不可表达节点数==(更深节点最小许可长度-1)
    # 『增长合并:』[更深节点最大的不可表达节点数 <= 翅膀最小许可长度*2-1]
    assert 更深节点最大的不可表达节点数 <= 翅膀最小许可长度*2-1
    # 『增长合并:』[更深节点最小许可长度 >= 2]
    assert 更深节点最小许可长度 >= 2
  if 缩水分裂:
    # 『缩水分裂:』[翅膀最小许可长度+1 <= 更深节点最小许可长度 <= 更深节点最大许可长度 <= 翅膀最大许可长度]
    assert 翅膀最小许可长度+1 <= 更深节点最小许可长度 <= 更深节点最大许可长度 <= 翅膀最大许可长度
    # ===后来添加的:
    # 『紧致假设:』[更深节点许可长度集合 == {更深节点最小许可长度..=更深节点最大许可长度}]
  if 紧致假设:
    assert 更深节点许可长度集合 == range(更深节点最小许可长度, 1+更深节点最大许可长度)
    ######################
#end-def 检查约束囗双侧展翅树囗配置囗







__all__
class 乸双侧展翅树囗参数配置囗囗紧致假设(StaticImmutableNamespaceBase
    #total 25==16+9
    , ordered_user_attr_seq = r'''
    更深节点最小许可长度
    更深节点最大许可长度
    更深节点最优许可长度
    更深节点许可长度集合
    更深节点最大的不可表达节点数
    翅膀最小许可长度
    翅膀最大许可长度
    翅膀溢出时分裂出的更深节点的各自长度
    翅膀溢出时分裂出的节点的数目
    翅膀溢出时分裂出的更深节点的数目
    光杆树最小许可长度
    光杆树溢出时分裂出的双翼的长度
    光杆树溢出时分裂出的更深节点的各自长度
    光杆树溢出时分裂出的中间节点的数目
    光杆树溢出时分裂出的更深节点的数目
    光杆树最大许可长度
    翅膀缺员时退化上限
    优先支持对半搜索
    紧致假设
    增长
    缩水
    增长防板荡
    可疑
    缩水防板荡
    消息盈虚防板荡
    增长合并
    缩水分裂
    '''.split()#'''
    ):
    r'''
    紧致假设:goto
    『紧致假设:』[更深节点许可长度集合 == {更深节点最小许可长度..=更深节点最大许可长度}]

    '''#'''
    __slots__ = ()
    def __init__(sf, /, **kwds):
        if not sf.紧致假设:
            raise TypeError
        检查约束囗双侧展翅树囗配置囗(**kwds)

#end-class 乸双侧展翅树囗参数配置囗囗紧致假设

def 构造囗最小化方案囗囗双侧展翅树囗参数配置囗囗紧致假设囗(更深节点最小许可长度, /, *, 可疑, 优先支持对半搜索):
    紧致假设=True
    增长=True
    缩水=True
    增长防板荡=True
    可疑
    缩水防板荡=True
    消息盈虚防板荡=True
    增长合并=True
    缩水分裂=True
    return 乸双侧展翅树囗参数配置囗囗紧致假设(**{**locals(), **双侧展翅树囗最小设计方案囗(更深节点最小许可长度, 可疑=可疑, 优先支持对半搜索=优先支持对半搜索)})


构造囗最小化方案囗囗双侧展翅树囗参数配置囗囗紧致假设囗
匞双侧展翅树囗最小参数配置囗囗囗二囗无印 = 构造囗最小化方案囗囗双侧展翅树囗参数配置囗囗紧致假设囗(2, 可疑=False, 优先支持对半搜索=False)
匞双侧展翅树囗最小参数配置囗囗囗二囗对半 = 构造囗最小化方案囗囗双侧展翅树囗参数配置囗囗紧致假设囗(2, 可疑=False, 优先支持对半搜索=True)
匞双侧展翅树囗最小参数配置囗囗囗二囗可疑 = 构造囗最小化方案囗囗双侧展翅树囗参数配置囗囗紧致假设囗(2, 可疑=True, 优先支持对半搜索=False)
匞双侧展翅树囗最小参数配置囗囗囗二囗可疑囗对半 = 构造囗最小化方案囗囗双侧展翅树囗参数配置囗囗紧致假设囗(2, 可疑=True, 优先支持对半搜索=True)
def __():
    匞双侧展翅树囗最小参数配置囗囗囗二囗无印 = 构造囗最小化方案囗囗双侧展翅树囗参数配置囗囗紧致假设囗(2, 可疑=False)
    匞双侧展翅树囗最小参数配置囗囗囗三囗无印 = 构造囗最小化方案囗囗双侧展翅树囗参数配置囗囗紧致假设囗(3, 可疑=False)
    匞双侧展翅树囗最小参数配置囗囗囗四囗无印 = 构造囗最小化方案囗囗双侧展翅树囗参数配置囗囗紧致假设囗(4, 可疑=False)
    匞双侧展翅树囗最小参数配置囗囗囗五囗无印 = 构造囗最小化方案囗囗双侧展翅树囗参数配置囗囗紧致假设囗(5, 可疑=False)
    匞双侧展翅树囗最小参数配置囗囗囗六囗无印 = 构造囗最小化方案囗囗双侧展翅树囗参数配置囗囗紧致假设囗(6, 可疑=False)
    匞双侧展翅树囗最小参数配置囗囗囗七囗无印 = 构造囗最小化方案囗囗双侧展翅树囗参数配置囗囗紧致假设囗(7, 可疑=False)
    匞双侧展翅树囗最小参数配置囗囗囗八囗无印 = 构造囗最小化方案囗囗双侧展翅树囗参数配置囗囗紧致假设囗(8, 可疑=False)
    匞双侧展翅树囗最小参数配置囗囗囗九囗无印 = 构造囗最小化方案囗囗双侧展翅树囗参数配置囗囗紧致假设囗(9, 可疑=False)



    匞双侧展翅树囗最小参数配置囗囗囗二囗可疑 = 构造囗最小化方案囗囗双侧展翅树囗参数配置囗囗紧致假设囗(2, 可疑=True)
    匞双侧展翅树囗最小参数配置囗囗囗三囗可疑 = 构造囗最小化方案囗囗双侧展翅树囗参数配置囗囗紧致假设囗(3, 可疑=True)
    匞双侧展翅树囗最小参数配置囗囗囗四囗可疑 = 构造囗最小化方案囗囗双侧展翅树囗参数配置囗囗紧致假设囗(4, 可疑=True)
    匞双侧展翅树囗最小参数配置囗囗囗五囗可疑 = 构造囗最小化方案囗囗双侧展翅树囗参数配置囗囗紧致假设囗(5, 可疑=True)
    匞双侧展翅树囗最小参数配置囗囗囗六囗可疑 = 构造囗最小化方案囗囗双侧展翅树囗参数配置囗囗紧致假设囗(6, 可疑=True)
    匞双侧展翅树囗最小参数配置囗囗囗七囗可疑 = 构造囗最小化方案囗囗双侧展翅树囗参数配置囗囗紧致假设囗(7, 可疑=True)
    匞双侧展翅树囗最小参数配置囗囗囗八囗可疑 = 构造囗最小化方案囗囗双侧展翅树囗参数配置囗囗紧致假设囗(8, 可疑=True)
    匞双侧展翅树囗最小参数配置囗囗囗九囗可疑 = 构造囗最小化方案囗囗双侧展翅树囗参数配置囗囗紧致假设囗(9, 可疑=True)



















class 错误(Exception):pass
class 错误囗囗空树囗囗光杆树(错误):pass
class 错误囗囗缺员囗囗光杆树(错误):pass
class 错误囗囗缺员囗囗翅膀(错误):pass
class 错误囗囗溢出囗囗光杆树(错误):pass
class 错误囗囗溢出囗囗翅膀(错误):pass
class 错误囗囗零深度节点囗子节点(错误):pass

class 错误囗囗长度囗囗翅膀(错误):pass
class 错误囗囗长度囗囗更深节点(错误):pass
class 错误囗囗长度囗囗光杆树(错误):pass

######################
def is4bool_(a, b, /):
    check_type_is(bool, a)
    check_type_is(bool, b)
    return a is b
def xor4bool_(a, b, /):
    check_type_is(bool, a)
    check_type_is(bool, b)
    return a is not b
def 半扇囗相对定位巛绝对定位囗(*, 左起丷右起, 左半扇丷右半扇):
    起半扇丷讫半扇 = xor4bool_(左起丷右起, 左半扇丷右半扇)
    return 起半扇丷讫半扇
def 半扇囗绝对定位巛相对定位囗(*, 左起丷右起, 起半扇丷讫半扇):
    左半扇丷右半扇 = xor4bool_(左起丷右起, 起半扇丷讫半扇)
    return 左半扇丷右半扇
def 翅膀囗相对定位巛绝对定位囗(*, 左起丷右起, 左翼丷右翼):
    起翼丷讫翼 = xor4bool_(左起丷右起, 左翼丷右翼)
    return 起翼丷讫翼
def 翅膀囗绝对定位巛相对定位囗(*, 左起丷右起, 起翼丷讫翼):
    左翼丷右翼 = xor4bool_(左起丷右起, 起翼丷讫翼)
    return 左翼丷右翼
def 翅膀囗定位端口方位巛相对定位囗(*, 外端丷内端, 左起丷右起, 起翼丷讫翼):
    '-> 左端丷右端'
    左翼丷右翼 = 翅膀囗绝对定位巛相对定位囗(左起丷右起=左起丷右起, 起翼丷讫翼=起翼丷讫翼)
    左端丷右端 = 翅膀囗定位端口方位巛绝对定位囗(外端丷内端=外端丷内端, 左翼丷右翼=左翼丷右翼)
    return 左端丷右端
def 翅膀囗定位端口方位巛绝对定位囗(*, 外端丷内端, 左翼丷右翼):
    左端丷右端 = xor4bool_(外端丷内端, 左翼丷右翼)
    return 左端丷右端
######################
__all__
#class 魖双侧展翅树囗数据类型配置囗囗显式参数列举式囗囗面向适配底层数据类型(ABC):
    #底层接口冖冖某某某
#class 魖双侧展翅树囗数据类型配置囗囗显式参数打包式囗囗面向组合式接口编程(ABC):
    #外参接口冖冖某某某(..., 参数配置=???)
#class 魖双侧展翅树囗数据类型配置囗囗隐式参数囗囗面向树子类设计者囗囗节点版(ABC):
    #内参接口冖冖某某某<参数配置>(...)
    #元素版内参接口冖冖某某某
#class 魖双侧展翅树囗相关操作囗囗面向树实例终端用户囗囗元素版(ABC):
    #某某某#元素版
#


__all__
def __():
    class 魖双侧展翅树囗数据类型配置囗囗隐式参数囗囗面向树子类设计者囗囗节点版(ABC):
        #似乎没有必要
        __slots__ = ()
        ...

if __name__ == "__main__":
    pass
__all__

from seed.data_funcs.finger_tree.finger_tree_common import 乸双侧展翅树囗参数配置囗囗紧致假设
from seed.data_funcs.finger_tree.finger_tree_common import *




