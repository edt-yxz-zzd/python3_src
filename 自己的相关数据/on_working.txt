[
e ../../python3_src/seed/recognize/CmdlinePrefixParser.py



backup_tools
  nn_ns.filedir.backup_tools._debug
  nn_ns.filedir.backup_tools._test_main
    nn_ns.filedir.backup_tools.main
    nn_ns.filedir.backup_tools.filedir_cmp_utils__repository__fsys_mapping
  DONE-basic


view /sdcard/0my_files/tmp/src/glob.py
  py-3.8::glob
  e /sdcard/0my_files/tmp/src/glob_ex.py
  e ../../python3_src/seed/for_libs/for_glob/IGlob.py
  e ../../python3_src/seed/for_libs/for_glob/glob_match.py
  DONE


finger_tree_ops
  e ../../python3_src/script/finger_tree_ops.py

repr_sys
  e ../../python3_src/seed/helper/repr/repr_sys.py
  e ../../python3_src/seed/helper/repr/repr_api.py


IOps
  e ../../python3_src/seed/ops/___IOps___.py

IOps4OneMainObjType
  e ../../python3_src/seed/ops/IOps4OneMainObjType.py
  e ../../python3_src/seed/ops/___IOps4OneMainObjType___.py


py仿真hs
  e ../../python3_src/nn_ns/mimic_Haskell/Data.py
外挂接口体系
  e ../../python3_src/seed/hierarchy/README.txt


以构造 变换/函数 为 目标/输出:
  e ../../python3_src/seed/func_tools/parameterized_transform.py
  ---还有：
  fmap, dive-into, recur_convert
  深入，多参数平行深入
    单参数 fmap, hash, repr, CSV/TSV等 行域文本(域内之域，深入切分), filter(iterator, list, dict(pred on val)), check
    双参数 diff/patch(输出/输入delta), cmp/eq/lt(自引用 类型描述 需cache ancestor caller args), 泛型schema的匹配(求出 类型变量 的 统一融合值)
    ---
    [[拆分 fmapT.py
      fmapT__tiny.py
      DONE ]]
  DONE 拆分:e ../../python3_src/seed/func_tools/fmapT/_xxxT__tiny.py


包含 很多 unicode_13::UCD/Unihan 的 相关信息:
  e ../../python3_src/script/try_python/unicodedata/list_all_values_of_property.py
e ../../python3_src/script/try_python/unicodedata/list_all_values_of_property.py
  很多 TODO 目标
  parse UCD 13.0:
    区域名
    属性名 属性值别名
    汉字变体字:简繁字/形近字/同义字/异体字
    窄字符的全角字符变体/宽字符的半角字符变体
    成对字符/近似镜像字符
    ...
  [[拆分 移至 unicide 标准 的 笔记摘要
!mkdir ../../txt_phone/lots/NOTE/unicode/note4UnicodeStandard_13_0_pdf/
!cp ../../python3_src/script/try_python/unicodedata/list_all_values_of_property.py   ../../txt_phone/lots/NOTE/unicode/note4UnicodeStandard_13_0_pdf/[20220407]list_all_values_of_property.py
view ../../txt_phone/lots/NOTE/unicode/note4UnicodeStandard_13_0_pdf/[20220407]list_all_values_of_property.py
e ../../txt_phone/lots/NOTE/unicode/note4UnicodeStandard_13_0_pdf/unicode_ver13_0第3第4章摘要.txt
e ../../txt_phone/lots/NOTE/unicode/note4UnicodeStandard_13_0_pdf/unicode_ver13_0数据库清单及我注.txt
  ]]



考虑进一步 缩水:
  e ../../python3_src/nn_ns/CJK/cjk_subsets/cjk_common_subset.py
  去除 简繁不一致，有 异体字、形近字、同义字、...
  from nn_ns.CJK.cjk_subsets.hanzi import cjk_common_subset_1869

  ===
  还有 用 汉字 编码 整数
  主要是 要能 从 字形/笔划 上 看出 2进制 比特
  因为:
    bin 嫌太长，而且 没有 归组，很难 定位 到 特定 位置，以 读取 该位置上的 的 比特值。
    hex 很难 直观 得到 比特流。

[[
  from nn_ns.CJK.cjk_subsets.hanzi import cjk_common_subset_1869
  对比一下:
    nn_ns.CJK.CJK_data.汉字繁简
    nn_ns.CJK.unicode.ucd_unihan.unihan.parsed_result__of__Unihan_Variants_txt__of_ver13_0

e script/简繁字信息对比.py
  from nn_ns.CJK.CJK_data.汉字繁简 import (
    简繁字对集
        ,繁体字到简体字串
        ,简体字到繁体字串
    )
  view ../../python3_src/nn_ns/CJK/CJK_data/raw/汉字繁简.py
    简繁字对集
        繁体字到简体字串
        简体字到繁体字串
        ====上面是读取已打包好的数据，下面是解析生成
        view ../../python3_src/nn_ns/CJK/CJK_data/raw/parse_繁简.py
          从网上搜集的繁简字信息，但不含UCD::Unihan::Unihan_Variants.txt
  from nn_ns.CJK.unicode.ucd_unihan.unihan.parsed_result__of__Unihan_Variants_txt__of_ver13_0 import readonly_parsed_result4ver13_0, readonly_simplified_result4ver13_0
      view /storage/emulated/0/0my_files/unzip/e_book/unicode_13__Unihan/Unihan_Variants.txt
e script/简繁字信息对比.py
py script/简繁字信息对比.py > script/简繁字信息对比.py.out.txt
view script/简繁字信息对比.py.out.txt
py script/简繁字信息对比.py 显示消除非平凡繁简属性字后的1869与2513 -o script/简繁字信息对比.py.显示消除非平凡繁简属性字后的1869与2513.out.txt
view script/简繁字信息对比.py.显示消除非平凡繁简属性字后的1869与2513.out.txt
diff script/简繁字信息对比.py.显示消除非平凡繁简属性字后的1869与2513.out.txt script/简繁字信息对比.py.out.txt

!mkdir ../../python3_src/nn_ns/CJK/CJK_data/raw/简繁字信息对比/
!cp script/简繁字信息对比.py  script/简繁字信息对比.py.显示消除非平凡繁简属性字后的1869与2513.out.txt      ../../python3_src/nn_ns/CJK/CJK_data/raw/简繁字信息对比/
view ../../python3_src/nn_ns/CJK/CJK_data/raw/简繁字信息对比/简繁字信息对比.py.显示消除非平凡繁简属性字后的1869与2513.out.txt
view ../../python3_src/nn_ns/CJK/CJK_data/raw/简繁字信息对比/简繁字信息对比.py


[DONE:
hz2513 /-\ trivial_TS_hzs
  另外 建档
  中外共享汉字集
  古今中外共享汉字集
    =中外共享汉字集/-\平凡繁简汉字集
    =中外共享汉字集\-\非平凡繁简汉字集
e ../../python3_src/nn_ns/CJK/cjk_subsets/hanzi.py
]

[DONE:
hz2513 -> 笔顺码
  另外 建档
view ../../python3_src/nn_ns/CJK/cjk_subsets/共享汉字集笔顺码.py
]

[TODO:
hz2513 -> IDS
  另外 建档
e ../../python3_src/nn_ns/CJK/cjk_subsets/共享汉字集字形拆分树.py
  from:
    view script/collect_hz_components.py
from nn_ns.CJK.CJK_struct.CHISE_IDS_67b94ff_20191211.parse_result___CHISE_IDS import hz2tree___BMP_only

view script/collect_hz_components.py
    py_eval --startup 'import unicodedata as U' --turnoff_eval --postprocess 'lambda x:(x, U.name(x))' -i ⺳ タ 具 ⺢  ⻖ ⺗ 直 ⺯ 刃 ⺜ ⺇ ⻀ ⺫  𥄳 ⺃ 屮 旣 ⺲ ⻏ 灰 ⺈ ⺊  冗 ⺼ ⺧ ⻢ 穀 ⺣ ⺄ ⺆ 充  ⺪ 叟 者 ⻞ ⺶ ⻃ ⺌ ⻤ ⻌
[⺳タ具⺢⻖⺗直⺯刃⺜⺇⻀⺫𥄳⺃屮旣⺲⻏灰⺈⺊冗⺼⺧⻢穀⺣⺄⺆充⺪叟者⻞⺶⻃⺌⻤⻌]
DOING
]
[TODO:

view ../../python3_src/nn_ns/app/register_xor.py
  第二版 由almost_symmetry_cipher 到 真完全对称
e others/数学/编程/TODO_list/周期长度为二的对称加密.txt
e ../../python3_src/nn_ns/app/crypt/UnitSqrtCipher/unit_sqrt_cipher.py
DOING
e ../../python3_src/nn_ns/app/crypt/involution/InvolutoryCipher.py
e ../../python3_src/nn_ns/math_nn/convolution.py

]
[TODO:
hz2513 -> 频数/分级 ++Unihan
  另外 建档
e ../../python3_src/nn_ns/CJK/cjk_subsets/共享汉字集频度.py
]
[TODO:
hz2513 -> 拼音 ++Unihan
  另外 建档
e ../../python3_src/nn_ns/CJK/cjk_subsets/共享汉字集拼音.py
进一步 缩减:除去 多音字？
]
[DONE:
  mv to nn_ns?? 整合进 hanzi.py?? 再添个 模拟 佛曰/与佛论禅？
用于编码二进制数据的高稳定度汉字字集
用汉字编码数据.高稳定度汉字字集
可用于类似『佛曰/与佛论禅』的项目。

e ../../python3_src/nn_ns/CJK/CJK_data/raw/用汉字编码数据/高稳定度汉字字集.py
view ../../python3_src/nn_ns/CJK/CJK_data/raw/用汉字编码数据/chars_in_banned_words.u8
view ../../python3_src/script/char/common_CJK/[common_CJK]ReadMe.txt
]



[DONE
汉字笔划 --> 4bit/8bit  ...6bit?
e script/repr_binary_by_hz_stroke_kind.py
没有8bit
!mkdir   ../../python3_src/nn_ns/CJK/CJK_data/raw/用汉字表达二进制/
!cp script/repr_binary_by_hz_stroke_kind.py    ../../python3_src/nn_ns/CJK/CJK_data/raw/用汉字表达二进制/
view ../../python3_src/nn_ns/CJK/CJK_data/raw/用汉字表达二进制/repr_binary_by_hz_stroke_kind.py
!du -h ../../python3_src/nn_ns/CJK/CJK_data/raw/用汉字表达二进制/repr_binary_by_hz_stroke_kind.py
  108K
!mv script/repr_binary_by_hz_stroke_kind.py    script/[20220413]repr_binary_by_hz_stroke_kind.py
ls   'script/[20220413]repr_binary_by_hz_stroke_kind.py'

e ../../python3_src/nn_ns/CJK/CJK_data/raw/用汉字表达二进制/结果速报.txt
]

]]

[[DONE
---
filterT/alterT mimic fmapT
    filterT===ctor(filter(iter...))
    alterT===ctor(filter(chain...))
---
]]


[[[TODO:
尽量少拆

===
[[
拆字:
  拆否？
    天，矢/知，广，之，鬼...
    呆果男
    ===
    点 视为 附加物
      其他单笔，如果接触其他部件，也视为 附加物，不拆出
      土士王玉主义互母舟
    部件 并非 稳定，一个 代表 多个，不断精细化归类
      月:月，青字底，肉月
      日:日，子曰，冒头
      火:火，火左旁，火底，四点水，
      木:木，木左旁，木底(带钩？)
      耳:耳，戢，左立耳，右立耳，取，最，聽
    不同地区，字形不同，部件不同
    字形有特别约束的，不拆:
      二三土士未末曰冃日
    字形排版复杂的，不拆:
      兔鬼包
  命名:
    例子减去其余部分:
      打丁==>>提手
    近似叠加+所在例子:
      口木刺==>>朿 #不是『束/呆/杏』
]]
===

view ../../python3_src/nn_ns/CJK/CJK_struct/CHISE_IDS_67b94ff_20191211/basic_decomp.txt
  generated by:
    view ../../python3_src/nn_ns/CJK/CJK_struct/CHISE_IDS_67b94ff_20191211/parse_CHISE_IDS.py
每个tree建立反向索引:
  Map tree (Set ((idx, tree)|(0,hz)))
  一tree多字形
下面 部件=tree，身兼多个字形，并非正常意义上的部件
截止:
  * 交叠类 不拆
  * 当有一直接子部件是单笔部件时，不拆
  * 其余 人工检查
  ===
  拓扑排序
  计数被引用次数-->阈值
    定义 可拆出部件
      = 『被引用次数超过阈值』并且不是『单笔部件』并且不是『用户显式指定的不可拆出部件』的部件
      | 所有直接子部件都是『可拆出部件』的部件
  当一个部件的所有直接子部件都是『可拆出部件』时，可将之拆开。
e script/collect_hz_components.py
e ../../python3_src/seed/io/fielded_line_utils.py
$ ls ../../python3_src/nn_ns/CJK/unicode/ucd_unihan/ucd/
    dump_load___parsed_result__of__PropList_txt.py
    parse__PropList_txt.py
    parse__PropList_txt.py.out.ver13_0.hex.txt
    parsed_result__of__PropList_txt__of_ver13_0.py
      DONE:有毛病！unicode的PropList.txt本身就是TouchRanges(见:属性Pattern_Syntax)，但我没有转化为NonTouchRanges

[[
e script/show__Pattern_Syntax__Pattern_White_Space.py
view ../lots/NOTE/unicode/note4UnicodeStandard_13_0_pdf/unicode_ver13_0__Normalization.txt
===
view ../lots/NOTE/unicode/note4UnicodeStandard_14_0_annex/unicode_ver14_0_UAX31_UAX38摘要.txt
  分类:
  #字集不再变:
    Pattern_Syntax Characters
    Pattern_White_Space Characters
    #还有:Noncharacter_Code_Point=True也是不再变
  #字集可变:
    ID_Start Characters
      ++ from {ID_Nonstart Characters, Other Assigned Code Points, Unassigned Code Points}
    ID_Nonstart Characters
      ++ from {Other Assigned Code Points, Unassigned Code Points}
    Other Assigned Code Points
      ++ from {Unassigned Code Points}
    Unassigned Code Points
view /storage/emulated/0/0my_files/unzip/e_book/unicode_13__UCD/PropList.txt
    view ../../python3_src/nn_ns/CJK/unicode/ucd_unihan/ucd/parsed_result__of__PropList_txt__of_ver13_0.py
    view ../../python3_src/nn_ns/CJK/unicode/ucd_unihan/ucd/parse__PropList_txt.py.out.ver13_0.hex.txt
# Total code points: 2760
    ,'Pattern_Syntax'
    : [(0x21, 0x30), (0x3a, 0x41), (0x5b, 0x5f), (0x60, 0x61), (0x7b, 0x7f), (0xa1, 0xa8), (0xa9, 0xaa), (0xab, 0xad), (0xae, 0xaf), (0xb0, 0xb2), (0xb6, 0xb7), (0xbb, 0xbc), (0xbf, 0xc0), (0xd7, 0xd8), (0xf7, 0xf8), (0x2010, 0x2028), (0x2030, 0x203f), (0x2041, 0x2054), (0x2055, 0x205f), (0x2190, 0x2460), (0x2500, 0x2776), (0x2794, 0x2c00), (0x2e00, 0x2e80), (0x3001, 0x3004), (0x3008, 0x3021), (0x3030, 0x3031), (0xfd3e, 0xfd40), (0xfe45, 0xfe47)]
# Total code points: 11
    ,'Pattern_White_Space'
    : [(0x9, 0xe), (0x20, 0x21), (0x85, 0x86), (0x200e, 0x2010), (0x2028, 0x202a)]
e
]]


view ../../python3_src/nn_ns/CJK/unicode/ucd_unihan/ucd/parse__CJKRadicals_txt.py
view ../../python3_src/nn_ns/CJK/unicode/ucd_unihan/ucd/dump_load___parsed_result__of__CJKRadicals_txt.py

view ../../python3_src/nn_ns/CJK/unicode/ucd_unihan/ucd/parsed_result__of__PropList_txt__of_ver13_0.py
view ../../python3_src/nn_ns/CJK/unicode/ucd_unihan/ucd/parsed_result__of__CJKRadicals_txt__of_ver13_0.py
from nn_ns.CJK.unicode.ucd_unihan.ucd.parsed_result__of__CJKRadicals_txt__of_ver13_0 import readonly_parsed_result4ver13_0, readonly_compact_result4ver13_0, readonly_radical_char2unified_ideograph4ver13_0, readonly_simplified_radical2traditional_radical4ver13_0
view ../../python3_src/nn_ns/CJK/unicode/ucd_unihan/ucd/parse__CJKRadicals_txt.py.out.ver13_0.txt

[[
TODO:
  + 用 统一区汉字 替换掉 兼容字符 部首字符
  + hz2513 另档？
  + 手动 逐个记录 高频 部件(ref_count)，引用字集 使用 部件的不同字形 要区分开来

unicode 兼容字符 的 『原字符』属性名 是什么？
  DONE:Blocks/kIICore/kCompatibilityVariant...
  ===
  DONE:kCompatibilityVariant
      view ../../python3_src/nn_ns/CJK/unicode/ucd_unihan/unihan/parse__kCompatibilityVariant8Unihan_IRGSources_txt.py
      view ../../python3_src/nn_ns/CJK/unicode/ucd_unihan/unihan/dump_load___parsed_result__of__kCompatibilityVariant8Unihan_IRGSources_txt.py
      view ../../python3_src/nn_ns/CJK/unicode/ucd_unihan/unihan/parsed_result__of__kCompatibilityVariant8Unihan_IRGSources_txt__of_ver13_0.py
  ===
  DONE:view /sdcard/0my_files/unzip/e_book/unicode_13__UCD/Blocks.txt
      2FF0..2FFF; Ideographic Description Characters
    grep Compatibility /sdcard/0my_files/unzip/e_book/unicode_13__UCD/Blocks.txt
      3130..318F; Hangul Compatibility Jamo
      3300..33FF; CJK Compatibility
        2**8=256
      F900..FAFF; CJK Compatibility Ideographs
        2**9=512
      FE30..FE4F; CJK Compatibility Forms
        2**5=32
      2F800..2FA1F; CJK Compatibility Ideographs Supplement
        2**9+2**5=512+32
        ==>> 1344
        kCompatibilityVariant 只有1002对
      ==
    StackStyleSimpleIntSet-->StackStyleSimpleIntMapping
        view ../../python3_src/seed/data_funcs/rngs.py

      view ../../python3_src/nn_ns/CJK/unicode/ucd_unihan/ucd/parse__Blocks_txt.py
      view ../../python3_src/nn_ns/CJK/unicode/ucd_unihan/ucd/dump_load___parsed_result__of__Blocks_txt.py
      view ../../python3_src/nn_ns/CJK/unicode/ucd_unihan/ucd/parsed_result__of__Blocks_txt__of_ver13_0.py

      view ../../python3_src/nn_ns/CJK/unicode/ucd_unihan/ucd/_main4dump_load___parsed_result__of__xxx_txt.py
      view ../../python3_src/seed/helper/IHelper4parse__xxx_txt.py
  ===
  view /sdcard/0my_files/unzip/e_book/unicode_13__UCD/PropertyAliases.txt
    cjkCompatibilityVariant  ; kCompatibilityVariant
  ===
  view /sdcard/0my_files/unzip/e_book/unicode_13__UCD/PropertyValueAliases.txt
    # cjkCompatibilityVariant (cjkCompatibilityVariant)
    # @missing: 0000..10FFFF; cjkCompatibilityVariant; <code point>
  ===
  view ../lots/NOTE/unicode/note4UnicodeStandard_14_0_annex/unicode_ver14_0_UAX31_UAX38摘要.txt
    kCompatibilityVariant
      Description 	The canonical Decomposition_Mapping value for the ideograph, derived from UnicodeData.txt. This field is derived by taking the non-null Decomposition_Mapping values from Field 5 of UnicodeData.txt, for characters contained within the CJK Compatibility Ideographs block and the CJK Compatibility Ideographs Supplement block.
    Unihan_IRGSources.txt 	kCompatibilityVariant, kIICore, kIRG_GSource, kIRG_HSource, kIRG_JSource, kIRG_KPSource, kIRG_KSource, kIRG_MSource, kIRG_SSource, kIRG_TSource, kIRG_UKSource, kIRG_USource, kIRG_VSource, kRSUnicode, kTotalStrokes
  ===
  view /sdcard/0my_files/unzip/e_book/unicode_13__Unihan/Unihan_IRGSources.txt
    U+F900	kCompatibilityVariant	U+8C48
      #豈豈
    U+F901	kCompatibilityVariant	U+66F4
      #更更
    U+F91B	kCompatibilityVariant	U+4E82
      #亂亂
  ===

[DONE:kIICore
from seed.data_funcs.rngs import make_Ranges, sorted_ints_to_iter_nontouch_ranges, detect_iter_ranges, StackStyleSimpleIntSet, StackStyleSimpleIntMapping, TouchRangeBasedIntMapping
        view ../../python3_src/seed/data_funcs/rngs.py
      view ../../python3_src/nn_ns/CJK/unicode/ucd_unihan/unihan/parse__kIICore8Unihan_IRGSources_txt.py
      view ../../python3_src/nn_ns/CJK/unicode/ucd_unihan/unihan/dump_load___parsed_result__of__kIICore8Unihan_IRGSources_txt.py
        DONE:hzs_2143 --> hanzi.py
        DONE:500K 太大，改变保存方式？
      view ../../python3_src/nn_ns/CJK/unicode/ucd_unihan/unihan/parsed_result__of__kIICore8Unihan_IRGSources_txt__of_ver13_0.py

  view ../lots/NOTE/unicode/note4UnicodeStandard_14_0_annex/unicode_ver14_0_UAX31_UAX38摘要.txt
  ===
  kIICore
  Syntax 	[ABC][GHJKMPT]{1,7}
  Description 	Used for characters which are in IICore, the IRG-produced minimal set of required ideographs for East Asian use. A character is in IICore if and only if it has a value for the kIICore field.
  Each value consists of a letter (A, B, or C), indicating priority value, and one or more letters (G, H, J, K, M, P, or T), indicating source. The source letters are the same as used for IRG sources, except that "P" is used instead of "KP".
  ===
  cjkIICore                ; kIICore
  # cjkIICore (cjkIICore)
  # @missing: 0000..10FFFF; cjkIICore; <none>
  U+34E4	kIICore	CH
    #㓤
  U+3577	kIICore	CT
    #㕷
  U+35CE	kIICore	BHM
    #㗎
  U+3960	kIICore	CK
    #㥠
  U+39DF	kIICore	CG
  U+3ED0	kIICore	CP
  ...
  U+4E00	kIICore	AGTJHKMP
    #一
  #最核心字集，搜索:『\t\<A[GHJKMPT]\{7}\>』
  ===
]


[[DONE:kUnihanCore2020
  Unihan_DictionaryLikeData.txt 	kCangjie, kCheungBauer, kCihaiT, kFenn, kFourCornerCode, kFrequency, kGradeLevel, kHDZRadBreak, kHKGlyph, kPhonetic, kStrange, kUnihanCore2020
view ../lots/NOTE/unicode/note4UnicodeStandard_14_0_annex/unicode_ver14_0_UAX31_UAX38摘要.txt
[
Property 	kUnihanCore2020
Status 	Informative
Category 	Dictionary-like Data
Introduced 	13.0
Delimiter 	N/A
Syntax 	[GHJKMPT]{1,7}
Description 	Used for characters which are in the UnihanCore2020 set, the minimal set of required ideographs for East Asia. A character is in the UnihanCore2020 set if and only if it has a value for the kUnihanCore2020 property.

The property value consists of one or more letters (G, H, J, K, M, P, or T), indicating source. The source letters are the same as used for IRG sources, except that P is used instead of the two-letter sequence KP.
]
view /sdcard/0my_files/unzip/e_book/unicode_13__Unihan/Unihan_DictionaryLikeData.txt
# Unihan_DictionaryLikeData.txt
# Date: 2020-02-18 18:27:33 GMT [JHJ]
# Unicode version: 13.0.0
grep kUnihanCore2020 /sdcard/0my_files/unzip/e_book/unicode_13__Unihan/Unihan_DictionaryLikeData.txt > /sdcard/0my_files/tmp/_.txt
view /sdcard/0my_files/tmp/_.txt
  20720个！！！
!du -h /sdcard/0my_files/tmp/_.txt
  556K
!du -h ../../python3_src/nn_ns/CJK/cjk_subsets/hanzi.py
  164K
grep 'kUnihanCore2020\s\+\S\{7\}' /sdcard/0my_files/unzip/e_book/unicode_13__Unihan/Unihan_DictionaryLikeData.txt > /sdcard/0my_files/tmp/_.txt
view /sdcard/0my_files/tmp/_.txt
  2573个

      s/kIICore\C/kUnihanCore2020/g
      s/Unihan_IRGSources\C/Unihan_DictionaryLikeData/g
      view ../../python3_src/nn_ns/CJK/unicode/ucd_unihan/unihan/parse__kUnihanCore20208Unihan_DictionaryLikeData_txt.py
      view ../../python3_src/nn_ns/CJK/unicode/ucd_unihan/unihan/dump_load___parsed_result__of__kUnihanCore20208Unihan_DictionaryLikeData_txt.py
      view ../../python3_src/nn_ns/CJK/unicode/ucd_unihan/unihan/parsed_result__of__kUnihanCore20208Unihan_DictionaryLikeData_txt__of_ver13_0.py

DONE:hzs_2573 --> hanzi.py
]]
]]

]]]






[[TODO:

e ??目标计算-依赖DAG惰性求值缓存结果
  class ...:
    src: input-name/symbol, sf.attr/sf[key]
    @cached-property
    .z
      = f1(.x, .y)
      | f2(.w, .y)
    @cached-arged-property
    .xxx(*args)
      = f1(.x, .y)
      | f2(.w, .y)
]]
[[DONE:
:
e ../../python3_src/seed/tiny_/pprint4container__depth1.py

e script/download_zxcs_novel/collect_links_from_zxcs_sort_pages.py
  输出 纯数据
    [(idx, ID, title, 简介)]
e script/download_zxcs_novel/extract_scores_from_zxcs_novel_page.py
  ID -> (日期, [此刻评分]{len=5})
e script/download_zxcs_novel/merge_link_iinfos_and_scores.py
  合并 两个输出文件:
    view /sdcard/0my_files/tmp/out4py/download_zxcs_novel/collect_links_from_zxcs_sort_pages/sorts/42.html.iinfos.txt
    view /sdcard/0my_files/tmp/out4py/download_zxcs_novel/collect_links_from_zxcs_sort_pages/sorts/42.html.iinfos.scores.txt
  为：
    view /sdcard/0my_files/tmp/out4py/download_zxcs_novel/collect_links_from_zxcs_sort_pages/sorts/42.scored.html
]]



[[[
加密网页 第二版？
e script/加密囗短字符串.py
  TODO:简易 短字符串 压缩算法
    本来就不需要压缩！

算了，还是 继续用 呜呼哀哉尚飨加密 第二版
file:///storage/emulated/0/0my_files/git_repos/python3_src/nn_ns/app/呜呼哀哉尚飨加密/呜呼哀哉尚飨加密v2_3.html

]]]
[[DONE:使用 regex 严格检查
file:///storage/emulated/0/0my_files/git_repos/python3_src/nn_ns/app/呜呼哀哉尚飨加密/呜呼哀哉尚飨加密v2_3.html
e /storage/emulated/0/0my_files/git_repos/python3_src/nn_ns/app/呜呼哀哉尚飨加密/呜呼哀哉尚飨加密v2_3.html
  使用 regex 严格检查 @str2int
  BigInt(s)
  BigInt.asIntN
  BigInt.asUintN
  [[
  The BigInt.asUintN static method clamps a BigInt value to an unsigned integer value, and returns that value.
  const max = 2n ** 64n - 1n;
  function check64bit(number) {
    (number > max) ?
      console.log('Number doesn\'t fit in unsigned 64-bit integer!') :
      console.log(BigInt.asUintN(64, number));
  }
  check64bit(2n ** 64n);
  // expected output: "Number doesn't fit in unsigned 64-bit integer!"
  check64bit(2n ** 32n);
  // expected output: 4294967296n
  ]]

[[
#JavaScript Math.random()->float
#JavaScript parseInt()
#JavaScript parse BigInt
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt
function roughScale(x, base) {
  const parsed = parseInt(x, base);
  if (isNaN(parsed)) { return 0; }
  return parsed * 100;
}


A stricter parse function

It is sometimes useful to have a stricter way to parse integers.

Regular expressions can help:

function filterInt(value) {
  if (/^[-+]?(\d+|Infinity)$/.test(value)) {
    return Number(value)
  } else {
    return NaN
  }
}
]]
]]



[[[[
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
[[[
view others/数学/编程/永恒代码/原貌字符串.txt
原貌字符串
  求一有效结束串囗特定原貌字符串(结束串的结束串，结束串字集，原貌字符串)
    前置条件:
      [len(结束串的结束串) > 0]
      [len(结束串字集) >= 3]
        因为：
        [len(结束串的结束串) == 1][len(结束串字集) == 2][结束串的结束串[0] <- 结束串字集]:
          let ch = 结束串字集\-\{结束串的结束串[0]}
          [?n. 结束串=ch*n]
          [原貌字符串==ch*1]:
            [原貌字符串 必然 提前终止]
            [所有允许编码的结束串均无效]
    后置条件:
      let s = f'{结束串}{结束串的结束串}{原貌字符串}{结束串}'
          a, b, c = s.partition(结束串的结束串)
          d, e, f = c.partition(a)
      assert b == 结束串的结束串
      assert a == e  ##== 任一有效结束串
      assert f == ''
      assert d == 原貌字符串

    简单起见：
      [s 没有 非空真子双缀] =[def]= [@sz. [0 < sz < len(s)] --> [s[:sz] =!= s[len(s)-sz:]]]
      要求『结束串的结束串』没有『非空真子双缀』，以防『结束串』提取终止。
      要求『结束串』没有『非空真子双缀』，以防『原貌字符串』提取终止。

  简单起见：
    由于『结束串的结束串』与『结束串字集』完全受控，可要求使用『结束串的结束串囗单字符』，该字符不在『结束串字集』中。
    再改，将该字符作为『结束串』的尾字符！

  修改格式为：
  求一有效结束串囗特定原貌字符串囗简化(结束串的结束串囗单字符，结束串减囗字集，原貌字符串)
    前置条件:
      [结束串的结束串囗单字符 <-!- 结束串减囗字集]
      [len(结束串减囗字集) >= 1]
        提高效率:[len(结束串减囗字集) >= 2]
          [len(结束串) = O(log<len(结束串减囗字集)>(len(原貌字符串)))]
        证明:[[n>=0][字符串s 包含 字集S的所有长度为n的字符串][len(S)>=1] --> [len(s) >= len(S)**n+(n-1)]]
          let N=len(S)
          !![N >= 0]
          [字集S的所有长度为n的字符串 非空]
          !![字符串s 包含 字集S的所有长度为n的字符串]
          [字符串s 包含 至少一个 字集S的长度为n的字符串]
          [len(s) >= n]

          [n == 0]:
            [len(S)**n+(n-1) = N**0+0-1 = 0 <= len(s)]
          [n>=1][N == 1]:
            [len(S)**n+(n-1) = 1**n+n-1 = n <= len(s)]
          #[n>=1][N >= 2]:
          [n>=1][N >= 1]:
            定义 有向图囗带自环囗无重边:
              节点集 为 字集S的所有长度为(n-1)的字符串
              有向边 连结 满足以下关系的任意两个节点:
                起点[1:] === 终点[:-1]
            ==>>
            [任一节点 出度 为 N]
            [任一节点 入度 为 N]
            [有向边总数===N*节点总数===N**n]
            !![字符串s 包含 字集S的所有长度为n的字符串]
            [需要遍历所有 有向边]
            !![s是字符串 而非 字符环]
            [s初始(n-1)个字符 并没有遍历任何 有向边]
            [len(s) >= (n-1)+有向边总数 === N**n+(n-1)]
    后置条件
      let 结束串=f'{结束串减}{结束串的结束串囗单字符}'
            # ==>> [『结束串』没有『非空真子双缀』]
            # ==>> [[结束串 not in 原貌字符串] --> [原貌字符串 不会 提前终止]]
          s = f'{结束串}{原貌字符串}{结束串}'
          a, b, c = s.partition(结束串的结束串囗单字符*1)
          d, e, f = c.partition(a+b)
      assert b == 结束串的结束串囗单字符*1
      assert a+b == e  ##== 任一有效结束串
      assert f == ''
      assert d == 原貌字符串
      ===找出一个最短的有效 结束串
      ？扫描一遍suffix_array(原貌字符串)
        不行，太多其他字符

      suffix_tree(原貌字符串)
      1.检查『结束串的结束串囗单字符』是否在『原貌字符串』中
        在则...
      2.检查(『结束串减囗字集』\-\『原貌字符串』)是否非空
        非空则...
      3. 找出原貌字符串的所有以『结束串减囗字集』中的字符开始的后缀，层层排查下去(依上面两点)


TODO
e ../../python3_src/seed/seq_tools/escape_schemes/universal_single_point_escape_scheme__enable_raw_text__disable_recur.py
  不允许嵌套但允许内嵌原貌字符串的通用单点转义方案
    txt -> (txt, [txt])
      #转义符 存在的意义 只是 切分 文本而已！
      #     原貌字符串 即使被识别出来，也应当融入 相邻文本
      #至于 转义符 之后 的 转义 序列 的 长度 再由 用户自定义
    [escape schemes]【转义方案】
    ===
    见上面:原貌字符串
    见下面:转义
    ===
    转义次数头囗字符串 <- 允空字符串
    转义次数尾囗字符串 <- 允空字符串
    转义次数数字表囗次序字集{len>=2,不重复,用户自定义次序}
    转义次数 = 转义次数数字表囗次序字集*
    最小转义次数囗字符串 <- 转义次数/-\允空字符串
    单点转义符 = 转义次数头囗字符串 最小转义次数囗字符串 转义次数尾囗字符串
      要求:[单点转义符 <- 非空字符串]
      [[
      ===感觉还是有问题
      ===假如只当作逗号用，能否避免被左右文本融合(而非 仅只要求『从左往右能解析』就成)？
        ==当然文本需要预处理: join(txts)=单点转义符.join(map 预处理 txts)
        ==预处理(txt)=再组(提升(切分<单点转义符囗下降空间>(txt)))
      ==>>边界清晰（无序解析无歧义）
      ==>>[@[a,b<-单点转义符囗下降空间] -> @[i<-[1..min(len a, len b)]] -> [a[-i:] === b[:i]] -> [a===b][i===len a]]
      ==>>:
      **
        [?i. [转义次数尾囗字符串[i] <-/- 转义次数数字表囗次序字集]]
        [?i. [转义次数头囗字符串[i] <-/- 转义次数数字表囗次序字集]]
        ==>> 两者非空！
      **
        [(转义次数头囗字符串++转义次数尾囗字符串) 没有 非空真子双缀]
      **
        lhs = regex_f'{head}[mid]{{L}}{tail}'
        rhs = regex_f'{head}[mid]{{R}}{tail}'

        非空
        +[len(head++tail) > 0]
        let [H=len(head)]
        let [T=len(tail)]

        左对齐
        +[R>L][lhs++regex_f'.{{R-L}}' =/= rhs]

        左不对齐
        +[regex_f'.+' ++lhs++regex_f'.+' =/= rhs]
        +[regex_f'.{{1,len(rhs)-1}}' ++lhs=/= rhs++regex_f'.*']
        or:
          not [regex_f'.{{0,len(rhs)-1}}' ++lhs++regex_f'.*'=== rhs++regex_f'.*']
        ***(not ===)
        let [I<-[0..len(rhs)-1]]
        [I+H+L+T+X===H+R+T+Y]
        * I cut H
          [0 <= I < H]
          * IH cut R
            * IHL cut R/T/Y
          * IH cut T
            * IHL cut T/Y
          * IH cut Y
        * I cut R
          [H <= I < H+R]
          * IH cut R
            * IHL cut R/T/Y
          * IH cut T
            * IHL cut T/Y
          * IH cut Y
        * I cut T
          [H+R <= I < H+R+T]
          * IH cut T
            * IHL cut T/Y
          * IH cut Y
        最多几种组合？
          命名8个点:
            lhs.I/H/L/T
            rhs.H/R/T/Y
          lhs.w 出现 在 rhs.z 之前，则 表示 lhs.I..w < rhs.H..z
          lhs.w 出现 在 rhs.z 之后，则 表示 lhs.I..w >= rhs.H..z
          因为lhs.IHLTX===rhs.HRTY, 故lhs.X不参与,但rhs.Y参与(『>=』==>>lhs.X必在rhs.Y之后)
          choose(4+4,4)=C(8,4)=8*7*6*5/(4*3*2*1)=70
          再除去:[lhs.IH.. < rhs.H] C(8-2,4-2)=C(6,2)=15种
              #再除去:[lhs.I..?0 < rhs.H..?1 <=[所有被包含,但R/Y不在lhs所以其实只有rhs.H] lhs.I..?0]
          再除去:[lhs.I >= rhs.HRT] C(8-3,4-3)=C(5,1)=5种
          70 -15 -5 =50
          已知长度:H,T
          未知长度:I,L,R,X,Y
            I/L/X 与 R/Y 重叠的部分 可取消
            这样一来，就不存在无限长度


      ]]


    单点转义符囗上升空间 = 转义次数头囗字符串 转义次数{次数(.)>次数(最小转义次数囗字符串)} 转义次数尾囗字符串
    单点转义符囗下降空间 =:
      | 单点转义符
      | 单点转义符囗上升空间

    单点转义序列 = 单点转义符 自结尾序列
    自结尾序列 = 单点转义序列囗公共头部囗字符串 转义种类头@kind 单点转义序列囗公共颈部囗字符串 特化自结尾序列的躯干<kind> 单点转义序列囗公共尾部囗字符串
    单点转义序列囗公共头部囗字符串 <- 允空字符串
    单点转义序列囗公共颈部囗字符串 <- 允空字符串
    单点转义序列囗公共尾部囗字符串 <- 允空字符串
    转义种类头 =:
      | 原貌字符串囗转义种类头囗字符串
      | ...
      要求:[转义种类头 <- 非空字符串]
      要求:[[转义次数尾囗字符串 <- 非空字符串]或[转义种类头[0] <-/- 转义次数数字表囗次序字集]]

    结束串囗前缀囗字符串 <- 允空字符串
    结束串囗后缀囗字符串 <- 非空字符串
    结束串囗中段囗字集{len>=2,不重复,标准次序}
    结束串囗中段囗字符串 = 结束串囗中段囗字集*
    结束串囗中后段囗字符串 = 结束串囗中段囗字符串 结束串囗后缀囗字符串

    结束串 = 结束串囗前缀囗字符串 结束串囗中段囗字符串 结束串囗后缀囗字符串

    特化自结尾序列的躯干<原貌字符串囗转义种类头囗字符串> =原貌字符串囗最小封装
    原貌字符串囗最小封装 =结束串@eos (.*?@原貌字符串) (.*){=eos}
      # 独立出来，可以 在其他组件中复用
      #
      # 第二个 结束串 用于 标识 原貌字符串 的 结束
      # 第一个 结束串，是 第二个结束串 的 定义(只针对 后面的 原貌字符串，局部使用)
      #==>>需要 识别 第一个 结束串
      #==>>结束串 自结尾
      #==>>使用 结束串囗后缀囗字符串
      [第一个 结束串 从左至右 可识别/自结尾] ==>>:
          结束串自结尾囗约束(结束串) =[def]= [?i. [结束串囗后缀囗字符串[i] <-/- 结束串囗中段囗字集]]
            #因此 非空
          结束串囗后缀囗中部字集极大后缀囗字符串 =[def]= 结束串囗后缀囗字符串[1+max{i|[[结束串囗后缀囗字符串[i] <-/- 结束串囗中段囗字集]]}:]
          [0 <= len(结束串囗后缀囗中部字集极大后缀囗字符串) < len(结束串囗后缀囗字符串)]
      结束串囗推论一: [[结束串自结尾囗约束(结束串)] -->> [结束串囗中后段囗字符串 的 真子双缀 最长为 len(结束串囗后缀囗中部字集极大后缀囗字符串)]]

      [第二个 结束串 从左至右 经过 原貌字符串 不会 提前出现] ==>>:
          结束串约束囗特化版<原貌字符串>(结束串) =[def]= [结束串 not in (原貌字符串++结束串)[:-1]]

      通用要求:
          #不指定 原貌字符串 的 情形下
          #虽然 结束串 永远是 特定于 原貌字符串 的，但 可以 通过 约束，指定 原貌字符串 集合 而非 特定某个
          #
          结束串约束囗通用版<结束串与原貌字符串的假设关系>(结束串) =[def]= [@原貌字符串. [结束串与原貌字符串的假设关系(结束串,原貌字符串)] -->> 结束串约束囗特化版<原貌字符串>(结束串)]


      基于用途囗细化要求:
        * 特定于 某 原貌字符串，用于 检查 用户提供 的 结束串
          假设:[结束串 not in 原貌字符串]
            # 『整个』结束串
            要求:[结束串  没有 非空真子双缀]
          即：结束串约束囗通用版<[结束串 not in 原貌字符串]>(结束串) <==> [结束串  没有 非空真子双缀]

        * 特定于 某 原貌字符串，用于 自动生成 长度为O(log(len(原貌字符串)))的 结束串
          假设甲:[结束串囗中后段囗字符串 not in (原貌字符串++结束串囗前缀囗字符串)]
            # 归属权更改: 结束串囗前缀囗字符串
          假设甲囗实现方案: 逆转 (原貌字符串++结束串囗前缀囗字符串)，针对 suffix_tree 其于 逆转 结束串囗后缀囗字符串 之下的 子树，求 逆转 结束串囗中段囗字符串
            # 不考虑 结束串囗前缀囗字符串 更容易 实现，但 所得并非最短！
            要求:[结束串  没有 长度大于len(结束串囗前缀囗字符串)的 真子双缀]

          即：结束串约束囗通用版<[结束串囗中后段囗字符串 not in (原貌字符串++结束串囗前缀囗字符串)]>(结束串) <==> [结束串  没有 长度大于len(结束串囗前缀囗字符串)的 真子双缀]


            一级简化要求(不考虑 结束串囗前缀囗字符串):[结束串囗中后段囗字符串  没有 非空真子双缀]
            二级简化要求(考虑 所有 结束串囗中段囗字符串)(不考虑 结束串囗前缀囗字符串):[结束串囗后缀囗字符串[-1] <-/- 结束串囗中段囗字集][结束串囗后缀囗字符串  没有 非空真子双缀]
                !! 结束串囗推论一
                <==> [结束串囗后缀囗字符串[-1] <-/- 结束串囗中段囗字集]
                  即 第二部分可省去

          假设乙:[[结束串囗中段囗字符串 not in 原貌字符串]或[两者皆空]]
            #假设甲囗实现方案 还是 比较 麻烦
          假设乙囗实现方案: 针对 原貌字符串suffix_tree，求 结束串囗中段囗字符串
            #bug:要求:[结束串  没有 长度大于min(len(结束串囗前缀囗字符串),len(结束串囗后缀囗字符串))的 真子双缀]
            要求:[结束串  没有 长度大于len(结束串囗后缀囗字符串)的 真子双缀]
              ##注意！与 假设甲 要求不同！！一个 前缀，一个 后缀

          即：结束串约束囗通用版<[[结束串囗中段囗字符串 not in 原貌字符串]或[两者皆空]]>(结束串) <==> [结束串  没有 长度大于len(结束串囗后缀囗字符串)的 真子双缀]
              !! 结束串囗推论一
              [结束串囗中后段囗字符串 的 真子双缀 最长为 len(结束串囗后缀囗中部字集极大后缀囗字符串)]
              [结束串 的 真子双缀 最长为 len(结束串囗前缀囗字符串)+len(结束串囗后缀囗中部字集极大后缀囗字符串)]

              结束串囗前缀囗中部字集极大前缀囗字符串 =[def]= 结束串囗前缀囗字符串[:min({len(结束串囗前缀囗字符串)}\-/{i|[[结束串囗前缀囗字符串[i] <-/- 结束串囗中段囗字集]]})]
              最大退步数 =[def]= [len(结束串囗前缀囗字符串) - (len(结束串囗后缀囗字符串)-len(结束串囗后缀囗中部字集极大后缀囗字符串))]
              === [len(结束串囗前缀囗字符串)+len(结束串囗后缀囗中部字集极大后缀囗字符串) - len(结束串囗后缀囗字符串)]

            等价要求:[结束串  没有 长度大于len(结束串囗后缀囗字符串) 且 小于等于len(结束串囗后缀囗字符串)+最大退步数 的 真子双缀]

            * [最大退步数 <= 0]:
              ok
            * [最大退步数 > 0]:
              ???见下面『退步数』

            @[退步数 <- [1..最大退步数]]:
              left_side_condition1 =[def]= [退步数 <= len(结束串囗中段囗字符串)]
                前缀 左侧 对照 的 退步串 完全属于 中段 #未触及 前缀
              right_side_condition1 =[def]= [退步数 <= len(结束串囗前缀囗字符串)+len(结束串囗中段囗字符串)-len(结束串囗后缀囗字符串)]
                #bug:后缀 右侧 对照 的 退步串 完全属于 中段
                后缀 右侧 对照 的 退步串 完全属于 前中段 #未触及 后缀
                * [right_side_condition1][len(结束串囗前缀囗字符串)<=len(结束串囗后缀囗字符串)]:
                    后缀 右侧 对照 的 退步串 完全属于 中段
              left_right_independent_condition =[def]= [left_side_condition1][right_side_condition1][2*(len(结束串囗后缀囗字符串)+退步数)<=len(结束串)]
                 === [left_side_condition1][right_side_condition1][len(结束串囗后缀囗字符串)+2*退步数 <= len(结束串囗前缀囗字符串)+len(结束串囗中段囗字符串)]
                 === [left_side_condition1][len(结束串囗后缀囗字符串)+2*退步数 <= len(结束串囗前缀囗字符串)+len(结束串囗中段囗字符串)]
                 === [left_side_condition1][2*退步数 <= len(结束串囗前缀囗字符串)+len(结束串囗中段囗字符串)-len(结束串囗后缀囗字符串)]
                 === [2*退步数 <= len(结束串囗中段囗字符串)+min{len(结束串囗中段囗字符串), len(结束串囗前缀囗字符串)-len(结束串囗后缀囗字符串)}]
                中段 等效于 无限长
              * [left_right_independent_condition][len(结束串囗前缀囗字符串)<=len(结束串囗后缀囗字符串)]:
                即：[中段 等效于 无限长][后缀 右侧 对照 的 退步串 完全属于 中段]
                要求:[[退步数>len(结束串囗前缀囗中部字集极大前缀囗字符串)]或[结束串囗前缀囗字符串[退步数:] =/= 结束串囗后缀囗字符串[:len(结束串囗前缀囗字符串)-退步数]]]


      检查通用要求:
        结束串约束囗通用版<[结束串 not in 原貌字符串]>(结束串) <==> [结束串  没有 非空真子双缀]
        即：检查 [@结束串囗中段囗字符串, [结束串  没有 非空真子双缀]]
        @[退步数 <- [1..最大退步数]]:
          @[变量数量 <- [0..中段等效无限长的最小长度(退步数)]]:
            要求:变量无解，即 不存在某个 中段 使得 在此 退步数 下 的 前缀与后缀 匹配
          [[DONE:
view others/数学/Disjoint-Set.txt
view ../../python3_src/seed/types/union_find_algo/DisjointSet.py
  特定 退步数: 建立 方程组，等价关系传播
grep 'union[ _-]\?find' -i -r . -a -l
grep 'disjoint[ _-]\?set' -i -r . -a -l
xxx view ../../python3_src/nn_ns/RecognizeSystem/Utils.py
view ../../python3_src/seed/types/MergableImmutable.py

view ../../python3_src/seed/algo/page_rank.py
  我的实现

view ../../python3_src/seed/algo/merge_sort.py
merge sort:
  结合律？
    重新打括号
    初始 划分极大上升组/下降组
  霍夫曼编码？
  等价于 求 二叉树，最小化 所有 子树的虚拟叶节点数之和
    二叉树的叶节点 的 虚拟叶节点数 即是 升降区长度(这里还有一个 边界归属问题))
  以前:矩阵乘法链 结合律 优化...
          ]]

      极度简化通用要求:
        +要求:[结束串囗后缀囗字符串[-1] <-/- 结束串囗前缀囗字符串]
        +要求:[结束串囗后缀囗字符串[-1] <-/- 结束串囗中段囗字集]
        #不需要:[结束串囗后缀囗字符串[-1] <-/- 结束串囗后缀囗字符串[:-1]]
    结束串
]]]
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
[[[
转义
  ...是否允许内嵌原貌字符串？==>>两种转义方案
      无条件全局一致转义
  ...是否允许重新配置转义方案？
      状态转移动态转义
  ...是否允许嵌套配置转义方案？
      状态嵌套局部转义



TODO
转义序列
    仅相当于 \xxx 而非 xml
    相当于 编码 xml中的 < &
        因为这些 字符 实属 带外信息
    [[[
    ====草案目标
    [...]
        独立
    [:raw]...[/raw]
        原貌
    [:tag]...[/tag]
        嵌套
    [!...]
    [!:raw]...[/raw]
    [!:tag]...[/tag]
        注释
    --有无 可能 重新配置 标点？
    [:<config(head,tail)>raw]...[/raw]
        专用语言
        内容是 专用嵌套标记语言
        以避免 过长转义
        #下面 实际方案中 本语言的 head=『[/:』, tail=『/]』
    ====实际方案:
    ==范型:
    [/:string/]
        # xxx head=『[/:』, tail=『/]』
        # head_head=『[/』, head_tail=『:』, tail=『/]』
        #   Total=3
        #
        #补偿几个[[[[\[
        string <- regex'((?!/\]))'
        可用做 成对的头尾
        为何 使用 俩字符『/]』结束 而非 只用 单字符『]』？
            因为 string 很可能 包含 『]』
            比如：补偿性地注释添加一个『]』以使vim『%』动作 正常工作。
        转义『[/:』:
        『[/:』
        『[/0:』..『[/9:』
        『[/00:』..『[/99:』
        『[/000:』..『[/999:』
        ...
        #补偿几个]]]]]]]]
    ==细化<范型>: 独立，成对，独立注释，成对注释
    [/:=string/]
    [/:{string/]
    [/:}string/]
        # data_isolated=『=』
        #   允空，表示otherwise/fallback，只要 不与 comment_isolated 冲突
        # data_open=『{』
        # data_close=『}』
        #   Total+=3 ->6
        #补偿几个[
    #命名/定义 与上面的 保持 尾部 完全一致！
    #   见:引用独立
    [/:.id=string/]
    [/:.id{string/]
    [/:.}string/]
        #id 前缀 区分 私用 与 公开
    #内嵌原貌 与上面的 保持 尾部 完全一致！
    #   以防 string 中 出现 『/]』
    [/:[raw]=string[raw]/]
    [/:[raw]{string[raw]/]
    [/:[raw]}string[raw]/]
    [/:[raw].id=string[raw]/]
    [/:[raw].id{string[raw]/]
    [/:[raw].}string[raw]/]
    #注释 与上面的 保持 尾部 完全一致！
        #补偿[[[
    #   注释是必需的！见下面:ZWSP 破 『/]』
    #       不对！没必要，因为 嵌套 主体 内 的 『/]』 无特殊意义，而 转义序列 内嵌内容 则 不允许 『/]』出现，因为 以其为 终止符(当使用 内嵌中止模式 时)。
    [/:!=string/]
    [/:!{string/]
    [/:!}string/]
    [/:![raw]=string[raw]/]
    [/:![raw]{string[raw]/]
    [/:![raw]}string[raw]/]
    [/:![raw].id=string[raw]/]
    [/:![raw].id{string[raw]/]
    [/:![raw].}string[raw]/]
        # comment_isolated=『!=』
        #   允空，表示otherwise/fallback，只要 不与 data_isolated 冲突
        # comment_open=『!{』
        # comment_close=『!}』
        #   Total+=3 ->9
    ==细化<独立>: 内建独立，应用独立
    [/:=/string/]
    [/:==string/]
    ==细化<成对>: 内建成对，应用成对
    [/:{/string/]
    [/:}/string/]
    [/:{=string/]
    [/:}=string/]
    ==细化<成对>: 原貌，嵌套(解析/树) # 乘以 上面的 内建、应用==>> 4对
    # 这里的原貌 是指 嵌套内容(即 成对的两个转义序列open/close中间所夹的内容) 的 原貌
    #   而 上面 内嵌原貌 是指 单个转义序列 内部的原貌(即 [/:.../]里面的内容)
    # [/:{[raw]string/]
    # [/:}[raw]string/]
        [/:{[raw]/string/]
        [/:}[raw]/string/]
        [/:{[raw]=string/]
        [/:}[raw]=string/]
    # [/:{{string/]
    # [/:}}string/]
        [/:{{/string/]
        [/:}}/string/]
        [/:{{=string/]
        [/:}}=string/]
    ########
        # xxx raw_data_open=『{[』
        # xxx raw_data_close=『}[』
        # tag_data_open=『{{』
        # tag_data_close=『}}』
        #   Total+=2 ->11
        # 补偿 ]]
    ==细化<嵌套>:多自多引入,???应用嵌套？
        TODO 见:引入独立
    ==细化<内建独立>:字符串独立，引用独立(见:命名)，引入独立
    [/:=/=string/]
    [/:=/&qname/]
    [/:=/&qname@&qname/]
    [/:=/&qname@:external_path/]
        # 这里 很有可能 需要 内嵌原貌
        #   ??? ==>> [内嵌原貌的必要性]???
        #   不对！可用 嵌套 破之！
        #   嵌套 似乎更好，支持 多个 引入源？按 优先度 排序？多个 引入目标？
        #

    ==细化<原貌>: 外用，专用
    [/:{[raw]=string/]
    [/:}[raw]=string/]
    [/:{[raw]#domain_ML,ver=1_0,ctor=1_0,nargs=15,=strings<15即nargs即Total>/]
    [/:}[raw]#/]
        # app_raw_data_open?=『{[』+『]=』
        # app_raw_data_close?=『}[』+『]=』
        # cfg_raw_data_open?=『{[』+『]#』
        # cfg_raw_data_close?=『}[』+『]#』
        #   Total+=4 ->15
        strings<n> <- regex'(#unicode){n}'
        unicode <- regex'(_u\x+_)+'
        # raw/上面的标识名+值 不得使用 任何括号+引号，『,=/』
        # raw/ID/val 只能使用 regex'[_\w]*' #含 汉字
        #   机器自动生成的raw，或者说 任意 配置下，共通子集 为:regex'[0-9A-H]*' #不含 小写/下划线/汉字
        #   ID 不得为空
        # val 只能使用 regex'[_\d]*'
        # nargs.val 只能使用 regex'[\d]+'
        #
        # ver ==>> 语言实际版本 #语法树类型模版
        # ctor ==>> 语法树类型模版的构造用别名模版
        #       alias template ctor 用于 精简
        # nargs ==>> 语法树类型模版的构造用别名模版的输入参数的数目
        #
    ==具体string是何语义，由应用自行决定
    ==  特别地，成对的头尾 它俩的string是何关系，由应用自行决定。
    ==      （不一定相等，也可反转标签if-fi，也可带参数xml）
    一次转义就多了7-8个字符！！！
        补偿性注释 至少8字符
            [/:!=[/]
            [/:!=]/]
            [/:!=\[/]
            [/:!=\]/]
    =========
    拓展:是否 添加 内建 字符串 转义？
        #补偿一个[
        其实 作为 转义序列 的 语言，提供了 带外信息/非字符信息，用户 可以 使用 嵌套+用户自定义字符串转义。
        也 并未 阻止用户使用 任何字符，但 某些 序列 『/]』却被禁止，但 嵌套 空注释 (类似 零宽空格ZWSP) 可破。
            #见下面:？内嵌原貌模式？
        只是 太长，太复杂，不够统一。
    =========
    拓展:命名，引用，引入，内嵌原貌
    =========
    上面 仅止于 转义模式/内嵌中止模式:
        #补偿几个[[[[
        即 『/]』中止 一个 转义序列，不考虑 其中 内容
    拓展 使之更像 ML/markup-lang:
        内嵌解析模式:
            对里面的 里面的 内容 进行解析
                提前 指定 格式，默认 与 外部 相同
                更新 范型::成对::原貌::专用 的格式
        内嵌原貌模式:
            以『[raw]/]』作为 终止符，读取 内容
        内嵌中止再解析模式:
            先以『/]』作为 终止符，读取 内容
            再 解析 内容
        内嵌原貌再解析模式:
            先以『[raw]/]』作为 终止符，读取 内容
            再 解析 内容

    ]]]
]]]

TODO
[[[
    ---seed.int_tools.base64 泛化
    uint -> hex -> uint<1~7 bit>
        查表法！
        array.array!!
    ---
    转义序列/带外信息
        考虑 编码:
            00xx 独
            01xx 起
            11xx 承
            10xx 讫
            ---
            带内信息:
                00xx
                01xx 11xx* 10xx
            带外信息:
                10xx 11xx* 01xx
                这样不好，无法 单点 确定 位置
]]]
[[[
TODO
e ../../python3_src/nn_ns/CJK/cjk_subsets/cjk_common_subset.py
TODO
e ../../python3_src/seed/func_tools/parameterized_transform.py
        directed-fmapT/transform(sf, type_info, x, /):
            e ../../python3_src/seed/func_tools/fmapT/...
]]]
]]]]






DONE:
  view ../../python3_src/seed/func_tools/recur5yield.py

[[DONE

拆分 parsed_result__of__Unihan_Variants_txt__of_ver13_0
拆分 parsed_result__of__PropList_txt__of_ver13_0
  dump_load___parsed_result__of__Unihan_Variants_txt
  dump_load___parsed_result__of__PropList_txt
!mv ../../python3_src/nn_ns/CJK/unicode/ucd_unihan/unihan/parsed_result__of__Unihan_Variants_txt__of_ver13_0.py ../../python3_src/nn_ns/CJK/unicode/ucd_unihan/unihan/dump_load___parsed_result__of__Unihan_Variants_txt.py
!mv ../../python3_src/nn_ns/CJK/unicode/ucd_unihan/ucd/parsed_result__of__PropList_txt__of_ver13_0.py ../../python3_src/nn_ns/CJK/unicode/ucd_unihan/ucd/dump_load___parsed_result__of__PropList_txt.py

view ../../python3_src/nn_ns/CJK/unicode/ucd_unihan/unihan/dump_load___parsed_result__of__Unihan_Variants_txt.py
view ../../python3_src/nn_ns/CJK/unicode/ucd_unihan/unihan/parsed_result__of__Unihan_Variants_txt__of_ver13_0.py


view ../../python3_src/nn_ns/CJK/unicode/ucd_unihan/ucd/dump_load___parsed_result__of__PropList_txt.py
view ../../python3_src/nn_ns/CJK/unicode/ucd_unihan/ucd/parsed_result__of__PropList_txt__of_ver13_0.py

DONE！

]]
]
